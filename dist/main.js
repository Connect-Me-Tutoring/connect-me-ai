var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name51 in all)
    __defProp(target, name51, { get: all[name51], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name51) {
  return new Error(`[unenv] ${name51} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name51) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name51);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name51, options) {
        this.name = name51;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name51, type) {
        return this._entries.filter((e) => e.name === name51 && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name51, options) {
        const entry = new PerformanceMark(name51, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now2 = Date.now();
      const seconds = Math.trunc(now2 / 1e3);
      const nanos = now2 % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/@mastra/core/dist/chunk-PZUZNPFM.js
function safeParseErrorObject(obj) {
  if (typeof obj !== "object" || obj === null) {
    return String(obj);
  }
  try {
    const stringified = JSON.stringify(obj);
    if (stringified === "{}") {
      return String(obj);
    }
    return stringified;
  } catch {
    return String(obj);
  }
}
function getErrorFromUnknown(unknown3, options = {}) {
  const defaultOptions6 = {
    fallbackMessage: "Unknown error",
    maxDepth: 5,
    supportSerialization: true,
    includeStack: true
  };
  const mergedOptions = options ? { ...defaultOptions6, ...options } : defaultOptions6;
  const { fallbackMessage, maxDepth, supportSerialization, includeStack } = mergedOptions;
  if (unknown3 && unknown3 instanceof Error) {
    if (includeStack === false) {
      unknown3.stack = void 0;
    }
    if (supportSerialization) {
      addErrorToJSON(unknown3);
    }
    return unknown3;
  }
  let error87;
  if (unknown3 && typeof unknown3 === "object") {
    const errorMessage = unknown3 && "message" in unknown3 && typeof unknown3.message === "string" ? unknown3.message : safeParseErrorObject(unknown3);
    const errorCause = "cause" in unknown3 && unknown3.cause !== void 0 ? unknown3.cause instanceof Error ? unknown3.cause : maxDepth > 0 ? getErrorFromUnknown(unknown3.cause, { ...mergedOptions, maxDepth: maxDepth - 1 }) : void 0 : void 0;
    error87 = new Error(errorMessage, errorCause ? { cause: errorCause } : void 0);
    const { stack: _, ...propsWithoutStack } = unknown3;
    Object.assign(error87, propsWithoutStack);
    if (includeStack) {
      error87.stack = "stack" in unknown3 && typeof unknown3.stack === "string" ? unknown3.stack : void 0;
    }
  } else if (unknown3 && typeof unknown3 === "string") {
    error87 = new Error(unknown3);
    error87.stack = void 0;
  } else {
    error87 = new Error(fallbackMessage);
    error87.stack = void 0;
  }
  if (supportSerialization) {
    addErrorToJSON(error87);
  }
  return error87;
}
function addErrorToJSON(error87) {
  if (error87.toJSON) {
    return;
  }
  Object.defineProperty(error87, "toJSON", {
    value: /* @__PURE__ */ __name(function() {
      const json3 = {
        message: this.message,
        name: this.name
      };
      if (this.stack !== void 0) {
        json3.stack = this.stack;
      }
      if (this.cause !== void 0) {
        json3.cause = this.cause;
      }
      const errorAsAny = this;
      for (const key in errorAsAny) {
        if (errorAsAny.hasOwnProperty(key) && !(key in json3) && key !== "toJSON") {
          json3[key] = errorAsAny[key];
        }
      }
      return json3;
    }, "value"),
    enumerable: false,
    writable: true,
    configurable: true
  });
}
var MastraBaseError, MastraError;
var init_chunk_PZUZNPFM = __esm({
  "node_modules/@mastra/core/dist/chunk-PZUZNPFM.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    __name(safeParseErrorObject, "safeParseErrorObject");
    __name(getErrorFromUnknown, "getErrorFromUnknown");
    __name(addErrorToJSON, "addErrorToJSON");
    MastraBaseError = class extends Error {
      static {
        __name(this, "MastraBaseError");
      }
      id;
      domain;
      category;
      details = {};
      message;
      constructor(errorDefinition, originalError) {
        let error87;
        if (originalError instanceof Error) {
          error87 = originalError;
        } else if (originalError) {
          const errorMessage = safeParseErrorObject(originalError);
          error87 = new Error(errorMessage);
        }
        const message = errorDefinition.text ?? error87?.message ?? "Unknown error";
        super(message, { cause: error87 });
        this.id = errorDefinition.id;
        this.domain = errorDefinition.domain;
        this.category = errorDefinition.category;
        this.details = errorDefinition.details ?? {};
        this.message = message;
        Object.setPrototypeOf(this, new.target.prototype);
      }
      /**
       * Returns a structured representation of the error, useful for logging or API responses.
       */
      toJSONDetails() {
        return {
          message: this.message,
          domain: this.domain,
          category: this.category,
          details: this.details
        };
      }
      toJSON() {
        return {
          message: this.message,
          details: this.toJSONDetails(),
          code: this.id
        };
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    MastraError = class extends MastraBaseError {
      static {
        __name(this, "MastraError");
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/@opentelemetry/api/build/src/platform/browser/index.js
var require_browser = __commonJS({
  "node_modules/@opentelemetry/api/build/src/platform/browser/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return m[k];
      }, "get") });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_globalThis(), exports);
  }
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "node_modules/@opentelemetry/api/build/src/version.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS({
  "node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCompatible = exports._makeCompatibilityCheck = void 0;
    var version_1 = require_version();
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      const rejectedVersions = /* @__PURE__ */ new Set();
      const myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return () => false;
      }
      const ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        const globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        const globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    exports._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = void 0;
    var platform_1 = require_browser();
    var version_1 = require_version();
    var semver_1 = require_semver();
    var major = version_1.VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
    var _global = platform_1._globalThis;
    function registerGlobal(type, instance, diag, allowOverride = false) {
      var _a61;
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a61 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a61 !== void 0 ? _a61 : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type]) {
        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== version_1.VERSION) {
        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    exports.registerGlobal = registerGlobal;
    function getGlobal(type) {
      var _a61, _b;
      const globalVersion = (_a61 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a61 === void 0 ? void 0 : _a61.version;
      if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    __name(getGlobal, "getGlobal");
    exports.getGlobal = getGlobal;
    function unregisterGlobal(type, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    exports.unregisterGlobal = unregisterGlobal;
  }
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils();
    var DiagComponentLogger = class {
      static {
        __name(this, "DiagComponentLogger");
      }
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args) {
        return logProxy("debug", this._namespace, args);
      }
      error(...args) {
        return logProxy("error", this._namespace, args);
      }
      info(...args) {
        return logProxy("info", this._namespace, args);
      }
      warn(...args) {
        return logProxy("warn", this._namespace, args);
      }
      verbose(...args) {
        return logProxy("verbose", this._namespace, args);
      }
    };
    exports.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args) {
      const logger = (0, global_utils_1.getGlobal)("diag");
      if (!logger) {
        return;
      }
      args.unshift(namespace);
      return logger[funcName](...args);
    }
    __name(logProxy, "logProxy");
  }
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/types.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagLogLevel = void 0;
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogLevelDiagLogger = void 0;
    var types_1 = require_types();
    function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < types_1.DiagLogLevel.NONE) {
        maxLevel = types_1.DiagLogLevel.NONE;
      } else if (maxLevel > types_1.DiagLogLevel.ALL) {
        maxLevel = types_1.DiagLogLevel.ALL;
      }
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        const theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/diag.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger();
    var logLevelLogger_1 = require_logLevelLogger();
    var types_1 = require_types();
    var global_utils_1 = require_global_utils();
    var API_NAME = "diag";
    var DiagAPI = class _DiagAPI {
      static {
        __name(this, "DiagAPI");
      }
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args) {
            const logger = (0, global_utils_1.getGlobal)("diag");
            if (!logger)
              return;
            return logger[funcName](...args);
          };
        }
        __name(_logProxy, "_logProxy");
        const self2 = this;
        const setLogger = /* @__PURE__ */ __name((logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
          var _a61, _b, _c;
          if (logger === self2) {
            const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a61 = err.stack) !== null && _a61 !== void 0 ? _a61 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          const oldLogger = (0, global_utils_1.getGlobal)("diag");
          const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`);
            newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
        }, "setLogger");
        self2.setLogger = setLogger;
        self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        };
        self2.createComponentLogger = (options) => {
          return new ComponentLogger_1.DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        if (!this._instance) {
          this._instance = new _DiagAPI();
        }
        return this._instance;
      }
    };
    exports.DiagAPI = DiagAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaggageImpl = void 0;
    var BaggageImpl = class _BaggageImpl {
      static {
        __name(this, "BaggageImpl");
      }
      constructor(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        const entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      }
      removeEntry(key) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      }
      removeEntries(...keys) {
        const newBaggage = new _BaggageImpl(this._entries);
        for (const key of keys) {
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      }
      clear() {
        return new _BaggageImpl();
      }
    };
    exports.BaggageImpl = BaggageImpl;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataSymbol = void 0;
    exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
    var diag_1 = require_diag();
    var baggage_impl_1 = require_baggage_impl();
    var symbol_1 = require_symbol();
    var diag = diag_1.DiagAPI.instance();
    function createBaggage(entries = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
    }
    __name(createBaggage, "createBaggage");
    exports.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
        str = "";
      }
      return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context/context.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ROOT_CONTEXT = exports.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    exports.createContextKey = createContextKey;
    var BaseContext = class _BaseContext {
      static {
        __name(this, "BaseContext");
      }
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        const self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = (key) => self2._currentContext.get(key);
        self2.setValue = (key, value) => {
          const context3 = new _BaseContext(self2._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self2.deleteValue = (key) => {
          const context3 = new _BaseContext(self2._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
    };
    exports.ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagConsoleLogger = void 0;
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = class {
      static {
        __name(this, "DiagConsoleLogger");
      }
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (let i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
    };
    exports.DiagConsoleLogger = DiagConsoleLogger;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
    var NoopMeter = class {
      static {
        __name(this, "NoopMeter");
      }
      constructor() {
      }
      /**
       * @see {@link Meter.createGauge}
       */
      createGauge(_name, _options) {
        return exports.NOOP_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    exports.NoopMeter = NoopMeter;
    var NoopMetric = class {
      static {
        __name(this, "NoopMetric");
      }
    };
    exports.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopUpDownCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopGaugeMetric = class extends NoopMetric {
      static {
        __name(this, "NoopGaugeMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports.NoopGaugeMetric = NoopGaugeMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      static {
        __name(this, "NoopHistogramMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      static {
        __name(this, "NoopObservableMetric");
      }
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    exports.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableCounterMetric");
      }
    };
    exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableGaugeMetric");
      }
    };
    exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableUpDownCounterMetric");
      }
    };
    exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports.NOOP_METER = new NoopMeter();
    exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports.NOOP_METER;
    }
    __name(createNoopMeter, "createNoopMeter");
    exports.createNoopMeter = createNoopMeter;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueType = void 0;
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType = exports.ValueType || (exports.ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
    exports.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    exports.defaultTextMapSetter = {
      set(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopContextManager = void 0;
    var context_1 = require_context();
    var NoopContextManager = class {
      static {
        __name(this, "NoopContextManager");
      }
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
        return target;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    exports.NoopContextManager = NoopContextManager;
  }
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/context.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
    var ContextAPI = class _ContextAPI {
      static {
        __name(this, "ContextAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _ContextAPI();
        }
        return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context3, fn, thisArg, ...args) {
        return this._getContextManager().with(context3, fn, thisArg, ...args);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context3, target) {
        return this._getContextManager().bind(context3, target);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable();
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.ContextAPI = ContextAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceFlags = void 0;
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports.INVALID_SPANID = "0000000000000000";
    exports.INVALID_TRACEID = "00000000000000000000000000000000";
    exports.INVALID_SPAN_CONTEXT = {
      traceId: exports.INVALID_TRACEID,
      spanId: exports.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan = class {
      static {
        __name(this, "NonRecordingSpan");
      }
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      addLink(_link) {
        return this;
      }
      addLinks(_links) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    exports.NonRecordingSpan = NonRecordingSpan;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = void 0;
    var context_1 = require_context();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var context_2 = require_context2();
    var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context3) {
      return context3.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    exports.getSpan = getSpan;
    function getActiveSpan() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    __name(getActiveSpan, "getActiveSpan");
    exports.getActiveSpan = getActiveSpan;
    function setSpan(context3, span) {
      return context3.setValue(SPAN_KEY, span);
    }
    __name(setSpan, "setSpan");
    exports.setSpan = setSpan;
    function deleteSpan(context3) {
      return context3.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    exports.deleteSpan = deleteSpan;
    function setSpanContext(context3, spanContext) {
      return setSpan(context3, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    exports.setSpanContext = setSpanContext;
    function getSpanContext(context3) {
      var _a61;
      return (_a61 = getSpan(context3)) === null || _a61 === void 0 ? void 0 : _a61.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    exports.getSpanContext = getSpanContext;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    exports.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    exports.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    exports.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    exports.wrapSpanContext = wrapSpanContext;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracer = void 0;
    var context_1 = require_context2();
    var context_utils_1 = require_context_utils();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var spancontext_utils_1 = require_spancontext_utils();
    var contextApi = context_1.ContextAPI.getInstance();
    var NoopTracer = class {
      static {
        __name(this, "NoopTracer");
      }
      // startSpan starts a noop span.
      startSpan(name51, options, context3 = contextApi.active()) {
        const root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
        const parentFromContext = context3 && (0, context_utils_1.getSpanContext)(context3);
        if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
          return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
      }
      startActiveSpan(name51, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        const span = this.startSpan(name51, opts, parentContext);
        const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      }
    };
    exports.NoopTracer = NoopTracer;
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NOOP_TRACER = new NoopTracer_1.NoopTracer();
    var ProxyTracer = class {
      static {
        __name(this, "ProxyTracer");
      }
      constructor(_provider, name51, version4, options) {
        this._provider = _provider;
        this.name = name51;
        this.version = version4;
        this.options = options;
      }
      startSpan(name51, options, context3) {
        return this._getTracer().startSpan(name51, options, context3);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        const tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate) {
          return this._delegate;
        }
        const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      }
    };
    exports.ProxyTracer = ProxyTracer;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NoopTracerProvider = class {
      static {
        __name(this, "NoopTracerProvider");
      }
      getTracer(_name, _version, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    exports.NoopTracerProvider = NoopTracerProvider;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer();
    var NoopTracerProvider_1 = require_NoopTracerProvider();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
    var ProxyTracerProvider = class {
      static {
        __name(this, "ProxyTracerProvider");
      }
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name51, version4, options) {
        var _a61;
        return (_a61 = this.getDelegateTracer(name51, version4, options)) !== null && _a61 !== void 0 ? _a61 : new ProxyTracer_1.ProxyTracer(this, name51, version4, options);
      }
      getDelegate() {
        var _a61;
        return (_a61 = this._delegate) !== null && _a61 !== void 0 ? _a61 : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name51, version4, options) {
        var _a61;
        return (_a61 = this._delegate) === null || _a61 === void 0 ? void 0 : _a61.getTracer(name51, version4, options);
      }
    };
    exports.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanKind = void 0;
    var SpanKind2;
    (function(SpanKind3) {
      SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
      SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
      SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
      SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
      SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind2 = exports.SpanKind || (exports.SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/status.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanStatusCode = void 0;
    var SpanStatusCode3;
    (function(SpanStatusCode4) {
      SpanStatusCode4[SpanStatusCode4["UNSET"] = 0] = "UNSET";
      SpanStatusCode4[SpanStatusCode4["OK"] = 1] = "OK";
      SpanStatusCode4[SpanStatusCode4["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode3 = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    exports.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    __name(validateValue, "validateValue");
    exports.validateValue = validateValue;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = class _TraceStateImpl {
      static {
        __name(this, "TraceStateImpl");
      }
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceStateImpl = TraceStateImpl;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    __name(createTraceState, "createTraceState");
    exports.createTraceState = createTraceState;
  }
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context-api.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.context = void 0;
    var context_1 = require_context2();
    exports.context = context_1.ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag-api.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diag = void 0;
    var diag_1 = require_diag();
    exports.diag = diag_1.DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter();
    var NoopMeterProvider = class {
      static {
        __name(this, "NoopMeterProvider");
      }
      getMeter(_name, _version, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    exports.NoopMeterProvider = NoopMeterProvider;
    exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "metrics";
    var MetricsAPI = class _MetricsAPI {
      static {
        __name(this, "MetricsAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _MetricsAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name51, version4, options) {
        return this.getMeterProvider().getMeter(name51, version4, options);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.MetricsAPI = MetricsAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metrics = void 0;
    var metrics_1 = require_metrics();
    exports.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      static {
        __name(this, "NoopTextMapPropagator");
      }
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context3, _carrier) {
        return context3;
      }
      fields() {
        return [];
      }
    };
    exports.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = void 0;
    var context_1 = require_context2();
    var context_2 = require_context();
    var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context3) {
      return context3.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    exports.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    __name(getActiveBaggage, "getActiveBaggage");
    exports.getActiveBaggage = getActiveBaggage;
    function setBaggage(context3, baggage) {
      return context3.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    exports.setBaggage = setBaggage;
    function deleteBaggage(context3) {
      return context3.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    exports.deleteBaggage = deleteBaggage;
  }
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
    var TextMapPropagator_1 = require_TextMapPropagator();
    var context_helpers_1 = require_context_helpers();
    var utils_1 = require_utils();
    var diag_1 = require_diag();
    var API_NAME = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
    var PropagationAPI = class _PropagationAPI {
      static {
        __name(this, "PropagationAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage;
        this.getBaggage = context_helpers_1.getBaggage;
        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
        this.setBaggage = context_helpers_1.setBaggage;
        this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _PropagationAPI();
        }
        return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context3, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context3, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    exports.PropagationAPI = PropagationAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.propagation = void 0;
    var propagation_1 = require_propagation();
    exports.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/trace.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceAPI = void 0;
    var global_utils_1 = require_global_utils();
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    var spancontext_utils_1 = require_spancontext_utils();
    var context_utils_1 = require_context_utils();
    var diag_1 = require_diag();
    var API_NAME = "trace";
    var TraceAPI = class _TraceAPI {
      static {
        __name(this, "TraceAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
        this.deleteSpan = context_utils_1.deleteSpan;
        this.getSpan = context_utils_1.getSpan;
        this.getActiveSpan = context_utils_1.getActiveSpan;
        this.getSpanContext = context_utils_1.getSpanContext;
        this.setSpan = context_utils_1.setSpan;
        this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _TraceAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        const success3 = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        if (success3) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success3;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name51, version4) {
        return this.getTracerProvider().getTracer(name51, version4);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    exports.TraceAPI = TraceAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace-api.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = void 0;
    var trace_1 = require_trace();
    exports.trace = trace_1.TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "node_modules/@opentelemetry/api/build/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_1.baggageEntryMetadataFromString;
    }, "get") });
    var context_1 = require_context();
    Object.defineProperty(exports, "createContextKey", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_1.createContextKey;
    }, "get") });
    Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_1.ROOT_CONTEXT;
    }, "get") });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return consoleLogger_1.DiagConsoleLogger;
    }, "get") });
    var types_1 = require_types();
    Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return types_1.DiagLogLevel;
    }, "get") });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopMeter_1.createNoopMeter;
    }, "get") });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports, "ValueType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Metric_1.ValueType;
    }, "get") });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return TextMapPropagator_1.defaultTextMapGetter;
    }, "get") });
    Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return TextMapPropagator_1.defaultTextMapSetter;
    }, "get") });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyTracer_1.ProxyTracer;
    }, "get") });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    }, "get") });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return SamplingResult_1.SamplingDecision;
    }, "get") });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports, "SpanKind", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return span_kind_1.SpanKind;
    }, "get") });
    var status_1 = require_status();
    Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return status_1.SpanStatusCode;
    }, "get") });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return trace_flags_1.TraceFlags;
    }, "get") });
    var utils_2 = require_utils2();
    Object.defineProperty(exports, "createTraceState", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_2.createTraceState;
    }, "get") });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isSpanContextValid;
    }, "get") });
    Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isValidTraceId;
    }, "get") });
    Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isValidSpanId;
    }, "get") });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_SPANID;
    }, "get") });
    Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_TRACEID;
    }, "get") });
    Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    }, "get") });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports, "context", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_api_1.context;
    }, "get") });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports, "diag", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return diag_api_1.diag;
    }, "get") });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports, "metrics", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return metrics_api_1.metrics;
    }, "get") });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports, "propagation", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return propagation_api_1.propagation;
    }, "get") });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports, "trace", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return trace_api_1.trace;
    }, "get") });
    exports.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// node_modules/@mastra/core/dist/chunk-UXG7PYML.js
var RegisteredLogger, LogLevel, MastraLogger, ConsoleLogger;
var init_chunk_UXG7PYML = __esm({
  "node_modules/@mastra/core/dist/chunk-UXG7PYML.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    RegisteredLogger = {
      AGENT: "AGENT",
      AI_TRACING: "AI_TRACING",
      AUTH: "AUTH",
      NETWORK: "NETWORK",
      WORKFLOW: "WORKFLOW",
      LLM: "LLM",
      TTS: "TTS",
      VOICE: "VOICE",
      VECTOR: "VECTOR",
      BUNDLER: "BUNDLER",
      DEPLOYER: "DEPLOYER",
      MEMORY: "MEMORY",
      STORAGE: "STORAGE",
      EMBEDDINGS: "EMBEDDINGS",
      MCP_SERVER: "MCP_SERVER",
      SERVER_CACHE: "SERVER_CACHE"
    };
    LogLevel = {
      DEBUG: "debug",
      INFO: "info",
      WARN: "warn",
      ERROR: "error",
      NONE: "silent"
    };
    MastraLogger = class {
      static {
        __name(this, "MastraLogger");
      }
      name;
      level;
      transports;
      constructor(options = {}) {
        this.name = options.name || "Mastra";
        this.level = options.level || LogLevel.ERROR;
        this.transports = new Map(Object.entries(options.transports || {}));
      }
      getTransports() {
        return this.transports;
      }
      trackException(_error) {
      }
      async getLogs(transportId, params) {
        if (!transportId || !this.transports.has(transportId)) {
          return { logs: [], total: 0, page: params?.page ?? 1, perPage: params?.perPage ?? 100, hasMore: false };
        }
        return this.transports.get(transportId).getLogs(params) ?? {
          logs: [],
          total: 0,
          page: params?.page ?? 1,
          perPage: params?.perPage ?? 100,
          hasMore: false
        };
      }
      async getLogsByRunId({
        transportId,
        runId,
        fromDate,
        toDate,
        logLevel,
        filters,
        page,
        perPage
      }) {
        if (!transportId || !this.transports.has(transportId) || !runId) {
          return { logs: [], total: 0, page: page ?? 1, perPage: perPage ?? 100, hasMore: false };
        }
        return this.transports.get(transportId).getLogsByRunId({ runId, fromDate, toDate, logLevel, filters, page, perPage }) ?? {
          logs: [],
          total: 0,
          page: page ?? 1,
          perPage: perPage ?? 100,
          hasMore: false
        };
      }
    };
    ConsoleLogger = class extends MastraLogger {
      static {
        __name(this, "ConsoleLogger");
      }
      constructor(options = {}) {
        super(options);
      }
      debug(message, ...args) {
        if (this.level === LogLevel.DEBUG) {
          console.info(message, ...args);
        }
      }
      info(message, ...args) {
        if (this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
          console.info(message, ...args);
        }
      }
      warn(message, ...args) {
        if (this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
          console.info(message, ...args);
        }
      }
      error(message, ...args) {
        if (this.level === LogLevel.ERROR || this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
          console.error(message, ...args);
        }
      }
      async getLogs(_transportId, _params) {
        return { logs: [], total: 0, page: _params?.page ?? 1, perPage: _params?.perPage ?? 100, hasMore: false };
      }
      async getLogsByRunId(_args) {
        return { logs: [], total: 0, page: _args.page ?? 1, perPage: _args.perPage ?? 100, hasMore: false };
      }
    };
  }
});

// node_modules/@mastra/core/dist/chunk-VQASQG5D.js
var MastraBase;
var init_chunk_VQASQG5D = __esm({
  "node_modules/@mastra/core/dist/chunk-VQASQG5D.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_UXG7PYML();
    MastraBase = class {
      static {
        __name(this, "MastraBase");
      }
      component = RegisteredLogger.LLM;
      logger;
      name;
      telemetry;
      constructor({ component, name: name51 }) {
        this.component = component || RegisteredLogger.LLM;
        this.name = name51;
        this.logger = new ConsoleLogger({ name: `${this.component} - ${this.name}` });
      }
      /**
       * Set the logger for the agent
       * @param logger
       */
      __setLogger(logger) {
        this.logger = logger;
        if (this.component !== RegisteredLogger.LLM) {
          this.logger.debug(`Logger updated [component=${this.component}] [name=${this.name}]`);
        }
      }
      /**
       * Set the telemetry for the
       * @param telemetry
       */
      __setTelemetry(telemetry) {
        this.telemetry = telemetry;
        if (this.component !== RegisteredLogger.LLM) {
          this.logger.debug(`Telemetry updated [component=${this.component}] [name=${this.telemetry.name}]`);
        }
      }
      /**
       * Get the telemetry on the vector
       * @returns telemetry
       */
      __getTelemetry() {
        return this.telemetry;
      }
      /* 
        get experimental_telemetry config
        */
      get experimental_telemetry() {
        return this.telemetry ? {
          // tracer: this.telemetry.tracer,
          tracer: this.telemetry.getBaggageTracer(),
          isEnabled: !!this.telemetry.tracer
        } : void 0;
      }
    };
  }
});

// node_modules/eventsource-parser/dist/index.js
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  __name(feed, "feed");
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  __name(parseLine, "parseLine");
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  __name(processField, "processField");
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  __name(dispatchEvent, "dispatchEvent");
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  __name(reset, "reset");
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var ParseError;
var init_dist = __esm({
  "node_modules/eventsource-parser/dist/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    ParseError = class extends Error {
      static {
        __name(this, "ParseError");
      }
      constructor(message, options) {
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
      }
    };
    __name(noop, "noop");
    __name(createParser, "createParser");
    __name(splitLines, "splitLines");
  }
});

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream;
var init_stream = __esm({
  "node_modules/eventsource-parser/dist/stream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist();
    EventSourceParserStream = class extends TransformStream {
      static {
        __name(this, "EventSourceParserStream");
      }
      constructor({ onError, onRetry, onComment } = {}) {
        let parser;
        super({
          start(controller) {
            parser = createParser({
              onEvent: /* @__PURE__ */ __name((event) => {
                controller.enqueue(event);
              }, "onEvent"),
              onError(error87) {
                onError === "terminate" ? controller.error(error87) : typeof onError == "function" && onError(error87);
              },
              onRetry,
              onComment
            });
          },
          transform(chunk) {
            parser.feed(chunk);
          }
        });
      }
    };
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name51, initializer5, params) {
  function init(inst, def) {
    var _a61;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a61 = inst._zod).traits ?? (_a61.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name51);
    initializer5(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", { value: name51 });
  function _(def) {
    var _a61;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a61 = inst._zod).deferred ?? (_a61.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  __name(_, "_");
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name51);
    }, "value")
  });
  Object.defineProperty(_, "name", { value: name51 });
  return _;
}
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, globalConfig;
var init_core = __esm({
  "node_modules/zod/v4/core/core.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    NEVER = Object.freeze({
      status: "aborted"
    });
    __name($constructor, "$constructor");
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      static {
        __name(this, "$ZodAsyncError");
      }
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    globalConfig = {};
    __name(config2, "config");
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert2,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert2(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object5, key, getter) {
  const set3 = false;
  Object.defineProperty(object5, key, {
    get() {
      if (!set3) {
        const value = getter();
        object5[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object5, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: /* @__PURE__ */ __name(() => params, "error") };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: /* @__PURE__ */ __name(() => params.error, "error") };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class3 ? new Class3({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class3, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class3({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path3, issues) {
  return issues.map((iss) => {
    var _a61;
    (_a61 = iss).path ?? (_a61.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config4) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config4.customError?.(iss)) ?? unwrapMessage(config4.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/zod/v4/core/util.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    __name(assertEqual, "assertEqual");
    __name(assertNotEqual, "assertNotEqual");
    __name(assertIs, "assertIs");
    __name(assertNever, "assertNever");
    __name(assert2, "assert");
    __name(getEnumValues, "getEnumValues");
    __name(joinValues, "joinValues");
    __name(jsonStringifyReplacer, "jsonStringifyReplacer");
    __name(cached, "cached");
    __name(nullish, "nullish");
    __name(cleanRegex, "cleanRegex");
    __name(floatSafeRemainder, "floatSafeRemainder");
    __name(defineLazy, "defineLazy");
    __name(assignProp, "assignProp");
    __name(getElementAtPath, "getElementAtPath");
    __name(promiseAllObject, "promiseAllObject");
    __name(randomString, "randomString");
    __name(esc, "esc");
    captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
    };
    __name(isObject, "isObject");
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && "Cloudflare-Workers"?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    __name(isPlainObject, "isPlainObject");
    __name(numKeys, "numKeys");
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    }, "getParsedType");
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    __name(escapeRegex, "escapeRegex");
    __name(clone, "clone");
    __name(normalizeParams, "normalizeParams");
    __name(createTransparentProxy, "createTransparentProxy");
    __name(stringifyPrimitive, "stringifyPrimitive");
    __name(optionalKeys, "optionalKeys");
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    __name(pick, "pick");
    __name(omit, "omit");
    __name(extend, "extend");
    __name(merge, "merge");
    __name(partial, "partial");
    __name(required, "required");
    __name(aborted, "aborted");
    __name(prefixIssues, "prefixIssues");
    __name(unwrapMessage, "unwrapMessage");
    __name(finalizeIssue, "finalizeIssue");
    __name(getSizableOrigin, "getSizableOrigin");
    __name(getLengthableOrigin, "getLengthableOrigin");
    __name(issue, "issue");
    __name(cleanEnum, "cleanEnum");
    Class = class {
      static {
        __name(this, "Class");
      }
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error87, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error87.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error87, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = /* @__PURE__ */ __name((error88) => {
    for (const issue3 of error88.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  }, "processError");
  processError(error87);
  return fieldErrors;
}
function treeifyError(error87, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = /* @__PURE__ */ __name((error88, path3 = []) => {
    var _a61, _b;
    for (const issue3 of error88.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path3, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a61 = curr.properties)[el] ?? (_a61[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  }, "processError");
  processError(error87);
  return result;
}
function toDotPath(path3) {
  const segs = [];
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error87) {
  const lines = [];
  const issues = [...error87.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue3.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core();
    init_util();
    initializer = /* @__PURE__ */ __name((inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      Object.defineProperty(inst, "message", {
        get() {
          return JSON.stringify(def, jsonStringifyReplacer, 2);
        },
        enumerable: true
        // configurable: false,
      });
      Object.defineProperty(inst, "toString", {
        value: /* @__PURE__ */ __name(() => inst.message, "value"),
        enumerable: false
      });
    }, "initializer");
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
    __name(flattenError, "flattenError");
    __name(formatError, "formatError");
    __name(treeifyError, "treeifyError");
    __name(toDotPath, "toDotPath");
    __name(prettifyError, "prettifyError");
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync;
var init_parse = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core();
    init_errors();
    init_util();
    _parse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    }, "_parse");
    parse = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    }, "_parseAsync");
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
      } : { success: true, data: result.value };
    }, "_safeParse");
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
      } : { success: true, data: result.value };
    }, "_safeParseAsync");
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  _emoji: () => _emoji,
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint2,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain2,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, browserEmail, _emoji, ipv4, ipv6, cidrv4, cidrv6, base64, base64url, hostname, domain2, e164, dateSource, date, string, bigint2, integer, number, boolean, _null, _undefined, lowercase, uppercase;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = /* @__PURE__ */ __name((version4) => {
      if (!version4)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version4}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    }, "uuid");
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    __name(emoji, "emoji");
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
    domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    __name(timeSource, "timeSource");
    __name(time, "time");
    __name(datetime, "datetime");
    string = /* @__PURE__ */ __name((params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    }, "string");
    bigint2 = /^\d+n?$/;
    integer = /^\d+$/;
    number = /^-?\d+(?:\.\d+)?/i;
    boolean = /true|false/i;
    _null = /null/i;
    _undefined = /undefined/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a61;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a61 = inst._zod).onattach ?? (_a61.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a61;
        (_a61 = inst2._zod.bag).multipleOf ?? (_a61.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt2 = def.format?.includes("int");
      const origin = isInt2 ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt2)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt2) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a61;
      $ZodCheck.init(inst, def);
      (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a61, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a61 = inst._zod).check ?? (_a61.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    __name(handleCheckPropertyResult, "handleCheckPropertyResult");
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    Doc = class {
      static {
        __name(this, "Doc");
      }
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version2;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    version2 = {
      major: 4,
      minor: 0,
      patch: 0
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base646 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base646.padEnd(Math.ceil(base646.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  });
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodUnion, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodReadonly, $ZodTemplateLiteral, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_checks();
    init_core();
    init_doc();
    init_parse();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a61;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version2;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a61 = inst._zod).deferred ?? (_a61.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
          let isAborted2 = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted2) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted2)
                  isAborted2 = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted2)
                isAborted2 = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        }, "runChecks");
        inst._zod.run = (payload, ctx) => {
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: /* @__PURE__ */ __name((value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        }, "validate"),
        vendor: "zod",
        version: 1
      };
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const orig = payload.value;
          const url3 = new URL(orig);
          const href = url3.href;
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url3.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (!orig.endsWith("/") && href.endsWith("/")) {
            payload.value = href.slice(0, -1);
          } else {
            payload.value = href;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const [address, prefix] = payload.value.split("/");
        try {
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    __name(isValidBase64, "isValidBase64");
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    __name(isValidBase64URL, "isValidBase64URL");
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    __name(isValidJWT, "isValidJWT");
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint2;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate3 = input instanceof Date;
        const isValidDate = isDate3 && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate3 ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    __name(handleArrayResult, "handleArrayResult");
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    __name(handleObjectResult, "handleObjectResult");
    __name(handleOptionalObjectResult, "handleOptionalObjectResult");
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const _normalized = cached(() => {
        const keys = Object.keys(def.shape);
        for (const k of keys) {
          if (!(def.shape[k] instanceof $ZodType)) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
          }
        }
        const okeys = optionalKeys(def.shape);
        return {
          shape: def.shape,
          keys,
          keySet: new Set(keys),
          numKeys: keys.length,
          optionalKeys: new Set(okeys)
        };
      });
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const generateFastpass = /* @__PURE__ */ __name((shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = /* @__PURE__ */ __name((key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        }, "parseStr");
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {}`);
        for (const key of normalized.keys) {
          if (normalized.optionalKeys.has(key)) {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            const k = esc(key);
            doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
          } else {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
            doc.write(`newResult[${esc(key)}] = ${id}.value`);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      }, "generateFastpass");
      let fastpass;
      const isObject4 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval3 = allowsEval;
      const fastEnabled = jit && allowsEval3.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
        } else {
          payload.value = {};
          const shape = value.shape;
          for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
            if (r instanceof Promise) {
              proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
            } else if (isOptional) {
              handleOptionalObjectResult(r, payload, key, input);
            } else {
              handleObjectResult(r, payload, key);
            }
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        const unrecognized = [];
        const keySet = value.keySet;
        const _catchall = catchall._zod;
        const t = _catchall.def.type;
        for (const key of Object.keys(input)) {
          if (keySet.has(key))
            continue;
          if (t === "never") {
            unrecognized.push(key);
            continue;
          }
          const r = _catchall.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
          } else {
            handleObjectResult(r, payload, key);
          }
        }
        if (unrecognized.length) {
          payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst
          });
        }
        if (!proms.length)
          return payload;
        return Promise.all(proms).then(() => {
          return payload;
        });
      };
    });
    __name(handleUnionResults, "handleUnionResults");
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map3 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map3.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map3.set(v, o);
          }
        }
        return map3;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    __name(mergeValues, "mergeValues");
    __name(handleIntersectionResults, "handleIntersectionResults");
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              input,
              inst,
              origin: "array",
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    __name(handleTupleResult, "handleTupleResult");
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    __name(handleMapResult, "handleMapResult");
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    __name(handleSetResult, "handleSetResult");
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      inst._zod.values = new Set(values);
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const _out = def.transform(payload.value, payload);
        if (_ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    __name(handleDefaultResult, "handleDefaultResult");
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    __name(handleNonOptionalResult, "handleNonOptionalResult");
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def, ctx));
        }
        return handlePipeResult(left, def, ctx);
      };
    });
    __name(handlePipeResult, "handlePipeResult");
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    __name(handleReadonlyResult, "handleReadonlyResult");
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (part instanceof $ZodType) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
    __name(handleRefineResult, "handleRefineResult");
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    }, "error");
    __name(ar_default, "default");
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error2 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue3.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    }, "error");
    __name(az_default, "default");
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    __name(getBelarusianPlural, "getBelarusianPlural");
    error3 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    }, "error");
    __name(be_default, "default");
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error4 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType5(issue3.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue3.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue3.values, " o ")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue3.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    }, "error");
    __name(ca_default, "default");
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error5 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue3.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue3.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    }, "error");
    __name(cs_default, "default");
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error6 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue3.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue3.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    }, "error");
    __name(de_default, "default");
  }
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error7()
  };
}
var parsedType, error7;
var init_en = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    parsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    }, "parsedType");
    error7 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue3.expected}, received ${parsedType(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue3.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue3.origin}`;
          default:
            return `Invalid input`;
        }
      };
    }, "error");
    __name(en_default, "default");
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error8()
  };
}
var parsedType2, error8;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    parsedType2 = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    }, "parsedType");
    error8 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType2(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue3.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue3.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue3.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    }, "error");
    __name(eo_default, "default");
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error9 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "arreglo";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${issue3.expected}, recibido ${parsedType5(issue3.input)}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue3.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${issue3.origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${issue3.origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${issue3.origin} fuera ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${issue3.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    }, "error");
    __name(es_default, "default");
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error10()
  };
}
var error10;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error10 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType5(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    }, "error");
    __name(fa_default, "default");
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error11 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue3.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    }, "error");
    __name(fi_default, "default");
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error12 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType5(issue3.input)} re\xE7u`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue3.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue3.values, "|")} attendue`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    }, "error");
    __name(fr_default, "default");
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error13 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue3.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    }, "error");
    __name(fr_CA_default, "default");
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error14 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType5(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue3.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    }, "error");
    __name(he_default, "default");
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error15 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType5(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue3.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    }, "error");
    __name(hu_default, "default");
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_id = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error16 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue3.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue3.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    }, "error");
    __name(id_default, "default");
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error17 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType5(issue3.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue3.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue3.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue3.origin}`;
          default:
            return `Input non valido`;
        }
      };
    }, "error");
    __name(it_default, "default");
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error18 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType5(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    }, "error");
    __name(ja_default, "default");
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error19 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue3.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    }, "error");
    __name(kh_default, "default");
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error20 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType5(issue3.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    }, "error");
    __name(ko_default, "default");
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error21 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType5(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    }, "error");
    __name(mk_default, "default");
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error22 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue3.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue3.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    }, "error");
    __name(ms_default, "default");
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error23 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue3.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue3.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue3.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    }, "error");
    __name(nl_default, "default");
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error24 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue3.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue3.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue3.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    }, "error");
    __name(no_default, "default");
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error25 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType5(issue3.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue3.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    }, "error");
    __name(ota_default, "default");
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error26()
  };
}
var error26;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error26 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType5(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue3.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    }, "error");
    __name(ps_default, "default");
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error27 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue3.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    }, "error");
    __name(pl_default, "default");
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error28 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue3.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue3.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    }, "error");
    __name(pt_default, "default");
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    __name(getRussianPlural, "getRussianPlural");
    error29 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    }, "error");
    __name(ru_default, "default");
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error30 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue3.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue3.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    }, "error");
    __name(sl_default, "default");
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error31 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue3.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    }, "error");
    __name(sv_default, "default");
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error32 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    }, "error");
    __name(ta_default, "default");
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error33 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    }, "error");
    __name(th_default, "default");
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error34()
  };
}
var parsedType3, error34;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    parsedType3 = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    }, "parsedType");
    error34 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType3(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue3.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    }, "error");
    __name(tr_default, "default");
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error35 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType5(issue3.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    }, "error");
    __name(ua_default, "default");
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error36 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType5(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    }, "error");
    __name(ur_default, "default");
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error37 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue3.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    }, "error");
    __name(vi_default, "default");
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error38 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue3.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    }, "error");
    __name(zh_CN_default, "default");
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util();
    error39 = /* @__PURE__ */ __name(() => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      __name(getSizing, "getSizing");
      const parsedType5 = /* @__PURE__ */ __name((data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      }, "parsedType");
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue3.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    }, "error");
    __name(zh_TW_default, "default");
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_ar();
    init_az();
    init_be();
    init_ca();
    init_cs();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_id();
    init_it();
    init_ja();
    init_kh();
    init_ko();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_ur();
    init_vi();
    init_zh_CN();
    init_zh_TW();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      static {
        __name(this, "$ZodRegistry");
      }
      constructor() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          if (this._idmap.has(meta3.id)) {
            throw new Error(`ID ${meta3.id} already exists in the registry`);
          }
          this._idmap.set(meta3.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta3 = this._map.get(schema);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          return { ...pm, ...this._map.get(schema) };
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    __name(registry, "registry");
    globalRegistry = /* @__PURE__ */ registry();
  }
});

// node_modules/zod/v4/core/api.js
function _string(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom(Class3, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: /* @__PURE__ */ __name((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    }, "transform"),
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_checks();
    init_schemas();
    init_util();
    __name(_string, "_string");
    __name(_coercedString, "_coercedString");
    __name(_email, "_email");
    __name(_guid, "_guid");
    __name(_uuid, "_uuid");
    __name(_uuidv4, "_uuidv4");
    __name(_uuidv6, "_uuidv6");
    __name(_uuidv7, "_uuidv7");
    __name(_url, "_url");
    __name(_emoji2, "_emoji");
    __name(_nanoid, "_nanoid");
    __name(_cuid, "_cuid");
    __name(_cuid2, "_cuid2");
    __name(_ulid, "_ulid");
    __name(_xid, "_xid");
    __name(_ksuid, "_ksuid");
    __name(_ipv4, "_ipv4");
    __name(_ipv6, "_ipv6");
    __name(_cidrv4, "_cidrv4");
    __name(_cidrv6, "_cidrv6");
    __name(_base64, "_base64");
    __name(_base64url, "_base64url");
    __name(_e164, "_e164");
    __name(_jwt, "_jwt");
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
    __name(_isoDateTime, "_isoDateTime");
    __name(_isoDate, "_isoDate");
    __name(_isoTime, "_isoTime");
    __name(_isoDuration, "_isoDuration");
    __name(_number, "_number");
    __name(_coercedNumber, "_coercedNumber");
    __name(_int, "_int");
    __name(_float32, "_float32");
    __name(_float64, "_float64");
    __name(_int32, "_int32");
    __name(_uint32, "_uint32");
    __name(_boolean, "_boolean");
    __name(_coercedBoolean, "_coercedBoolean");
    __name(_bigint, "_bigint");
    __name(_coercedBigint, "_coercedBigint");
    __name(_int64, "_int64");
    __name(_uint64, "_uint64");
    __name(_symbol, "_symbol");
    __name(_undefined2, "_undefined");
    __name(_null2, "_null");
    __name(_any, "_any");
    __name(_unknown, "_unknown");
    __name(_never, "_never");
    __name(_void, "_void");
    __name(_date, "_date");
    __name(_coercedDate, "_coercedDate");
    __name(_nan, "_nan");
    __name(_lt, "_lt");
    __name(_lte, "_lte");
    __name(_gt, "_gt");
    __name(_gte, "_gte");
    __name(_positive, "_positive");
    __name(_negative, "_negative");
    __name(_nonpositive, "_nonpositive");
    __name(_nonnegative, "_nonnegative");
    __name(_multipleOf, "_multipleOf");
    __name(_maxSize, "_maxSize");
    __name(_minSize, "_minSize");
    __name(_size, "_size");
    __name(_maxLength, "_maxLength");
    __name(_minLength, "_minLength");
    __name(_length, "_length");
    __name(_regex, "_regex");
    __name(_lowercase, "_lowercase");
    __name(_uppercase, "_uppercase");
    __name(_includes, "_includes");
    __name(_startsWith, "_startsWith");
    __name(_endsWith, "_endsWith");
    __name(_property, "_property");
    __name(_mime, "_mime");
    __name(_overwrite, "_overwrite");
    __name(_normalize, "_normalize");
    __name(_trim, "_trim");
    __name(_toLowerCase, "_toLowerCase");
    __name(_toUpperCase, "_toUpperCase");
    __name(_array, "_array");
    __name(_union, "_union");
    __name(_discriminatedUnion, "_discriminatedUnion");
    __name(_intersection, "_intersection");
    __name(_tuple, "_tuple");
    __name(_record, "_record");
    __name(_map, "_map");
    __name(_set, "_set");
    __name(_enum, "_enum");
    __name(_nativeEnum, "_nativeEnum");
    __name(_literal, "_literal");
    __name(_file, "_file");
    __name(_transform, "_transform");
    __name(_optional, "_optional");
    __name(_nullable, "_nullable");
    __name(_default, "_default");
    __name(_nonoptional, "_nonoptional");
    __name(_success, "_success");
    __name(_catch, "_catch");
    __name(_pipe, "_pipe");
    __name(_readonly, "_readonly");
    __name(_templateLiteral, "_templateLiteral");
    __name(_lazy, "_lazy");
    __name(_promise, "_promise");
    __name(_custom, "_custom");
    __name(_refine, "_refine");
    __name(_stringbool, "_stringbool");
    __name(_stringFormat, "_stringFormat");
  }
});

// node_modules/zod/v4/core/function.js
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
var $ZodFunction;
var init_function = __esm({
  "node_modules/zod/v4/core/function.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_api();
    init_parse();
    init_schemas();
    init_schemas();
    $ZodFunction = class {
      static {
        __name(this, "$ZodFunction");
      }
      constructor(def) {
        this._def = def;
        this.def = def;
      }
      implement(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = /* @__PURE__ */ __name(((...args) => {
          const parsedArgs = this._def.input ? parse(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = func(...parsedArgs);
          return this._def.output ? parse(this._def.output, output, void 0, { callee: impl }) : output;
        }), "impl");
        return impl;
      }
      implementAsync(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = /* @__PURE__ */ __name((async (...args) => {
          const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = await func(...parsedArgs);
          return this._def.output ? parseAsync(this._def.output, output, void 0, { callee: impl }) : output;
        }), "impl");
        return impl;
      }
      input(...args) {
        const F = this.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: this._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: this._def.output
        });
      }
      output(output) {
        const F = this.constructor;
        return new F({
          type: "function",
          input: this._def.input,
          output
        });
      }
    };
    __name(_function, "_function");
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
var JSONSchemaGenerator;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_registries();
    init_util();
    JSONSchemaGenerator = class {
      static {
        __name(this, "JSONSchemaGenerator");
      }
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a61;
        const def = schema._zod.def;
        const formatMap2 = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json3 = _json;
                json3.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minLength = minimum;
                if (typeof maximum === "number")
                  json3.maxLength = maximum;
                if (format) {
                  json3.format = formatMap2[format] ?? format;
                  if (json3.format === "")
                    delete json3.format;
                }
                if (contentEncoding)
                  json3.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json3.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json3 = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json3.type = "integer";
                else
                  json3.type = "number";
                if (typeof exclusiveMinimum === "number")
                  json3.exclusiveMinimum = exclusiveMinimum;
                if (typeof minimum === "number") {
                  json3.minimum = minimum;
                  if (typeof exclusiveMinimum === "number") {
                    if (exclusiveMinimum >= minimum)
                      delete json3.minimum;
                    else
                      delete json3.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number")
                  json3.exclusiveMaximum = exclusiveMaximum;
                if (typeof maximum === "number") {
                  json3.maximum = maximum;
                  if (typeof exclusiveMaximum === "number") {
                    if (exclusiveMaximum <= maximum)
                      delete json3.maximum;
                    else
                      delete json3.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json3.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json3 = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                json3.type = "array";
                json3.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json3 = _json;
                json3.type = "object";
                json3.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json3.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json3.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json3.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json3.additionalProperties = false;
                } else if (def.catchall) {
                  json3.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json3 = _json;
                json3.anyOf = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                break;
              }
              case "intersection": {
                const json3 = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json3.allOf = allOf;
                break;
              }
              case "tuple": {
                const json3 = _json;
                json3.type = "array";
                const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
                if (this.target === "draft-2020-12") {
                  json3.prefixItems = prefixItems;
                } else {
                  json3.items = prefixItems;
                }
                if (def.rest) {
                  const rest = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                  if (this.target === "draft-2020-12") {
                    json3.items = rest;
                  } else {
                    json3.additionalItems = rest;
                  }
                }
                if (def.rest) {
                  json3.items = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                break;
              }
              case "record": {
                const json3 = _json;
                json3.type = "object";
                json3.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
                json3.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json3 = _json;
                const values = getEnumValues(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json3.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json3.type = "string";
                json3.enum = values;
                break;
              }
              case "literal": {
                const json3 = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json3.type = val === null ? "null" : typeof val;
                  json3.const = val;
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json3.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json3.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json3.type = "string";
                  if (vals.every((v) => v === null))
                    json3.type = "null";
                  json3.enum = vals;
                }
                break;
              }
              case "file": {
                const json3 = _json;
                const file3 = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file3.minLength = minimum;
                if (maximum !== void 0)
                  file3.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file3.contentMediaType = mime[0];
                    Object.assign(json3, file3);
                  } else {
                    json3.anyOf = mime.map((m) => {
                      const mFile = { ...file3, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json3, file3);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                _json.anyOf = [inner, { type: "null" }];
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json3 = _json;
                const pattern = schema._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json3.type = "string";
                json3.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta3 = this.metadataRegistry.get(schema);
        if (meta3)
          Object.assign(result.schema, meta3);
        if (this.io === "input" && isTransforming(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a61 = result.schema).default ?? (_a61.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = /* @__PURE__ */ __name((entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        }, "makeURI");
        const extractToDef = /* @__PURE__ */ __name((entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref: ref2, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
          }
          schema2.$ref = ref2;
        }, "extractToDef");
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = /* @__PURE__ */ __name((zodSchema6, params2) => {
          const seen = this.seen.get(zodSchema6);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref2 = seen.ref;
          seen.ref = null;
          if (ref2) {
            flattenRef(ref2, params2);
            const refSchema = this.seen.get(ref2).schema;
            if (refSchema.$ref && params2.target === "draft-7") {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema: zodSchema6,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        }, "flattenRef");
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
    __name(toJSONSchema, "toJSONSchema");
    __name(isTransforming, "isTransforming");
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
  }
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config2,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version2
});
var init_core2 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core();
    init_parse();
    init_errors();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_function();
    init_api();
    init_to_json_schema();
    init_json_schema();
  }
});

// node_modules/zod/v4/classic/checks.js
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(datetime2, "datetime");
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(date2, "date");
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(time2, "time");
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(duration2, "duration");
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors2 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_core2();
    initializer2 = /* @__PURE__ */ __name((inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: /* @__PURE__ */ __name((mapper) => formatError(inst, mapper), "value")
          // enumerable: false,
        },
        flatten: {
          value: /* @__PURE__ */ __name((mapper) => flattenError(inst, mapper), "value")
          // enumerable: false,
        },
        addIssue: {
          value: /* @__PURE__ */ __name((issue3) => inst.issues.push(issue3), "value")
          // enumerable: false,
        },
        addIssues: {
          value: /* @__PURE__ */ __name((issues2) => inst.issues.push(...issues2), "value")
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    }, "initializer");
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse2, parseAsync2, safeParse2, safeParseAsync2;
var init_parse2 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_errors2();
    parse2 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint3(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(util_exports.issue(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json(params) {
  const jsonSchema6 = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema6), record(string2(), jsonSchema6)]);
  });
  return jsonSchema6;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodCustom, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_core2();
    init_checks2();
    init_iso();
    init_parse2();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(
          {
            ...def,
            checks: [
              ...def.checks ?? [],
              ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }
          // { parent: true }
        );
      };
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      });
      inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.refine = (check3, params) => inst.check(refine(check3, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    __name(string2, "string");
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(email2, "email");
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(guid2, "guid");
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(uuid2, "uuid");
    __name(uuidv4, "uuidv4");
    __name(uuidv6, "uuidv6");
    __name(uuidv7, "uuidv7");
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(url, "url");
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(emoji2, "emoji");
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(nanoid2, "nanoid");
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(cuid3, "cuid");
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(cuid22, "cuid2");
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(ulid2, "ulid");
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(xid2, "xid");
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(ksuid2, "ksuid");
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(ipv42, "ipv4");
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(ipv62, "ipv6");
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(cidrv42, "cidrv4");
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(cidrv62, "cidrv6");
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(base642, "base64");
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(base64url2, "base64url");
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(e1642, "e164");
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(jwt, "jwt");
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    __name(stringFormat, "stringFormat");
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    __name(number2, "number");
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    __name(int, "int");
    __name(float32, "float32");
    __name(float64, "float64");
    __name(int32, "int32");
    __name(uint32, "uint32");
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(boolean2, "boolean");
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    __name(bigint3, "bigint");
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    __name(int64, "int64");
    __name(uint64, "uint64");
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(symbol, "symbol");
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(_undefined3, "_undefined");
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(_null3, "_null");
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(any, "any");
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(unknown, "unknown");
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(never, "never");
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(_void2, "_void");
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    __name(date3, "date");
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    __name(array, "array");
    __name(keyof, "keyof");
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObject.init(inst, def);
      ZodType.init(inst, def);
      util_exports.defineLazy(inst, "shape", () => def.shape);
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    __name(object, "object");
    __name(strictObject, "strictObject");
    __name(looseObject, "looseObject");
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst.options = def.options;
    });
    __name(union, "union");
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    __name(discriminatedUnion, "discriminatedUnion");
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(intersection, "intersection");
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    __name(tuple, "tuple");
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    __name(record, "record");
    __name(partialRecord, "partialRecord");
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    __name(map, "map");
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    __name(set, "set");
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    __name(_enum2, "_enum");
    __name(nativeEnum, "nativeEnum");
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    __name(literal, "literal");
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    __name(file, "file");
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.addIssue = (issue3) => {
          if (typeof issue3 === "string") {
            payload.issues.push(util_exports.issue(issue3, payload.value, def));
          } else {
            const _issue = issue3;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            _issue.continue ?? (_issue.continue = true);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    __name(transform, "transform");
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(optional, "optional");
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(nullable, "nullable");
    __name(nullish2, "nullish");
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    __name(_default2, "_default");
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(prefault, "prefault");
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(nonoptional, "nonoptional");
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(success, "success");
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    __name(_catch2, "_catch");
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(nan, "nan");
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    __name(pipe, "pipe");
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(readonly, "readonly");
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(templateLiteral, "templateLiteral");
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    __name(lazy, "lazy");
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    __name(promise, "promise");
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
    });
    __name(check, "check");
    __name(custom, "custom");
    __name(refine, "refine");
    __name(superRefine, "superRefine");
    __name(_instanceof, "_instanceof");
    stringbool = /* @__PURE__ */ __name((...args) => _stringbool({
      Pipe: ZodPipe,
      Boolean: ZodBoolean,
      String: ZodString,
      Transform: ZodTransform
    }, ...args), "stringbool");
    __name(json, "json");
    __name(preprocess, "preprocess");
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap() {
  return config2().customError;
}
var ZodIssueCode;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint4,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint4(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_schemas2();
    __name(string3, "string");
    __name(number3, "number");
    __name(boolean3, "boolean");
    __name(bigint4, "bigint");
    __name(date4, "date");
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  coerce: () => coerce_exports,
  config: () => config2,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
var init_external = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors2();
    init_parse2();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config2(en_default());
  }
});

// node_modules/zod/v4/classic/index.js
var classic_default;
var init_classic = __esm({
  "node_modules/zod/v4/classic/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_external();
    init_external();
    classic_default = external_exports;
  }
});

// node_modules/zod/v4/index.js
var v4_default;
var init_v4 = __esm({
  "node_modules/zod/v4/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_classic();
    init_classic();
    v4_default = classic_default;
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType2;
var init_util2 = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs3(_arg) {
      }
      __name(assertIs3, "assertIs");
      util2.assertIs = assertIs3;
      function assertNever3(_x) {
        throw new Error();
      }
      __name(assertNever3, "assertNever");
      util2.assertNever = assertNever3;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object5) => {
        const keys = [];
        for (const key in object5) {
          if (Object.prototype.hasOwnProperty.call(object5, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues3(array3, separator = " | ") {
        return array3.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues3, "joinValues");
      util2.joinValues = joinValues3;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType2 = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode2, quotelessJson, ZodError2;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_util2();
    ZodIssueCode2 = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json3 = JSON.stringify(obj, null, 2);
      return json3.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError2 = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue3) {
          return issue3.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error87) => {
          for (const issue3 of error87.issues) {
            if (issue3.code === "invalid_union") {
              issue3.unionErrors.map(processError);
            } else if (issue3.code === "invalid_return_type") {
              processError(issue3.returnTypeError);
            } else if (issue3.code === "invalid_arguments") {
              processError(issue3.argumentsError);
            } else if (issue3.path.length === 0) {
              fieldErrors._errors.push(mapper(issue3));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue3.path.length) {
                const el = issue3.path[i];
                const terminal = i === issue3.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue3));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue3) => issue3.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError2.create = (issues) => {
      const error87 = new ZodError2(issues);
      return error87;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default2;
var init_en2 = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_ZodError();
    init_util2();
    errorMap = /* @__PURE__ */ __name((issue3, _ctx) => {
      let message;
      switch (issue3.code) {
        case ZodIssueCode2.invalid_type:
          if (issue3.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue3.expected}, received ${issue3.received}`;
          }
          break;
        case ZodIssueCode2.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue3.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode2.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue3.keys, ", ")}`;
          break;
        case ZodIssueCode2.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue3.options)}`;
          break;
        case ZodIssueCode2.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue3.options)}, received '${issue3.received}'`;
          break;
        case ZodIssueCode2.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode2.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode2.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode2.invalid_string:
          if (typeof issue3.validation === "object") {
            if ("includes" in issue3.validation) {
              message = `Invalid input: must include "${issue3.validation.includes}"`;
              if (typeof issue3.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue3.validation.position}`;
              }
            } else if ("startsWith" in issue3.validation) {
              message = `Invalid input: must start with "${issue3.validation.startsWith}"`;
            } else if ("endsWith" in issue3.validation) {
              message = `Invalid input: must end with "${issue3.validation.endsWith}"`;
            } else {
              util.assertNever(issue3.validation);
            }
          } else if (issue3.validation !== "regex") {
            message = `Invalid ${issue3.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode2.too_small:
          if (issue3.type === "array")
            message = `Array must contain ${issue3.exact ? "exactly" : issue3.inclusive ? `at least` : `more than`} ${issue3.minimum} element(s)`;
          else if (issue3.type === "string")
            message = `String must contain ${issue3.exact ? "exactly" : issue3.inclusive ? `at least` : `over`} ${issue3.minimum} character(s)`;
          else if (issue3.type === "number")
            message = `Number must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${issue3.minimum}`;
          else if (issue3.type === "bigint")
            message = `Number must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${issue3.minimum}`;
          else if (issue3.type === "date")
            message = `Date must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue3.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.too_big:
          if (issue3.type === "array")
            message = `Array must contain ${issue3.exact ? `exactly` : issue3.inclusive ? `at most` : `less than`} ${issue3.maximum} element(s)`;
          else if (issue3.type === "string")
            message = `String must contain ${issue3.exact ? `exactly` : issue3.inclusive ? `at most` : `under`} ${issue3.maximum} character(s)`;
          else if (issue3.type === "number")
            message = `Number must be ${issue3.exact ? `exactly` : issue3.inclusive ? `less than or equal to` : `less than`} ${issue3.maximum}`;
          else if (issue3.type === "bigint")
            message = `BigInt must be ${issue3.exact ? `exactly` : issue3.inclusive ? `less than or equal to` : `less than`} ${issue3.maximum}`;
          else if (issue3.type === "date")
            message = `Date must be ${issue3.exact ? `exactly` : issue3.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue3.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode2.not_multiple_of:
          message = `Number must be a multiple of ${issue3.multipleOf}`;
          break;
        case ZodIssueCode2.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue3);
      }
      return { message };
    }, "errorMap");
    en_default2 = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap2(map3) {
  overrideErrorMap = map3;
}
function getErrorMap2() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors3 = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_en2();
    overrideErrorMap = en_default2;
    __name(setErrorMap2, "setErrorMap");
    __name(getErrorMap2, "getErrorMap");
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue3 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default2 ? void 0 : en_default2
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue3);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_errors3();
    init_en2();
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path: path3, errorMaps, issueData } = params;
      const fullPath = [...path3, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map3 of maps) {
        errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt3, alg) {
  if (!jwtRegex.test(jwt3))
    return false;
  try {
    const [header] = jwt3.split(".");
    if (!header)
      return false;
    const base646 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base646));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray2) {
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple2) {
    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues2(a, b) {
  const aType = getParsedType2(a);
  const bType = getParsedType2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom2(check3, _params = {}, fatal) {
  if (check3)
    return ZodAny2.create().superRefine((data, ctx) => {
      const r = check3(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny2.create();
}
var ParseInputLazyPath, handleResult, ZodType2, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString2, ZodNumber2, ZodBigInt2, ZodBoolean2, ZodDate2, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodArray2, ZodObject2, ZodUnion2, getDiscriminator, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodFunction, ZodLazy2, ZodLiteral2, ZodEnum2, ZodNativeEnum, ZodPromise2, ZodEffects, ZodOptional2, ZodNullable2, ZodDefault2, ZodCatch2, ZodNaN2, BRAND, ZodBranded, ZodPipeline, ZodReadonly2, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER2;
var init_types = __esm({
  "node_modules/zod/v3/types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_ZodError();
    init_errors3();
    init_errorUtil();
    init_parseUtil();
    init_util2();
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path3, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path3;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error87 = new ZodError2(ctx.common.issues);
            this._error = error87;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType2 = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType2(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType2(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType2(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check3, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check3(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode2.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check3, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check3(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional2.create(this, this._def);
      }
      nullable() {
        return ZodNullable2.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray2.create(this);
      }
      promise() {
        return ZodPromise2.create(this, this._def);
      }
      or(option) {
        return ZodUnion2.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection2.create(this, incoming, this._def);
      }
      transform(transform3) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform3 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault2({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch2({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly2.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT2, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString2 = class _ZodString3 extends ZodType2 {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check3 of this._def.checks) {
          if (check3.kind === "min") {
            if (input.data.length < check3.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check3.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "max") {
            if (input.data.length > check3.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check3.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "length") {
            const tooBig = input.data.length > check3.value;
            const tooSmall = input.data.length < check3.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode2.too_big,
                  maximum: check3.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check3.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode2.too_small,
                  minimum: check3.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check3.message
                });
              }
              status.dirty();
            }
          } else if (check3.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "regex") {
            check3.regex.lastIndex = 0;
            const testResult = check3.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "trim") {
            input.data = input.data.trim();
          } else if (check3.kind === "includes") {
            if (!input.data.includes(check3.value, check3.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { includes: check3.value, position: check3.position },
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check3.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check3.kind === "startsWith") {
            if (!input.data.startsWith(check3.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { startsWith: check3.value },
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "endsWith") {
            if (!input.data.endsWith(check3.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { endsWith: check3.value },
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "datetime") {
            const regex = datetimeRegex(check3);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "datetime",
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "date",
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "time") {
            const regex = timeRegex(check3);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "time",
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "ip") {
            if (!isValidIP(input.data, check3.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "jwt") {
            if (!isValidJWT2(input.data, check3.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "cidr") {
            if (!isValidCidr(input.data, check3.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode2.invalid_string,
                message: check3.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check3);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode2.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check3) {
        return new _ZodString3({
          ...this._def,
          checks: [...this._def.checks, check3]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString3({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString3({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString3({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString2.create = (params) => {
      return new ZodString2({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder2, "floatSafeRemainder");
    ZodNumber2 = class _ZodNumber extends ZodType2 {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check3 of this._def.checks) {
          if (check3.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_type,
                expected: "integer",
                received: "float",
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "min") {
            const tooSmall = check3.inclusive ? input.data < check3.value : input.data <= check3.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check3.value,
                type: "number",
                inclusive: check3.inclusive,
                exact: false,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "max") {
            const tooBig = check3.inclusive ? input.data > check3.value : input.data >= check3.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check3.value,
                type: "number",
                inclusive: check3.inclusive,
                exact: false,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "multipleOf") {
            if (floatSafeRemainder2(input.data, check3.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check3.value,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_finite,
                message: check3.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check3);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check3) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check3]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber2.create = (params) => {
      return new ZodNumber2({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt2 = class _ZodBigInt extends ZodType2 {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check3 of this._def.checks) {
          if (check3.kind === "min") {
            const tooSmall = check3.inclusive ? input.data < check3.value : input.data <= check3.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                type: "bigint",
                minimum: check3.value,
                inclusive: check3.inclusive,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "max") {
            const tooBig = check3.inclusive ? input.data > check3.value : input.data >= check3.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                type: "bigint",
                maximum: check3.value,
                inclusive: check3.inclusive,
                message: check3.message
              });
              status.dirty();
            }
          } else if (check3.kind === "multipleOf") {
            if (input.data % check3.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check3.value,
                message: check3.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check3);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check3) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check3]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt2.create = (params) => {
      return new ZodBigInt2({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean2 = class extends ZodType2 {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean2.create = (params) => {
      return new ZodBoolean2({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate2 = class _ZodDate extends ZodType2 {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check3 of this._def.checks) {
          if (check3.kind === "min") {
            if (input.data.getTime() < check3.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                message: check3.message,
                inclusive: true,
                exact: false,
                minimum: check3.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check3.kind === "max") {
            if (input.data.getTime() > check3.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                message: check3.message,
                inclusive: true,
                exact: false,
                maximum: check3.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check3);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check3) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check3]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate2.create = (params) => {
      return new ZodDate2({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol2 = class extends ZodType2 {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol2.create = (params) => {
      return new ZodSymbol2({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined2 = class extends ZodType2 {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined2.create = (params) => {
      return new ZodUndefined2({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull2 = class extends ZodType2 {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull2.create = (params) => {
      return new ZodNull2({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny2 = class extends ZodType2 {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny2.create = (params) => {
      return new ZodAny2({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown2 = class extends ZodType2 {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown2.create = (params) => {
      return new ZodUnknown2({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever2 = class extends ZodType2 {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever2.create = (params) => {
      return new ZodNever2({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid2 = class extends ZodType2 {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid2.create = (params) => {
      return new ZodVoid2({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray2 = class _ZodArray extends ZodType2 {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray2.create = (schema, params) => {
      return new ZodArray2({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject2 = class _ZodObject extends ZodType2 {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever2) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode2.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue3, ctx) => {
              const defaultError = this._def.errorMap?.(issue3, ctx).message ?? ctx.defaultError;
              if (issue3.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional2) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject2.create = (shape, params) => {
      return new ZodObject2({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject2.strictCreate = (shape, params) => {
      return new ZodObject2({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject2.lazycreate = (shape, params) => {
      return new ZodObject2({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion2 = class extends ZodType2 {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError2(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion2.create = (types, params) => {
      return new ZodUnion2({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy2) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral2) {
        return [type.value];
      } else if (type instanceof ZodEnum2) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault2) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined2) {
        return [void 0];
      } else if (type instanceof ZodNull2) {
        return [null];
      } else if (type instanceof ZodOptional2) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable2) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly2) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch2) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    __name(mergeValues2, "mergeValues");
    ZodIntersection2 = class extends ZodType2 {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues2(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection2.create = (left, right, params) => {
      return new ZodIntersection2({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple2 = class _ZodTuple extends ZodType2 {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple2.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple2({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord2 = class _ZodRecord extends ZodType2 {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType2) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString2.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap2 = class extends ZodType2 {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap2.create = (keyType, valueType, params) => {
      return new ZodMap2({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet2 = class _ZodSet extends ZodType2 {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet2.create = (valueType, params) => {
      return new ZodSet2({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType2 {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error87) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_arguments,
              argumentsError: error87
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error87) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_return_type,
              returnTypeError: error87
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise2) {
          const me = this;
          return OK(async function(...args) {
            const error87 = new ZodError2([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error87.addIssue(makeArgsIssue(args, e));
              throw error87;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error87.addIssue(makeReturnsIssue(result, e));
              throw error87;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple2.create(items).rest(ZodUnknown2.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
          returns: returns || ZodUnknown2.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy2 = class extends ZodType2 {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema4 = this._def.getter();
        return lazySchema4._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy2.create = (getter, params) => {
      return new ZodLazy2({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral2 = class extends ZodType2 {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral2.create = (value, params) => {
      return new ZodLiteral2({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum2 = class _ZodEnum extends ZodType2 {
      static {
        __name(this, "ZodEnum");
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum2.create = createZodEnum;
    ZodNativeEnum = class extends ZodType2 {
      static {
        __name(this, "ZodNativeEnum");
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise2 = class extends ZodType2 {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise2.create = (schema, params) => {
      return new ZodPromise2({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType2 {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess3, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess3 },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional2 = class extends ZodType2 {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional2.create = (type, params) => {
      return new ZodOptional2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable2 = class extends ZodType2 {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable2.create = (type, params) => {
      return new ZodNullable2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault2 = class extends ZodType2 {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault2.create = (type, params) => {
      return new ZodDefault2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch2 = class extends ZodType2 {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError2(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError2(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch2.create = (type, params) => {
      return new ZodCatch2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN2 = class extends ZodType2 {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType5 = this._getType(input);
        if (parsedType5 !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN2.create = (params) => {
      return new ZodNaN2({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType2 {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType2 {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly2 = class extends ZodType2 {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly2.create = (type, params) => {
      return new ZodReadonly2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom2, "custom");
    late = {
      object: ZodObject2.lazycreate
    };
    (function(ZodFirstPartyTypeKind3) {
      ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom2((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString2.create;
    numberType = ZodNumber2.create;
    nanType = ZodNaN2.create;
    bigIntType = ZodBigInt2.create;
    booleanType = ZodBoolean2.create;
    dateType = ZodDate2.create;
    symbolType = ZodSymbol2.create;
    undefinedType = ZodUndefined2.create;
    nullType = ZodNull2.create;
    anyType = ZodAny2.create;
    unknownType = ZodUnknown2.create;
    neverType = ZodNever2.create;
    voidType = ZodVoid2.create;
    arrayType = ZodArray2.create;
    objectType = ZodObject2.create;
    strictObjectType = ZodObject2.strictCreate;
    unionType = ZodUnion2.create;
    discriminatedUnionType = ZodDiscriminatedUnion2.create;
    intersectionType = ZodIntersection2.create;
    tupleType = ZodTuple2.create;
    recordType = ZodRecord2.create;
    mapType = ZodMap2.create;
    setType = ZodSet2.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy2.create;
    literalType = ZodLiteral2.create;
    enumType = ZodEnum2.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise2.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional2.create;
    nullableType = ZodNullable2.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name(((arg) => ZodString2.create({ ...arg, coerce: true })), "string"),
      number: /* @__PURE__ */ __name(((arg) => ZodNumber2.create({ ...arg, coerce: true })), "number"),
      boolean: /* @__PURE__ */ __name(((arg) => ZodBoolean2.create({
        ...arg,
        coerce: true
      })), "boolean"),
      bigint: /* @__PURE__ */ __name(((arg) => ZodBigInt2.create({ ...arg, coerce: true })), "bigint"),
      date: /* @__PURE__ */ __name(((arg) => ZodDate2.create({ ...arg, coerce: true })), "date")
    };
    NEVER2 = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports2 = {};
__export(external_exports2, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER2,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType2,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBigInt: () => ZodBigInt2,
  ZodBoolean: () => ZodBoolean2,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch2,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever2,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSchema: () => ZodType2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodSymbol: () => ZodSymbol2,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom2,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default2,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap2,
  getParsedType: () => getParsedType2,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap2,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external2 = __esm({
  "node_modules/zod/v3/external.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_errors3();
    init_parseUtil();
    init_typeAliases();
    init_util2();
    init_types();
    init_ZodError();
  }
});

// node_modules/zod/v3/index.js
var init_v3 = __esm({
  "node_modules/zod/v3/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_external2();
  }
});

// node_modules/@standard-schema/spec/dist/index.js
var init_dist2 = __esm({
  "node_modules/@standard-schema/spec/dist/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
  }
});

// node_modules/zod/index.js
var zod_default;
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_external2();
    init_external2();
    zod_default = external_exports2;
  }
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx10 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx10 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse12(text3, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text3)) {
        text3 = text3.toString();
      }
      if (text3 && text3.charCodeAt(0) === 65279) {
        text3 = text3.slice(1);
      }
      const obj = JSON.parse(text3, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx10.test(text3) === false && suspectConstructorRx10.test(text3) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx10.test(text3) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx10.test(text3) === false) {
          return obj;
        }
      }
      return filter10(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    __name(_parse12, "_parse");
    function filter10(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    __name(filter10, "filter");
    function parse5(text3, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse12(text3, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    __name(parse5, "parse");
    function safeParse5(text3, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse12(text3, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    __name(safeParse5, "safeParse");
    module.exports = parse5;
    module.exports.default = parse5;
    module.exports.parse = parse5;
    module.exports.safeParse = safeParse5;
    module.exports.scan = filter10;
  }
});

// node_modules/p-map/index.js
var p_map_exports = {};
__export(p_map_exports, {
  default: () => pMap,
  pMapIterable: () => pMapIterable,
  pMapSkip: () => pMapSkip
});
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve_, reject_) => {
    if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = /* @__PURE__ */ new Map();
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === void 0 ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const signalListener = /* @__PURE__ */ __name(() => {
      reject(signal.reason);
    }, "signalListener");
    const cleanup = /* @__PURE__ */ __name(() => {
      signal?.removeEventListener("abort", signalListener);
    }, "cleanup");
    const resolve3 = /* @__PURE__ */ __name((value) => {
      resolve_(value);
      cleanup();
    }, "resolve");
    const reject = /* @__PURE__ */ __name((reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
      cleanup();
    }, "reject");
    if (signal) {
      if (signal.aborted) {
        reject(signal.reason);
      }
      signal.addEventListener("abort", signalListener, { once: true });
    }
    const next = /* @__PURE__ */ __name(async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve3(result);
            return;
          }
          const pureResult = [];
          for (const [index2, value] of result.entries()) {
            if (skippedIndexesMap.get(index2) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve3(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index, value);
          }
          result[index] = value;
          resolvingCount--;
          await next();
        } catch (error87) {
          if (stopOnError) {
            reject(error87);
          } else {
            errors.push(error87);
            resolvingCount--;
            try {
              await next();
            } catch (error88) {
              reject(error88);
            }
          }
        }
      })();
    }, "next");
    (async () => {
      for (let index = 0; index < concurrency; index++) {
        try {
          await next();
        } catch (error87) {
          reject(error87);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
function pMapIterable(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  backpressure = concurrency
} = {}) {
  if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
    throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
  }
  if (typeof mapper !== "function") {
    throw new TypeError("Mapper function is required");
  }
  if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
  }
  if (!(Number.isSafeInteger(backpressure) && backpressure >= concurrency || backpressure === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`backpressure\` to be an integer from \`concurrency\` (${concurrency}) and up or \`Infinity\`, got \`${backpressure}\` (${typeof backpressure})`);
  }
  return {
    async *[Symbol.asyncIterator]() {
      const iterator = iterable[Symbol.asyncIterator] === void 0 ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();
      const promises = [];
      let pendingPromisesCount = 0;
      let isDone = false;
      let index = 0;
      function trySpawn() {
        if (isDone || !(pendingPromisesCount < concurrency && promises.length < backpressure)) {
          return;
        }
        pendingPromisesCount++;
        const promise3 = (async () => {
          const { done, value } = await iterator.next();
          if (done) {
            pendingPromisesCount--;
            return { done: true };
          }
          trySpawn();
          try {
            const returnValue = await mapper(await value, index++);
            pendingPromisesCount--;
            if (returnValue === pMapSkip) {
              const index2 = promises.indexOf(promise3);
              if (index2 > 0) {
                promises.splice(index2, 1);
              }
            }
            trySpawn();
            return { done: false, value: returnValue };
          } catch (error87) {
            pendingPromisesCount--;
            isDone = true;
            return { error: error87 };
          }
        })();
        promises.push(promise3);
      }
      __name(trySpawn, "trySpawn");
      trySpawn();
      while (promises.length > 0) {
        const { error: error87, done, value } = await promises[0];
        promises.shift();
        if (error87) {
          throw error87;
        }
        if (done) {
          return;
        }
        trySpawn();
        if (value === pMapSkip) {
          continue;
        }
        yield value;
      }
    }
  };
}
var pMapSkip;
var init_p_map = __esm({
  "node_modules/p-map/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    __name(pMap, "pMap");
    __name(pMapIterable, "pMapIterable");
    pMapSkip = Symbol("skip");
  }
});

// node_modules/@mastra/core/dist/chunk-BJ6XIEC6.js
var MastraModelGateway;
var init_chunk_BJ6XIEC6 = __esm({
  "node_modules/@mastra/core/dist/chunk-BJ6XIEC6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    MastraModelGateway = class {
      static {
        __name(this, "MastraModelGateway");
      }
      /**
       * Get the gateway ID
       */
      getId() {
        return this.id;
      }
    };
  }
});

// node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage5(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker19, symbol20, _a21, _AISDKError7, AISDKError4, name19, marker26, symbol27, _a26, APICallError3, name26, marker36, symbol36, _a36, EmptyResponseBodyError2, name36, marker46, symbol46, _a46, InvalidArgumentError5, name46, marker56, symbol56, _a56, name56, marker66, symbol66, _a66, name66, marker76, symbol76, _a76, JSONParseError3, name76, marker86, symbol86, _a86, LoadAPIKeyError2, name86, marker96, symbol96, _a96, name96, marker106, symbol106, _a106, name106, marker116, symbol116, _a116, NoSuchModelError2, name116, marker126, symbol126, _a126, name126, marker136, symbol136, _a136, _TypeValidationError5, TypeValidationError3, name136, marker146, symbol146, _a146, UnsupportedFunctionalityError3;
var init_dist3 = __esm({
  "node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker19 = "vercel.ai.error";
    symbol20 = Symbol.for(marker19);
    _AISDKError7 = class _AISDKError8 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a21] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError8.hasMarker(error87, marker19);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a21 = symbol20;
    AISDKError4 = _AISDKError7;
    name19 = "AI_APICallError";
    marker26 = `vercel.ai.error.${name19}`;
    symbol27 = Symbol.for(marker26);
    APICallError3 = class extends AISDKError4 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name19, message, cause });
        this[_a26] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker26);
      }
    };
    _a26 = symbol27;
    name26 = "AI_EmptyResponseBodyError";
    marker36 = `vercel.ai.error.${name26}`;
    symbol36 = Symbol.for(marker36);
    EmptyResponseBodyError2 = class extends AISDKError4 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name26, message });
        this[_a36] = true;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker36);
      }
    };
    _a36 = symbol36;
    __name(getErrorMessage5, "getErrorMessage");
    name36 = "AI_InvalidArgumentError";
    marker46 = `vercel.ai.error.${name36}`;
    symbol46 = Symbol.for(marker46);
    InvalidArgumentError5 = class extends AISDKError4 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name36, message, cause });
        this[_a46] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker46);
      }
    };
    _a46 = symbol46;
    name46 = "AI_InvalidPromptError";
    marker56 = `vercel.ai.error.${name46}`;
    symbol56 = Symbol.for(marker56);
    _a56 = symbol56;
    name56 = "AI_InvalidResponseDataError";
    marker66 = `vercel.ai.error.${name56}`;
    symbol66 = Symbol.for(marker66);
    _a66 = symbol66;
    name66 = "AI_JSONParseError";
    marker76 = `vercel.ai.error.${name66}`;
    symbol76 = Symbol.for(marker76);
    JSONParseError3 = class extends AISDKError4 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name66,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage5(cause)}`,
          cause
        });
        this[_a76] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker76);
      }
    };
    _a76 = symbol76;
    name76 = "AI_LoadAPIKeyError";
    marker86 = `vercel.ai.error.${name76}`;
    symbol86 = Symbol.for(marker86);
    LoadAPIKeyError2 = class extends AISDKError4 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name76, message });
        this[_a86] = true;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker86);
      }
    };
    _a86 = symbol86;
    name86 = "AI_LoadSettingError";
    marker96 = `vercel.ai.error.${name86}`;
    symbol96 = Symbol.for(marker96);
    _a96 = symbol96;
    name96 = "AI_NoContentGeneratedError";
    marker106 = `vercel.ai.error.${name96}`;
    symbol106 = Symbol.for(marker106);
    _a106 = symbol106;
    name106 = "AI_NoSuchModelError";
    marker116 = `vercel.ai.error.${name106}`;
    symbol116 = Symbol.for(marker116);
    NoSuchModelError2 = class extends AISDKError4 {
      static {
        __name(this, "NoSuchModelError");
      }
      constructor({
        errorName = name106,
        modelId,
        modelType,
        message = `No such ${modelType}: ${modelId}`
      }) {
        super({ name: errorName, message });
        this[_a116] = true;
        this.modelId = modelId;
        this.modelType = modelType;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker116);
      }
    };
    _a116 = symbol116;
    name116 = "AI_TooManyEmbeddingValuesForCallError";
    marker126 = `vercel.ai.error.${name116}`;
    symbol126 = Symbol.for(marker126);
    _a126 = symbol126;
    name126 = "AI_TypeValidationError";
    marker136 = `vercel.ai.error.${name126}`;
    symbol136 = Symbol.for(marker136);
    _TypeValidationError5 = class _TypeValidationError6 extends AISDKError4 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name126,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage5(cause)}`,
          cause
        });
        this[_a136] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker136);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError6.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError6({ value, cause });
      }
    };
    _a136 = symbol136;
    TypeValidationError3 = _TypeValidationError5;
    name136 = "AI_UnsupportedFunctionalityError";
    marker146 = `vercel.ai.error.${name136}`;
    symbol146 = Symbol.for(marker146);
    UnsupportedFunctionalityError3 = class extends AISDKError4 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name136, message });
        this[_a146] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError4.hasMarker(error87, marker146);
      }
    };
    _a146 = symbol146;
  }
});

// node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError4(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError4(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError3({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError2({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError2({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError2({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError2({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse4(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text3) === false && suspectConstructorRx2.test(text3) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse4(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator3(validate) {
  return { [validatorSymbol4]: true, validate };
}
function isValidator3(value) {
  return typeof value === "object" && value !== null && validatorSymbol4 in value && value[validatorSymbol4] === true && "validate" in value;
}
function asValidator3(value) {
  return isValidator3(value) ? value : typeof value === "function" ? value() : standardSchemaValidator2(value);
}
function standardSchemaValidator2(standardSchema) {
  return validator3(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError3({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes2({
  value,
  schema
}) {
  const result = await safeValidateTypes3({ value, schema });
  if (!result.success) {
    throw TypeValidationError3.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes3({
  value,
  schema
}) {
  const validator22 = asValidator3(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse2(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes2({ value, schema });
  } catch (error87) {
    if (JSONParseError3.isInstance(error87) || TypeValidationError3.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError3({ text: text3, cause: error87 });
  }
}
async function safeParseJSON3({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse2(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes3({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError3.isInstance(error87) ? error87 : new JSONParseError3({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON3({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes3({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError5({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function tool2(tool22) {
  return tool22;
}
function createProviderDefinedToolFactory({
  id,
  name: name51,
  inputSchema
}) {
  return ({
    execute: execute2,
    outputSchema: outputSchema2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool2({
    type: "provider-defined",
    id,
    name: name51,
    args,
    inputSchema,
    outputSchema: outputSchema2,
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function createProviderDefinedToolFactoryWithOutputSchema({
  id,
  name: name51,
  inputSchema,
  outputSchema: outputSchema2
}) {
  return ({
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool2({
    type: "provider-defined",
    id,
    name: name51,
    args,
    inputSchema,
    outputSchema: outputSchema2,
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
function parseAnyDef3() {
  return {};
}
function parseArrayDef3(def, refs) {
  var _a61, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a61 = def.type) == null ? void 0 : _a61._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef3(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef3(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef3() {
  return { type: "boolean" };
}
function parseBrandedDef3(_def, refs) {
  return parseDef3(_def.type._def, refs);
}
function parseDateDef3(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef3(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser3(def);
  }
}
function parseDefaultDef3(_def, refs) {
  return {
    ...parseDef3(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef3(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef3(_def.schema._def, refs) : parseAnyDef3();
}
function parseEnumDef3(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
function parseIntersectionDef3(def, refs) {
  const allOf = [
    parseDef3(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef3(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType3(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef3(def) {
  const parsedType5 = typeof def.value;
  if (parsedType5 !== "bigint" && parsedType5 !== "number" && parsedType5 !== "boolean" && parsedType5 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType5 === "bigint" ? "integer" : parsedType5,
    const: def.value
  };
}
function parseStringDef3(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check3 of def.checks) {
      switch (check3.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat3(res, "email", check3.message, refs);
              break;
            case "format:idn-email":
              addFormat3(res, "idn-email", check3.message, refs);
              break;
            case "pattern:zod":
              addPattern3(res, zodPatterns3.email, check3.message, refs);
              break;
          }
          break;
        case "url":
          addFormat3(res, "uri", check3.message, refs);
          break;
        case "uuid":
          addFormat3(res, "uuid", check3.message, refs);
          break;
        case "regex":
          addPattern3(res, check3.regex, check3.message, refs);
          break;
        case "cuid":
          addPattern3(res, zodPatterns3.cuid, check3.message, refs);
          break;
        case "cuid2":
          addPattern3(res, zodPatterns3.cuid2, check3.message, refs);
          break;
        case "startsWith":
          addPattern3(
            res,
            RegExp(`^${escapeLiteralCheckValue3(check3.value, refs)}`),
            check3.message,
            refs
          );
          break;
        case "endsWith":
          addPattern3(
            res,
            RegExp(`${escapeLiteralCheckValue3(check3.value, refs)}$`),
            check3.message,
            refs
          );
          break;
        case "datetime":
          addFormat3(res, "date-time", check3.message, refs);
          break;
        case "date":
          addFormat3(res, "date", check3.message, refs);
          break;
        case "time":
          addFormat3(res, "time", check3.message, refs);
          break;
        case "duration":
          addFormat3(res, "duration", check3.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "includes": {
          addPattern3(
            res,
            RegExp(escapeLiteralCheckValue3(check3.value, refs)),
            check3.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check3.version !== "v6") {
            addFormat3(res, "ipv4", check3.message, refs);
          }
          if (check3.version !== "v4") {
            addFormat3(res, "ipv6", check3.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern3(res, zodPatterns3.base64url, check3.message, refs);
          break;
        case "jwt":
          addPattern3(res, zodPatterns3.jwt, check3.message, refs);
          break;
        case "cidr": {
          if (check3.version !== "v6") {
            addPattern3(res, zodPatterns3.ipv4Cidr, check3.message, refs);
          }
          if (check3.version !== "v4") {
            addPattern3(res, zodPatterns3.ipv6Cidr, check3.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern3(res, zodPatterns3.emoji(), check3.message, refs);
          break;
        case "ulid": {
          addPattern3(res, zodPatterns3.ulid, check3.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat3(res, "binary", check3.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern3(res, zodPatterns3.base64, check3.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern3(res, zodPatterns3.nanoid, check3.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check3);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue3(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric3(literal3) : literal3;
}
function escapeNonAlphaNumeric3(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC4.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat3(schema, value, message, refs) {
  var _a61;
  if (schema.format || ((_a61 = schema.anyOf) == null ? void 0 : _a61.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern3(schema, regex, message, refs) {
  var _a61;
  if (schema.pattern || ((_a61 = schema.allOf) == null ? void 0 : _a61.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags3(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags3(regex, refs);
  }
}
function stringifyRegExpWithFlags3(regex, refs) {
  var _a61;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a61 = source[i + 2]) == null ? void 0 : _a61.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef3(def, refs) {
  var _a61, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a61 = parseDef3(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a61 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef3(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef3(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef3(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef3(def, refs);
  }
  const keys = parseDef3(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef3();
  const values = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef3();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef3(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef3() {
  return { not: parseAnyDef3() };
}
function parseNullDef3() {
  return {
    type: "null"
  };
}
function parseUnionDef3(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings3 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings3[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf3(def, refs);
}
function parseNullableDef3(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings3[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef3(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef3(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseObjectDef3(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional3(propDef);
    const parsedDef = parseDef3(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties3(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties3(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef3(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional3(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
function parsePromiseDef3(def, refs) {
  return parseDef3(def.type._def, refs);
}
function parseSetDef3(def, refs) {
  const items = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef3(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef3(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef3(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef3(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef3() {
  return {
    not: parseAnyDef3()
  };
}
function parseUnknownDef3() {
  return parseAnyDef3();
}
function parseDef3(def, refs, forceResolution = false) {
  var _a61;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a61 = refs.override) == null ? void 0 : _a61.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride4) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref3(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser4(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta3(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
function zod3Schema2(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default2(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function zod4Schema2(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await safeParseAsync2(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function isZod4Schema2(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema3(zodSchema22, options) {
  if (isZod4Schema2(zodSchema22)) {
    return zod4Schema2(zodSchema22, options);
  } else {
    return zod3Schema2(zodSchema22, options);
  }
}
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema3(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol4]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol4]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
function convertUint8ArrayToBase643(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa5(latin1string);
}
function convertToBase64(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase643(value) : value;
}
function withoutTrailingSlash(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator4, generateId4, FETCH_FAILED_ERROR_MESSAGES, VERSION, suspectProtoRx2, suspectConstructorRx2, validatorSymbol4, getOriginalFetch2, postJsonToApi, postToApi, createJsonErrorResponseHandler, createEventSourceResponseHandler, createJsonResponseHandler, getRelativePath3, ignoreOverride4, defaultOptions3, getDefaultOptions3, parseCatchDef3, integerDateParser3, isJsonSchema7AllOfType3, emojiRegex4, zodPatterns3, ALPHA_NUMERIC4, primitiveMappings3, asAnyOf3, parseOptionalDef3, parsePipelineDef3, parseReadonlyDef3, selectParser4, get$ref3, addMeta3, getRefs3, zodToJsonSchema4, zod_to_json_schema_default2, schemaSymbol4, btoa5, atob5;
var init_dist4 = __esm({
  "node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist3();
    init_dist3();
    init_dist3();
    init_dist3();
    init_dist3();
    init_dist3();
    init_stream();
    init_dist3();
    init_dist3();
    init_dist3();
    init_v4();
    init_v3();
    init_v3();
    init_v3();
    init_dist2();
    __name(combineHeaders, "combineHeaders");
    __name(extractResponseHeaders, "extractResponseHeaders");
    createIdGenerator4 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError5({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId4 = createIdGenerator4();
    __name(isAbortError4, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
    __name(handleFetchError, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent, "getRuntimeEnvironmentUserAgent");
    __name(removeUndefinedEntries, "removeUndefinedEntries");
    __name(withUserAgentSuffix2, "withUserAgentSuffix");
    VERSION = true ? "3.0.12" : "0.0.0-test";
    __name(loadApiKey, "loadApiKey");
    suspectProtoRx2 = /"__proto__"\s*:/;
    suspectConstructorRx2 = /"constructor"\s*:/;
    __name(_parse4, "_parse");
    __name(filter2, "filter");
    __name(secureJsonParse2, "secureJsonParse");
    validatorSymbol4 = Symbol.for("vercel.ai.validator");
    __name(validator3, "validator");
    __name(isValidator3, "isValidator");
    __name(asValidator3, "asValidator");
    __name(standardSchemaValidator2, "standardSchemaValidator");
    __name(validateTypes2, "validateTypes");
    __name(safeValidateTypes3, "safeValidateTypes");
    __name(parseJSON, "parseJSON");
    __name(safeParseJSON3, "safeParseJSON");
    __name(parseJsonEventStream2, "parseJsonEventStream");
    __name(parseProviderOptions, "parseProviderOptions");
    getOriginalFetch2 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch2()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix2(
            headers,
            `ai-sdk/provider-utils/${VERSION}`,
            getRuntimeEnvironmentUserAgent()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError4(error87) || APICallError3.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError3({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError4(error87) || APICallError3.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError3({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    __name(tool2, "tool");
    __name(createProviderDefinedToolFactory, "createProviderDefinedToolFactory");
    __name(createProviderDefinedToolFactoryWithOutputSchema, "createProviderDefinedToolFactoryWithOutputSchema");
    __name(resolve, "resolve");
    createJsonErrorResponseHandler = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError3({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError3({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError3({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError2({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream2({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON3({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders(response);
      if (!parsedResult.success) {
        throw new APICallError3({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    getRelativePath3 = /* @__PURE__ */ __name((pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i]) break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    }, "getRelativePath");
    ignoreOverride4 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    defaultOptions3 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions3 = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
      ...defaultOptions3,
      name: options
    } : {
      ...defaultOptions3,
      ...options
    }, "getDefaultOptions");
    __name(parseAnyDef3, "parseAnyDef");
    __name(parseArrayDef3, "parseArrayDef");
    __name(parseBigintDef3, "parseBigintDef");
    __name(parseBooleanDef3, "parseBooleanDef");
    __name(parseBrandedDef3, "parseBrandedDef");
    parseCatchDef3 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef3(def.innerType._def, refs);
    }, "parseCatchDef");
    __name(parseDateDef3, "parseDateDef");
    integerDateParser3 = /* @__PURE__ */ __name((def) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check3 of def.checks) {
        switch (check3.kind) {
          case "min":
            res.minimum = check3.value;
            break;
          case "max":
            res.maximum = check3.value;
            break;
        }
      }
      return res;
    }, "integerDateParser");
    __name(parseDefaultDef3, "parseDefaultDef");
    __name(parseEffectsDef3, "parseEffectsDef");
    __name(parseEnumDef3, "parseEnumDef");
    isJsonSchema7AllOfType3 = /* @__PURE__ */ __name((type) => {
      if ("type" in type && type.type === "string") return false;
      return "allOf" in type;
    }, "isJsonSchema7AllOfType");
    __name(parseIntersectionDef3, "parseIntersectionDef");
    __name(parseLiteralDef3, "parseLiteralDef");
    emojiRegex4 = void 0;
    zodPatterns3 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: /* @__PURE__ */ __name(() => {
        if (emojiRegex4 === void 0) {
          emojiRegex4 = RegExp(
            "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
            "u"
          );
        }
        return emojiRegex4;
      }, "emoji"),
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    __name(parseStringDef3, "parseStringDef");
    __name(escapeLiteralCheckValue3, "escapeLiteralCheckValue");
    ALPHA_NUMERIC4 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    __name(escapeNonAlphaNumeric3, "escapeNonAlphaNumeric");
    __name(addFormat3, "addFormat");
    __name(addPattern3, "addPattern");
    __name(stringifyRegExpWithFlags3, "stringifyRegExpWithFlags");
    __name(parseRecordDef3, "parseRecordDef");
    __name(parseMapDef3, "parseMapDef");
    __name(parseNativeEnumDef3, "parseNativeEnumDef");
    __name(parseNeverDef3, "parseNeverDef");
    __name(parseNullDef3, "parseNullDef");
    primitiveMappings3 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    __name(parseUnionDef3, "parseUnionDef");
    asAnyOf3 = /* @__PURE__ */ __name((def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
        (x, i) => parseDef3(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "anyOf", `${i}`]
        })
      ).filter(
        (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
      );
      return anyOf.length ? { anyOf } : void 0;
    }, "asAnyOf");
    __name(parseNullableDef3, "parseNullableDef");
    __name(parseNumberDef3, "parseNumberDef");
    __name(parseObjectDef3, "parseObjectDef");
    __name(decideAdditionalProperties3, "decideAdditionalProperties");
    __name(safeIsOptional3, "safeIsOptional");
    parseOptionalDef3 = /* @__PURE__ */ __name((def, refs) => {
      var _a61;
      if (refs.currentPath.toString() === ((_a61 = refs.propertyPath) == null ? void 0 : _a61.toString())) {
        return parseDef3(def.innerType._def, refs);
      }
      const innerSchema = parseDef3(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? { anyOf: [{ not: parseAnyDef3() }, innerSchema] } : parseAnyDef3();
    }, "parseOptionalDef");
    parsePipelineDef3 = /* @__PURE__ */ __name((def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef3(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef3(def.out._def, refs);
      }
      const a = parseDef3(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef3(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      });
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    }, "parsePipelineDef");
    __name(parsePromiseDef3, "parsePromiseDef");
    __name(parseSetDef3, "parseSetDef");
    __name(parseTupleDef3, "parseTupleDef");
    __name(parseUndefinedDef3, "parseUndefinedDef");
    __name(parseUnknownDef3, "parseUnknownDef");
    parseReadonlyDef3 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef3(def.innerType._def, refs);
    }, "parseReadonlyDef");
    selectParser4 = /* @__PURE__ */ __name((def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef3(def);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef3(def);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef3();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef3();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef3();
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef3(def);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef3(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef3(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef3();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef3();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef3();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef3(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    }, "selectParser");
    __name(parseDef3, "parseDef");
    get$ref3 = /* @__PURE__ */ __name((item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath3(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
            console.warn(
              `Recursive reference detected at ${refs.currentPath.join(
                "/"
              )}! Defaulting to any`
            );
            return parseAnyDef3();
          }
          return refs.$refStrategy === "seen" ? parseAnyDef3() : void 0;
        }
      }
    }, "get$ref");
    addMeta3 = /* @__PURE__ */ __name((def, refs, jsonSchema22) => {
      if (def.description) {
        jsonSchema22.description = def.description;
      }
      return jsonSchema22;
    }, "addMeta");
    getRefs3 = /* @__PURE__ */ __name((options) => {
      const _options = getDefaultOptions3(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(_options.definitions).map(([name51, def]) => [
            def._def,
            {
              def: def._def,
              path: [..._options.basePath, _options.definitionPath, name51],
              // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
              jsonSchema: void 0
            }
          ])
        )
      };
    }, "getRefs");
    zodToJsonSchema4 = /* @__PURE__ */ __name((schema, options) => {
      var _a61;
      const refs = getRefs3(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
        (acc, [name216, schema2]) => {
          var _a217;
          return {
            ...acc,
            [name216]: (_a217 = parseDef3(
              schema2._def,
              {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name216]
              },
              true
            )) != null ? _a217 : parseAnyDef3()
          };
        },
        {}
      ) : void 0;
      const name51 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
      const main = (_a61 = parseDef3(
        schema._def,
        name51 === void 0 ? refs : {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name51]
        },
        false
      )) != null ? _a61 : parseAnyDef3();
      const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title2 !== void 0) {
        main.title = title2;
      }
      const combined = name51 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name51
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name51]: main
        }
      };
      combined.$schema = "http://json-schema.org/draft-07/schema#";
      return combined;
    }, "zodToJsonSchema");
    zod_to_json_schema_default2 = zodToJsonSchema4;
    __name(zod3Schema2, "zod3Schema");
    __name(zod4Schema2, "zod4Schema");
    __name(isZod4Schema2, "isZod4Schema");
    __name(zodSchema3, "zodSchema");
    schemaSymbol4 = Symbol.for("vercel.ai.schema");
    __name(lazySchema, "lazySchema");
    __name(jsonSchema3, "jsonSchema");
    ({ btoa: btoa5, atob: atob5 } = globalThis);
    __name(convertUint8ArrayToBase643, "convertUint8ArrayToBase64");
    __name(convertToBase64, "convertToBase64");
    __name(withoutTrailingSlash, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/anthropic-v5/dist/index.mjs
function getCacheControl(providerMetadata) {
  var _a61;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a61 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a61 : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
async function prepareTools({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator11 = cacheControlValidator || new CacheControlValidator();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools2 = [];
  for (const tool5 of tools) {
    switch (tool5.type) {
      case "function": {
        const cacheControl = validator11.getCacheControl(tool5.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        anthropicTools2.push({
          name: tool5.name,
          description: tool5.description,
          input_schema: tool5.inputSchema,
          cache_control: cacheControl
        });
        break;
      }
      case "provider-defined": {
        switch (tool5.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools2.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools2.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool5.args.displayWidthPx,
              display_height_px: tool5.args.displayHeightPx,
              display_number: tool5.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool5.args.displayWidthPx,
              display_height_px: tool5.args.displayHeightPx,
              display_number: tool5.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args = await validateTypes2({
              value: tool5.args,
              schema: textEditor_20250728ArgsSchema
            });
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools2.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args = await validateTypes2({
              value: tool5.args,
              schema: webFetch_20250910ArgsSchema
            });
            anthropicTools2.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              citations: args.citations,
              max_content_tokens: args.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args = await validateTypes2({
              value: tool5.args,
              schema: webSearch_20250305ArgsSchema
            });
            anthropicTools2.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              user_location: args.userLocation,
              cache_control: void 0
            });
            break;
          }
          default: {
            toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools2,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError3({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function convertToString(data) {
  if (typeof data === "string") {
    return Buffer.from(data, "base64").toString("utf-8");
  }
  if (data instanceof Uint8Array) {
    return new TextDecoder().decode(data);
  }
  if (data instanceof URL) {
    throw new UnsupportedFunctionalityError3({
      functionality: "URL-based text documents are not supported for citations"
    });
  }
  throw new UnsupportedFunctionalityError3({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
async function convertToAnthropicMessagesPrompt({
  prompt,
  sendReasoning,
  warnings,
  cacheControlValidator
}) {
  var _a61, _b, _c, _d, _e;
  const betas = /* @__PURE__ */ new Set();
  const blocks = groupIntoBlocks(prompt);
  const validator11 = cacheControlValidator || new CacheControlValidator();
  let system = void 0;
  const messages = [];
  async function shouldEnableCitations(providerMetadata) {
    var _a217, _b2;
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return (_b2 = (_a217 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a217.enabled) != null ? _b2 : false;
  }
  __name(shouldEnableCitations, "shouldEnableCitations");
  async function getDocumentMetadata(providerMetadata) {
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return {
      title: anthropicOptions == null ? void 0 : anthropicOptions.title,
      context: anthropicOptions == null ? void 0 : anthropicOptions.context
    };
  }
  __name(getDocumentMetadata, "getDocumentMetadata");
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type = block.type;
    switch (type) {
      case "system": {
        if (system != null) {
          throw new UnsupportedFunctionalityError3({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        system = block.messages.map(({ content, providerOptions }) => ({
          type: "text",
          text: content,
          cache_control: validator11.getCacheControl(providerOptions, {
            type: "system message",
            canCache: true
          })
        }));
        break;
      }
      case "user": {
        const anthropicContent = [];
        for (const message of block.messages) {
          const { role, content } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                const isLastPart = j === content.length - 1;
                const cacheControl = (_a61 = validator11.getCacheControl(part.providerOptions, {
                  type: "user message part",
                  canCache: true
                })) != null ? _a61 : isLastPart ? validator11.getCacheControl(message.providerOptions, {
                  type: "user message",
                  canCache: true
                }) : void 0;
                switch (part.type) {
                  case "text": {
                    anthropicContent.push({
                      type: "text",
                      text: part.text,
                      cache_control: cacheControl
                    });
                    break;
                  }
                  case "file": {
                    if (part.mediaType.startsWith("image/")) {
                      anthropicContent.push({
                        type: "image",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                          data: convertToBase64(part.data)
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "application/pdf") {
                      betas.add("pdfs-2024-09-25");
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: "application/pdf",
                          data: convertToBase64(part.data)
                        },
                        title: (_b = metadata.title) != null ? _b : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "text/plain") {
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "text",
                          media_type: "text/plain",
                          data: convertToString(part.data)
                        },
                        title: (_c = metadata.title) != null ? _c : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      throw new UnsupportedFunctionalityError3({
                        functionality: `media type: ${part.mediaType}`
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let i2 = 0; i2 < content.length; i2++) {
                const part = content[i2];
                const isLastPart = i2 === content.length - 1;
                const cacheControl = (_d = validator11.getCacheControl(part.providerOptions, {
                  type: "tool result part",
                  canCache: true
                })) != null ? _d : isLastPart ? validator11.getCacheControl(message.providerOptions, {
                  type: "tool result message",
                  canCache: true
                }) : void 0;
                const output = part.output;
                let contentValue;
                switch (output.type) {
                  case "content":
                    contentValue = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return {
                            type: "text",
                            text: contentPart.text
                          };
                        case "media": {
                          if (contentPart.mediaType.startsWith("image/")) {
                            return {
                              type: "image",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          if (contentPart.mediaType === "application/pdf") {
                            betas.add("pdfs-2024-09-25");
                            return {
                              type: "document",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          throw new UnsupportedFunctionalityError3({
                            functionality: `media type: ${contentPart.mediaType}`
                          });
                        }
                      }
                    });
                    break;
                  case "text":
                  case "error-text":
                    contentValue = output.value;
                    break;
                  case "json":
                  case "error-json":
                  default:
                    contentValue = JSON.stringify(output.value);
                    break;
                }
                anthropicContent.push({
                  type: "tool_result",
                  tool_use_id: part.toolCallId,
                  content: contentValue,
                  is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                  cache_control: cacheControl
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
        }
        messages.push({ role: "user", content: anthropicContent });
        break;
      }
      case "assistant": {
        const anthropicContent = [];
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            const cacheControl = (_e = validator11.getCacheControl(part.providerOptions, {
              type: "assistant message part",
              canCache: true
            })) != null ? _e : isLastContentPart ? validator11.getCacheControl(message.providerOptions, {
              type: "assistant message",
              canCache: true
            }) : void 0;
            switch (part.type) {
              case "text": {
                anthropicContent.push({
                  type: "text",
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Anthropic does not allow trailing whitespace
                    // in pre-filled assistant responses
                    isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                  ),
                  cache_control: cacheControl
                });
                break;
              }
              case "reasoning": {
                if (sendReasoning) {
                  const reasoningMetadata = await parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: part.providerOptions,
                    schema: anthropicReasoningMetadataSchema
                  });
                  if (reasoningMetadata != null) {
                    if (reasoningMetadata.signature != null) {
                      validator11.getCacheControl(part.providerOptions, {
                        type: "thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: reasoningMetadata.signature
                      });
                    } else if (reasoningMetadata.redactedData != null) {
                      validator11.getCacheControl(part.providerOptions, {
                        type: "redacted thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "redacted_thinking",
                        data: reasoningMetadata.redactedData
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "unsupported reasoning metadata"
                    });
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: "sending reasoning content is disabled for this model"
                  });
                }
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.input.type,
                      // map back to subtool name
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else if (part.toolName === "code_execution" || // code execution 20250522
                  part.toolName === "web_fetch" || part.toolName === "web_search") {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.toolName,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool call for tool ${part.toolName} is not supported`
                    });
                  }
                  break;
                }
                anthropicContent.push({
                  type: "tool_use",
                  id: part.toolCallId,
                  name: part.toolName,
                  input: part.input,
                  cache_control: cacheControl
                });
                break;
              }
              case "tool-result": {
                if (part.toolName === "code_execution") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                    });
                    break;
                  }
                  if (output.value.type === "code_execution_result") {
                    const codeExecutionOutput = await validateTypes2({
                      value: output.value,
                      schema: codeExecution_20250522OutputSchema
                    });
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code
                      },
                      cache_control: cacheControl
                    });
                  } else {
                    const codeExecutionOutput = await validateTypes2({
                      value: output.value,
                      schema: codeExecution_20250825OutputSchema
                    });
                    anthropicContent.push(
                      codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      } : {
                        type: "text_editor_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      }
                    );
                  }
                  break;
                }
                if (part.toolName === "web_fetch") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webFetchOutput = await validateTypes2({
                    value: output.value,
                    schema: webFetch_20250910OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_fetch_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "web_fetch_result",
                      url: webFetchOutput.url,
                      retrieved_at: webFetchOutput.retrievedAt,
                      content: {
                        type: "document",
                        title: webFetchOutput.content.title,
                        citations: webFetchOutput.content.citations,
                        source: {
                          type: webFetchOutput.content.source.type,
                          media_type: webFetchOutput.content.source.mediaType,
                          data: webFetchOutput.content.source.data
                        }
                      }
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                if (part.toolName === "web_search") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webSearchOutput = await validateTypes2({
                    value: output.value,
                    schema: webSearch_20250305OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: webSearchOutput.map((result) => ({
                      url: result.url,
                      title: result.title,
                      page_age: result.pageAge,
                      encrypted_content: result.encryptedContent,
                      type: result.type
                    })),
                    cache_control: cacheControl
                  });
                  break;
                }
                warnings.push({
                  type: "other",
                  message: `provider executed tool result for tool ${part.toolName} is not supported`
                });
                break;
              }
            }
          }
        }
        messages.push({ role: "assistant", content: anthropicContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`content type: ${_exhaustiveCheck}`);
      }
    }
  }
  return {
    prompt: { system, messages },
    betas
  };
}
function groupIntoBlocks(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
      return "length";
    default:
      return "unknown";
  }
}
function createCitationSource(citation, citationDocuments, generateId32) {
  var _a61;
  if (citation.type !== "page_location" && citation.type !== "char_location") {
    return;
  }
  const documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo) {
    return;
  }
  return {
    type: "source",
    sourceType: "document",
    id: generateId32(),
    mediaType: documentInfo.mediaType,
    title: (_a61 = citation.document_title) != null ? _a61 : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
function getMaxOutputTokensForModel(modelId) {
  if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
    return 64e3;
  } else if (modelId.includes("claude-opus-4-")) {
    return 32e3;
  } else if (modelId.includes("claude-3-5-haiku")) {
    return 8192;
  } else {
    return 4096;
  }
}
function createAnthropic(options = {}) {
  var _a61;
  const baseURL = (_a61 = withoutTrailingSlash(options.baseURL)) != null ? _a61 : "https://api.anthropic.com/v1";
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix2(
    {
      "anthropic-version": "2023-06-01",
      "x-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      }),
      ...options.headers
    },
    `ai-sdk/anthropic/${VERSION2}`
  ), "getHeaders");
  const createChatModel = /* @__PURE__ */ __name((modelId) => {
    var _a217;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: "anthropic.messages",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a217 = options.generateId) != null ? _a217 : generateId4,
      supportedUrls: /* @__PURE__ */ __name(() => ({
        "image/*": [/^https?:\/\/.*$/]
      }), "supportedUrls")
    });
  }, "createChatModel");
  const provider = /* @__PURE__ */ __name(function(modelId) {
    if (new.target) {
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  }, "provider");
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new NoSuchModelError2({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError2({ modelId, modelType: "imageModel" });
  };
  provider.tools = anthropicTools;
  return provider;
}
var VERSION2, anthropicErrorDataSchema, anthropicFailedResponseHandler, anthropicMessagesResponseSchema, anthropicMessagesChunkSchema, anthropicReasoningMetadataSchema, anthropicFilePartProviderOptions, anthropicProviderOptions, MAX_CACHE_BREAKPOINTS, CacheControlValidator, textEditor_20250728ArgsSchema, textEditor_20250728InputSchema, factory, textEditor_20250728, webSearch_20250305ArgsSchema, webSearch_20250305OutputSchema, webSearch_20250305InputSchema, factory2, webSearch_20250305, webFetch_20250910ArgsSchema, webFetch_20250910OutputSchema, webFetch_20250910InputSchema, factory3, webFetch_20250910, codeExecution_20250522OutputSchema, codeExecution_20250522InputSchema, factory4, codeExecution_20250522, codeExecution_20250825OutputSchema, codeExecution_20250825InputSchema, factory5, codeExecution_20250825, AnthropicMessagesLanguageModel, bash_20241022InputSchema, bash_20241022, bash_20250124InputSchema, bash_20250124, computer_20241022InputSchema, computer_20241022, computer_20250124InputSchema, computer_20250124, memory_20250818InputSchema, memory_20250818, textEditor_20241022InputSchema, textEditor_20241022, textEditor_20250124InputSchema, textEditor_20250124, textEditor_20250429InputSchema, textEditor_20250429, anthropicTools, anthropic;
var init_dist5 = __esm({
  "node_modules/@ai-sdk/anthropic-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist3();
    init_dist4();
    init_dist3();
    init_dist4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_v4();
    init_dist3();
    init_dist4();
    init_v4();
    init_dist4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_dist3();
    init_dist4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    init_dist4();
    init_v4();
    VERSION2 = true ? "2.0.33" : "0.0.0-test";
    anthropicErrorDataSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          type: external_exports.literal("error"),
          error: external_exports.object({
            type: external_exports.string(),
            message: external_exports.string()
          })
        })
      )
    );
    anthropicFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: anthropicErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    });
    anthropicMessagesResponseSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          type: external_exports.literal("message"),
          id: external_exports.string().nullish(),
          model: external_exports.string().nullish(),
          content: external_exports.array(
            external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("text"),
                text: external_exports.string(),
                citations: external_exports.array(
                  external_exports.discriminatedUnion("type", [
                    external_exports.object({
                      type: external_exports.literal("web_search_result_location"),
                      cited_text: external_exports.string(),
                      url: external_exports.string(),
                      title: external_exports.string(),
                      encrypted_index: external_exports.string()
                    }),
                    external_exports.object({
                      type: external_exports.literal("page_location"),
                      cited_text: external_exports.string(),
                      document_index: external_exports.number(),
                      document_title: external_exports.string().nullable(),
                      start_page_number: external_exports.number(),
                      end_page_number: external_exports.number()
                    }),
                    external_exports.object({
                      type: external_exports.literal("char_location"),
                      cited_text: external_exports.string(),
                      document_index: external_exports.number(),
                      document_title: external_exports.string().nullable(),
                      start_char_index: external_exports.number(),
                      end_char_index: external_exports.number()
                    })
                  ])
                ).optional()
              }),
              external_exports.object({
                type: external_exports.literal("thinking"),
                thinking: external_exports.string(),
                signature: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("redacted_thinking"),
                data: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("tool_use"),
                id: external_exports.string(),
                name: external_exports.string(),
                input: external_exports.unknown()
              }),
              external_exports.object({
                type: external_exports.literal("server_tool_use"),
                id: external_exports.string(),
                name: external_exports.string(),
                input: external_exports.record(external_exports.string(), external_exports.unknown()).nullish()
              }),
              external_exports.object({
                type: external_exports.literal("web_fetch_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.object({
                    type: external_exports.literal("web_fetch_result"),
                    url: external_exports.string(),
                    retrieved_at: external_exports.string(),
                    content: external_exports.object({
                      type: external_exports.literal("document"),
                      title: external_exports.string().nullable(),
                      citations: external_exports.object({ enabled: external_exports.boolean() }).optional(),
                      source: external_exports.object({
                        type: external_exports.literal("text"),
                        media_type: external_exports.string(),
                        data: external_exports.string()
                      })
                    })
                  }),
                  external_exports.object({
                    type: external_exports.literal("web_fetch_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              external_exports.object({
                type: external_exports.literal("web_search_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.array(
                    external_exports.object({
                      type: external_exports.literal("web_search_result"),
                      url: external_exports.string(),
                      title: external_exports.string(),
                      encrypted_content: external_exports.string(),
                      page_age: external_exports.string().nullish()
                    })
                  ),
                  external_exports.object({
                    type: external_exports.literal("web_search_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              external_exports.object({
                type: external_exports.literal("code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.object({
                    type: external_exports.literal("code_execution_result"),
                    stdout: external_exports.string(),
                    stderr: external_exports.string(),
                    return_code: external_exports.number()
                  }),
                  external_exports.object({
                    type: external_exports.literal("code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              external_exports.object({
                type: external_exports.literal("bash_code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("bash_code_execution_result"),
                    content: external_exports.array(
                      external_exports.object({
                        type: external_exports.literal("bash_code_execution_output"),
                        file_id: external_exports.string()
                      })
                    ),
                    stdout: external_exports.string(),
                    stderr: external_exports.string(),
                    return_code: external_exports.number()
                  }),
                  external_exports.object({
                    type: external_exports.literal("bash_code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              external_exports.object({
                type: external_exports.literal("text_editor_code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  }),
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_view_result"),
                    content: external_exports.string(),
                    file_type: external_exports.string(),
                    num_lines: external_exports.number().nullable(),
                    start_line: external_exports.number().nullable(),
                    total_lines: external_exports.number().nullable()
                  }),
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_create_result"),
                    is_file_update: external_exports.boolean()
                  }),
                  external_exports.object({
                    type: external_exports.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: external_exports.array(external_exports.string()).nullable(),
                    new_lines: external_exports.number().nullable(),
                    new_start: external_exports.number().nullable(),
                    old_lines: external_exports.number().nullable(),
                    old_start: external_exports.number().nullable()
                  })
                ])
              })
            ])
          ),
          stop_reason: external_exports.string().nullish(),
          stop_sequence: external_exports.string().nullish(),
          usage: external_exports.looseObject({
            input_tokens: external_exports.number(),
            output_tokens: external_exports.number(),
            cache_creation_input_tokens: external_exports.number().nullish(),
            cache_read_input_tokens: external_exports.number().nullish()
          })
        })
      )
    );
    anthropicMessagesChunkSchema = lazySchema(
      () => zodSchema3(
        external_exports.discriminatedUnion("type", [
          external_exports.object({
            type: external_exports.literal("message_start"),
            message: external_exports.object({
              id: external_exports.string().nullish(),
              model: external_exports.string().nullish(),
              usage: external_exports.looseObject({
                input_tokens: external_exports.number(),
                cache_creation_input_tokens: external_exports.number().nullish(),
                cache_read_input_tokens: external_exports.number().nullish()
              })
            })
          }),
          external_exports.object({
            type: external_exports.literal("content_block_start"),
            index: external_exports.number(),
            content_block: external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("text"),
                text: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("thinking"),
                thinking: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("tool_use"),
                id: external_exports.string(),
                name: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("redacted_thinking"),
                data: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("server_tool_use"),
                id: external_exports.string(),
                name: external_exports.string(),
                input: external_exports.record(external_exports.string(), external_exports.unknown()).nullish()
              }),
              external_exports.object({
                type: external_exports.literal("web_fetch_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.object({
                    type: external_exports.literal("web_fetch_result"),
                    url: external_exports.string(),
                    retrieved_at: external_exports.string(),
                    content: external_exports.object({
                      type: external_exports.literal("document"),
                      title: external_exports.string().nullable(),
                      citations: external_exports.object({ enabled: external_exports.boolean() }).optional(),
                      source: external_exports.object({
                        type: external_exports.literal("text"),
                        media_type: external_exports.string(),
                        data: external_exports.string()
                      })
                    })
                  }),
                  external_exports.object({
                    type: external_exports.literal("web_fetch_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              external_exports.object({
                type: external_exports.literal("web_search_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.array(
                    external_exports.object({
                      type: external_exports.literal("web_search_result"),
                      url: external_exports.string(),
                      title: external_exports.string(),
                      encrypted_content: external_exports.string(),
                      page_age: external_exports.string().nullish()
                    })
                  ),
                  external_exports.object({
                    type: external_exports.literal("web_search_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              external_exports.object({
                type: external_exports.literal("code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.union([
                  external_exports.object({
                    type: external_exports.literal("code_execution_result"),
                    stdout: external_exports.string(),
                    stderr: external_exports.string(),
                    return_code: external_exports.number()
                  }),
                  external_exports.object({
                    type: external_exports.literal("code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              external_exports.object({
                type: external_exports.literal("bash_code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("bash_code_execution_result"),
                    content: external_exports.array(
                      external_exports.object({
                        type: external_exports.literal("bash_code_execution_output"),
                        file_id: external_exports.string()
                      })
                    ),
                    stdout: external_exports.string(),
                    stderr: external_exports.string(),
                    return_code: external_exports.number()
                  }),
                  external_exports.object({
                    type: external_exports.literal("bash_code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              external_exports.object({
                type: external_exports.literal("text_editor_code_execution_tool_result"),
                tool_use_id: external_exports.string(),
                content: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_tool_result_error"),
                    error_code: external_exports.string()
                  }),
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_view_result"),
                    content: external_exports.string(),
                    file_type: external_exports.string(),
                    num_lines: external_exports.number().nullable(),
                    start_line: external_exports.number().nullable(),
                    total_lines: external_exports.number().nullable()
                  }),
                  external_exports.object({
                    type: external_exports.literal("text_editor_code_execution_create_result"),
                    is_file_update: external_exports.boolean()
                  }),
                  external_exports.object({
                    type: external_exports.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: external_exports.array(external_exports.string()).nullable(),
                    new_lines: external_exports.number().nullable(),
                    new_start: external_exports.number().nullable(),
                    old_lines: external_exports.number().nullable(),
                    old_start: external_exports.number().nullable()
                  })
                ])
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("content_block_delta"),
            index: external_exports.number(),
            delta: external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("input_json_delta"),
                partial_json: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("text_delta"),
                text: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("thinking_delta"),
                thinking: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("signature_delta"),
                signature: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("citations_delta"),
                citation: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("web_search_result_location"),
                    cited_text: external_exports.string(),
                    url: external_exports.string(),
                    title: external_exports.string(),
                    encrypted_index: external_exports.string()
                  }),
                  external_exports.object({
                    type: external_exports.literal("page_location"),
                    cited_text: external_exports.string(),
                    document_index: external_exports.number(),
                    document_title: external_exports.string().nullable(),
                    start_page_number: external_exports.number(),
                    end_page_number: external_exports.number()
                  }),
                  external_exports.object({
                    type: external_exports.literal("char_location"),
                    cited_text: external_exports.string(),
                    document_index: external_exports.number(),
                    document_title: external_exports.string().nullable(),
                    start_char_index: external_exports.number(),
                    end_char_index: external_exports.number()
                  })
                ])
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("content_block_stop"),
            index: external_exports.number()
          }),
          external_exports.object({
            type: external_exports.literal("error"),
            error: external_exports.object({
              type: external_exports.string(),
              message: external_exports.string()
            })
          }),
          external_exports.object({
            type: external_exports.literal("message_delta"),
            delta: external_exports.object({
              stop_reason: external_exports.string().nullish(),
              stop_sequence: external_exports.string().nullish()
            }),
            usage: external_exports.looseObject({
              output_tokens: external_exports.number(),
              cache_creation_input_tokens: external_exports.number().nullish()
            })
          }),
          external_exports.object({
            type: external_exports.literal("message_stop")
          }),
          external_exports.object({
            type: external_exports.literal("ping")
          })
        ])
      )
    );
    anthropicReasoningMetadataSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          signature: external_exports.string().optional(),
          redactedData: external_exports.string().optional()
        })
      )
    );
    anthropicFilePartProviderOptions = external_exports.object({
      /**
       * Citation configuration for this document.
       * When enabled, this document will generate citations in the response.
       */
      citations: external_exports.object({
        /**
         * Enable citations for this document
         */
        enabled: external_exports.boolean()
      }).optional(),
      /**
       * Custom title for the document.
       * If not provided, the filename will be used.
       */
      title: external_exports.string().optional(),
      /**
       * Context about the document that will be passed to the model
       * but not used towards cited content.
       * Useful for storing document metadata as text or stringified JSON.
       */
      context: external_exports.string().optional()
    });
    anthropicProviderOptions = external_exports.object({
      sendReasoning: external_exports.boolean().optional(),
      thinking: external_exports.object({
        type: external_exports.union([external_exports.literal("enabled"), external_exports.literal("disabled")]),
        budgetTokens: external_exports.number().optional()
      }).optional(),
      /**
       * Whether to disable parallel function calling during tool use. Default is false.
       * When set to true, Claude will use at most one tool per response.
       */
      disableParallelToolUse: external_exports.boolean().optional(),
      /**
       * Cache control settings for this message.
       * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
       */
      cacheControl: external_exports.object({
        type: external_exports.literal("ephemeral"),
        ttl: external_exports.union([external_exports.literal("5m"), external_exports.literal("1h")]).optional()
      }).optional(),
      /**
       * Agent Skills configuration. Skills enable Claude to perform specialized tasks
       * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
       * Requires code execution tool to be enabled.
       */
      container: external_exports.object({
        id: external_exports.string().optional(),
        skills: external_exports.array(
          external_exports.object({
            type: external_exports.union([external_exports.literal("anthropic"), external_exports.literal("custom")]),
            skillId: external_exports.string(),
            version: external_exports.string().optional()
          })
        ).optional()
      }).optional()
    });
    MAX_CACHE_BREAKPOINTS = 4;
    __name(getCacheControl, "getCacheControl");
    CacheControlValidator = class {
      static {
        __name(this, "CacheControlValidator");
      }
      constructor() {
        this.breakpointCount = 0;
        this.warnings = [];
      }
      getCacheControl(providerMetadata, context3) {
        const cacheControlValue = getCacheControl(providerMetadata);
        if (!cacheControlValue) {
          return void 0;
        }
        if (!context3.canCache) {
          this.warnings.push({
            type: "unsupported-setting",
            setting: "cacheControl",
            details: `cache_control cannot be set on ${context3.type}. It will be ignored.`
          });
          return void 0;
        }
        this.breakpointCount++;
        if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
          this.warnings.push({
            type: "unsupported-setting",
            setting: "cacheControl",
            details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
          });
          return void 0;
        }
        return cacheControlValue;
      }
      getWarnings() {
        return this.warnings;
      }
    };
    textEditor_20250728ArgsSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          maxCharacters: external_exports.number().optional()
        })
      )
    );
    textEditor_20250728InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.enum(["view", "create", "str_replace", "insert"]),
          path: external_exports.string(),
          file_text: external_exports.string().optional(),
          insert_line: external_exports.number().int().optional(),
          new_str: external_exports.string().optional(),
          old_str: external_exports.string().optional(),
          view_range: external_exports.array(external_exports.number().int()).optional()
        })
      )
    );
    factory = createProviderDefinedToolFactory({
      id: "anthropic.text_editor_20250728",
      name: "str_replace_based_edit_tool",
      inputSchema: textEditor_20250728InputSchema
    });
    textEditor_20250728 = /* @__PURE__ */ __name((args = {}) => {
      return factory(args);
    }, "textEditor_20250728");
    webSearch_20250305ArgsSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          maxUses: external_exports.number().optional(),
          allowedDomains: external_exports.array(external_exports.string()).optional(),
          blockedDomains: external_exports.array(external_exports.string()).optional(),
          userLocation: external_exports.object({
            type: external_exports.literal("approximate"),
            city: external_exports.string().optional(),
            region: external_exports.string().optional(),
            country: external_exports.string().optional(),
            timezone: external_exports.string().optional()
          }).optional()
        })
      )
    );
    webSearch_20250305OutputSchema = lazySchema(
      () => zodSchema3(
        external_exports.array(
          external_exports.object({
            url: external_exports.string(),
            title: external_exports.string(),
            pageAge: external_exports.string().nullable(),
            encryptedContent: external_exports.string(),
            type: external_exports.literal("web_search_result")
          })
        )
      )
    );
    webSearch_20250305InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          query: external_exports.string()
        })
      )
    );
    factory2 = createProviderDefinedToolFactoryWithOutputSchema({
      id: "anthropic.web_search_20250305",
      name: "web_search",
      inputSchema: webSearch_20250305InputSchema,
      outputSchema: webSearch_20250305OutputSchema
    });
    webSearch_20250305 = /* @__PURE__ */ __name((args = {}) => {
      return factory2(args);
    }, "webSearch_20250305");
    webFetch_20250910ArgsSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          maxUses: external_exports.number().optional(),
          allowedDomains: external_exports.array(external_exports.string()).optional(),
          blockedDomains: external_exports.array(external_exports.string()).optional(),
          citations: external_exports.object({ enabled: external_exports.boolean() }).optional(),
          maxContentTokens: external_exports.number().optional()
        })
      )
    );
    webFetch_20250910OutputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          type: external_exports.literal("web_fetch_result"),
          url: external_exports.string(),
          content: external_exports.object({
            type: external_exports.literal("document"),
            title: external_exports.string(),
            citations: external_exports.object({ enabled: external_exports.boolean() }).optional(),
            source: external_exports.union([
              external_exports.object({
                type: external_exports.literal("base64"),
                mediaType: external_exports.literal("application/pdf"),
                data: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("text"),
                mediaType: external_exports.literal("text/plain"),
                data: external_exports.string()
              })
            ])
          }),
          retrievedAt: external_exports.string().nullable()
        })
      )
    );
    webFetch_20250910InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          url: external_exports.string()
        })
      )
    );
    factory3 = createProviderDefinedToolFactoryWithOutputSchema({
      id: "anthropic.web_fetch_20250910",
      name: "web_fetch",
      inputSchema: webFetch_20250910InputSchema,
      outputSchema: webFetch_20250910OutputSchema
    });
    webFetch_20250910 = /* @__PURE__ */ __name((args = {}) => {
      return factory3(args);
    }, "webFetch_20250910");
    __name(prepareTools, "prepareTools");
    codeExecution_20250522OutputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          type: external_exports.literal("code_execution_result"),
          stdout: external_exports.string(),
          stderr: external_exports.string(),
          return_code: external_exports.number()
        })
      )
    );
    codeExecution_20250522InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          code: external_exports.string()
        })
      )
    );
    factory4 = createProviderDefinedToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250522",
      name: "code_execution",
      inputSchema: codeExecution_20250522InputSchema,
      outputSchema: codeExecution_20250522OutputSchema
    });
    codeExecution_20250522 = /* @__PURE__ */ __name((args = {}) => {
      return factory4(args);
    }, "codeExecution_20250522");
    codeExecution_20250825OutputSchema = lazySchema(
      () => zodSchema3(
        external_exports.discriminatedUnion("type", [
          external_exports.object({
            type: external_exports.literal("bash_code_execution_result"),
            content: external_exports.array(
              external_exports.object({
                type: external_exports.literal("bash_code_execution_output"),
                file_id: external_exports.string()
              })
            ),
            stdout: external_exports.string(),
            stderr: external_exports.string(),
            return_code: external_exports.number()
          }),
          external_exports.object({
            type: external_exports.literal("bash_code_execution_tool_result_error"),
            error_code: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("text_editor_code_execution_tool_result_error"),
            error_code: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("text_editor_code_execution_view_result"),
            content: external_exports.string(),
            file_type: external_exports.string(),
            num_lines: external_exports.number().nullable(),
            start_line: external_exports.number().nullable(),
            total_lines: external_exports.number().nullable()
          }),
          external_exports.object({
            type: external_exports.literal("text_editor_code_execution_create_result"),
            is_file_update: external_exports.boolean()
          }),
          external_exports.object({
            type: external_exports.literal("text_editor_code_execution_str_replace_result"),
            lines: external_exports.array(external_exports.string()).nullable(),
            new_lines: external_exports.number().nullable(),
            new_start: external_exports.number().nullable(),
            old_lines: external_exports.number().nullable(),
            old_start: external_exports.number().nullable()
          })
        ])
      )
    );
    codeExecution_20250825InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.discriminatedUnion("type", [
          external_exports.object({
            type: external_exports.literal("bash_code_execution"),
            command: external_exports.string()
          }),
          external_exports.discriminatedUnion("command", [
            external_exports.object({
              type: external_exports.literal("text_editor_code_execution"),
              command: external_exports.literal("view"),
              path: external_exports.string()
            }),
            external_exports.object({
              type: external_exports.literal("text_editor_code_execution"),
              command: external_exports.literal("create"),
              path: external_exports.string(),
              file_text: external_exports.string().nullish()
            }),
            external_exports.object({
              type: external_exports.literal("text_editor_code_execution"),
              command: external_exports.literal("str_replace"),
              path: external_exports.string(),
              old_str: external_exports.string(),
              new_str: external_exports.string()
            })
          ])
        ])
      )
    );
    factory5 = createProviderDefinedToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250825",
      name: "code_execution",
      inputSchema: codeExecution_20250825InputSchema,
      outputSchema: codeExecution_20250825OutputSchema
    });
    codeExecution_20250825 = /* @__PURE__ */ __name((args = {}) => {
      return factory5(args);
    }, "codeExecution_20250825");
    __name(convertToString, "convertToString");
    __name(convertToAnthropicMessagesPrompt, "convertToAnthropicMessagesPrompt");
    __name(groupIntoBlocks, "groupIntoBlocks");
    __name(mapAnthropicStopReason, "mapAnthropicStopReason");
    __name(createCitationSource, "createCitationSource");
    AnthropicMessagesLanguageModel = class {
      static {
        __name(this, "AnthropicMessagesLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        var _a61;
        this.modelId = modelId;
        this.config = config4;
        this.generateId = (_a61 = config4.generateId) != null ? _a61 : generateId4;
      }
      supportsUrl(url3) {
        return url3.protocol === "https:";
      }
      get provider() {
        return this.config.provider;
      }
      get supportedUrls() {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).supportedUrls) == null ? void 0 : _b.call(_a61)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        if (frequencyPenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty"
          });
        }
        if (presencePenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty"
          });
        }
        if (seed != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "seed"
          });
        }
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
          if (responseFormat.schema == null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "responseFormat",
              details: "JSON response format requires a schema. The response format is ignored."
            });
          } else if (tools != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "tools",
              details: "JSON response format does not support tools. The provided tools are ignored."
            });
          }
        }
        const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
          type: "function",
          name: "json",
          description: "Respond with a JSON object.",
          inputSchema: responseFormat.schema
        } : void 0;
        const anthropicOptions = await parseProviderOptions({
          provider: "anthropic",
          providerOptions,
          schema: anthropicProviderOptions
        });
        const cacheControlValidator = new CacheControlValidator();
        const { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
          prompt,
          sendReasoning: (_a61 = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a61 : true,
          warnings,
          cacheControlValidator
        });
        const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
        const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
        const maxOutputTokensForModel = getMaxOutputTokensForModel(this.modelId);
        const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
        const baseArgs = {
          // model id:
          model: this.modelId,
          // standardized settings:
          max_tokens: maxTokens,
          temperature,
          top_k: topK,
          top_p: topP,
          stop_sequences: stopSequences,
          // provider specific settings:
          ...isThinking && {
            thinking: { type: "enabled", budget_tokens: thinkingBudget }
          },
          // container with agent skills:
          ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
            container: {
              id: anthropicOptions.container.id,
              skills: (_d = anthropicOptions.container.skills) == null ? void 0 : _d.map((skill) => ({
                type: skill.type,
                skill_id: skill.skillId,
                version: skill.version
              }))
            }
          },
          // prompt:
          system: messagesPrompt.system,
          messages: messagesPrompt.messages
        };
        if (isThinking) {
          if (thinkingBudget == null) {
            throw new UnsupportedFunctionalityError3({
              functionality: "thinking requires a budget"
            });
          }
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "temperature",
              details: "temperature is not supported when thinking is enabled"
            });
          }
          if (topK != null) {
            baseArgs.top_k = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "topK",
              details: "topK is not supported when thinking is enabled"
            });
          }
          if (topP != null) {
            baseArgs.top_p = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "topP",
              details: "topP is not supported when thinking is enabled"
            });
          }
          baseArgs.max_tokens = maxTokens + thinkingBudget;
        }
        if (baseArgs.max_tokens > maxOutputTokensForModel) {
          if (maxOutputTokens != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "maxOutputTokens",
              details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
            });
          }
          baseArgs.max_tokens = maxOutputTokensForModel;
        }
        if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
          betas.add("code-execution-2025-08-25");
          betas.add("skills-2025-10-02");
          betas.add("files-api-2025-04-14");
          if (!(tools == null ? void 0 : tools.some(
            (tool5) => tool5.type === "provider-defined" && tool5.id === "anthropic.code_execution_20250825"
          ))) {
            warnings.push({
              type: "other",
              message: "code execution tool is required when using skills"
            });
          }
        }
        const {
          tools: anthropicTools2,
          toolChoice: anthropicToolChoice,
          toolWarnings,
          betas: toolsBetas
        } = await prepareTools(
          jsonResponseTool != null ? {
            tools: [jsonResponseTool],
            toolChoice: { type: "tool", toolName: jsonResponseTool.name },
            disableParallelToolUse: true,
            cacheControlValidator
          } : {
            tools: tools != null ? tools : [],
            toolChoice,
            disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
            cacheControlValidator
          }
        );
        const cacheWarnings = cacheControlValidator.getWarnings();
        return {
          args: {
            ...baseArgs,
            tools: anthropicTools2,
            tool_choice: anthropicToolChoice
          },
          warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
          betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas]),
          usesJsonResponseTool: jsonResponseTool != null
        };
      }
      async getHeaders({
        betas,
        headers
      }) {
        return combineHeaders(
          await resolve(this.config.headers),
          betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
          headers
        );
      }
      buildRequestUrl(isStreaming) {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a61, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
      }
      transformRequestBody(args) {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).transformRequestBody) == null ? void 0 : _b.call(_a61, args)) != null ? _c : args;
      }
      extractCitationDocuments(prompt) {
        const isCitationPart = /* @__PURE__ */ __name((part) => {
          var _a61, _b;
          if (part.type !== "file") {
            return false;
          }
          if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
            return false;
          }
          const anthropic2 = (_a61 = part.providerOptions) == null ? void 0 : _a61.anthropic;
          const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
          return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
        }, "isCitationPart");
        return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
          var _a61;
          const filePart = part;
          return {
            title: (_a61 = filePart.filename) != null ? _a61 : "Untitled Document",
            filename: filePart.filename,
            mediaType: filePart.mediaType
          };
        });
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f;
        const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
        const citationDocuments = this.extractCitationDocuments(options.prompt);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.buildRequestUrl(false),
          headers: await this.getHeaders({ betas, headers: options.headers }),
          body: this.transformRequestBody(args),
          failedResponseHandler: anthropicFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            anthropicMessagesResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const content = [];
        for (const part of response.content) {
          switch (part.type) {
            case "text": {
              if (!usesJsonResponseTool) {
                content.push({ type: "text", text: part.text });
                if (part.citations) {
                  for (const citation of part.citations) {
                    const source = createCitationSource(
                      citation,
                      citationDocuments,
                      this.generateId
                    );
                    if (source) {
                      content.push(source);
                    }
                  }
                }
              }
              break;
            }
            case "thinking": {
              content.push({
                type: "reasoning",
                text: part.thinking,
                providerMetadata: {
                  anthropic: {
                    signature: part.signature
                  }
                }
              });
              break;
            }
            case "redacted_thinking": {
              content.push({
                type: "reasoning",
                text: "",
                providerMetadata: {
                  anthropic: {
                    redactedData: part.data
                  }
                }
              });
              break;
            }
            case "tool_use": {
              content.push(
                // when a json response tool is used, the tool call becomes the text:
                usesJsonResponseTool ? {
                  type: "text",
                  text: JSON.stringify(part.input)
                } : {
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: part.name,
                  input: JSON.stringify(part.input)
                }
              );
              break;
            }
            case "server_tool_use": {
              if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: "code_execution",
                  input: JSON.stringify({ type: part.name, ...part.input }),
                  providerExecuted: true
                });
              } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: part.name,
                  input: JSON.stringify(part.input),
                  providerExecuted: true
                });
              }
              break;
            }
            case "web_fetch_tool_result": {
              if (part.content.type === "web_fetch_result") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "web_fetch",
                  result: {
                    type: "web_fetch_result",
                    url: part.content.url,
                    retrievedAt: part.content.retrieved_at,
                    content: {
                      type: part.content.content.type,
                      title: part.content.content.title,
                      citations: part.content.content.citations,
                      source: {
                        type: part.content.content.source.type,
                        mediaType: part.content.content.source.media_type,
                        data: part.content.content.source.data
                      }
                    }
                  },
                  providerExecuted: true
                });
              } else if (part.content.type === "web_fetch_tool_result_error") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "web_fetch",
                  isError: true,
                  result: {
                    type: "web_fetch_tool_result_error",
                    errorCode: part.content.error_code
                  },
                  providerExecuted: true
                });
              }
              break;
            }
            case "web_search_tool_result": {
              if (Array.isArray(part.content)) {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "web_search",
                  result: part.content.map((result) => {
                    var _a217;
                    return {
                      url: result.url,
                      title: result.title,
                      pageAge: (_a217 = result.page_age) != null ? _a217 : null,
                      encryptedContent: result.encrypted_content,
                      type: result.type
                    };
                  }),
                  providerExecuted: true
                });
                for (const result of part.content) {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: this.generateId(),
                    url: result.url,
                    title: result.title,
                    providerMetadata: {
                      anthropic: {
                        pageAge: (_a61 = result.page_age) != null ? _a61 : null
                      }
                    }
                  });
                }
              } else {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "web_search",
                  isError: true,
                  result: {
                    type: "web_search_tool_result_error",
                    errorCode: part.content.error_code
                  },
                  providerExecuted: true
                });
              }
              break;
            }
            // code execution 20250522:
            case "code_execution_tool_result": {
              if (part.content.type === "code_execution_result") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "code_execution",
                  result: {
                    type: part.content.type,
                    stdout: part.content.stdout,
                    stderr: part.content.stderr,
                    return_code: part.content.return_code
                  },
                  providerExecuted: true
                });
              } else if (part.content.type === "code_execution_tool_result_error") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: "code_execution",
                  isError: true,
                  result: {
                    type: "code_execution_tool_result_error",
                    errorCode: part.content.error_code
                  },
                  providerExecuted: true
                });
              }
              break;
            }
            // code execution 20250825:
            case "bash_code_execution_tool_result":
            case "text_editor_code_execution_tool_result": {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "code_execution",
                result: part.content,
                providerExecuted: true
              });
              break;
            }
          }
        }
        return {
          content,
          finishReason: mapAnthropicStopReason({
            finishReason: response.stop_reason,
            isJsonResponseFromTool: usesJsonResponseTool
          }),
          usage: {
            inputTokens: response.usage.input_tokens,
            outputTokens: response.usage.output_tokens,
            totalTokens: response.usage.input_tokens + response.usage.output_tokens,
            cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
          },
          request: { body: args },
          response: {
            id: (_c = response.id) != null ? _c : void 0,
            modelId: (_d = response.model) != null ? _d : void 0,
            headers: responseHeaders,
            body: rawResponse
          },
          warnings,
          providerMetadata: {
            anthropic: {
              usage: response.usage,
              cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
              stopSequence: (_f = response.stop_sequence) != null ? _f : null
            }
          }
        };
      }
      async doStream(options) {
        const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
        const citationDocuments = this.extractCitationDocuments(options.prompt);
        const body = { ...args, stream: true };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.buildRequestUrl(true),
          headers: await this.getHeaders({ betas, headers: options.headers }),
          body: this.transformRequestBody(body),
          failedResponseHandler: anthropicFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            anthropicMessagesChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        const contentBlocks = {};
        let rawUsage = void 0;
        let cacheCreationInputTokens = null;
        let stopSequence = null;
        let blockType = void 0;
        const generateId32 = this.generateId;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a61, _b, _c, _d, _e, _f, _g, _h;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                switch (value.type) {
                  case "ping": {
                    return;
                  }
                  case "content_block_start": {
                    const contentBlockType = value.content_block.type;
                    blockType = contentBlockType;
                    switch (contentBlockType) {
                      case "text": {
                        contentBlocks[value.index] = { type: "text" };
                        controller.enqueue({
                          type: "text-start",
                          id: String(value.index)
                        });
                        return;
                      }
                      case "thinking": {
                        contentBlocks[value.index] = { type: "reasoning" };
                        controller.enqueue({
                          type: "reasoning-start",
                          id: String(value.index)
                        });
                        return;
                      }
                      case "redacted_thinking": {
                        contentBlocks[value.index] = { type: "reasoning" };
                        controller.enqueue({
                          type: "reasoning-start",
                          id: String(value.index),
                          providerMetadata: {
                            anthropic: {
                              redactedData: value.content_block.data
                            }
                          }
                        });
                        return;
                      }
                      case "tool_use": {
                        contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                          type: "tool-call",
                          toolCallId: value.content_block.id,
                          toolName: value.content_block.name,
                          input: "",
                          firstDelta: true
                        };
                        controller.enqueue(
                          usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                            type: "tool-input-start",
                            id: value.content_block.id,
                            toolName: value.content_block.name
                          }
                        );
                        return;
                      }
                      case "server_tool_use": {
                        if ([
                          "web_fetch",
                          "web_search",
                          // code execution 20250825:
                          "code_execution",
                          // code execution 20250825 text editor:
                          "text_editor_code_execution",
                          // code execution 20250825 bash:
                          "bash_code_execution"
                        ].includes(value.content_block.name)) {
                          contentBlocks[value.index] = {
                            type: "tool-call",
                            toolCallId: value.content_block.id,
                            toolName: value.content_block.name,
                            input: "",
                            providerExecuted: true,
                            firstDelta: true
                          };
                          const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                          controller.enqueue({
                            type: "tool-input-start",
                            id: value.content_block.id,
                            toolName: mappedToolName,
                            providerExecuted: true
                          });
                        }
                        return;
                      }
                      case "web_fetch_tool_result": {
                        const part = value.content_block;
                        if (part.content.type === "web_fetch_result") {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "web_fetch",
                            result: {
                              type: "web_fetch_result",
                              url: part.content.url,
                              retrievedAt: part.content.retrieved_at,
                              content: {
                                type: part.content.content.type,
                                title: part.content.content.title,
                                citations: part.content.content.citations,
                                source: {
                                  type: part.content.content.source.type,
                                  mediaType: part.content.content.source.media_type,
                                  data: part.content.content.source.data
                                }
                              }
                            }
                          });
                        } else if (part.content.type === "web_fetch_tool_result_error") {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "web_fetch",
                            isError: true,
                            result: {
                              type: "web_fetch_tool_result_error",
                              errorCode: part.content.error_code
                            },
                            providerExecuted: true
                          });
                        }
                        return;
                      }
                      case "web_search_tool_result": {
                        const part = value.content_block;
                        if (Array.isArray(part.content)) {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "web_search",
                            result: part.content.map((result) => {
                              var _a217;
                              return {
                                url: result.url,
                                title: result.title,
                                pageAge: (_a217 = result.page_age) != null ? _a217 : null,
                                encryptedContent: result.encrypted_content,
                                type: result.type
                              };
                            }),
                            providerExecuted: true
                          });
                          for (const result of part.content) {
                            controller.enqueue({
                              type: "source",
                              sourceType: "url",
                              id: generateId32(),
                              url: result.url,
                              title: result.title,
                              providerMetadata: {
                                anthropic: {
                                  pageAge: (_a61 = result.page_age) != null ? _a61 : null
                                }
                              }
                            });
                          }
                        } else {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "web_search",
                            isError: true,
                            result: {
                              type: "web_search_tool_result_error",
                              errorCode: part.content.error_code
                            },
                            providerExecuted: true
                          });
                        }
                        return;
                      }
                      // code execution 20250522:
                      case "code_execution_tool_result": {
                        const part = value.content_block;
                        if (part.content.type === "code_execution_result") {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "code_execution",
                            result: {
                              type: part.content.type,
                              stdout: part.content.stdout,
                              stderr: part.content.stderr,
                              return_code: part.content.return_code
                            },
                            providerExecuted: true
                          });
                        } else if (part.content.type === "code_execution_tool_result_error") {
                          controller.enqueue({
                            type: "tool-result",
                            toolCallId: part.tool_use_id,
                            toolName: "code_execution",
                            isError: true,
                            result: {
                              type: "code_execution_tool_result_error",
                              errorCode: part.content.error_code
                            },
                            providerExecuted: true
                          });
                        }
                        return;
                      }
                      // code execution 20250825:
                      case "bash_code_execution_tool_result":
                      case "text_editor_code_execution_tool_result": {
                        const part = value.content_block;
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: "code_execution",
                          result: part.content,
                          providerExecuted: true
                        });
                        return;
                      }
                      default: {
                        const _exhaustiveCheck = contentBlockType;
                        throw new Error(
                          `Unsupported content block type: ${_exhaustiveCheck}`
                        );
                      }
                    }
                  }
                  case "content_block_stop": {
                    if (contentBlocks[value.index] != null) {
                      const contentBlock = contentBlocks[value.index];
                      switch (contentBlock.type) {
                        case "text": {
                          controller.enqueue({
                            type: "text-end",
                            id: String(value.index)
                          });
                          break;
                        }
                        case "reasoning": {
                          controller.enqueue({
                            type: "reasoning-end",
                            id: String(value.index)
                          });
                          break;
                        }
                        case "tool-call":
                          if (!usesJsonResponseTool) {
                            controller.enqueue({
                              type: "tool-input-end",
                              id: contentBlock.toolCallId
                            });
                            const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                            controller.enqueue({
                              type: "tool-call",
                              toolCallId: contentBlock.toolCallId,
                              toolName,
                              input: contentBlock.input,
                              providerExecuted: contentBlock.providerExecuted
                            });
                          }
                          break;
                      }
                      delete contentBlocks[value.index];
                    }
                    blockType = void 0;
                    return;
                  }
                  case "content_block_delta": {
                    const deltaType = value.delta.type;
                    switch (deltaType) {
                      case "text_delta": {
                        if (usesJsonResponseTool) {
                          return;
                        }
                        controller.enqueue({
                          type: "text-delta",
                          id: String(value.index),
                          delta: value.delta.text
                        });
                        return;
                      }
                      case "thinking_delta": {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(value.index),
                          delta: value.delta.thinking
                        });
                        return;
                      }
                      case "signature_delta": {
                        if (blockType === "thinking") {
                          controller.enqueue({
                            type: "reasoning-delta",
                            id: String(value.index),
                            delta: "",
                            providerMetadata: {
                              anthropic: {
                                signature: value.delta.signature
                              }
                            }
                          });
                        }
                        return;
                      }
                      case "input_json_delta": {
                        const contentBlock = contentBlocks[value.index];
                        let delta = value.delta.partial_json;
                        if (delta.length === 0) {
                          return;
                        }
                        if (usesJsonResponseTool) {
                          if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                            return;
                          }
                          controller.enqueue({
                            type: "text-delta",
                            id: String(value.index),
                            delta
                          });
                        } else {
                          if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                            return;
                          }
                          if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                            delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                          }
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: contentBlock.toolCallId,
                            delta
                          });
                          contentBlock.input += delta;
                          contentBlock.firstDelta = false;
                        }
                        return;
                      }
                      case "citations_delta": {
                        const citation = value.delta.citation;
                        const source = createCitationSource(
                          citation,
                          citationDocuments,
                          generateId32
                        );
                        if (source) {
                          controller.enqueue(source);
                        }
                        return;
                      }
                      default: {
                        const _exhaustiveCheck = deltaType;
                        throw new Error(
                          `Unsupported delta type: ${_exhaustiveCheck}`
                        );
                      }
                    }
                  }
                  case "message_start": {
                    usage.inputTokens = value.message.usage.input_tokens;
                    usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                    rawUsage = {
                      ...value.message.usage
                    };
                    cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                    controller.enqueue({
                      type: "response-metadata",
                      id: (_d = value.message.id) != null ? _d : void 0,
                      modelId: (_e = value.message.model) != null ? _e : void 0
                    });
                    return;
                  }
                  case "message_delta": {
                    usage.outputTokens = value.usage.output_tokens;
                    usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                    finishReason = mapAnthropicStopReason({
                      finishReason: value.delta.stop_reason,
                      isJsonResponseFromTool: usesJsonResponseTool
                    });
                    stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                    rawUsage = {
                      ...rawUsage,
                      ...value.usage
                    };
                    return;
                  }
                  case "message_stop": {
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      providerMetadata: {
                        anthropic: {
                          usage: rawUsage != null ? rawUsage : null,
                          cacheCreationInputTokens,
                          stopSequence
                        }
                      }
                    });
                    return;
                  }
                  case "error": {
                    controller.enqueue({ type: "error", error: value.error });
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = value;
                    throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                  }
                }
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    __name(getMaxOutputTokensForModel, "getMaxOutputTokensForModel");
    bash_20241022InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.string(),
          restart: external_exports.boolean().optional()
        })
      )
    );
    bash_20241022 = createProviderDefinedToolFactory({
      id: "anthropic.bash_20241022",
      name: "bash",
      inputSchema: bash_20241022InputSchema
    });
    bash_20250124InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.string(),
          restart: external_exports.boolean().optional()
        })
      )
    );
    bash_20250124 = createProviderDefinedToolFactory({
      id: "anthropic.bash_20250124",
      name: "bash",
      inputSchema: bash_20250124InputSchema
    });
    computer_20241022InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          action: external_exports.enum([
            "key",
            "type",
            "mouse_move",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "screenshot",
            "cursor_position"
          ]),
          coordinate: external_exports.array(external_exports.number().int()).optional(),
          text: external_exports.string().optional()
        })
      )
    );
    computer_20241022 = createProviderDefinedToolFactory({
      id: "anthropic.computer_20241022",
      name: "computer",
      inputSchema: computer_20241022InputSchema
    });
    computer_20250124InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          action: external_exports.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot"
          ]),
          coordinate: external_exports.tuple([external_exports.number().int(), external_exports.number().int()]).optional(),
          duration: external_exports.number().optional(),
          scroll_amount: external_exports.number().optional(),
          scroll_direction: external_exports.enum(["up", "down", "left", "right"]).optional(),
          start_coordinate: external_exports.tuple([external_exports.number().int(), external_exports.number().int()]).optional(),
          text: external_exports.string().optional()
        })
      )
    );
    computer_20250124 = createProviderDefinedToolFactory({
      id: "anthropic.computer_20250124",
      name: "computer",
      inputSchema: computer_20250124InputSchema
    });
    memory_20250818InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.discriminatedUnion("command", [
          external_exports.object({
            command: external_exports.literal("view"),
            path: external_exports.string(),
            view_range: external_exports.tuple([external_exports.number(), external_exports.number()]).optional()
          }),
          external_exports.object({
            command: external_exports.literal("create"),
            path: external_exports.string(),
            file_text: external_exports.string()
          }),
          external_exports.object({
            command: external_exports.literal("str_replace"),
            path: external_exports.string(),
            old_str: external_exports.string(),
            new_str: external_exports.string()
          }),
          external_exports.object({
            command: external_exports.literal("insert"),
            path: external_exports.string(),
            insert_line: external_exports.number(),
            insert_text: external_exports.string()
          }),
          external_exports.object({
            command: external_exports.literal("delete"),
            path: external_exports.string()
          }),
          external_exports.object({
            command: external_exports.literal("rename"),
            old_path: external_exports.string(),
            new_path: external_exports.string()
          })
        ])
      )
    );
    memory_20250818 = createProviderDefinedToolFactory({
      id: "anthropic.memory_20250818",
      name: "memory",
      inputSchema: memory_20250818InputSchema
    });
    textEditor_20241022InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: external_exports.string(),
          file_text: external_exports.string().optional(),
          insert_line: external_exports.number().int().optional(),
          new_str: external_exports.string().optional(),
          old_str: external_exports.string().optional(),
          view_range: external_exports.array(external_exports.number().int()).optional()
        })
      )
    );
    textEditor_20241022 = createProviderDefinedToolFactory({
      id: "anthropic.text_editor_20241022",
      name: "str_replace_editor",
      inputSchema: textEditor_20241022InputSchema
    });
    textEditor_20250124InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: external_exports.string(),
          file_text: external_exports.string().optional(),
          insert_line: external_exports.number().int().optional(),
          new_str: external_exports.string().optional(),
          old_str: external_exports.string().optional(),
          view_range: external_exports.array(external_exports.number().int()).optional()
        })
      )
    );
    textEditor_20250124 = createProviderDefinedToolFactory({
      id: "anthropic.text_editor_20250124",
      name: "str_replace_editor",
      inputSchema: textEditor_20250124InputSchema
    });
    textEditor_20250429InputSchema = lazySchema(
      () => zodSchema3(
        external_exports.object({
          command: external_exports.enum(["view", "create", "str_replace", "insert"]),
          path: external_exports.string(),
          file_text: external_exports.string().optional(),
          insert_line: external_exports.number().int().optional(),
          new_str: external_exports.string().optional(),
          old_str: external_exports.string().optional(),
          view_range: external_exports.array(external_exports.number().int()).optional()
        })
      )
    );
    textEditor_20250429 = createProviderDefinedToolFactory({
      id: "anthropic.text_editor_20250429",
      name: "str_replace_based_edit_tool",
      inputSchema: textEditor_20250429InputSchema
    });
    anthropicTools = {
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       *
       * Tool name must be `bash`.
       */
      bash_20241022,
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       *
       * Tool name must be `bash`.
       */
      bash_20250124,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       *
       * Tool name must be `code_execution`.
       */
      codeExecution_20250522,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       *
       * This is the latest version with enhanced Bash support and file operations.
       *
       * Tool name must be `code_execution`.
       */
      codeExecution_20250825,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * Tool name must be `computer`.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20241022,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * Tool name must be `computer`.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20250124,
      /**
       * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
       * Claude can create, read, update, and delete files that persist between sessions,
       * allowing it to build knowledge over time without keeping everything in the context window.
       * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
       *
       * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
       *
       * Tool name must be `memory`.
       */
      memory_20250818,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.5
       *
       * Tool name must be `str_replace_editor`.
       */
      textEditor_20241022,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.7
       *
       * Tool name must be `str_replace_editor`.
       */
      textEditor_20250124,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command.
       *
       * Tool name must be `str_replace_based_edit_tool`.
       *
       * @deprecated Use textEditor_20250728 instead
       */
      textEditor_20250429,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
       *
       * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
       *
       * Tool name must be `str_replace_based_edit_tool`.
       *
       * @param maxCharacters - Optional maximum number of characters to view in the file
       */
      textEditor_20250728,
      /**
       * Creates a web fetch tool that gives Claude direct access to real-time web content.
       *
       * Tool name must be `web_fetch`.
       *
       * @param maxUses - The max_uses parameter limits the number of web fetches performed
       * @param allowedDomains - Only fetch from these domains
       * @param blockedDomains - Never fetch from these domains
       * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
       * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
       */
      webFetch_20250910,
      /**
       * Creates a web search tool that gives Claude direct access to real-time web content.
       *
       * Tool name must be `web_search`.
       *
       * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
       * @param allowedDomains - Optional list of domains that Claude is allowed to search.
       * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
       * @param userLocation - Optional user location information to provide geographically relevant search results.
       */
      webSearch_20250305
    };
    __name(createAnthropic, "createAnthropic");
    anthropic = createAnthropic();
  }
});

// node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage6(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker20, symbol21, _a27, _AISDKError9, AISDKError5, name20, marker27, symbol28, _a28, APICallError4, name27, marker37, symbol37, _a37, EmptyResponseBodyError3, name37, marker47, symbol47, _a47, InvalidArgumentError6, name47, marker57, symbol57, _a57, name57, marker67, symbol67, _a67, name67, marker77, symbol77, _a77, JSONParseError4, name77, marker87, symbol87, _a87, LoadAPIKeyError3, name87, marker97, symbol97, _a97, name97, marker107, symbol107, _a107, name107, marker117, symbol117, _a117, name117, marker127, symbol127, _a127, TooManyEmbeddingValuesForCallError2, name127, marker137, symbol137, _a137, _TypeValidationError7, TypeValidationError4, name137, marker147, symbol147, _a147, UnsupportedFunctionalityError4;
var init_dist6 = __esm({
  "node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker20 = "vercel.ai.error";
    symbol21 = Symbol.for(marker20);
    _AISDKError9 = class _AISDKError10 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a27] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError10.hasMarker(error87, marker20);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a27 = symbol21;
    AISDKError5 = _AISDKError9;
    name20 = "AI_APICallError";
    marker27 = `vercel.ai.error.${name20}`;
    symbol28 = Symbol.for(marker27);
    APICallError4 = class extends AISDKError5 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name20, message, cause });
        this[_a28] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker27);
      }
    };
    _a28 = symbol28;
    name27 = "AI_EmptyResponseBodyError";
    marker37 = `vercel.ai.error.${name27}`;
    symbol37 = Symbol.for(marker37);
    EmptyResponseBodyError3 = class extends AISDKError5 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name27, message });
        this[_a37] = true;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker37);
      }
    };
    _a37 = symbol37;
    __name(getErrorMessage6, "getErrorMessage");
    name37 = "AI_InvalidArgumentError";
    marker47 = `vercel.ai.error.${name37}`;
    symbol47 = Symbol.for(marker47);
    InvalidArgumentError6 = class extends AISDKError5 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name37, message, cause });
        this[_a47] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker47);
      }
    };
    _a47 = symbol47;
    name47 = "AI_InvalidPromptError";
    marker57 = `vercel.ai.error.${name47}`;
    symbol57 = Symbol.for(marker57);
    _a57 = symbol57;
    name57 = "AI_InvalidResponseDataError";
    marker67 = `vercel.ai.error.${name57}`;
    symbol67 = Symbol.for(marker67);
    _a67 = symbol67;
    name67 = "AI_JSONParseError";
    marker77 = `vercel.ai.error.${name67}`;
    symbol77 = Symbol.for(marker77);
    JSONParseError4 = class extends AISDKError5 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name67,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage6(cause)}`,
          cause
        });
        this[_a77] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker77);
      }
    };
    _a77 = symbol77;
    name77 = "AI_LoadAPIKeyError";
    marker87 = `vercel.ai.error.${name77}`;
    symbol87 = Symbol.for(marker87);
    LoadAPIKeyError3 = class extends AISDKError5 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name77, message });
        this[_a87] = true;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker87);
      }
    };
    _a87 = symbol87;
    name87 = "AI_LoadSettingError";
    marker97 = `vercel.ai.error.${name87}`;
    symbol97 = Symbol.for(marker97);
    _a97 = symbol97;
    name97 = "AI_NoContentGeneratedError";
    marker107 = `vercel.ai.error.${name97}`;
    symbol107 = Symbol.for(marker107);
    _a107 = symbol107;
    name107 = "AI_NoSuchModelError";
    marker117 = `vercel.ai.error.${name107}`;
    symbol117 = Symbol.for(marker117);
    _a117 = symbol117;
    name117 = "AI_TooManyEmbeddingValuesForCallError";
    marker127 = `vercel.ai.error.${name117}`;
    symbol127 = Symbol.for(marker127);
    TooManyEmbeddingValuesForCallError2 = class extends AISDKError5 {
      static {
        __name(this, "TooManyEmbeddingValuesForCallError");
      }
      constructor(options) {
        super({
          name: name117,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a127] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker127);
      }
    };
    _a127 = symbol127;
    name127 = "AI_TypeValidationError";
    marker137 = `vercel.ai.error.${name127}`;
    symbol137 = Symbol.for(marker137);
    _TypeValidationError7 = class _TypeValidationError8 extends AISDKError5 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name127,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage6(cause)}`,
          cause
        });
        this[_a137] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker137);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError8.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError8({ value, cause });
      }
    };
    _a137 = symbol137;
    TypeValidationError4 = _TypeValidationError7;
    name137 = "AI_UnsupportedFunctionalityError";
    marker147 = `vercel.ai.error.${name137}`;
    symbol147 = Symbol.for(marker147);
    UnsupportedFunctionalityError4 = class extends AISDKError5 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name137, message });
        this[_a147] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError5.hasMarker(error87, marker147);
      }
    };
    _a147 = symbol147;
  }
});

// node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError5(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError2({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError5(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError4({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix3(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
function loadApiKey2({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError3({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError3({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError3({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError3({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse5(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx3.test(text3) === false && suspectConstructorRx3.test(text3) === false) {
    return obj;
  }
  return filter3(obj);
}
function filter3(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse3(text3) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse5(text3);
  }
  try {
    return _parse5(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator4(validate) {
  return { [validatorSymbol5]: true, validate };
}
function isValidator4(value) {
  return typeof value === "object" && value !== null && validatorSymbol5 in value && value[validatorSymbol5] === true && "validate" in value;
}
function asValidator4(value) {
  return isValidator4(value) ? value : typeof value === "function" ? value() : standardSchemaValidator3(value);
}
function standardSchemaValidator3(standardSchema) {
  return validator4(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError4({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes3({
  value,
  schema
}) {
  const result = await safeValidateTypes4({ value, schema });
  if (!result.success) {
    throw TypeValidationError4.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes4({
  value,
  schema
}) {
  const validator22 = asValidator4(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON2({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse3(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes3({ value, schema });
  } catch (error87) {
    if (JSONParseError4.isInstance(error87) || TypeValidationError4.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError4({ text: text3, cause: error87 });
  }
}
async function safeParseJSON4({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse3(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes4({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError4.isInstance(error87) ? error87 : new JSONParseError4({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream3({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON4({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions2({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes4({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError6({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function tool3(tool22) {
  return tool22;
}
function createProviderDefinedToolFactory2({
  id,
  name: name51,
  inputSchema
}) {
  return ({
    execute: execute2,
    outputSchema: outputSchema2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool3({
    type: "provider-defined",
    id,
    name: name51,
    args,
    inputSchema,
    outputSchema: outputSchema2,
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function createProviderDefinedToolFactoryWithOutputSchema2({
  id,
  name: name51,
  inputSchema,
  outputSchema: outputSchema2
}) {
  return ({
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool3({
    type: "provider-defined",
    id,
    name: name51,
    args,
    inputSchema,
    outputSchema: outputSchema2,
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
async function resolve2(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
function parseAnyDef4() {
  return {};
}
function parseArrayDef4(def, refs) {
  var _a61, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a61 = def.type) == null ? void 0 : _a61._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef4(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef4(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef4() {
  return { type: "boolean" };
}
function parseBrandedDef4(_def, refs) {
  return parseDef4(_def.type._def, refs);
}
function parseDateDef4(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef4(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser4(def);
  }
}
function parseDefaultDef4(_def, refs) {
  return {
    ...parseDef4(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef4(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef4(_def.schema._def, refs) : parseAnyDef4();
}
function parseEnumDef4(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
function parseIntersectionDef4(def, refs) {
  const allOf = [
    parseDef4(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef4(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType4(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef4(def) {
  const parsedType5 = typeof def.value;
  if (parsedType5 !== "bigint" && parsedType5 !== "number" && parsedType5 !== "boolean" && parsedType5 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType5 === "bigint" ? "integer" : parsedType5,
    const: def.value
  };
}
function parseStringDef4(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check3 of def.checks) {
      switch (check3.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat4(res, "email", check3.message, refs);
              break;
            case "format:idn-email":
              addFormat4(res, "idn-email", check3.message, refs);
              break;
            case "pattern:zod":
              addPattern4(res, zodPatterns4.email, check3.message, refs);
              break;
          }
          break;
        case "url":
          addFormat4(res, "uri", check3.message, refs);
          break;
        case "uuid":
          addFormat4(res, "uuid", check3.message, refs);
          break;
        case "regex":
          addPattern4(res, check3.regex, check3.message, refs);
          break;
        case "cuid":
          addPattern4(res, zodPatterns4.cuid, check3.message, refs);
          break;
        case "cuid2":
          addPattern4(res, zodPatterns4.cuid2, check3.message, refs);
          break;
        case "startsWith":
          addPattern4(
            res,
            RegExp(`^${escapeLiteralCheckValue4(check3.value, refs)}`),
            check3.message,
            refs
          );
          break;
        case "endsWith":
          addPattern4(
            res,
            RegExp(`${escapeLiteralCheckValue4(check3.value, refs)}$`),
            check3.message,
            refs
          );
          break;
        case "datetime":
          addFormat4(res, "date-time", check3.message, refs);
          break;
        case "date":
          addFormat4(res, "date", check3.message, refs);
          break;
        case "time":
          addFormat4(res, "time", check3.message, refs);
          break;
        case "duration":
          addFormat4(res, "duration", check3.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "includes": {
          addPattern4(
            res,
            RegExp(escapeLiteralCheckValue4(check3.value, refs)),
            check3.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check3.version !== "v6") {
            addFormat4(res, "ipv4", check3.message, refs);
          }
          if (check3.version !== "v4") {
            addFormat4(res, "ipv6", check3.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern4(res, zodPatterns4.base64url, check3.message, refs);
          break;
        case "jwt":
          addPattern4(res, zodPatterns4.jwt, check3.message, refs);
          break;
        case "cidr": {
          if (check3.version !== "v6") {
            addPattern4(res, zodPatterns4.ipv4Cidr, check3.message, refs);
          }
          if (check3.version !== "v4") {
            addPattern4(res, zodPatterns4.ipv6Cidr, check3.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern4(res, zodPatterns4.emoji(), check3.message, refs);
          break;
        case "ulid": {
          addPattern4(res, zodPatterns4.ulid, check3.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat4(res, "binary", check3.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern4(res, zodPatterns4.base64, check3.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern4(res, zodPatterns4.nanoid, check3.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check3);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue4(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric4(literal3) : literal3;
}
function escapeNonAlphaNumeric4(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC5.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat4(schema, value, message, refs) {
  var _a61;
  if (schema.format || ((_a61 = schema.anyOf) == null ? void 0 : _a61.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern4(schema, regex, message, refs) {
  var _a61;
  if (schema.pattern || ((_a61 = schema.allOf) == null ? void 0 : _a61.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags4(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags4(regex, refs);
  }
}
function stringifyRegExpWithFlags4(regex, refs) {
  var _a61;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a61 = source[i + 2]) == null ? void 0 : _a61.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef4(def, refs) {
  var _a61, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a61 = parseDef4(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a61 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef4(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef4(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef4(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef4(def, refs);
  }
  const keys = parseDef4(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef4();
  const values = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef4();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef4(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef4() {
  return { not: parseAnyDef4() };
}
function parseNullDef4() {
  return {
    type: "null"
  };
}
function parseUnionDef4(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings4 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings4[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf4(def, refs);
}
function parseNullableDef4(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings4[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef4(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseObjectDef4(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional4(propDef);
    const parsedDef = parseDef4(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties4(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties4(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef4(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional4(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
function parsePromiseDef4(def, refs) {
  return parseDef4(def.type._def, refs);
}
function parseSetDef4(def, refs) {
  const items = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef4(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef4(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef4() {
  return {
    not: parseAnyDef4()
  };
}
function parseUnknownDef4() {
  return parseAnyDef4();
}
function parseDef4(def, refs, forceResolution = false) {
  var _a61;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a61 = refs.override) == null ? void 0 : _a61.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride5) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref4(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser5(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef4(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta4(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
function zod3Schema3(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default3(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function zod4Schema3(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await safeParseAsync2(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function isZod4Schema3(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema4(zodSchema22, options) {
  if (isZod4Schema3(zodSchema22)) {
    return zod4Schema3(zodSchema22, options);
  } else {
    return zod3Schema3(zodSchema22, options);
  }
}
function lazySchema2(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema4(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol5]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol5]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
function convertUint8ArrayToBase644(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa6(latin1string);
}
function convertToBase642(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase644(value) : value;
}
function withoutTrailingSlash2(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator5, generateId5, FETCH_FAILED_ERROR_MESSAGES2, VERSION3, suspectProtoRx3, suspectConstructorRx3, validatorSymbol5, getOriginalFetch22, postJsonToApi2, postToApi2, createJsonErrorResponseHandler2, createEventSourceResponseHandler2, createJsonResponseHandler2, getRelativePath4, ignoreOverride5, defaultOptions4, getDefaultOptions4, parseCatchDef4, integerDateParser4, isJsonSchema7AllOfType4, emojiRegex5, zodPatterns4, ALPHA_NUMERIC5, primitiveMappings4, asAnyOf4, parseOptionalDef4, parsePipelineDef4, parseReadonlyDef4, selectParser5, get$ref4, addMeta4, getRefs4, zodToJsonSchema5, zod_to_json_schema_default3, schemaSymbol5, btoa6, atob6;
var init_dist7 = __esm({
  "node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_stream();
    init_dist6();
    init_dist6();
    init_dist6();
    init_v4();
    init_v3();
    init_v3();
    init_v3();
    init_dist2();
    __name(combineHeaders2, "combineHeaders");
    __name(extractResponseHeaders2, "extractResponseHeaders");
    createIdGenerator5 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError6({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId5 = createIdGenerator5();
    __name(isAbortError5, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError2, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent2, "getRuntimeEnvironmentUserAgent");
    __name(normalizeHeaders, "normalizeHeaders");
    __name(withUserAgentSuffix3, "withUserAgentSuffix");
    VERSION3 = true ? "3.0.17" : "0.0.0-test";
    __name(loadApiKey2, "loadApiKey");
    suspectProtoRx3 = /"__proto__"\s*:/;
    suspectConstructorRx3 = /"constructor"\s*:/;
    __name(_parse5, "_parse");
    __name(filter3, "filter");
    __name(secureJsonParse3, "secureJsonParse");
    validatorSymbol5 = Symbol.for("vercel.ai.validator");
    __name(validator4, "validator");
    __name(isValidator4, "isValidator");
    __name(asValidator4, "asValidator");
    __name(standardSchemaValidator3, "standardSchemaValidator");
    __name(validateTypes3, "validateTypes");
    __name(safeValidateTypes4, "safeValidateTypes");
    __name(parseJSON2, "parseJSON");
    __name(safeParseJSON4, "safeParseJSON");
    __name(parseJsonEventStream3, "parseJsonEventStream");
    __name(parseProviderOptions2, "parseProviderOptions");
    getOriginalFetch22 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi2 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi2({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi2 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch22()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix3(
            headers,
            `ai-sdk/provider-utils/${VERSION3}`,
            getRuntimeEnvironmentUserAgent2()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders2(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError5(error87) || APICallError4.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError4({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError5(error87) || APICallError4.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError4({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError2({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    __name(tool3, "tool");
    __name(createProviderDefinedToolFactory2, "createProviderDefinedToolFactory");
    __name(createProviderDefinedToolFactoryWithOutputSchema2, "createProviderDefinedToolFactoryWithOutputSchema");
    __name(resolve2, "resolve");
    createJsonErrorResponseHandler2 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders2(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError4({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON2({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError4({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError4({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler2 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders2(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError3({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream3({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler2 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON4({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders2(response);
      if (!parsedResult.success) {
        throw new APICallError4({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    getRelativePath4 = /* @__PURE__ */ __name((pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i]) break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    }, "getRelativePath");
    ignoreOverride5 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    defaultOptions4 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions4 = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
      ...defaultOptions4,
      name: options
    } : {
      ...defaultOptions4,
      ...options
    }, "getDefaultOptions");
    __name(parseAnyDef4, "parseAnyDef");
    __name(parseArrayDef4, "parseArrayDef");
    __name(parseBigintDef4, "parseBigintDef");
    __name(parseBooleanDef4, "parseBooleanDef");
    __name(parseBrandedDef4, "parseBrandedDef");
    parseCatchDef4 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef4(def.innerType._def, refs);
    }, "parseCatchDef");
    __name(parseDateDef4, "parseDateDef");
    integerDateParser4 = /* @__PURE__ */ __name((def) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check3 of def.checks) {
        switch (check3.kind) {
          case "min":
            res.minimum = check3.value;
            break;
          case "max":
            res.maximum = check3.value;
            break;
        }
      }
      return res;
    }, "integerDateParser");
    __name(parseDefaultDef4, "parseDefaultDef");
    __name(parseEffectsDef4, "parseEffectsDef");
    __name(parseEnumDef4, "parseEnumDef");
    isJsonSchema7AllOfType4 = /* @__PURE__ */ __name((type) => {
      if ("type" in type && type.type === "string") return false;
      return "allOf" in type;
    }, "isJsonSchema7AllOfType");
    __name(parseIntersectionDef4, "parseIntersectionDef");
    __name(parseLiteralDef4, "parseLiteralDef");
    emojiRegex5 = void 0;
    zodPatterns4 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: /* @__PURE__ */ __name(() => {
        if (emojiRegex5 === void 0) {
          emojiRegex5 = RegExp(
            "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
            "u"
          );
        }
        return emojiRegex5;
      }, "emoji"),
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    __name(parseStringDef4, "parseStringDef");
    __name(escapeLiteralCheckValue4, "escapeLiteralCheckValue");
    ALPHA_NUMERIC5 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    __name(escapeNonAlphaNumeric4, "escapeNonAlphaNumeric");
    __name(addFormat4, "addFormat");
    __name(addPattern4, "addPattern");
    __name(stringifyRegExpWithFlags4, "stringifyRegExpWithFlags");
    __name(parseRecordDef4, "parseRecordDef");
    __name(parseMapDef4, "parseMapDef");
    __name(parseNativeEnumDef4, "parseNativeEnumDef");
    __name(parseNeverDef4, "parseNeverDef");
    __name(parseNullDef4, "parseNullDef");
    primitiveMappings4 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    __name(parseUnionDef4, "parseUnionDef");
    asAnyOf4 = /* @__PURE__ */ __name((def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "anyOf", `${i}`]
        })
      ).filter(
        (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
      );
      return anyOf.length ? { anyOf } : void 0;
    }, "asAnyOf");
    __name(parseNullableDef4, "parseNullableDef");
    __name(parseNumberDef4, "parseNumberDef");
    __name(parseObjectDef4, "parseObjectDef");
    __name(decideAdditionalProperties4, "decideAdditionalProperties");
    __name(safeIsOptional4, "safeIsOptional");
    parseOptionalDef4 = /* @__PURE__ */ __name((def, refs) => {
      var _a61;
      if (refs.currentPath.toString() === ((_a61 = refs.propertyPath) == null ? void 0 : _a61.toString())) {
        return parseDef4(def.innerType._def, refs);
      }
      const innerSchema = parseDef4(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? { anyOf: [{ not: parseAnyDef4() }, innerSchema] } : parseAnyDef4();
    }, "parseOptionalDef");
    parsePipelineDef4 = /* @__PURE__ */ __name((def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef4(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef4(def.out._def, refs);
      }
      const a = parseDef4(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef4(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      });
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    }, "parsePipelineDef");
    __name(parsePromiseDef4, "parsePromiseDef");
    __name(parseSetDef4, "parseSetDef");
    __name(parseTupleDef4, "parseTupleDef");
    __name(parseUndefinedDef4, "parseUndefinedDef");
    __name(parseUnknownDef4, "parseUnknownDef");
    parseReadonlyDef4 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef4(def.innerType._def, refs);
    }, "parseReadonlyDef");
    selectParser5 = /* @__PURE__ */ __name((def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef4(def);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef4(def);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef4();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef4();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef4();
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef4(def);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef4(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef4(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef4();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef4();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef4();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef4(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    }, "selectParser");
    __name(parseDef4, "parseDef");
    get$ref4 = /* @__PURE__ */ __name((item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath4(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
            console.warn(
              `Recursive reference detected at ${refs.currentPath.join(
                "/"
              )}! Defaulting to any`
            );
            return parseAnyDef4();
          }
          return refs.$refStrategy === "seen" ? parseAnyDef4() : void 0;
        }
      }
    }, "get$ref");
    addMeta4 = /* @__PURE__ */ __name((def, refs, jsonSchema22) => {
      if (def.description) {
        jsonSchema22.description = def.description;
      }
      return jsonSchema22;
    }, "addMeta");
    getRefs4 = /* @__PURE__ */ __name((options) => {
      const _options = getDefaultOptions4(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(_options.definitions).map(([name51, def]) => [
            def._def,
            {
              def: def._def,
              path: [..._options.basePath, _options.definitionPath, name51],
              // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
              jsonSchema: void 0
            }
          ])
        )
      };
    }, "getRefs");
    zodToJsonSchema5 = /* @__PURE__ */ __name((schema, options) => {
      var _a61;
      const refs = getRefs4(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
        (acc, [name216, schema2]) => {
          var _a217;
          return {
            ...acc,
            [name216]: (_a217 = parseDef4(
              schema2._def,
              {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name216]
              },
              true
            )) != null ? _a217 : parseAnyDef4()
          };
        },
        {}
      ) : void 0;
      const name51 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
      const main = (_a61 = parseDef4(
        schema._def,
        name51 === void 0 ? refs : {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name51]
        },
        false
      )) != null ? _a61 : parseAnyDef4();
      const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title2 !== void 0) {
        main.title = title2;
      }
      const combined = name51 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name51
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name51]: main
        }
      };
      combined.$schema = "http://json-schema.org/draft-07/schema#";
      return combined;
    }, "zodToJsonSchema");
    zod_to_json_schema_default3 = zodToJsonSchema5;
    __name(zod3Schema3, "zod3Schema");
    __name(zod4Schema3, "zod4Schema");
    __name(isZod4Schema3, "isZod4Schema");
    __name(zodSchema4, "zodSchema");
    schemaSymbol5 = Symbol.for("vercel.ai.schema");
    __name(lazySchema2, "lazySchema");
    __name(jsonSchema4, "jsonSchema");
    ({ btoa: btoa6, atob: atob6 } = globalThis);
    __name(convertUint8ArrayToBase644, "convertUint8ArrayToBase64");
    __name(convertToBase642, "convertToBase64");
    __name(withoutTrailingSlash2, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/google-v5/dist/index.mjs
function convertJSONSchemaToOpenAPISchema(jsonSchema6) {
  if (jsonSchema6 == null || isEmptyObjectSchema(jsonSchema6)) {
    return void 0;
  }
  if (typeof jsonSchema6 === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type,
    description,
    required: required3,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema6;
  const result = {};
  if (description) result.description = description;
  if (required3) result.required = required3;
  if (format) result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type) {
    if (Array.isArray(type)) {
      if (type.includes("null")) {
        result.type = type.filter((t) => t !== "null")[0];
        result.nullable = true;
      } else {
        result.type = type;
      }
    } else if (type === "null") {
      result.type = "null";
    } else {
      result.type = type;
    }
  }
  if (enumValues !== void 0) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema(value);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (anyOf) {
    if (anyOf.some(
      (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
    )) {
      const nonNullSchemas = anyOf.filter(
        (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
      );
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (minLength !== void 0) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema(jsonSchema6) {
  return jsonSchema6 != null && typeof jsonSchema6 === "object" && jsonSchema6.type === "object" && (jsonSchema6.properties == null || Object.keys(jsonSchema6.properties).length === 0) && !jsonSchema6.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
  var _a61;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  const isGemmaModel = (_a61 = options == null ? void 0 : options.isGemmaModel) != null ? _a61 : false;
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new UnsupportedFunctionalityError4({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: mediaType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: mediaType,
                    data: convertToBase642(part.data)
                  }
                }
              );
              break;
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a217, _b, _c;
            const thoughtSignature = ((_b = (_a217 = part.providerOptions) == null ? void 0 : _a217.google) == null ? void 0 : _b.thoughtSignature) != null ? String((_c = part.providerOptions.google) == null ? void 0 : _c.thoughtSignature) : void 0;
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature
                };
              }
              case "reasoning": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: true,
                  thoughtSignature
                };
              }
              case "file": {
                if (part.mediaType !== "image/png") {
                  throw new UnsupportedFunctionalityError4({
                    functionality: "Only PNG images are supported in assistant messages"
                  });
                }
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError4({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase642(part.data)
                  }
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature
                };
              }
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          const output = part.output;
          if (output.type === "content") {
            for (const contentPart of output.value) {
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "media":
                  parts.push(
                    {
                      inlineData: {
                        mimeType: contentPart.mediaType,
                        data: contentPart.data
                      }
                    },
                    {
                      text: "Tool executed successfully and returned this image as a response"
                    }
                  );
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
            }
          } else {
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.value
                }
              }
            });
          }
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
    contents[0].parts.unshift({ text: systemText + "\n\n" });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
function prepareTools2({
  tools,
  toolChoice,
  modelId
}) {
  var _a61;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const isLatest = [
    "gemini-flash-latest",
    "gemini-flash-lite-latest",
    "gemini-pro-latest"
  ].some((id) => id === modelId);
  const isGemini2orNewer = modelId.includes("gemini-2") || modelId.includes("gemini-3") || isLatest;
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  const supportsFileSearch = modelId.includes("gemini-2.5");
  if (tools == null) {
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  }
  const hasFunctionTools = tools.some((tool5) => tool5.type === "function");
  const hasProviderDefinedTools = tools.some(
    (tool5) => tool5.type === "provider-defined"
  );
  if (hasFunctionTools && hasProviderDefinedTools) {
    const functionTools = tools.filter((tool5) => tool5.type === "function");
    toolWarnings.push({
      type: "unsupported-tool",
      tool: tools.find((tool5) => tool5.type === "function"),
      details: `Cannot mix function tools with provider-defined tools in the same request. Falling back to provider-defined tools only. The following function tools will be ignored: ${functionTools.map((t) => t.name).join(", ")}. Please use either function tools or provider-defined tools, but not both.`
    });
  }
  if (hasProviderDefinedTools) {
    const googleTools2 = [];
    const providerDefinedTools = tools.filter(
      (tool5) => tool5.type === "provider-defined"
    );
    providerDefinedTools.forEach((tool5) => {
      switch (tool5.id) {
        case "google.google_search":
          if (isGemini2orNewer) {
            googleTools2.push({ googleSearch: {} });
          } else if (supportsDynamicRetrieval) {
            googleTools2.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool5.args.mode,
                  dynamicThreshold: tool5.args.dynamicThreshold
                }
              }
            });
          } else {
            googleTools2.push({ googleSearchRetrieval: {} });
          }
          break;
        case "google.url_context":
          if (isGemini2orNewer) {
            googleTools2.push({ urlContext: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool5,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.code_execution":
          if (isGemini2orNewer) {
            googleTools2.push({ codeExecution: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool5,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.file_search":
          if (supportsFileSearch) {
            googleTools2.push({ fileSearch: { ...tool5.args } });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool5,
              details: "The file search tool is only supported with Gemini 2.5 models."
            });
          }
          break;
        case "google.vertex_rag_store":
          if (isGemini2orNewer) {
            googleTools2.push({
              retrieval: {
                vertex_rag_store: {
                  rag_resources: {
                    rag_corpus: tool5.args.ragCorpus
                  },
                  similarity_top_k: tool5.args.topK
                }
              }
            });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool5,
              details: "The RAG store tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
          break;
      }
    });
    return {
      tools: googleTools2.length > 0 ? googleTools2 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const functionDeclarations = [];
  for (const tool5 of tools) {
    switch (tool5.type) {
      case "function":
        functionDeclarations.push({
          name: tool5.name,
          description: (_a61 = tool5.description) != null ? _a61 : "",
          parameters: convertJSONSchemaToOpenAPISchema(tool5.inputSchema)
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
        break;
    }
  }
  if (toolChoice == null) {
    return {
      tools: { functionDeclarations },
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: { functionDeclarations },
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError4({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    default:
      return "unknown";
  }
}
function getToolCallsFromParts({
  parts,
  generateId: generateId32
}) {
  const functionCallParts = parts == null ? void 0 : parts.filter(
    (part) => "functionCall" in part
  );
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId32(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
  }));
}
function getInlineDataParts(parts) {
  return parts == null ? void 0 : parts.filter(
    (part) => "inlineData" in part
  );
}
function extractSources({
  groundingMetadata,
  generateId: generateId32
}) {
  var _a61, _b, _c;
  if (!(groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks)) {
    return void 0;
  }
  const sources = [];
  for (const chunk of groundingMetadata.groundingChunks) {
    if (chunk.web != null) {
      sources.push({
        type: "source",
        sourceType: "url",
        id: generateId32(),
        url: chunk.web.uri,
        title: (_a61 = chunk.web.title) != null ? _a61 : void 0
      });
    } else if (chunk.retrievedContext != null) {
      const uri = chunk.retrievedContext.uri;
      if (uri.startsWith("http://") || uri.startsWith("https://")) {
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId32(),
          url: uri,
          title: (_b = chunk.retrievedContext.title) != null ? _b : void 0
        });
      } else {
        const title2 = (_c = chunk.retrievedContext.title) != null ? _c : "Unknown Document";
        let mediaType = "application/octet-stream";
        let filename = void 0;
        if (uri.endsWith(".pdf")) {
          mediaType = "application/pdf";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".txt")) {
          mediaType = "text/plain";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".docx")) {
          mediaType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".doc")) {
          mediaType = "application/msword";
          filename = uri.split("/").pop();
        } else if (uri.match(/\.(md|markdown)$/)) {
          mediaType = "text/markdown";
          filename = uri.split("/").pop();
        } else {
          filename = uri.split("/").pop();
        }
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId32(),
          mediaType,
          title: title2,
          filename
        });
      }
    }
  }
  return sources.length > 0 ? sources : void 0;
}
function createGoogleGenerativeAI(options = {}) {
  var _a61, _b;
  const baseURL = (_a61 = withoutTrailingSlash2(options.baseURL)) != null ? _a61 : "https://generativelanguage.googleapis.com/v1beta";
  const providerName = (_b = options.name) != null ? _b : "google.generative-ai";
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix3(
    {
      "x-goog-api-key": loadApiKey2({
        apiKey: options.apiKey,
        environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
        description: "Google Generative AI"
      }),
      ...options.headers
    },
    `ai-sdk/google/${VERSION4}`
  ), "getHeaders");
  const createChatModel = /* @__PURE__ */ __name((modelId) => {
    var _a217;
    return new GoogleGenerativeAILanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      generateId: (_a217 = options.generateId) != null ? _a217 : generateId5,
      supportedUrls: /* @__PURE__ */ __name(() => ({
        "*": [
          // Google Generative Language "files" endpoint
          // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
          new RegExp(`^${baseURL}/files/.*$`),
          // YouTube URLs (public or unlisted videos)
          new RegExp(
            `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
          ),
          new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
        ]
      }), "supportedUrls"),
      fetch: options.fetch
    });
  }, "createChatModel");
  const createEmbeddingModel = /* @__PURE__ */ __name((modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), "createEmbeddingModel");
  const createImageModel = /* @__PURE__ */ __name((modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), "createImageModel");
  const provider = /* @__PURE__ */ __name(function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Generative AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  }, "provider");
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.generativeAI = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = googleTools;
  return provider;
}
var VERSION4, googleErrorDataSchema, googleFailedResponseHandler, googleGenerativeAIEmbeddingProviderOptions, GoogleGenerativeAIEmbeddingModel, googleGenerativeAITextEmbeddingResponseSchema, googleGenerativeAISingleEmbeddingResponseSchema, googleGenerativeAIProviderOptions, GoogleGenerativeAILanguageModel, getGroundingMetadataSchema, getContentSchema, getSafetyRatingSchema, usageSchema, getUrlContextMetadataSchema, responseSchema, chunkSchema, codeExecution, fileSearchArgsBaseSchema, fileSearchArgsSchema, fileSearch, googleSearch, urlContext, vertexRagStore, googleTools, GoogleGenerativeAIImageModel, googleImageResponseSchema, googleImageProviderOptionsSchema, google;
var init_dist8 = __esm({
  "node_modules/@ai-sdk/google-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist7();
    init_dist6();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist6();
    init_dist7();
    init_dist7();
    init_v4();
    init_dist6();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    init_dist7();
    init_v4();
    VERSION4 = true ? "2.0.40" : "0.0.0-test";
    googleErrorDataSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          error: external_exports.object({
            code: external_exports.number().nullable(),
            message: external_exports.string(),
            status: external_exports.string()
          })
        })
      )
    );
    googleFailedResponseHandler = createJsonErrorResponseHandler2({
      errorSchema: googleErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    });
    googleGenerativeAIEmbeddingProviderOptions = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          /**
           * Optional. Optional reduced dimension for the output embedding.
           * If set, excessive values in the output embedding are truncated from the end.
           */
          outputDimensionality: external_exports.number().optional(),
          /**
           * Optional. Specifies the task type for generating embeddings.
           * Supported task types:
           * - SEMANTIC_SIMILARITY: Optimized for text similarity.
           * - CLASSIFICATION: Optimized for text classification.
           * - CLUSTERING: Optimized for clustering texts based on similarity.
           * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
           * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
           * - QUESTION_ANSWERING: Optimized for answering questions.
           * - FACT_VERIFICATION: Optimized for verifying factual information.
           * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
           */
          taskType: external_exports.enum([
            "SEMANTIC_SIMILARITY",
            "CLASSIFICATION",
            "CLUSTERING",
            "RETRIEVAL_DOCUMENT",
            "RETRIEVAL_QUERY",
            "QUESTION_ANSWERING",
            "FACT_VERIFICATION",
            "CODE_RETRIEVAL_QUERY"
          ]).optional()
        })
      )
    );
    GoogleGenerativeAIEmbeddingModel = class {
      static {
        __name(this, "GoogleGenerativeAIEmbeddingModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        const googleOptions = await parseProviderOptions2({
          provider: "google",
          providerOptions,
          schema: googleGenerativeAIEmbeddingProviderOptions
        });
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError2({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const mergedHeaders = combineHeaders2(
          await resolve2(this.config.headers),
          headers
        );
        if (values.length === 1) {
          const {
            responseHeaders: responseHeaders2,
            value: response2,
            rawValue: rawValue2
          } = await postJsonToApi2({
            url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
            headers: mergedHeaders,
            body: {
              model: `models/${this.modelId}`,
              content: {
                parts: [{ text: values[0] }]
              },
              outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
              taskType: googleOptions == null ? void 0 : googleOptions.taskType
            },
            failedResponseHandler: googleFailedResponseHandler,
            successfulResponseHandler: createJsonResponseHandler2(
              googleGenerativeAISingleEmbeddingResponseSchema
            ),
            abortSignal,
            fetch: this.config.fetch
          });
          return {
            embeddings: [response2.embedding.values],
            usage: void 0,
            response: { headers: responseHeaders2, body: rawValue2 }
          };
        }
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi2({
          url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
          headers: mergedHeaders,
          body: {
            requests: values.map((value) => ({
              model: `models/${this.modelId}`,
              content: { role: "user", parts: [{ text: value }] },
              outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
              taskType: googleOptions == null ? void 0 : googleOptions.taskType
            }))
          },
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            googleGenerativeAITextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: response.embeddings.map((item) => item.values),
          usage: void 0,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    googleGenerativeAITextEmbeddingResponseSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          embeddings: external_exports.array(external_exports.object({ values: external_exports.array(external_exports.number()) }))
        })
      )
    );
    googleGenerativeAISingleEmbeddingResponseSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          embedding: external_exports.object({ values: external_exports.array(external_exports.number()) })
        })
      )
    );
    __name(convertJSONSchemaToOpenAPISchema, "convertJSONSchemaToOpenAPISchema");
    __name(isEmptyObjectSchema, "isEmptyObjectSchema");
    __name(convertToGoogleGenerativeAIMessages, "convertToGoogleGenerativeAIMessages");
    __name(getModelPath, "getModelPath");
    googleGenerativeAIProviderOptions = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          responseModalities: external_exports.array(external_exports.enum(["TEXT", "IMAGE"])).optional(),
          thinkingConfig: external_exports.object({
            thinkingBudget: external_exports.number().optional(),
            includeThoughts: external_exports.boolean().optional(),
            // https://ai.google.dev/gemini-api/docs/gemini-3?thinking=high#thinking_level
            thinkingLevel: external_exports.enum(["low", "medium", "high"]).optional()
          }).optional(),
          /**
           * Optional.
           * The name of the cached content used as context to serve the prediction.
           * Format: cachedContents/{cachedContent}
           */
          cachedContent: external_exports.string().optional(),
          /**
           * Optional. Enable structured output. Default is true.
           *
           * This is useful when the JSON Schema contains elements that are
           * not supported by the OpenAPI schema version that
           * Google Generative AI uses. You can use this to disable
           * structured outputs if you need to.
           */
          structuredOutputs: external_exports.boolean().optional(),
          /**
           * Optional. A list of unique safety settings for blocking unsafe content.
           */
          safetySettings: external_exports.array(
            external_exports.object({
              category: external_exports.enum([
                "HARM_CATEGORY_UNSPECIFIED",
                "HARM_CATEGORY_HATE_SPEECH",
                "HARM_CATEGORY_DANGEROUS_CONTENT",
                "HARM_CATEGORY_HARASSMENT",
                "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "HARM_CATEGORY_CIVIC_INTEGRITY"
              ]),
              threshold: external_exports.enum([
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                "BLOCK_LOW_AND_ABOVE",
                "BLOCK_MEDIUM_AND_ABOVE",
                "BLOCK_ONLY_HIGH",
                "BLOCK_NONE",
                "OFF"
              ])
            })
          ).optional(),
          threshold: external_exports.enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
          ]).optional(),
          /**
           * Optional. Enables timestamp understanding for audio-only files.
           *
           * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
           */
          audioTimestamp: external_exports.boolean().optional(),
          /**
           * Optional. Defines labels used in billing reports. Available on Vertex AI only.
           *
           * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
           */
          labels: external_exports.record(external_exports.string(), external_exports.string()).optional(),
          /**
           * Optional. If specified, the media resolution specified will be used.
           *
           * https://ai.google.dev/api/generate-content#MediaResolution
           */
          mediaResolution: external_exports.enum([
            "MEDIA_RESOLUTION_UNSPECIFIED",
            "MEDIA_RESOLUTION_LOW",
            "MEDIA_RESOLUTION_MEDIUM",
            "MEDIA_RESOLUTION_HIGH"
          ]).optional(),
          /**
           * Optional. Configures the image generation aspect ratio for Gemini models.
           *
           * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
           */
          imageConfig: external_exports.object({
            aspectRatio: external_exports.enum([
              "1:1",
              "2:3",
              "3:2",
              "3:4",
              "4:3",
              "4:5",
              "5:4",
              "9:16",
              "16:9",
              "21:9"
            ]).optional(),
            imageSize: external_exports.enum(["1K", "2K", "4K"]).optional()
          }).optional()
        })
      )
    );
    __name(prepareTools2, "prepareTools");
    __name(mapGoogleGenerativeAIFinishReason, "mapGoogleGenerativeAIFinishReason");
    GoogleGenerativeAILanguageModel = class {
      static {
        __name(this, "GoogleGenerativeAILanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        var _a61;
        this.modelId = modelId;
        this.config = config4;
        this.generateId = (_a61 = config4.generateId) != null ? _a61 : generateId5;
      }
      get provider() {
        return this.config.provider;
      }
      get supportedUrls() {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).supportedUrls) == null ? void 0 : _b.call(_a61)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a61;
        const warnings = [];
        const googleOptions = await parseProviderOptions2({
          provider: "google",
          providerOptions,
          schema: googleGenerativeAIProviderOptions
        });
        if ((tools == null ? void 0 : tools.some(
          (tool5) => tool5.type === "provider-defined" && tool5.id === "google.vertex_rag_store"
        )) && !this.config.provider.startsWith("google.vertex.")) {
          warnings.push({
            type: "other",
            message: `The 'vertex_rag_store' tool is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
          });
        }
        const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
        const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
          prompt,
          { isGemmaModel }
        );
        const {
          tools: googleTools2,
          toolConfig: googleToolConfig,
          toolWarnings
        } = prepareTools2({
          tools,
          toolChoice,
          modelId: this.modelId
        });
        return {
          args: {
            generationConfig: {
              // standardized settings:
              maxOutputTokens,
              temperature,
              topK,
              topP,
              frequencyPenalty,
              presencePenalty,
              stopSequences,
              seed,
              // response format:
              responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
              responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
              // so this is needed as an escape hatch:
              // TODO convert into provider option
              ((_a61 = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _a61 : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
              ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
                audioTimestamp: googleOptions.audioTimestamp
              },
              // provider options:
              responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
              thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig,
              ...(googleOptions == null ? void 0 : googleOptions.imageConfig) && {
                imageConfig: googleOptions.imageConfig
              },
              ...(googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
                mediaResolution: googleOptions.mediaResolution
              }
            },
            contents,
            systemInstruction: isGemmaModel ? void 0 : systemInstruction,
            safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
            tools: googleTools2,
            toolConfig: googleToolConfig,
            cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
            labels: googleOptions == null ? void 0 : googleOptions.labels
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        const { args, warnings } = await this.getArgs(options);
        const body = JSON.stringify(args);
        const mergedHeaders = combineHeaders2(
          await resolve2(this.config.headers),
          options.headers
        );
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi2({
          url: `${this.config.baseURL}/${getModelPath(
            this.modelId
          )}:generateContent`,
          headers: mergedHeaders,
          body: args,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(responseSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const candidate = response.candidates[0];
        const content = [];
        const parts = (_b = (_a61 = candidate.content) == null ? void 0 : _a61.parts) != null ? _b : [];
        const usageMetadata = response.usageMetadata;
        let lastCodeExecutionToolCallId;
        for (const part of parts) {
          if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
            const toolCallId = this.config.generateId();
            lastCodeExecutionToolCallId = toolCallId;
            content.push({
              type: "tool-call",
              toolCallId,
              toolName: "code_execution",
              input: JSON.stringify(part.executableCode),
              providerExecuted: true
            });
          } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
            content.push({
              type: "tool-result",
              // Assumes a result directly follows its corresponding call part.
              toolCallId: lastCodeExecutionToolCallId,
              toolName: "code_execution",
              result: {
                outcome: part.codeExecutionResult.outcome,
                output: part.codeExecutionResult.output
              },
              providerExecuted: true
            });
            lastCodeExecutionToolCallId = void 0;
          } else if ("text" in part && part.text != null && part.text.length > 0) {
            content.push({
              type: part.thought === true ? "reasoning" : "text",
              text: part.text,
              providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
            });
          } else if ("functionCall" in part) {
            content.push({
              type: "tool-call",
              toolCallId: this.config.generateId(),
              toolName: part.functionCall.name,
              input: JSON.stringify(part.functionCall.args),
              providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
            });
          } else if ("inlineData" in part) {
            content.push({
              type: "file",
              data: part.inlineData.data,
              mediaType: part.inlineData.mimeType
            });
          }
        }
        const sources = (_d = extractSources({
          groundingMetadata: candidate.groundingMetadata,
          generateId: this.config.generateId
        })) != null ? _d : [];
        for (const source of sources) {
          content.push(source);
        }
        return {
          content,
          finishReason: mapGoogleGenerativeAIFinishReason({
            finishReason: candidate.finishReason,
            hasToolCalls: content.some((part) => part.type === "tool-call")
          }),
          usage: {
            inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
            outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
            totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
            reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
            cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
          },
          warnings,
          providerMetadata: {
            google: {
              promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
              groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
              urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
              safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
              usageMetadata: usageMetadata != null ? usageMetadata : null
            }
          },
          request: { body },
          response: {
            // TODO timestamp, model id, id
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
      async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const body = JSON.stringify(args);
        const headers = combineHeaders2(
          await resolve2(this.config.headers),
          options.headers
        );
        const { responseHeaders, value: response } = await postJsonToApi2({
          url: `${this.config.baseURL}/${getModelPath(
            this.modelId
          )}:streamGenerateContent?alt=sse`,
          headers,
          body: args,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler2(chunkSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let providerMetadata = void 0;
        const generateId32 = this.config.generateId;
        let hasToolCalls = false;
        let currentTextBlockId = null;
        let currentReasoningBlockId = null;
        let blockCounter = 0;
        const emittedSourceUrls = /* @__PURE__ */ new Set();
        let lastCodeExecutionToolCallId;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                const usageMetadata = value.usageMetadata;
                if (usageMetadata != null) {
                  usage.inputTokens = (_a61 = usageMetadata.promptTokenCount) != null ? _a61 : void 0;
                  usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                  usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                  usage.reasoningTokens = (_d = usageMetadata.thoughtsTokenCount) != null ? _d : void 0;
                  usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
                }
                const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
                if (candidate == null) {
                  return;
                }
                const content = candidate.content;
                const sources = extractSources({
                  groundingMetadata: candidate.groundingMetadata,
                  generateId: generateId32
                });
                if (sources != null) {
                  for (const source of sources) {
                    if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                      emittedSourceUrls.add(source.url);
                      controller.enqueue(source);
                    }
                  }
                }
                if (content != null) {
                  const parts = (_g = content.parts) != null ? _g : [];
                  for (const part of parts) {
                    if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                      const toolCallId = generateId32();
                      lastCodeExecutionToolCallId = toolCallId;
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId,
                        toolName: "code_execution",
                        input: JSON.stringify(part.executableCode),
                        providerExecuted: true
                      });
                      hasToolCalls = true;
                    } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                      const toolCallId = lastCodeExecutionToolCallId;
                      if (toolCallId) {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId,
                          toolName: "code_execution",
                          result: {
                            outcome: part.codeExecutionResult.outcome,
                            output: part.codeExecutionResult.output
                          },
                          providerExecuted: true
                        });
                        lastCodeExecutionToolCallId = void 0;
                      }
                    } else if ("text" in part && part.text != null && part.text.length > 0) {
                      if (part.thought === true) {
                        if (currentTextBlockId !== null) {
                          controller.enqueue({
                            type: "text-end",
                            id: currentTextBlockId
                          });
                          currentTextBlockId = null;
                        }
                        if (currentReasoningBlockId === null) {
                          currentReasoningBlockId = String(blockCounter++);
                          controller.enqueue({
                            type: "reasoning-start",
                            id: currentReasoningBlockId,
                            providerMetadata: part.thoughtSignature ? {
                              google: {
                                thoughtSignature: part.thoughtSignature
                              }
                            } : void 0
                          });
                        }
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: currentReasoningBlockId,
                          delta: part.text,
                          providerMetadata: part.thoughtSignature ? {
                            google: { thoughtSignature: part.thoughtSignature }
                          } : void 0
                        });
                      } else {
                        if (currentReasoningBlockId !== null) {
                          controller.enqueue({
                            type: "reasoning-end",
                            id: currentReasoningBlockId
                          });
                          currentReasoningBlockId = null;
                        }
                        if (currentTextBlockId === null) {
                          currentTextBlockId = String(blockCounter++);
                          controller.enqueue({
                            type: "text-start",
                            id: currentTextBlockId,
                            providerMetadata: part.thoughtSignature ? {
                              google: {
                                thoughtSignature: part.thoughtSignature
                              }
                            } : void 0
                          });
                        }
                        controller.enqueue({
                          type: "text-delta",
                          id: currentTextBlockId,
                          delta: part.text,
                          providerMetadata: part.thoughtSignature ? {
                            google: { thoughtSignature: part.thoughtSignature }
                          } : void 0
                        });
                      }
                    }
                  }
                  const inlineDataParts = getInlineDataParts(content.parts);
                  if (inlineDataParts != null) {
                    for (const part of inlineDataParts) {
                      controller.enqueue({
                        type: "file",
                        mediaType: part.inlineData.mimeType,
                        data: part.inlineData.data
                      });
                    }
                  }
                  const toolCallDeltas = getToolCallsFromParts({
                    parts: content.parts,
                    generateId: generateId32
                  });
                  if (toolCallDeltas != null) {
                    for (const toolCall of toolCallDeltas) {
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall.toolCallId,
                        delta: toolCall.args,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.toolCallId,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        input: toolCall.args,
                        providerMetadata: toolCall.providerMetadata
                      });
                      hasToolCalls = true;
                    }
                  }
                }
                if (candidate.finishReason != null) {
                  finishReason = mapGoogleGenerativeAIFinishReason({
                    finishReason: candidate.finishReason,
                    hasToolCalls
                  });
                  providerMetadata = {
                    google: {
                      promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                      groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                      urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                      safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                    }
                  };
                  if (usageMetadata != null) {
                    providerMetadata.google.usageMetadata = usageMetadata;
                  }
                }
              },
              flush(controller) {
                if (currentTextBlockId !== null) {
                  controller.enqueue({
                    type: "text-end",
                    id: currentTextBlockId
                  });
                }
                if (currentReasoningBlockId !== null) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: currentReasoningBlockId
                  });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata
                });
              }
            })
          ),
          response: { headers: responseHeaders },
          request: { body }
        };
      }
    };
    __name(getToolCallsFromParts, "getToolCallsFromParts");
    __name(getInlineDataParts, "getInlineDataParts");
    __name(extractSources, "extractSources");
    getGroundingMetadataSchema = /* @__PURE__ */ __name(() => external_exports.object({
      webSearchQueries: external_exports.array(external_exports.string()).nullish(),
      retrievalQueries: external_exports.array(external_exports.string()).nullish(),
      searchEntryPoint: external_exports.object({ renderedContent: external_exports.string() }).nullish(),
      groundingChunks: external_exports.array(
        external_exports.object({
          web: external_exports.object({ uri: external_exports.string(), title: external_exports.string().nullish() }).nullish(),
          retrievedContext: external_exports.object({
            uri: external_exports.string(),
            title: external_exports.string().nullish(),
            text: external_exports.string().nullish()
          }).nullish()
        })
      ).nullish(),
      groundingSupports: external_exports.array(
        external_exports.object({
          segment: external_exports.object({
            startIndex: external_exports.number().nullish(),
            endIndex: external_exports.number().nullish(),
            text: external_exports.string().nullish()
          }),
          segment_text: external_exports.string().nullish(),
          groundingChunkIndices: external_exports.array(external_exports.number()).nullish(),
          supportChunkIndices: external_exports.array(external_exports.number()).nullish(),
          confidenceScores: external_exports.array(external_exports.number()).nullish(),
          confidenceScore: external_exports.array(external_exports.number()).nullish()
        })
      ).nullish(),
      retrievalMetadata: external_exports.union([
        external_exports.object({
          webDynamicRetrievalScore: external_exports.number()
        }),
        external_exports.object({})
      ]).nullish()
    }), "getGroundingMetadataSchema");
    getContentSchema = /* @__PURE__ */ __name(() => external_exports.object({
      parts: external_exports.array(
        external_exports.union([
          // note: order matters since text can be fully empty
          external_exports.object({
            functionCall: external_exports.object({
              name: external_exports.string(),
              args: external_exports.unknown()
            }),
            thoughtSignature: external_exports.string().nullish()
          }),
          external_exports.object({
            inlineData: external_exports.object({
              mimeType: external_exports.string(),
              data: external_exports.string()
            })
          }),
          external_exports.object({
            executableCode: external_exports.object({
              language: external_exports.string(),
              code: external_exports.string()
            }).nullish(),
            codeExecutionResult: external_exports.object({
              outcome: external_exports.string(),
              output: external_exports.string()
            }).nullish(),
            text: external_exports.string().nullish(),
            thought: external_exports.boolean().nullish(),
            thoughtSignature: external_exports.string().nullish()
          })
        ])
      ).nullish()
    }), "getContentSchema");
    getSafetyRatingSchema = /* @__PURE__ */ __name(() => external_exports.object({
      category: external_exports.string().nullish(),
      probability: external_exports.string().nullish(),
      probabilityScore: external_exports.number().nullish(),
      severity: external_exports.string().nullish(),
      severityScore: external_exports.number().nullish(),
      blocked: external_exports.boolean().nullish()
    }), "getSafetyRatingSchema");
    usageSchema = external_exports.object({
      cachedContentTokenCount: external_exports.number().nullish(),
      thoughtsTokenCount: external_exports.number().nullish(),
      promptTokenCount: external_exports.number().nullish(),
      candidatesTokenCount: external_exports.number().nullish(),
      totalTokenCount: external_exports.number().nullish(),
      // https://cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1/GenerateContentResponse#TrafficType
      trafficType: external_exports.string().nullish()
    });
    getUrlContextMetadataSchema = /* @__PURE__ */ __name(() => external_exports.object({
      urlMetadata: external_exports.array(
        external_exports.object({
          retrievedUrl: external_exports.string(),
          urlRetrievalStatus: external_exports.string()
        })
      )
    }), "getUrlContextMetadataSchema");
    responseSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          candidates: external_exports.array(
            external_exports.object({
              content: getContentSchema().nullish().or(external_exports.object({}).strict()),
              finishReason: external_exports.string().nullish(),
              safetyRatings: external_exports.array(getSafetyRatingSchema()).nullish(),
              groundingMetadata: getGroundingMetadataSchema().nullish(),
              urlContextMetadata: getUrlContextMetadataSchema().nullish()
            })
          ),
          usageMetadata: usageSchema.nullish(),
          promptFeedback: external_exports.object({
            blockReason: external_exports.string().nullish(),
            safetyRatings: external_exports.array(getSafetyRatingSchema()).nullish()
          }).nullish()
        })
      )
    );
    chunkSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          candidates: external_exports.array(
            external_exports.object({
              content: getContentSchema().nullish(),
              finishReason: external_exports.string().nullish(),
              safetyRatings: external_exports.array(getSafetyRatingSchema()).nullish(),
              groundingMetadata: getGroundingMetadataSchema().nullish(),
              urlContextMetadata: getUrlContextMetadataSchema().nullish()
            })
          ).nullish(),
          usageMetadata: usageSchema.nullish(),
          promptFeedback: external_exports.object({
            blockReason: external_exports.string().nullish(),
            safetyRatings: external_exports.array(getSafetyRatingSchema()).nullish()
          }).nullish()
        })
      )
    );
    codeExecution = createProviderDefinedToolFactoryWithOutputSchema2({
      id: "google.code_execution",
      name: "code_execution",
      inputSchema: external_exports.object({
        language: external_exports.string().describe("The programming language of the code."),
        code: external_exports.string().describe("The code to be executed.")
      }),
      outputSchema: external_exports.object({
        outcome: external_exports.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
        output: external_exports.string().describe("The output from the code execution.")
      })
    });
    fileSearchArgsBaseSchema = external_exports.object({
      /** The names of the file_search_stores to retrieve from.
       *  Example: `fileSearchStores/my-file-search-store-123`
       */
      fileSearchStoreNames: external_exports.array(external_exports.string()).describe(
        "The names of the file_search_stores to retrieve from. Example: `fileSearchStores/my-file-search-store-123`"
      ),
      /** The number of file search retrieval chunks to retrieve. */
      topK: external_exports.number().int().positive().describe("The number of file search retrieval chunks to retrieve.").optional(),
      /** Metadata filter to apply to the file search retrieval documents.
       *  See https://google.aip.dev/160 for the syntax of the filter expression.
       */
      metadataFilter: external_exports.string().describe(
        "Metadata filter to apply to the file search retrieval documents. See https://google.aip.dev/160 for the syntax of the filter expression."
      ).optional()
    }).passthrough();
    fileSearchArgsSchema = lazySchema2(
      () => zodSchema4(fileSearchArgsBaseSchema)
    );
    fileSearch = createProviderDefinedToolFactory2({
      id: "google.file_search",
      name: "file_search",
      inputSchema: fileSearchArgsSchema
    });
    googleSearch = createProviderDefinedToolFactory2({
      id: "google.google_search",
      name: "google_search",
      inputSchema: lazySchema2(
        () => zodSchema4(
          external_exports.object({
            mode: external_exports.enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
            dynamicThreshold: external_exports.number().default(1)
          })
        )
      )
    });
    urlContext = createProviderDefinedToolFactory2({
      id: "google.url_context",
      name: "url_context",
      inputSchema: lazySchema2(() => zodSchema4(external_exports.object({})))
    });
    vertexRagStore = createProviderDefinedToolFactory2({
      id: "google.vertex_rag_store",
      name: "vertex_rag_store",
      inputSchema: external_exports.object({
        ragCorpus: external_exports.string(),
        topK: external_exports.number().optional()
      })
    });
    googleTools = {
      /**
       * Creates a Google search tool that gives Google direct access to real-time web content.
       * Must have name "google_search".
       */
      googleSearch,
      /**
       * Creates a URL context tool that gives Google direct access to real-time web content.
       * Must have name "url_context".
       */
      urlContext,
      /**
       * Enables Retrieval Augmented Generation (RAG) via the Gemini File Search tool.
       * Must have name "file_search".
       *
       * @param fileSearchStoreNames - Fully-qualified File Search store resource names.
       * @param metadataFilter - Optional filter expression to restrict the files that can be retrieved.
       * @param topK - Optional result limit for the number of chunks returned from File Search.
       *
       * @see https://ai.google.dev/gemini-api/docs/file-search
       */
      fileSearch,
      /**
       * A tool that enables the model to generate and run Python code.
       * Must have name "code_execution".
       *
       * @note Ensure the selected model supports Code Execution.
       * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
       *
       * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
       * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
       */
      codeExecution,
      /**
       * Creates a Vertex RAG Store tool that enables the model to perform RAG searches against a Vertex RAG Store.
       * Must have name "vertex_rag_store".
       */
      vertexRagStore
    };
    GoogleGenerativeAIImageModel = class {
      static {
        __name(this, "GoogleGenerativeAIImageModel");
      }
      constructor(modelId, settings, config4) {
        this.modelId = modelId;
        this.settings = settings;
        this.config = config4;
        this.specificationVersion = "v2";
      }
      get maxImagesPerCall() {
        var _a61;
        return (_a61 = this.settings.maxImagesPerCall) != null ? _a61 : 4;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate(options) {
        var _a61, _b, _c;
        const {
          prompt,
          n = 1,
          size = "1024x1024",
          aspectRatio = "1:1",
          seed,
          providerOptions,
          headers,
          abortSignal
        } = options;
        const warnings = [];
        if (size != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "size",
            details: "This model does not support the `size` option. Use `aspectRatio` instead."
          });
        }
        if (seed != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "seed",
            details: "This model does not support the `seed` option through this provider."
          });
        }
        const googleOptions = await parseProviderOptions2({
          provider: "google",
          providerOptions,
          schema: googleImageProviderOptionsSchema
        });
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const parameters = {
          sampleCount: n
        };
        if (aspectRatio != null) {
          parameters.aspectRatio = aspectRatio;
        }
        if (googleOptions) {
          Object.assign(parameters, googleOptions);
        }
        const body = {
          instances: [{ prompt }],
          parameters
        };
        const { responseHeaders, value: response } = await postJsonToApi2({
          url: `${this.config.baseURL}/models/${this.modelId}:predict`,
          headers: combineHeaders2(await resolve2(this.config.headers), headers),
          body,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            googleImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.predictions.map(
            (p) => p.bytesBase64Encoded
          ),
          warnings: warnings != null ? warnings : [],
          providerMetadata: {
            google: {
              images: response.predictions.map((prediction) => ({
                // Add any prediction-specific metadata here
              }))
            }
          },
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    googleImageResponseSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          predictions: external_exports.array(external_exports.object({ bytesBase64Encoded: external_exports.string() })).default([])
        })
      )
    );
    googleImageProviderOptionsSchema = lazySchema2(
      () => zodSchema4(
        external_exports.object({
          personGeneration: external_exports.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
          aspectRatio: external_exports.enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
        })
      )
    );
    __name(createGoogleGenerativeAI, "createGoogleGenerativeAI");
    google = createGoogleGenerativeAI();
  }
});

// node_modules/@ai-sdk/mistral-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage7(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker21, symbol29, _a29, _AISDKError11, AISDKError6, name21, marker28, symbol210, _a210, APICallError5, name28, marker38, symbol38, _a38, EmptyResponseBodyError4, name38, marker48, symbol48, _a48, InvalidArgumentError7, name48, marker58, symbol58, _a58, name58, marker68, symbol68, _a68, name68, marker78, symbol78, _a78, JSONParseError5, name78, marker88, symbol88, _a88, LoadAPIKeyError4, name88, marker98, symbol98, _a98, name98, marker108, symbol108, _a108, name108, marker118, symbol118, _a118, NoSuchModelError3, name118, marker128, symbol128, _a128, TooManyEmbeddingValuesForCallError3, name128, marker138, symbol138, _a138, _TypeValidationError9, TypeValidationError5, name138, marker148, symbol148, _a148, UnsupportedFunctionalityError5;
var init_dist9 = __esm({
  "node_modules/@ai-sdk/mistral-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker21 = "vercel.ai.error";
    symbol29 = Symbol.for(marker21);
    _AISDKError11 = class _AISDKError12 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a29] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError12.hasMarker(error87, marker21);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a29 = symbol29;
    AISDKError6 = _AISDKError11;
    name21 = "AI_APICallError";
    marker28 = `vercel.ai.error.${name21}`;
    symbol210 = Symbol.for(marker28);
    APICallError5 = class extends AISDKError6 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name21, message, cause });
        this[_a210] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker28);
      }
    };
    _a210 = symbol210;
    name28 = "AI_EmptyResponseBodyError";
    marker38 = `vercel.ai.error.${name28}`;
    symbol38 = Symbol.for(marker38);
    EmptyResponseBodyError4 = class extends AISDKError6 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name28, message });
        this[_a38] = true;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker38);
      }
    };
    _a38 = symbol38;
    __name(getErrorMessage7, "getErrorMessage");
    name38 = "AI_InvalidArgumentError";
    marker48 = `vercel.ai.error.${name38}`;
    symbol48 = Symbol.for(marker48);
    InvalidArgumentError7 = class extends AISDKError6 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name38, message, cause });
        this[_a48] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker48);
      }
    };
    _a48 = symbol48;
    name48 = "AI_InvalidPromptError";
    marker58 = `vercel.ai.error.${name48}`;
    symbol58 = Symbol.for(marker58);
    _a58 = symbol58;
    name58 = "AI_InvalidResponseDataError";
    marker68 = `vercel.ai.error.${name58}`;
    symbol68 = Symbol.for(marker68);
    _a68 = symbol68;
    name68 = "AI_JSONParseError";
    marker78 = `vercel.ai.error.${name68}`;
    symbol78 = Symbol.for(marker78);
    JSONParseError5 = class extends AISDKError6 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name68,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage7(cause)}`,
          cause
        });
        this[_a78] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker78);
      }
    };
    _a78 = symbol78;
    name78 = "AI_LoadAPIKeyError";
    marker88 = `vercel.ai.error.${name78}`;
    symbol88 = Symbol.for(marker88);
    LoadAPIKeyError4 = class extends AISDKError6 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name78, message });
        this[_a88] = true;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker88);
      }
    };
    _a88 = symbol88;
    name88 = "AI_LoadSettingError";
    marker98 = `vercel.ai.error.${name88}`;
    symbol98 = Symbol.for(marker98);
    _a98 = symbol98;
    name98 = "AI_NoContentGeneratedError";
    marker108 = `vercel.ai.error.${name98}`;
    symbol108 = Symbol.for(marker108);
    _a108 = symbol108;
    name108 = "AI_NoSuchModelError";
    marker118 = `vercel.ai.error.${name108}`;
    symbol118 = Symbol.for(marker118);
    NoSuchModelError3 = class extends AISDKError6 {
      static {
        __name(this, "NoSuchModelError");
      }
      constructor({
        errorName = name108,
        modelId,
        modelType,
        message = `No such ${modelType}: ${modelId}`
      }) {
        super({ name: errorName, message });
        this[_a118] = true;
        this.modelId = modelId;
        this.modelType = modelType;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker118);
      }
    };
    _a118 = symbol118;
    name118 = "AI_TooManyEmbeddingValuesForCallError";
    marker128 = `vercel.ai.error.${name118}`;
    symbol128 = Symbol.for(marker128);
    TooManyEmbeddingValuesForCallError3 = class extends AISDKError6 {
      static {
        __name(this, "TooManyEmbeddingValuesForCallError");
      }
      constructor(options) {
        super({
          name: name118,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a128] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker128);
      }
    };
    _a128 = symbol128;
    name128 = "AI_TypeValidationError";
    marker138 = `vercel.ai.error.${name128}`;
    symbol138 = Symbol.for(marker138);
    _TypeValidationError9 = class _TypeValidationError10 extends AISDKError6 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name128,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage7(cause)}`,
          cause
        });
        this[_a138] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker138);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError10.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError10({ value, cause });
      }
    };
    _a138 = symbol138;
    TypeValidationError5 = _TypeValidationError9;
    name138 = "AI_UnsupportedFunctionalityError";
    marker148 = `vercel.ai.error.${name138}`;
    symbol148 = Symbol.for(marker148);
    UnsupportedFunctionalityError5 = class extends AISDKError6 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name138, message });
        this[_a148] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError6.hasMarker(error87, marker148);
      }
    };
    _a148 = symbol148;
  }
});

// node_modules/@ai-sdk/mistral-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders3(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders3(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError6(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError3({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError6(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES3.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError5({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent3(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders2(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix4(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders2(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
function injectJsonInstruction3({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX3 : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX3 : DEFAULT_GENERIC_SUFFIX3
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
function injectJsonInstructionIntoMessages2({
  messages,
  schema,
  schemaPrefix,
  schemaSuffix
}) {
  var _a61, _b;
  const systemMessage = ((_a61 = messages[0]) == null ? void 0 : _a61.role) === "system" ? { ...messages[0] } : { role: "system", content: "" };
  systemMessage.content = injectJsonInstruction3({
    prompt: systemMessage.content,
    schema,
    schemaPrefix,
    schemaSuffix
  });
  return [
    systemMessage,
    ...((_b = messages[0]) == null ? void 0 : _b.role) === "system" ? messages.slice(1) : messages
  ];
}
function loadApiKey3({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError4({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError4({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError4({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError4({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse6(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx4.test(text3) === false && suspectConstructorRx4.test(text3) === false) {
    return obj;
  }
  return filter4(obj);
}
function filter4(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse4(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse6(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator5(validate) {
  return { [validatorSymbol6]: true, validate };
}
function isValidator5(value) {
  return typeof value === "object" && value !== null && validatorSymbol6 in value && value[validatorSymbol6] === true && "validate" in value;
}
function asValidator5(value) {
  return isValidator5(value) ? value : typeof value === "function" ? value() : standardSchemaValidator4(value);
}
function standardSchemaValidator4(standardSchema) {
  return validator5(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError5({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes4({
  value,
  schema
}) {
  const result = await safeValidateTypes5({ value, schema });
  if (!result.success) {
    throw TypeValidationError5.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes5({
  value,
  schema
}) {
  const validator22 = asValidator5(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError5.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError5.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON3({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse4(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes4({ value, schema });
  } catch (error87) {
    if (JSONParseError5.isInstance(error87) || TypeValidationError5.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError5({ text: text3, cause: error87 });
  }
}
async function safeParseJSON5({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse4(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes5({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError5.isInstance(error87) ? error87 : new JSONParseError5({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream4({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON5({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions3({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes5({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError7({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function convertUint8ArrayToBase645(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa7(latin1string);
}
function convertToBase643(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase645(value) : value;
}
function withoutTrailingSlash3(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator6, generateId6, FETCH_FAILED_ERROR_MESSAGES3, VERSION5, DEFAULT_SCHEMA_PREFIX3, DEFAULT_SCHEMA_SUFFIX3, DEFAULT_GENERIC_SUFFIX3, suspectProtoRx4, suspectConstructorRx4, validatorSymbol6, getOriginalFetch23, postJsonToApi3, postToApi3, createJsonErrorResponseHandler3, createEventSourceResponseHandler3, createJsonResponseHandler3, ignoreOverride6, ALPHA_NUMERIC6, schemaSymbol6, btoa7, atob7;
var init_dist10 = __esm({
  "node_modules/@ai-sdk/mistral-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist9();
    init_dist9();
    init_dist9();
    init_dist9();
    init_dist9();
    init_dist9();
    init_stream();
    init_dist9();
    init_dist9();
    init_dist9();
    init_dist2();
    __name(combineHeaders3, "combineHeaders");
    __name(extractResponseHeaders3, "extractResponseHeaders");
    createIdGenerator6 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError7({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId6 = createIdGenerator6();
    __name(isAbortError6, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES3 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError3, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent3, "getRuntimeEnvironmentUserAgent");
    __name(normalizeHeaders2, "normalizeHeaders");
    __name(withUserAgentSuffix4, "withUserAgentSuffix");
    VERSION5 = true ? "3.0.16" : "0.0.0-test";
    DEFAULT_SCHEMA_PREFIX3 = "JSON schema:";
    DEFAULT_SCHEMA_SUFFIX3 = "You MUST answer with a JSON object that matches the JSON schema above.";
    DEFAULT_GENERIC_SUFFIX3 = "You MUST answer with JSON.";
    __name(injectJsonInstruction3, "injectJsonInstruction");
    __name(injectJsonInstructionIntoMessages2, "injectJsonInstructionIntoMessages");
    __name(loadApiKey3, "loadApiKey");
    suspectProtoRx4 = /"__proto__"\s*:/;
    suspectConstructorRx4 = /"constructor"\s*:/;
    __name(_parse6, "_parse");
    __name(filter4, "filter");
    __name(secureJsonParse4, "secureJsonParse");
    validatorSymbol6 = Symbol.for("vercel.ai.validator");
    __name(validator5, "validator");
    __name(isValidator5, "isValidator");
    __name(asValidator5, "asValidator");
    __name(standardSchemaValidator4, "standardSchemaValidator");
    __name(validateTypes4, "validateTypes");
    __name(safeValidateTypes5, "safeValidateTypes");
    __name(parseJSON3, "parseJSON");
    __name(safeParseJSON5, "safeParseJSON");
    __name(parseJsonEventStream4, "parseJsonEventStream");
    __name(parseProviderOptions3, "parseProviderOptions");
    getOriginalFetch23 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi3 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi3({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi3 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch23()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix4(
            headers,
            `ai-sdk/provider-utils/${VERSION5}`,
            getRuntimeEnvironmentUserAgent3()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders3(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError6(error87) || APICallError5.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError5({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError6(error87) || APICallError5.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError5({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError3({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    createJsonErrorResponseHandler3 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders3(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError5({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON3({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError5({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError5({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler3 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders3(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError4({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream4({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler3 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON5({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders3(response);
      if (!parsedResult.success) {
        throw new APICallError5({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    ignoreOverride6 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    ALPHA_NUMERIC6 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    schemaSymbol6 = Symbol.for("vercel.ai.schema");
    ({ btoa: btoa7, atob: atob7 } = globalThis);
    __name(convertUint8ArrayToBase645, "convertUint8ArrayToBase64");
    __name(convertToBase643, "convertToBase64");
    __name(withoutTrailingSlash3, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/mistral-v5/dist/index.mjs
function convertToMistralChatMessages(prompt) {
  const messages = [];
  for (let i = 0; i < prompt.length; i++) {
    const { role, content } = prompt[i];
    const isLastMessage = i === prompt.length - 1;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase643(part.data)}`
                  };
                } else if (part.mediaType === "application/pdf") {
                  return {
                    type: "document_url",
                    document_url: part.data.toString()
                  };
                } else {
                  throw new UnsupportedFunctionalityError5({
                    functionality: "Only images and PDF file parts are supported"
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text3 = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text3 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              text3 += part.text;
              break;
            }
            default: {
              throw new Error(
                `Unsupported content type in assistant message: ${part.type}`
              );
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text3,
          prefix: isLastMessage ? true : void 0,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            name: toolResponse.toolName,
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapMistralFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
    case "model_length":
      return "length";
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function prepareTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const mistralTools = [];
  for (const tool5 of tools) {
    if (tool5.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
    } else {
      mistralTools.push({
        type: "function",
        function: {
          name: tool5.name,
          description: tool5.description,
          parameters: tool5.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: mistralTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: mistralTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: mistralTools, toolChoice: "any", toolWarnings };
    // mistral does not support tool mode directly,
    // so we filter the tools and force the tool choice through 'any'
    case "tool":
      return {
        tools: mistralTools.filter(
          (tool5) => tool5.function.name === toolChoice.toolName
        ),
        toolChoice: "any",
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError5({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function extractReasoningContent(thinking) {
  return thinking.filter((chunk) => chunk.type === "text").map((chunk) => chunk.text).join("");
}
function extractTextContent(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content == null) {
    return void 0;
  }
  const textContent = [];
  for (const chunk of content) {
    const { type } = chunk;
    switch (type) {
      case "text":
        textContent.push(chunk.text);
        break;
      case "thinking":
      case "image_url":
      case "reference":
        break;
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  return textContent.length ? textContent.join("") : void 0;
}
function createMistral(options = {}) {
  var _a61;
  const baseURL = (_a61 = withoutTrailingSlash3(options.baseURL)) != null ? _a61 : "https://api.mistral.ai/v1";
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix4(
    {
      Authorization: `Bearer ${loadApiKey3({
        apiKey: options.apiKey,
        environmentVariableName: "MISTRAL_API_KEY",
        description: "Mistral"
      })}`,
      ...options.headers
    },
    `ai-sdk/mistral/${VERSION6}`
  ), "getHeaders");
  const createChatModel = /* @__PURE__ */ __name((modelId) => new MistralChatLanguageModel(modelId, {
    provider: "mistral.chat",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch,
    generateId: options.generateId
  }), "createChatModel");
  const createEmbeddingModel = /* @__PURE__ */ __name((modelId) => new MistralEmbeddingModel(modelId, {
    provider: "mistral.embedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), "createEmbeddingModel");
  const provider = /* @__PURE__ */ __name(function(modelId) {
    if (new.target) {
      throw new Error(
        "The Mistral model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  }, "provider");
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError3({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var mistralLanguageModelOptions, mistralErrorDataSchema, mistralFailedResponseHandler, MistralChatLanguageModel, mistralContentSchema, mistralUsageSchema, mistralChatResponseSchema, mistralChatChunkSchema, MistralEmbeddingModel, MistralTextEmbeddingResponseSchema, VERSION6, mistral;
var init_dist11 = __esm({
  "node_modules/@ai-sdk/mistral-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist9();
    init_dist10();
    init_dist10();
    init_v4();
    init_dist9();
    init_dist10();
    init_v4();
    init_dist10();
    init_v4();
    init_dist9();
    init_dist9();
    init_dist10();
    init_v4();
    __name(convertToMistralChatMessages, "convertToMistralChatMessages");
    __name(getResponseMetadata, "getResponseMetadata");
    __name(mapMistralFinishReason, "mapMistralFinishReason");
    mistralLanguageModelOptions = external_exports.object({
      /**
      Whether to inject a safety prompt before all conversations.
      
      Defaults to `false`.
         */
      safePrompt: external_exports.boolean().optional(),
      documentImageLimit: external_exports.number().optional(),
      documentPageLimit: external_exports.number().optional(),
      /**
       * Whether to use structured outputs.
       *
       * @default true
       */
      structuredOutputs: external_exports.boolean().optional(),
      /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */
      strictJsonSchema: external_exports.boolean().optional(),
      /**
       * Whether to enable parallel function calling during tool use.
       * When set to false, the model will use at most one tool per response.
       *
       * @default true
       */
      parallelToolCalls: external_exports.boolean().optional()
    });
    mistralErrorDataSchema = external_exports.object({
      object: external_exports.literal("error"),
      message: external_exports.string(),
      type: external_exports.string(),
      param: external_exports.string().nullable(),
      code: external_exports.string().nullable()
    });
    mistralFailedResponseHandler = createJsonErrorResponseHandler3({
      errorSchema: mistralErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.message, "errorToMessage")
    });
    __name(prepareTools3, "prepareTools");
    MistralChatLanguageModel = class {
      static {
        __name(this, "MistralChatLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.supportedUrls = {
          "application/pdf": [/^https:\/\/.*$/]
        };
        var _a61;
        this.modelId = modelId;
        this.config = config4;
        this.generateId = (_a61 = config4.generateId) != null ? _a61 : generateId6;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        const options = (_a61 = await parseProviderOptions3({
          provider: "mistral",
          providerOptions,
          schema: mistralLanguageModelOptions
        })) != null ? _a61 : {};
        if (topK != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "topK"
          });
        }
        if (frequencyPenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty"
          });
        }
        if (presencePenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty"
          });
        }
        if (stopSequences != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "stopSequences"
          });
        }
        const structuredOutputs = (_b = options.structuredOutputs) != null ? _b : true;
        const strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : false;
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema)) {
          prompt = injectJsonInstructionIntoMessages2({
            messages: prompt,
            schema: responseFormat.schema
          });
        }
        const baseArgs = {
          // model id:
          model: this.modelId,
          // model specific settings:
          safe_prompt: options.safePrompt,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          random_seed: seed,
          // response format:
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
            type: "json_schema",
            json_schema: {
              schema: responseFormat.schema,
              strict: strictJsonSchema,
              name: (_d = responseFormat.name) != null ? _d : "response",
              description: responseFormat.description
            }
          } : { type: "json_object" } : void 0,
          // mistral-specific provider options:
          document_image_limit: options.documentImageLimit,
          document_page_limit: options.documentPageLimit,
          // messages:
          messages: convertToMistralChatMessages(prompt)
        };
        const {
          tools: mistralTools,
          toolChoice: mistralToolChoice,
          toolWarnings
        } = prepareTools3({
          tools,
          toolChoice
        });
        return {
          args: {
            ...baseArgs,
            tools: mistralTools,
            tool_choice: mistralToolChoice,
            ...mistralTools != null && options.parallelToolCalls !== void 0 ? { parallel_tool_calls: options.parallelToolCalls } : {}
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        const { args: body, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi3({
          url: `${this.config.baseURL}/chat/completions`,
          headers: combineHeaders3(this.config.headers(), options.headers),
          body,
          failedResponseHandler: mistralFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler3(
            mistralChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = response.choices[0];
        const content = [];
        if (choice.message.content != null && Array.isArray(choice.message.content)) {
          for (const part of choice.message.content) {
            if (part.type === "thinking") {
              const reasoningText = extractReasoningContent(part.thinking);
              if (reasoningText.length > 0) {
                content.push({ type: "reasoning", text: reasoningText });
              }
            } else if (part.type === "text") {
              if (part.text.length > 0) {
                content.push({ type: "text", text: part.text });
              }
            }
          }
        } else {
          const text3 = extractTextContent(choice.message.content);
          if (text3 != null && text3.length > 0) {
            content.push({ type: "text", text: text3 });
          }
        }
        if (choice.message.tool_calls != null) {
          for (const toolCall of choice.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        return {
          content,
          finishReason: mapMistralFinishReason(choice.finish_reason),
          usage: {
            inputTokens: response.usage.prompt_tokens,
            outputTokens: response.usage.completion_tokens,
            totalTokens: response.usage.total_tokens
          },
          request: { body },
          response: {
            ...getResponseMetadata(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const body = { ...args, stream: true };
        const { responseHeaders, value: response } = await postJsonToApi3({
          url: `${this.config.baseURL}/chat/completions`,
          headers: combineHeaders3(this.config.headers(), options.headers),
          body,
          failedResponseHandler: mistralFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler3(
            mistralChatChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let isFirstChunk = true;
        let activeText = false;
        let activeReasoningId = null;
        const generateId22 = this.generateId;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata(value)
                  });
                }
                if (value.usage != null) {
                  usage.inputTokens = value.usage.prompt_tokens;
                  usage.outputTokens = value.usage.completion_tokens;
                  usage.totalTokens = value.usage.total_tokens;
                }
                const choice = value.choices[0];
                const delta = choice.delta;
                const textContent = extractTextContent(delta.content);
                if (delta.content != null && Array.isArray(delta.content)) {
                  for (const part of delta.content) {
                    if (part.type === "thinking") {
                      const reasoningDelta = extractReasoningContent(part.thinking);
                      if (reasoningDelta.length > 0) {
                        if (activeReasoningId == null) {
                          if (activeText) {
                            controller.enqueue({ type: "text-end", id: "0" });
                            activeText = false;
                          }
                          activeReasoningId = generateId22();
                          controller.enqueue({
                            type: "reasoning-start",
                            id: activeReasoningId
                          });
                        }
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: activeReasoningId,
                          delta: reasoningDelta
                        });
                      }
                    }
                  }
                }
                if (textContent != null && textContent.length > 0) {
                  if (!activeText) {
                    if (activeReasoningId != null) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: activeReasoningId
                      });
                      activeReasoningId = null;
                    }
                    controller.enqueue({ type: "text-start", id: "0" });
                    activeText = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: textContent
                  });
                }
                if ((delta == null ? void 0 : delta.tool_calls) != null) {
                  for (const toolCall of delta.tool_calls) {
                    const toolCallId = toolCall.id;
                    const toolName = toolCall.function.name;
                    const input = toolCall.function.arguments;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallId,
                      toolName
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCallId,
                      delta: input
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName,
                      input
                    });
                  }
                }
                if (choice.finish_reason != null) {
                  finishReason = mapMistralFinishReason(choice.finish_reason);
                }
              },
              flush(controller) {
                if (activeReasoningId != null) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: activeReasoningId
                  });
                }
                if (activeText) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    __name(extractReasoningContent, "extractReasoningContent");
    __name(extractTextContent, "extractTextContent");
    mistralContentSchema = external_exports.union([
      external_exports.string(),
      external_exports.array(
        external_exports.discriminatedUnion("type", [
          external_exports.object({
            type: external_exports.literal("text"),
            text: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("image_url"),
            image_url: external_exports.union([
              external_exports.string(),
              external_exports.object({
                url: external_exports.string(),
                detail: external_exports.string().nullable()
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("reference"),
            reference_ids: external_exports.array(external_exports.number())
          }),
          external_exports.object({
            type: external_exports.literal("thinking"),
            thinking: external_exports.array(
              external_exports.object({
                type: external_exports.literal("text"),
                text: external_exports.string()
              })
            )
          })
        ])
      )
    ]).nullish();
    mistralUsageSchema = external_exports.object({
      prompt_tokens: external_exports.number(),
      completion_tokens: external_exports.number(),
      total_tokens: external_exports.number()
    });
    mistralChatResponseSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          message: external_exports.object({
            role: external_exports.literal("assistant"),
            content: mistralContentSchema,
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string(),
                function: external_exports.object({ name: external_exports.string(), arguments: external_exports.string() })
              })
            ).nullish()
          }),
          index: external_exports.number(),
          finish_reason: external_exports.string().nullish()
        })
      ),
      object: external_exports.literal("chat.completion"),
      usage: mistralUsageSchema
    });
    mistralChatChunkSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          delta: external_exports.object({
            role: external_exports.enum(["assistant"]).optional(),
            content: mistralContentSchema,
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string(),
                function: external_exports.object({ name: external_exports.string(), arguments: external_exports.string() })
              })
            ).nullish()
          }),
          finish_reason: external_exports.string().nullish(),
          index: external_exports.number()
        })
      ),
      usage: mistralUsageSchema.nullish()
    });
    MistralEmbeddingModel = class {
      static {
        __name(this, "MistralEmbeddingModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 32;
        this.supportsParallelCalls = false;
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        abortSignal,
        headers
      }) {
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError3({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi3({
          url: `${this.config.baseURL}/embeddings`,
          headers: combineHeaders3(this.config.headers(), headers),
          body: {
            model: this.modelId,
            input: values,
            encoding_format: "float"
          },
          failedResponseHandler: mistralFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler3(
            MistralTextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: response.data.map((item) => item.embedding),
          usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    MistralTextEmbeddingResponseSchema = external_exports.object({
      data: external_exports.array(external_exports.object({ embedding: external_exports.array(external_exports.number()) })),
      usage: external_exports.object({ prompt_tokens: external_exports.number() }).nullish()
    });
    VERSION6 = true ? "2.0.23" : "0.0.0-test";
    __name(createMistral, "createMistral");
    mistral = createMistral();
  }
});

// node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage8(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker29, symbol30, _a30, _AISDKError13, AISDKError7, name29, marker210, symbol211, _a211, APICallError6, name210, marker39, symbol39, _a39, EmptyResponseBodyError5, name39, marker49, symbol49, _a49, InvalidArgumentError8, name49, marker59, symbol59, _a59, InvalidPromptError3, name59, marker69, symbol69, _a69, InvalidResponseDataError2, name69, marker79, symbol79, _a79, JSONParseError6, name79, marker89, symbol89, _a89, name89, marker99, symbol99, _a99, name99, marker109, symbol109, _a109, name109, marker119, symbol119, _a119, name119, marker129, symbol129, _a129, TooManyEmbeddingValuesForCallError4, name129, marker139, symbol139, _a139, _TypeValidationError11, TypeValidationError6, name139, marker149, symbol149, _a149, UnsupportedFunctionalityError6;
var init_dist12 = __esm({
  "node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker29 = "vercel.ai.error";
    symbol30 = Symbol.for(marker29);
    _AISDKError13 = class _AISDKError14 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a30] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError14.hasMarker(error87, marker29);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a30 = symbol30;
    AISDKError7 = _AISDKError13;
    name29 = "AI_APICallError";
    marker210 = `vercel.ai.error.${name29}`;
    symbol211 = Symbol.for(marker210);
    APICallError6 = class extends AISDKError7 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name29, message, cause });
        this[_a211] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker210);
      }
    };
    _a211 = symbol211;
    name210 = "AI_EmptyResponseBodyError";
    marker39 = `vercel.ai.error.${name210}`;
    symbol39 = Symbol.for(marker39);
    EmptyResponseBodyError5 = class extends AISDKError7 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name210, message });
        this[_a39] = true;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker39);
      }
    };
    _a39 = symbol39;
    __name(getErrorMessage8, "getErrorMessage");
    name39 = "AI_InvalidArgumentError";
    marker49 = `vercel.ai.error.${name39}`;
    symbol49 = Symbol.for(marker49);
    InvalidArgumentError8 = class extends AISDKError7 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name39, message, cause });
        this[_a49] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker49);
      }
    };
    _a49 = symbol49;
    name49 = "AI_InvalidPromptError";
    marker59 = `vercel.ai.error.${name49}`;
    symbol59 = Symbol.for(marker59);
    InvalidPromptError3 = class extends AISDKError7 {
      static {
        __name(this, "InvalidPromptError");
      }
      constructor({
        prompt,
        message,
        cause
      }) {
        super({ name: name49, message: `Invalid prompt: ${message}`, cause });
        this[_a59] = true;
        this.prompt = prompt;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker59);
      }
    };
    _a59 = symbol59;
    name59 = "AI_InvalidResponseDataError";
    marker69 = `vercel.ai.error.${name59}`;
    symbol69 = Symbol.for(marker69);
    InvalidResponseDataError2 = class extends AISDKError7 {
      static {
        __name(this, "InvalidResponseDataError");
      }
      constructor({
        data,
        message = `Invalid response data: ${JSON.stringify(data)}.`
      }) {
        super({ name: name59, message });
        this[_a69] = true;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker69);
      }
    };
    _a69 = symbol69;
    name69 = "AI_JSONParseError";
    marker79 = `vercel.ai.error.${name69}`;
    symbol79 = Symbol.for(marker79);
    JSONParseError6 = class extends AISDKError7 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name69,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage8(cause)}`,
          cause
        });
        this[_a79] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker79);
      }
    };
    _a79 = symbol79;
    name79 = "AI_LoadAPIKeyError";
    marker89 = `vercel.ai.error.${name79}`;
    symbol89 = Symbol.for(marker89);
    _a89 = symbol89;
    name89 = "AI_LoadSettingError";
    marker99 = `vercel.ai.error.${name89}`;
    symbol99 = Symbol.for(marker99);
    _a99 = symbol99;
    name99 = "AI_NoContentGeneratedError";
    marker109 = `vercel.ai.error.${name99}`;
    symbol109 = Symbol.for(marker109);
    _a109 = symbol109;
    name109 = "AI_NoSuchModelError";
    marker119 = `vercel.ai.error.${name109}`;
    symbol119 = Symbol.for(marker119);
    _a119 = symbol119;
    name119 = "AI_TooManyEmbeddingValuesForCallError";
    marker129 = `vercel.ai.error.${name119}`;
    symbol129 = Symbol.for(marker129);
    TooManyEmbeddingValuesForCallError4 = class extends AISDKError7 {
      static {
        __name(this, "TooManyEmbeddingValuesForCallError");
      }
      constructor(options) {
        super({
          name: name119,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a129] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker129);
      }
    };
    _a129 = symbol129;
    name129 = "AI_TypeValidationError";
    marker139 = `vercel.ai.error.${name129}`;
    symbol139 = Symbol.for(marker139);
    _TypeValidationError11 = class _TypeValidationError12 extends AISDKError7 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name129,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage8(cause)}`,
          cause
        });
        this[_a139] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker139);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError12.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError12({ value, cause });
      }
    };
    _a139 = symbol139;
    TypeValidationError6 = _TypeValidationError11;
    name139 = "AI_UnsupportedFunctionalityError";
    marker149 = `vercel.ai.error.${name139}`;
    symbol149 = Symbol.for(marker149);
    UnsupportedFunctionalityError6 = class extends AISDKError7 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name139, message });
        this[_a149] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError7.hasMarker(error87, marker149);
      }
    };
    _a149 = symbol149;
  }
});

// node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders4(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders4(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError7(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError4({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError7(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES4.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError6({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent4(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries2(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix5(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries2(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
function _parse7(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx5.test(text3) === false && suspectConstructorRx5.test(text3) === false) {
    return obj;
  }
  return filter5(obj);
}
function filter5(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse5(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse7(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator6(validate) {
  return { [validatorSymbol7]: true, validate };
}
function isValidator6(value) {
  return typeof value === "object" && value !== null && validatorSymbol7 in value && value[validatorSymbol7] === true && "validate" in value;
}
function asValidator6(value) {
  return isValidator6(value) ? value : typeof value === "function" ? value() : standardSchemaValidator5(value);
}
function standardSchemaValidator5(standardSchema) {
  return validator6(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError6({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes5({
  value,
  schema
}) {
  const result = await safeValidateTypes6({ value, schema });
  if (!result.success) {
    throw TypeValidationError6.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes6({
  value,
  schema
}) {
  const validator22 = asValidator6(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError6.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError6.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON4({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse5(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes5({ value, schema });
  } catch (error87) {
    if (JSONParseError6.isInstance(error87) || TypeValidationError6.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError6({ text: text3, cause: error87 });
  }
}
async function safeParseJSON6({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse5(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes6({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError6.isInstance(error87) ? error87 : new JSONParseError6({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function isParsableJson(input) {
  try {
    secureJsonParse5(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream5({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON6({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions4({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes6({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError8({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function convertUint8ArrayToBase646(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa8(latin1string);
}
function convertToBase644(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase646(value) : value;
}
function withoutTrailingSlash4(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator7, generateId7, FETCH_FAILED_ERROR_MESSAGES4, VERSION7, suspectProtoRx5, suspectConstructorRx5, validatorSymbol7, getOriginalFetch24, postJsonToApi4, postToApi4, createJsonErrorResponseHandler4, createEventSourceResponseHandler4, createJsonResponseHandler4, ignoreOverride7, ALPHA_NUMERIC7, schemaSymbol7, btoa8, atob8;
var init_dist13 = __esm({
  "node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist12();
    init_dist12();
    init_dist12();
    init_dist12();
    init_dist12();
    init_stream();
    init_dist12();
    init_dist12();
    init_dist12();
    init_dist2();
    __name(combineHeaders4, "combineHeaders");
    __name(extractResponseHeaders4, "extractResponseHeaders");
    createIdGenerator7 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError8({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId7 = createIdGenerator7();
    __name(isAbortError7, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES4 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError4, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent4, "getRuntimeEnvironmentUserAgent");
    __name(removeUndefinedEntries2, "removeUndefinedEntries");
    __name(withUserAgentSuffix5, "withUserAgentSuffix");
    VERSION7 = true ? "3.0.12" : "0.0.0-test";
    suspectProtoRx5 = /"__proto__"\s*:/;
    suspectConstructorRx5 = /"constructor"\s*:/;
    __name(_parse7, "_parse");
    __name(filter5, "filter");
    __name(secureJsonParse5, "secureJsonParse");
    validatorSymbol7 = Symbol.for("vercel.ai.validator");
    __name(validator6, "validator");
    __name(isValidator6, "isValidator");
    __name(asValidator6, "asValidator");
    __name(standardSchemaValidator5, "standardSchemaValidator");
    __name(validateTypes5, "validateTypes");
    __name(safeValidateTypes6, "safeValidateTypes");
    __name(parseJSON4, "parseJSON");
    __name(safeParseJSON6, "safeParseJSON");
    __name(isParsableJson, "isParsableJson");
    __name(parseJsonEventStream5, "parseJsonEventStream");
    __name(parseProviderOptions4, "parseProviderOptions");
    getOriginalFetch24 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi4 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi4({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi4 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch24()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix5(
            headers,
            `ai-sdk/provider-utils/${VERSION7}`,
            getRuntimeEnvironmentUserAgent4()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders4(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError7(error87) || APICallError6.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError6({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError7(error87) || APICallError6.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError6({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError4({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    createJsonErrorResponseHandler4 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders4(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError6({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON4({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError6({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError6({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler4 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders4(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError5({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream5({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler4 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON6({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders4(response);
      if (!parsedResult.success) {
        throw new APICallError6({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    ignoreOverride7 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    ALPHA_NUMERIC7 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    schemaSymbol7 = Symbol.for("vercel.ai.schema");
    ({ btoa: btoa8, atob: atob8 } = globalThis);
    __name(convertUint8ArrayToBase646, "convertUint8ArrayToBase64");
    __name(convertToBase644, "convertToBase64");
    __name(withoutTrailingSlash4, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/openai-compatible-v5/dist/index.mjs
function getOpenAIMetadata(message) {
  var _a61, _b;
  return (_b = (_a61 = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a61.openaiCompatible) != null ? _b : {};
}
function convertToOpenAICompatibleChatMessages(prompt) {
  const messages = [];
  for (const { role, content, ...message } of prompt) {
    const metadata = getOpenAIMetadata({ ...message });
    switch (role) {
      case "system": {
        messages.push({ role: "system", content, ...metadata });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({
            role: "user",
            content: content[0].text,
            ...getOpenAIMetadata(content[0])
          });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            const partMetadata = getOpenAIMetadata(part);
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text, ...partMetadata };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase644(part.data)}`
                    },
                    ...partMetadata
                  };
                } else {
                  throw new UnsupportedFunctionalityError6({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          }),
          ...metadata
        });
        break;
      }
      case "assistant": {
        let text3 = "";
        const toolCalls = [];
        for (const part of content) {
          const partMetadata = getOpenAIMetadata(part);
          switch (part.type) {
            case "text": {
              text3 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                },
                ...partMetadata
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text3,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          ...metadata
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          const toolResponseMetadata = getOpenAIMetadata(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue,
            ...toolResponseMetadata
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function prepareTools4({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiCompatTools = [];
  for (const tool5 of tools) {
    if (tool5.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
    } else {
      openaiCompatTools.push({
        type: "function",
        function: {
          name: tool5.name,
          description: tool5.description,
          parameters: tool5.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiCompatTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiCompatTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError6({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function convertToOpenAICompatibleCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text3 = "";
  if (prompt[0].role === "system") {
    text3 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError3({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text3 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError6({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text3 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError6({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text3 += `${assistant}:
`;
  return {
    prompt: text3,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata22({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function createOpenAICompatible(options) {
  const baseURL = withoutTrailingSlash4(options.baseURL);
  const providerName = options.name;
  const headers = {
    ...options.apiKey && { Authorization: `Bearer ${options.apiKey}` },
    ...options.headers
  };
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix5(headers, `ai-sdk/openai-compatible/${VERSION8}`), "getHeaders");
  const getCommonModelConfig = /* @__PURE__ */ __name((modelType) => ({
    provider: `${providerName}.${modelType}`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => {
      const url3 = new URL(`${baseURL}${path3}`);
      if (options.queryParams) {
        url3.search = new URLSearchParams(options.queryParams).toString();
      }
      return url3.toString();
    }, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "getCommonModelConfig");
  const createLanguageModel = /* @__PURE__ */ __name((modelId) => createChatModel(modelId), "createLanguageModel");
  const createChatModel = /* @__PURE__ */ __name((modelId) => new OpenAICompatibleChatLanguageModel(modelId, {
    ...getCommonModelConfig("chat"),
    includeUsage: options.includeUsage,
    supportsStructuredOutputs: options.supportsStructuredOutputs
  }), "createChatModel");
  const createCompletionModel = /* @__PURE__ */ __name((modelId) => new OpenAICompatibleCompletionLanguageModel(modelId, {
    ...getCommonModelConfig("completion"),
    includeUsage: options.includeUsage
  }), "createCompletionModel");
  const createEmbeddingModel = /* @__PURE__ */ __name((modelId) => new OpenAICompatibleEmbeddingModel(modelId, {
    ...getCommonModelConfig("embedding")
  }), "createEmbeddingModel");
  const createImageModel = /* @__PURE__ */ __name((modelId) => new OpenAICompatibleImageModel(modelId, getCommonModelConfig("image")), "createImageModel");
  const provider = /* @__PURE__ */ __name((modelId) => createLanguageModel(modelId), "provider");
  provider.languageModel = createLanguageModel;
  provider.chatModel = createChatModel;
  provider.completionModel = createCompletionModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = createImageModel;
  return provider;
}
var openaiCompatibleProviderOptions, openaiCompatibleErrorDataSchema, defaultOpenAICompatibleErrorStructure, OpenAICompatibleChatLanguageModel, openaiCompatibleTokenUsageSchema, OpenAICompatibleChatResponseSchema, createOpenAICompatibleChatChunkSchema, openaiCompatibleCompletionProviderOptions, OpenAICompatibleCompletionLanguageModel, usageSchema2, openaiCompatibleCompletionResponseSchema, createOpenAICompatibleCompletionChunkSchema, openaiCompatibleEmbeddingProviderOptions, OpenAICompatibleEmbeddingModel, openaiTextEmbeddingResponseSchema, OpenAICompatibleImageModel, openaiCompatibleImageResponseSchema, VERSION8;
var init_dist14 = __esm({
  "node_modules/@ai-sdk/openai-compatible-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist12();
    init_dist13();
    init_v4();
    init_dist12();
    init_dist13();
    init_v4();
    init_v4();
    init_dist12();
    init_dist13();
    init_v4();
    init_dist12();
    init_v4();
    init_dist12();
    init_dist13();
    init_v4();
    init_v4();
    init_dist13();
    init_v4();
    init_dist13();
    __name(getOpenAIMetadata, "getOpenAIMetadata");
    __name(convertToOpenAICompatibleChatMessages, "convertToOpenAICompatibleChatMessages");
    __name(getResponseMetadata2, "getResponseMetadata");
    __name(mapOpenAICompatibleFinishReason, "mapOpenAICompatibleFinishReason");
    openaiCompatibleProviderOptions = external_exports.object({
      /**
       * A unique identifier representing your end-user, which can help the provider to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: external_exports.string().optional(),
      /**
       * Controls the verbosity of the generated text. Defaults to `medium`.
       */
      textVerbosity: external_exports.string().optional()
    });
    openaiCompatibleErrorDataSchema = external_exports.object({
      error: external_exports.object({
        message: external_exports.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: external_exports.string().nullish(),
        param: external_exports.any().nullish(),
        code: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
      })
    });
    defaultOpenAICompatibleErrorStructure = {
      errorSchema: openaiCompatibleErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    };
    __name(prepareTools4, "prepareTools");
    OpenAICompatibleChatLanguageModel = class {
      static {
        __name(this, "OpenAICompatibleChatLanguageModel");
      }
      // type inferred via constructor
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        var _a61, _b;
        this.modelId = modelId;
        this.config = config4;
        const errorStructure = (_a61 = config4.errorStructure) != null ? _a61 : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleChatChunkSchema(
          errorStructure.errorSchema
        );
        this.failedResponseHandler = createJsonErrorResponseHandler4(errorStructure);
        this.supportsStructuredOutputs = (_b = config4.supportsStructuredOutputs) != null ? _b : false;
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get supportedUrls() {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).supportedUrls) == null ? void 0 : _b.call(_a61)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        providerOptions,
        stopSequences,
        responseFormat,
        seed,
        toolChoice,
        tools
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        const compatibleOptions = Object.assign(
          (_a61 = await parseProviderOptions4({
            provider: "openai-compatible",
            providerOptions,
            schema: openaiCompatibleProviderOptions
          })) != null ? _a61 : {},
          (_b = await parseProviderOptions4({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompatibleProviderOptions
          })) != null ? _b : {}
        );
        if (topK != null) {
          warnings.push({ type: "unsupported-setting", setting: "topK" });
        }
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format schema is only supported with structuredOutputs"
          });
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = prepareTools4({
          tools,
          toolChoice
        });
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            user: compatibleOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
              type: "json_schema",
              json_schema: {
                schema: responseFormat.schema,
                name: (_c = responseFormat.name) != null ? _c : "response",
                description: responseFormat.description
              }
            } : { type: "json_object" } : void 0,
            stop: stopSequences,
            seed,
            ...Object.fromEntries(
              Object.entries(
                (_d = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _d : {}
              ).filter(
                ([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key)
              )
            ),
            reasoning_effort: compatibleOptions.reasoningEffort,
            verbosity: compatibleOptions.textVerbosity,
            // messages:
            messages: convertToOpenAICompatibleChatMessages(prompt),
            // tools:
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
        const { args, warnings } = await this.getArgs({ ...options });
        const body = JSON.stringify(args);
        const {
          responseHeaders,
          value: responseBody,
          rawValue: rawResponse
        } = await postJsonToApi4({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), options.headers),
          body: args,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler4(
            OpenAICompatibleChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = responseBody.choices[0];
        const content = [];
        const text3 = choice.message.content;
        if (text3 != null && text3.length > 0) {
          content.push({ type: "text", text: text3 });
        }
        const reasoning = (_a61 = choice.message.reasoning_content) != null ? _a61 : choice.message.reasoning;
        if (reasoning != null && reasoning.length > 0) {
          content.push({
            type: "reasoning",
            text: reasoning
          });
        }
        if (choice.message.tool_calls != null) {
          for (const toolCall of choice.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: (_b = toolCall.id) != null ? _b : generateId7(),
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        const providerMetadata = {
          [this.providerOptionsName]: {},
          ...await ((_d = (_c = this.config.metadataExtractor) == null ? void 0 : _c.extractMetadata) == null ? void 0 : _d.call(_c, {
            parsedBody: rawResponse
          }))
        };
        const completionTokenDetails = (_e = responseBody.usage) == null ? void 0 : _e.completion_tokens_details;
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
          providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
        }
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
          providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
        }
        return {
          content,
          finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),
          usage: {
            inputTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : void 0,
            outputTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : void 0,
            totalTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.total_tokens) != null ? _k : void 0,
            reasoningTokens: (_n = (_m = (_l = responseBody.usage) == null ? void 0 : _l.completion_tokens_details) == null ? void 0 : _m.reasoning_tokens) != null ? _n : void 0,
            cachedInputTokens: (_q = (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
          },
          providerMetadata,
          request: { body },
          response: {
            ...getResponseMetadata2(responseBody),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        var _a61;
        const { args, warnings } = await this.getArgs({ ...options });
        const body = {
          ...args,
          stream: true,
          // only include stream_options when in strict compatibility mode:
          stream_options: this.config.includeUsage ? { include_usage: true } : void 0
        };
        const metadataExtractor = (_a61 = this.config.metadataExtractor) == null ? void 0 : _a61.createStreamExtractor();
        const { responseHeaders, value: response } = await postJsonToApi4({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), options.headers),
          body,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler4(
            this.chunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = "unknown";
        const usage = {
          completionTokens: void 0,
          completionTokensDetails: {
            reasoningTokens: void 0,
            acceptedPredictionTokens: void 0,
            rejectedPredictionTokens: void 0
          },
          promptTokens: void 0,
          promptTokensDetails: {
            cachedTokens: void 0
          },
          totalTokens: void 0
        };
        let isFirstChunk = true;
        const providerOptionsName = this.providerOptionsName;
        let isActiveReasoning = false;
        let isActiveText = false;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
              transform(chunk, controller) {
                var _a217, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error.message });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata2(value)
                  });
                }
                if (value.usage != null) {
                  const {
                    prompt_tokens,
                    completion_tokens,
                    total_tokens,
                    prompt_tokens_details,
                    completion_tokens_details
                  } = value.usage;
                  usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;
                  usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;
                  usage.totalTokens = total_tokens != null ? total_tokens : void 0;
                  if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                    usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
                  }
                  if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                    usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
                  }
                  if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                    usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
                  }
                  if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                    usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
                  }
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenAICompatibleFinishReason(
                    choice.finish_reason
                  );
                }
                if ((choice == null ? void 0 : choice.delta) == null) {
                  return;
                }
                const delta = choice.delta;
                const reasoningContent = (_a217 = delta.reasoning_content) != null ? _a217 : delta.reasoning;
                if (reasoningContent) {
                  if (!isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-start",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = true;
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: "reasoning-0",
                    delta: reasoningContent
                  });
                }
                if (delta.content) {
                  if (!isActiveText) {
                    controller.enqueue({ type: "text-start", id: "txt-0" });
                    isActiveText = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "txt-0",
                    delta: delta.content
                  });
                }
                if (delta.tool_calls != null) {
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = toolCallDelta.index;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError2({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_b = toolCallDelta.function) == null ? void 0 : _b.name) == null) {
                        throw new InvalidResponseDataError2({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCallDelta.id,
                        toolName: toolCallDelta.function.name
                      });
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_c = toolCallDelta.function.arguments) != null ? _c : ""
                        },
                        hasFinished: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (((_d = toolCall2.function) == null ? void 0 : _d.name) != null && ((_e = toolCall2.function) == null ? void 0 : _e.arguments) != null) {
                        if (toolCall2.function.arguments.length > 0) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall2.id,
                            delta: toolCall2.function.arguments
                          });
                        }
                        if (isParsableJson(toolCall2.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall2.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_f = toolCall2.id) != null ? _f : generateId7(),
                            toolName: toolCall2.function.name,
                            input: toolCall2.function.arguments
                          });
                          toolCall2.hasFinished = true;
                        }
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall.hasFinished) {
                      continue;
                    }
                    if (((_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null) {
                      toolCall.function.arguments += (_i = (_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null ? _i : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                    });
                    if (((_k = toolCall.function) == null ? void 0 : _k.name) != null && ((_l = toolCall.function) == null ? void 0 : _l.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_m = toolCall.id) != null ? _m : generateId7(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                      toolCall.hasFinished = true;
                    }
                  }
                }
              },
              flush(controller) {
                var _a217, _b, _c, _d, _e, _f;
                if (isActiveReasoning) {
                  controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
                }
                if (isActiveText) {
                  controller.enqueue({ type: "text-end", id: "txt-0" });
                }
                for (const toolCall of toolCalls.filter(
                  (toolCall2) => !toolCall2.hasFinished
                )) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a217 = toolCall.id) != null ? _a217 : generateId7(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                }
                const providerMetadata = {
                  [providerOptionsName]: {},
                  ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()
                };
                if (usage.completionTokensDetails.acceptedPredictionTokens != null) {
                  providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;
                }
                if (usage.completionTokensDetails.rejectedPredictionTokens != null) {
                  providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: {
                    inputTokens: (_b = usage.promptTokens) != null ? _b : void 0,
                    outputTokens: (_c = usage.completionTokens) != null ? _c : void 0,
                    totalTokens: (_d = usage.totalTokens) != null ? _d : void 0,
                    reasoningTokens: (_e = usage.completionTokensDetails.reasoningTokens) != null ? _e : void 0,
                    cachedInputTokens: (_f = usage.promptTokensDetails.cachedTokens) != null ? _f : void 0
                  },
                  providerMetadata
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiCompatibleTokenUsageSchema = external_exports.object({
      prompt_tokens: external_exports.number().nullish(),
      completion_tokens: external_exports.number().nullish(),
      total_tokens: external_exports.number().nullish(),
      prompt_tokens_details: external_exports.object({
        cached_tokens: external_exports.number().nullish()
      }).nullish(),
      completion_tokens_details: external_exports.object({
        reasoning_tokens: external_exports.number().nullish(),
        accepted_prediction_tokens: external_exports.number().nullish(),
        rejected_prediction_tokens: external_exports.number().nullish()
      }).nullish()
    }).nullish();
    OpenAICompatibleChatResponseSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          message: external_exports.object({
            role: external_exports.literal("assistant").nullish(),
            content: external_exports.string().nullish(),
            reasoning_content: external_exports.string().nullish(),
            reasoning: external_exports.string().nullish(),
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string().nullish(),
                function: external_exports.object({
                  name: external_exports.string(),
                  arguments: external_exports.string()
                })
              })
            ).nullish()
          }),
          finish_reason: external_exports.string().nullish()
        })
      ),
      usage: openaiCompatibleTokenUsageSchema
    });
    createOpenAICompatibleChatChunkSchema = /* @__PURE__ */ __name((errorSchema) => external_exports.union([
      external_exports.object({
        id: external_exports.string().nullish(),
        created: external_exports.number().nullish(),
        model: external_exports.string().nullish(),
        choices: external_exports.array(
          external_exports.object({
            delta: external_exports.object({
              role: external_exports.enum(["assistant"]).nullish(),
              content: external_exports.string().nullish(),
              // Most openai-compatible models set `reasoning_content`, but some
              // providers serving `gpt-oss` set `reasoning`. See #7866
              reasoning_content: external_exports.string().nullish(),
              reasoning: external_exports.string().nullish(),
              tool_calls: external_exports.array(
                external_exports.object({
                  index: external_exports.number(),
                  id: external_exports.string().nullish(),
                  function: external_exports.object({
                    name: external_exports.string().nullish(),
                    arguments: external_exports.string().nullish()
                  })
                })
              ).nullish()
            }).nullish(),
            finish_reason: external_exports.string().nullish()
          })
        ),
        usage: openaiCompatibleTokenUsageSchema
      }),
      errorSchema
    ]), "createOpenAICompatibleChatChunkSchema");
    __name(convertToOpenAICompatibleCompletionPrompt, "convertToOpenAICompatibleCompletionPrompt");
    __name(getResponseMetadata22, "getResponseMetadata2");
    __name(mapOpenAICompatibleFinishReason2, "mapOpenAICompatibleFinishReason2");
    openaiCompatibleCompletionProviderOptions = external_exports.object({
      /**
       * Echo back the prompt in addition to the completion.
       */
      echo: external_exports.boolean().optional(),
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: external_exports.record(external_exports.string(), external_exports.number()).optional(),
      /**
       * The suffix that comes after a completion of inserted text.
       */
      suffix: external_exports.string().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional()
    });
    OpenAICompatibleCompletionLanguageModel = class {
      static {
        __name(this, "OpenAICompatibleCompletionLanguageModel");
      }
      // type inferred via constructor
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        var _a61;
        this.modelId = modelId;
        this.config = config4;
        const errorStructure = (_a61 = config4.errorStructure) != null ? _a61 : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(
          errorStructure.errorSchema
        );
        this.failedResponseHandler = createJsonErrorResponseHandler4(errorStructure);
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get supportedUrls() {
        var _a61, _b, _c;
        return (_c = (_b = (_a61 = this.config).supportedUrls) == null ? void 0 : _b.call(_a61)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences: userStopSequences,
        responseFormat,
        seed,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a61;
        const warnings = [];
        const completionOptions = (_a61 = await parseProviderOptions4({
          provider: this.providerOptionsName,
          providerOptions,
          schema: openaiCompatibleCompletionProviderOptions
        })) != null ? _a61 : {};
        if (topK != null) {
          warnings.push({ type: "unsupported-setting", setting: "topK" });
        }
        if (tools == null ? void 0 : tools.length) {
          warnings.push({ type: "unsupported-setting", setting: "tools" });
        }
        if (toolChoice != null) {
          warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
        }
        if (responseFormat != null && responseFormat.type !== "text") {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format is not supported."
          });
        }
        const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt });
        const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            echo: completionOptions.echo,
            logit_bias: completionOptions.logitBias,
            suffix: completionOptions.suffix,
            user: completionOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            seed,
            ...providerOptions == null ? void 0 : providerOptions[this.providerOptionsName],
            // prompt:
            prompt: completionPrompt,
            // stop sequences:
            stop: stop.length > 0 ? stop : void 0
          },
          warnings
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f;
        const { args, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi4({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), options.headers),
          body: args,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler4(
            openaiCompatibleCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = response.choices[0];
        const content = [];
        if (choice.text != null && choice.text.length > 0) {
          content.push({ type: "text", text: choice.text });
        }
        return {
          content,
          usage: {
            inputTokens: (_b = (_a61 = response.usage) == null ? void 0 : _a61.prompt_tokens) != null ? _b : void 0,
            outputTokens: (_d = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d : void 0,
            totalTokens: (_f = (_e = response.usage) == null ? void 0 : _e.total_tokens) != null ? _f : void 0
          },
          finishReason: mapOpenAICompatibleFinishReason2(choice.finish_reason),
          request: { body: args },
          response: {
            ...getResponseMetadata22(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const body = {
          ...args,
          stream: true,
          // only include stream_options when in strict compatibility mode:
          stream_options: this.config.includeUsage ? { include_usage: true } : void 0
        };
        const { responseHeaders, value: response } = await postJsonToApi4({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), options.headers),
          body,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler4(
            this.chunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let isFirstChunk = true;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a61, _b, _c;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata22(value)
                  });
                  controller.enqueue({
                    type: "text-start",
                    id: "0"
                  });
                }
                if (value.usage != null) {
                  usage.inputTokens = (_a61 = value.usage.prompt_tokens) != null ? _a61 : void 0;
                  usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                  usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenAICompatibleFinishReason2(
                    choice.finish_reason
                  );
                }
                if ((choice == null ? void 0 : choice.text) != null) {
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: choice.text
                  });
                }
              },
              flush(controller) {
                if (!isFirstChunk) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    usageSchema2 = external_exports.object({
      prompt_tokens: external_exports.number(),
      completion_tokens: external_exports.number(),
      total_tokens: external_exports.number()
    });
    openaiCompatibleCompletionResponseSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          text: external_exports.string(),
          finish_reason: external_exports.string()
        })
      ),
      usage: usageSchema2.nullish()
    });
    createOpenAICompatibleCompletionChunkSchema = /* @__PURE__ */ __name((errorSchema) => external_exports.union([
      external_exports.object({
        id: external_exports.string().nullish(),
        created: external_exports.number().nullish(),
        model: external_exports.string().nullish(),
        choices: external_exports.array(
          external_exports.object({
            text: external_exports.string(),
            finish_reason: external_exports.string().nullish(),
            index: external_exports.number()
          })
        ),
        usage: usageSchema2.nullish()
      }),
      errorSchema
    ]), "createOpenAICompatibleCompletionChunkSchema");
    openaiCompatibleEmbeddingProviderOptions = external_exports.object({
      /**
       * The number of dimensions the resulting output embeddings should have.
       * Only supported in text-embedding-3 and later models.
       */
      dimensions: external_exports.number().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional()
    });
    OpenAICompatibleEmbeddingModel = class {
      static {
        __name(this, "OpenAICompatibleEmbeddingModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      get maxEmbeddingsPerCall() {
        var _a61;
        return (_a61 = this.config.maxEmbeddingsPerCall) != null ? _a61 : 2048;
      }
      get supportsParallelCalls() {
        var _a61;
        return (_a61 = this.config.supportsParallelCalls) != null ? _a61 : true;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a61, _b, _c;
        const compatibleOptions = Object.assign(
          (_a61 = await parseProviderOptions4({
            provider: "openai-compatible",
            providerOptions,
            schema: openaiCompatibleEmbeddingProviderOptions
          })) != null ? _a61 : {},
          (_b = await parseProviderOptions4({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompatibleEmbeddingProviderOptions
          })) != null ? _b : {}
        );
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError4({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi4({
          url: this.config.url({
            path: "/embeddings",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), headers),
          body: {
            model: this.modelId,
            input: values,
            encoding_format: "float",
            dimensions: compatibleOptions.dimensions,
            user: compatibleOptions.user
          },
          failedResponseHandler: createJsonErrorResponseHandler4(
            (_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure
          ),
          successfulResponseHandler: createJsonResponseHandler4(
            openaiTextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: response.data.map((item) => item.embedding),
          usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
          providerMetadata: response.providerMetadata,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    openaiTextEmbeddingResponseSchema = external_exports.object({
      data: external_exports.array(external_exports.object({ embedding: external_exports.array(external_exports.number()) })),
      usage: external_exports.object({ prompt_tokens: external_exports.number() }).nullish(),
      providerMetadata: external_exports.record(external_exports.string(), external_exports.record(external_exports.string(), external_exports.any())).optional()
    });
    OpenAICompatibleImageModel = class {
      static {
        __name(this, "OpenAICompatibleImageModel");
      }
      constructor(modelId, config4) {
        this.modelId = modelId;
        this.config = config4;
        this.specificationVersion = "v2";
        this.maxImagesPerCall = 10;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a61, _b, _c, _d, _e;
        const warnings = [];
        if (aspectRatio != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported-setting", setting: "seed" });
        }
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const { value: response, responseHeaders } = await postJsonToApi4({
          url: this.config.url({
            path: "/images/generations",
            modelId: this.modelId
          }),
          headers: combineHeaders4(this.config.headers(), headers),
          body: {
            model: this.modelId,
            prompt,
            n,
            size,
            ...(_d = providerOptions.openai) != null ? _d : {},
            response_format: "b64_json"
          },
          failedResponseHandler: createJsonErrorResponseHandler4(
            (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
          ),
          successfulResponseHandler: createJsonResponseHandler4(
            openaiCompatibleImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.data.map((item) => item.b64_json),
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    openaiCompatibleImageResponseSchema = external_exports.object({
      data: external_exports.array(external_exports.object({ b64_json: external_exports.string() }))
    });
    VERSION8 = true ? "1.0.22" : "0.0.0-test";
    __name(createOpenAICompatible, "createOpenAICompatible");
  }
});

// node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage9(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker30, symbol31, _a31, _AISDKError15, AISDKError8, name30, marker211, symbol212, _a212, APICallError7, name211, marker310, symbol310, _a310, EmptyResponseBodyError6, name310, marker410, symbol410, _a410, InvalidArgumentError9, name410, marker510, symbol510, _a510, InvalidPromptError4, name510, marker610, symbol610, _a610, InvalidResponseDataError3, name610, marker710, symbol710, _a710, JSONParseError7, name710, marker810, symbol810, _a810, LoadAPIKeyError5, name810, marker910, symbol910, _a910, name910, marker1010, symbol1010, _a1010, name1010, marker1110, symbol1110, _a1110, name1110, marker1210, symbol1210, _a1210, TooManyEmbeddingValuesForCallError5, name1210, marker1310, symbol1310, _a1310, _TypeValidationError13, TypeValidationError7, name1310, marker1410, symbol1410, _a1410, UnsupportedFunctionalityError7;
var init_dist15 = __esm({
  "node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker30 = "vercel.ai.error";
    symbol31 = Symbol.for(marker30);
    _AISDKError15 = class _AISDKError16 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a31] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError16.hasMarker(error87, marker30);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a31 = symbol31;
    AISDKError8 = _AISDKError15;
    name30 = "AI_APICallError";
    marker211 = `vercel.ai.error.${name30}`;
    symbol212 = Symbol.for(marker211);
    APICallError7 = class extends AISDKError8 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name30, message, cause });
        this[_a212] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker211);
      }
    };
    _a212 = symbol212;
    name211 = "AI_EmptyResponseBodyError";
    marker310 = `vercel.ai.error.${name211}`;
    symbol310 = Symbol.for(marker310);
    EmptyResponseBodyError6 = class extends AISDKError8 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name211, message });
        this[_a310] = true;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker310);
      }
    };
    _a310 = symbol310;
    __name(getErrorMessage9, "getErrorMessage");
    name310 = "AI_InvalidArgumentError";
    marker410 = `vercel.ai.error.${name310}`;
    symbol410 = Symbol.for(marker410);
    InvalidArgumentError9 = class extends AISDKError8 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name310, message, cause });
        this[_a410] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker410);
      }
    };
    _a410 = symbol410;
    name410 = "AI_InvalidPromptError";
    marker510 = `vercel.ai.error.${name410}`;
    symbol510 = Symbol.for(marker510);
    InvalidPromptError4 = class extends AISDKError8 {
      static {
        __name(this, "InvalidPromptError");
      }
      constructor({
        prompt,
        message,
        cause
      }) {
        super({ name: name410, message: `Invalid prompt: ${message}`, cause });
        this[_a510] = true;
        this.prompt = prompt;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker510);
      }
    };
    _a510 = symbol510;
    name510 = "AI_InvalidResponseDataError";
    marker610 = `vercel.ai.error.${name510}`;
    symbol610 = Symbol.for(marker610);
    InvalidResponseDataError3 = class extends AISDKError8 {
      static {
        __name(this, "InvalidResponseDataError");
      }
      constructor({
        data,
        message = `Invalid response data: ${JSON.stringify(data)}.`
      }) {
        super({ name: name510, message });
        this[_a610] = true;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker610);
      }
    };
    _a610 = symbol610;
    name610 = "AI_JSONParseError";
    marker710 = `vercel.ai.error.${name610}`;
    symbol710 = Symbol.for(marker710);
    JSONParseError7 = class extends AISDKError8 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name610,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage9(cause)}`,
          cause
        });
        this[_a710] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker710);
      }
    };
    _a710 = symbol710;
    name710 = "AI_LoadAPIKeyError";
    marker810 = `vercel.ai.error.${name710}`;
    symbol810 = Symbol.for(marker810);
    LoadAPIKeyError5 = class extends AISDKError8 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name710, message });
        this[_a810] = true;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker810);
      }
    };
    _a810 = symbol810;
    name810 = "AI_LoadSettingError";
    marker910 = `vercel.ai.error.${name810}`;
    symbol910 = Symbol.for(marker910);
    _a910 = symbol910;
    name910 = "AI_NoContentGeneratedError";
    marker1010 = `vercel.ai.error.${name910}`;
    symbol1010 = Symbol.for(marker1010);
    _a1010 = symbol1010;
    name1010 = "AI_NoSuchModelError";
    marker1110 = `vercel.ai.error.${name1010}`;
    symbol1110 = Symbol.for(marker1110);
    _a1110 = symbol1110;
    name1110 = "AI_TooManyEmbeddingValuesForCallError";
    marker1210 = `vercel.ai.error.${name1110}`;
    symbol1210 = Symbol.for(marker1210);
    TooManyEmbeddingValuesForCallError5 = class extends AISDKError8 {
      static {
        __name(this, "TooManyEmbeddingValuesForCallError");
      }
      constructor(options) {
        super({
          name: name1110,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a1210] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker1210);
      }
    };
    _a1210 = symbol1210;
    name1210 = "AI_TypeValidationError";
    marker1310 = `vercel.ai.error.${name1210}`;
    symbol1310 = Symbol.for(marker1310);
    _TypeValidationError13 = class _TypeValidationError14 extends AISDKError8 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name1210,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage9(cause)}`,
          cause
        });
        this[_a1310] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker1310);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError14.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError14({ value, cause });
      }
    };
    _a1310 = symbol1310;
    TypeValidationError7 = _TypeValidationError13;
    name1310 = "AI_UnsupportedFunctionalityError";
    marker1410 = `vercel.ai.error.${name1310}`;
    symbol1410 = Symbol.for(marker1410);
    UnsupportedFunctionalityError7 = class extends AISDKError8 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name1310, message });
        this[_a1410] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError8.hasMarker(error87, marker1410);
      }
    };
    _a1410 = symbol1410;
  }
});

// node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders5(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders5(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError8(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError5({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError8(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES5.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError7({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent5(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries3(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix6(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries3(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
function loadApiKey4({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError5({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError5({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError5({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError5({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
function mediaTypeToExtension(mediaType) {
  var _a61;
  const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
  return (_a61 = {
    mpeg: "mp3",
    "x-wav": "wav",
    opus: "ogg",
    mp4: "m4a",
    "x-m4a": "m4a"
  }[subtype]) != null ? _a61 : subtype;
}
function _parse8(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx6.test(text3) === false && suspectConstructorRx6.test(text3) === false) {
    return obj;
  }
  return filter6(obj);
}
function filter6(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse6(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse8(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator7(validate) {
  return { [validatorSymbol8]: true, validate };
}
function isValidator7(value) {
  return typeof value === "object" && value !== null && validatorSymbol8 in value && value[validatorSymbol8] === true && "validate" in value;
}
function lazyValidator2(createValidator) {
  let validator22;
  return () => {
    if (validator22 == null) {
      validator22 = createValidator();
    }
    return validator22;
  };
}
function asValidator7(value) {
  return isValidator7(value) ? value : typeof value === "function" ? value() : standardSchemaValidator6(value);
}
function standardSchemaValidator6(standardSchema) {
  return validator7(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError7({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes6({
  value,
  schema
}) {
  const result = await safeValidateTypes7({ value, schema });
  if (!result.success) {
    throw TypeValidationError7.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes7({
  value,
  schema
}) {
  const validator22 = asValidator7(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError7.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError7.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON5({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse6(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes6({ value, schema });
  } catch (error87) {
    if (JSONParseError7.isInstance(error87) || TypeValidationError7.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError7({ text: text3, cause: error87 });
  }
}
async function safeParseJSON7({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse6(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes7({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError7.isInstance(error87) ? error87 : new JSONParseError7({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function isParsableJson2(input) {
  try {
    secureJsonParse6(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream6({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON7({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions5({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes7({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError9({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function tool4(tool22) {
  return tool22;
}
function createProviderDefinedToolFactoryWithOutputSchema3({
  id,
  name: name51,
  inputSchema,
  outputSchema: outputSchema2
}) {
  return ({
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool4({
    type: "provider-defined",
    id,
    name: name51,
    args,
    inputSchema,
    outputSchema: outputSchema2,
    execute: execute2,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function parseAnyDef5() {
  return {};
}
function parseArrayDef5(def, refs) {
  var _a61, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a61 = def.type) == null ? void 0 : _a61._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef5(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef5(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef5() {
  return { type: "boolean" };
}
function parseBrandedDef5(_def, refs) {
  return parseDef5(_def.type._def, refs);
}
function parseDateDef5(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef5(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser5(def);
  }
}
function parseDefaultDef5(_def, refs) {
  return {
    ...parseDef5(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef5(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef5(_def.schema._def, refs) : parseAnyDef5();
}
function parseEnumDef5(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
function parseIntersectionDef5(def, refs) {
  const allOf = [
    parseDef5(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef5(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType5(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef5(def) {
  const parsedType5 = typeof def.value;
  if (parsedType5 !== "bigint" && parsedType5 !== "number" && parsedType5 !== "boolean" && parsedType5 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType5 === "bigint" ? "integer" : parsedType5,
    const: def.value
  };
}
function parseStringDef5(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check3 of def.checks) {
      switch (check3.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat5(res, "email", check3.message, refs);
              break;
            case "format:idn-email":
              addFormat5(res, "idn-email", check3.message, refs);
              break;
            case "pattern:zod":
              addPattern5(res, zodPatterns5.email, check3.message, refs);
              break;
          }
          break;
        case "url":
          addFormat5(res, "uri", check3.message, refs);
          break;
        case "uuid":
          addFormat5(res, "uuid", check3.message, refs);
          break;
        case "regex":
          addPattern5(res, check3.regex, check3.message, refs);
          break;
        case "cuid":
          addPattern5(res, zodPatterns5.cuid, check3.message, refs);
          break;
        case "cuid2":
          addPattern5(res, zodPatterns5.cuid2, check3.message, refs);
          break;
        case "startsWith":
          addPattern5(
            res,
            RegExp(`^${escapeLiteralCheckValue5(check3.value, refs)}`),
            check3.message,
            refs
          );
          break;
        case "endsWith":
          addPattern5(
            res,
            RegExp(`${escapeLiteralCheckValue5(check3.value, refs)}$`),
            check3.message,
            refs
          );
          break;
        case "datetime":
          addFormat5(res, "date-time", check3.message, refs);
          break;
        case "date":
          addFormat5(res, "date", check3.message, refs);
          break;
        case "time":
          addFormat5(res, "time", check3.message, refs);
          break;
        case "duration":
          addFormat5(res, "duration", check3.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "includes": {
          addPattern5(
            res,
            RegExp(escapeLiteralCheckValue5(check3.value, refs)),
            check3.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check3.version !== "v6") {
            addFormat5(res, "ipv4", check3.message, refs);
          }
          if (check3.version !== "v4") {
            addFormat5(res, "ipv6", check3.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern5(res, zodPatterns5.base64url, check3.message, refs);
          break;
        case "jwt":
          addPattern5(res, zodPatterns5.jwt, check3.message, refs);
          break;
        case "cidr": {
          if (check3.version !== "v6") {
            addPattern5(res, zodPatterns5.ipv4Cidr, check3.message, refs);
          }
          if (check3.version !== "v4") {
            addPattern5(res, zodPatterns5.ipv6Cidr, check3.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern5(res, zodPatterns5.emoji(), check3.message, refs);
          break;
        case "ulid": {
          addPattern5(res, zodPatterns5.ulid, check3.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat5(res, "binary", check3.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern5(res, zodPatterns5.base64, check3.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern5(res, zodPatterns5.nanoid, check3.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check3);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue5(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric5(literal3) : literal3;
}
function escapeNonAlphaNumeric5(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC8.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat5(schema, value, message, refs) {
  var _a61;
  if (schema.format || ((_a61 = schema.anyOf) == null ? void 0 : _a61.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern5(schema, regex, message, refs) {
  var _a61;
  if (schema.pattern || ((_a61 = schema.allOf) == null ? void 0 : _a61.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags5(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags5(regex, refs);
  }
}
function stringifyRegExpWithFlags5(regex, refs) {
  var _a61;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a61 = source[i + 2]) == null ? void 0 : _a61.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef5(def, refs) {
  var _a61, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a61 = parseDef5(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a61 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef5(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef5(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef5(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef5(def, refs);
  }
  const keys = parseDef5(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef5();
  const values = parseDef5(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef5();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef5(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef5() {
  return { not: parseAnyDef5() };
}
function parseNullDef5() {
  return {
    type: "null"
  };
}
function parseUnionDef5(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings5 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings5[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf5(def, refs);
}
function parseNullableDef5(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings5[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef5(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef5(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
function parseObjectDef5(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional5(propDef);
    const parsedDef = parseDef5(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties5(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties5(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef5(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional5(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
function parsePromiseDef5(def, refs) {
  return parseDef5(def.type._def, refs);
}
function parseSetDef5(def, refs) {
  const items = parseDef5(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef5(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef5(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef5(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef5(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef5() {
  return {
    not: parseAnyDef5()
  };
}
function parseUnknownDef5() {
  return parseAnyDef5();
}
function parseDef5(def, refs, forceResolution = false) {
  var _a61;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a61 = refs.override) == null ? void 0 : _a61.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride8) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref5(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser6(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef5(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta5(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
function zod3Schema4(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema5(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default4(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function zod4Schema4(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema5(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await safeParseAsync2(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
function isZod4Schema4(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema5(zodSchema22, options) {
  if (isZod4Schema4(zodSchema22)) {
    return zod4Schema4(zodSchema22, options);
  } else {
    return zod3Schema4(zodSchema22, options);
  }
}
function lazySchema3(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema5(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol8]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol8]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
function convertBase64ToUint8Array3(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob9(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase647(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa9(latin1string);
}
function convertToBase645(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase647(value) : value;
}
function withoutTrailingSlash5(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator8, generateId8, FETCH_FAILED_ERROR_MESSAGES5, VERSION9, suspectProtoRx6, suspectConstructorRx6, validatorSymbol8, getOriginalFetch25, postJsonToApi5, postFormDataToApi, postToApi5, createJsonErrorResponseHandler5, createEventSourceResponseHandler5, createJsonResponseHandler5, createBinaryResponseHandler, getRelativePath5, ignoreOverride8, defaultOptions5, getDefaultOptions5, parseCatchDef5, integerDateParser5, isJsonSchema7AllOfType5, emojiRegex6, zodPatterns5, ALPHA_NUMERIC8, primitiveMappings5, asAnyOf5, parseOptionalDef5, parsePipelineDef5, parseReadonlyDef5, selectParser6, get$ref5, addMeta5, getRefs5, zodToJsonSchema6, zod_to_json_schema_default4, schemaSymbol8, btoa9, atob9;
var init_dist16 = __esm({
  "node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist15();
    init_dist15();
    init_dist15();
    init_dist15();
    init_dist15();
    init_dist15();
    init_stream();
    init_dist15();
    init_dist15();
    init_dist15();
    init_v4();
    init_v3();
    init_v3();
    init_v3();
    init_dist2();
    __name(combineHeaders5, "combineHeaders");
    __name(extractResponseHeaders5, "extractResponseHeaders");
    createIdGenerator8 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError9({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId8 = createIdGenerator8();
    __name(isAbortError8, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES5 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError5, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent5, "getRuntimeEnvironmentUserAgent");
    __name(removeUndefinedEntries3, "removeUndefinedEntries");
    __name(withUserAgentSuffix6, "withUserAgentSuffix");
    VERSION9 = true ? "3.0.12" : "0.0.0-test";
    __name(loadApiKey4, "loadApiKey");
    __name(loadOptionalSetting, "loadOptionalSetting");
    __name(mediaTypeToExtension, "mediaTypeToExtension");
    suspectProtoRx6 = /"__proto__"\s*:/;
    suspectConstructorRx6 = /"constructor"\s*:/;
    __name(_parse8, "_parse");
    __name(filter6, "filter");
    __name(secureJsonParse6, "secureJsonParse");
    validatorSymbol8 = Symbol.for("vercel.ai.validator");
    __name(validator7, "validator");
    __name(isValidator7, "isValidator");
    __name(lazyValidator2, "lazyValidator");
    __name(asValidator7, "asValidator");
    __name(standardSchemaValidator6, "standardSchemaValidator");
    __name(validateTypes6, "validateTypes");
    __name(safeValidateTypes7, "safeValidateTypes");
    __name(parseJSON5, "parseJSON");
    __name(safeParseJSON7, "safeParseJSON");
    __name(isParsableJson2, "isParsableJson");
    __name(parseJsonEventStream6, "parseJsonEventStream");
    __name(parseProviderOptions5, "parseProviderOptions");
    getOriginalFetch25 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi5 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi5({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postFormDataToApi = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      formData,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi5({
      url: url3,
      headers,
      body: {
        content: formData,
        values: Object.fromEntries(formData.entries())
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postFormDataToApi");
    postToApi5 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch25()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix6(
            headers,
            `ai-sdk/provider-utils/${VERSION9}`,
            getRuntimeEnvironmentUserAgent5()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders5(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError8(error87) || APICallError7.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError7({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError8(error87) || APICallError7.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError7({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError5({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    __name(tool4, "tool");
    __name(createProviderDefinedToolFactoryWithOutputSchema3, "createProviderDefinedToolFactoryWithOutputSchema");
    createJsonErrorResponseHandler5 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders5(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError7({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON5({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError7({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError7({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler5 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders5(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError6({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream6({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler5 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON7({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders5(response);
      if (!parsedResult.success) {
        throw new APICallError7({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    createBinaryResponseHandler = /* @__PURE__ */ __name(() => async ({ response, url: url3, requestBodyValues }) => {
      const responseHeaders = extractResponseHeaders5(response);
      if (!response.body) {
        throw new APICallError7({
          message: "Response body is empty",
          url: url3,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody: void 0
        });
      }
      try {
        const buffer = await response.arrayBuffer();
        return {
          responseHeaders,
          value: new Uint8Array(buffer)
        };
      } catch (error87) {
        throw new APICallError7({
          message: "Failed to read response as array buffer",
          url: url3,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody: void 0,
          cause: error87
        });
      }
    }, "createBinaryResponseHandler");
    getRelativePath5 = /* @__PURE__ */ __name((pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i]) break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    }, "getRelativePath");
    ignoreOverride8 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    defaultOptions5 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions5 = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
      ...defaultOptions5,
      name: options
    } : {
      ...defaultOptions5,
      ...options
    }, "getDefaultOptions");
    __name(parseAnyDef5, "parseAnyDef");
    __name(parseArrayDef5, "parseArrayDef");
    __name(parseBigintDef5, "parseBigintDef");
    __name(parseBooleanDef5, "parseBooleanDef");
    __name(parseBrandedDef5, "parseBrandedDef");
    parseCatchDef5 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef5(def.innerType._def, refs);
    }, "parseCatchDef");
    __name(parseDateDef5, "parseDateDef");
    integerDateParser5 = /* @__PURE__ */ __name((def) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check3 of def.checks) {
        switch (check3.kind) {
          case "min":
            res.minimum = check3.value;
            break;
          case "max":
            res.maximum = check3.value;
            break;
        }
      }
      return res;
    }, "integerDateParser");
    __name(parseDefaultDef5, "parseDefaultDef");
    __name(parseEffectsDef5, "parseEffectsDef");
    __name(parseEnumDef5, "parseEnumDef");
    isJsonSchema7AllOfType5 = /* @__PURE__ */ __name((type) => {
      if ("type" in type && type.type === "string") return false;
      return "allOf" in type;
    }, "isJsonSchema7AllOfType");
    __name(parseIntersectionDef5, "parseIntersectionDef");
    __name(parseLiteralDef5, "parseLiteralDef");
    emojiRegex6 = void 0;
    zodPatterns5 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: /* @__PURE__ */ __name(() => {
        if (emojiRegex6 === void 0) {
          emojiRegex6 = RegExp(
            "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
            "u"
          );
        }
        return emojiRegex6;
      }, "emoji"),
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    __name(parseStringDef5, "parseStringDef");
    __name(escapeLiteralCheckValue5, "escapeLiteralCheckValue");
    ALPHA_NUMERIC8 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    __name(escapeNonAlphaNumeric5, "escapeNonAlphaNumeric");
    __name(addFormat5, "addFormat");
    __name(addPattern5, "addPattern");
    __name(stringifyRegExpWithFlags5, "stringifyRegExpWithFlags");
    __name(parseRecordDef5, "parseRecordDef");
    __name(parseMapDef5, "parseMapDef");
    __name(parseNativeEnumDef5, "parseNativeEnumDef");
    __name(parseNeverDef5, "parseNeverDef");
    __name(parseNullDef5, "parseNullDef");
    primitiveMappings5 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    __name(parseUnionDef5, "parseUnionDef");
    asAnyOf5 = /* @__PURE__ */ __name((def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
        (x, i) => parseDef5(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "anyOf", `${i}`]
        })
      ).filter(
        (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
      );
      return anyOf.length ? { anyOf } : void 0;
    }, "asAnyOf");
    __name(parseNullableDef5, "parseNullableDef");
    __name(parseNumberDef5, "parseNumberDef");
    __name(parseObjectDef5, "parseObjectDef");
    __name(decideAdditionalProperties5, "decideAdditionalProperties");
    __name(safeIsOptional5, "safeIsOptional");
    parseOptionalDef5 = /* @__PURE__ */ __name((def, refs) => {
      var _a61;
      if (refs.currentPath.toString() === ((_a61 = refs.propertyPath) == null ? void 0 : _a61.toString())) {
        return parseDef5(def.innerType._def, refs);
      }
      const innerSchema = parseDef5(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? { anyOf: [{ not: parseAnyDef5() }, innerSchema] } : parseAnyDef5();
    }, "parseOptionalDef");
    parsePipelineDef5 = /* @__PURE__ */ __name((def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef5(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef5(def.out._def, refs);
      }
      const a = parseDef5(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef5(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      });
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    }, "parsePipelineDef");
    __name(parsePromiseDef5, "parsePromiseDef");
    __name(parseSetDef5, "parseSetDef");
    __name(parseTupleDef5, "parseTupleDef");
    __name(parseUndefinedDef5, "parseUndefinedDef");
    __name(parseUnknownDef5, "parseUnknownDef");
    parseReadonlyDef5 = /* @__PURE__ */ __name((def, refs) => {
      return parseDef5(def.innerType._def, refs);
    }, "parseReadonlyDef");
    selectParser6 = /* @__PURE__ */ __name((def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef5(def);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef5(def);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef5();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef5();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef5();
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef5(def);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef5(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef5(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef5();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef5();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef5();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef5(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    }, "selectParser");
    __name(parseDef5, "parseDef");
    get$ref5 = /* @__PURE__ */ __name((item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath5(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
            console.warn(
              `Recursive reference detected at ${refs.currentPath.join(
                "/"
              )}! Defaulting to any`
            );
            return parseAnyDef5();
          }
          return refs.$refStrategy === "seen" ? parseAnyDef5() : void 0;
        }
      }
    }, "get$ref");
    addMeta5 = /* @__PURE__ */ __name((def, refs, jsonSchema22) => {
      if (def.description) {
        jsonSchema22.description = def.description;
      }
      return jsonSchema22;
    }, "addMeta");
    getRefs5 = /* @__PURE__ */ __name((options) => {
      const _options = getDefaultOptions5(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(_options.definitions).map(([name51, def]) => [
            def._def,
            {
              def: def._def,
              path: [..._options.basePath, _options.definitionPath, name51],
              // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
              jsonSchema: void 0
            }
          ])
        )
      };
    }, "getRefs");
    zodToJsonSchema6 = /* @__PURE__ */ __name((schema, options) => {
      var _a61;
      const refs = getRefs5(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
        (acc, [name216, schema2]) => {
          var _a217;
          return {
            ...acc,
            [name216]: (_a217 = parseDef5(
              schema2._def,
              {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name216]
              },
              true
            )) != null ? _a217 : parseAnyDef5()
          };
        },
        {}
      ) : void 0;
      const name51 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
      const main = (_a61 = parseDef5(
        schema._def,
        name51 === void 0 ? refs : {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name51]
        },
        false
      )) != null ? _a61 : parseAnyDef5();
      const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title2 !== void 0) {
        main.title = title2;
      }
      const combined = name51 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name51
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name51]: main
        }
      };
      combined.$schema = "http://json-schema.org/draft-07/schema#";
      return combined;
    }, "zodToJsonSchema");
    zod_to_json_schema_default4 = zodToJsonSchema6;
    __name(zod3Schema4, "zod3Schema");
    __name(zod4Schema4, "zod4Schema");
    __name(isZod4Schema4, "isZod4Schema");
    __name(zodSchema5, "zodSchema");
    schemaSymbol8 = Symbol.for("vercel.ai.schema");
    __name(lazySchema3, "lazySchema");
    __name(jsonSchema5, "jsonSchema");
    ({ btoa: btoa9, atob: atob9 } = globalThis);
    __name(convertBase64ToUint8Array3, "convertBase64ToUint8Array");
    __name(convertUint8ArrayToBase647, "convertUint8ArrayToBase64");
    __name(convertToBase645, "convertToBase64");
    __name(withoutTrailingSlash5, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/openai-v5/dist/index.mjs
function convertToOpenAIChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a61, _b, _c;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase645(part.data)}`,
                      // OpenAI specific extension: image detail
                      detail: (_b = (_a61 = part.providerOptions) == null ? void 0 : _a61.openai) == null ? void 0 : _b.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError7({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  switch (part.mediaType) {
                    case "audio/wav": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase645(part.data),
                          format: "wav"
                        }
                      };
                    }
                    case "audio/mp3":
                    case "audio/mpeg": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase645(part.data),
                          format: "mp3"
                        }
                      };
                    }
                    default: {
                      throw new UnsupportedFunctionalityError7({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                    }
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError7({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase645(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError7({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text3 = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text3 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text3,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata3({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function prepareChatTools({
  tools,
  toolChoice,
  structuredOutputs,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool5 of tools) {
    switch (tool5.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool5.name,
            description: tool5.description,
            parameters: tool5.inputSchema,
            strict: structuredOutputs ? strictJsonSchema : void 0
          }
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError7({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function isReasoningModel(modelId) {
  return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing(modelId) {
  return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing(modelId) {
  return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode(modelId) {
  var _a61, _b;
  if (!isReasoningModel(modelId)) {
    return "system";
  }
  return (_b = (_a61 = reasoningModels[modelId]) == null ? void 0 : _a61.systemMessageMode) != null ? _b : "developer";
}
function convertToOpenAICompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text3 = "";
  if (prompt[0].role === "system") {
    text3 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError4({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text3 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError7({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text3 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError7({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text3 += `${assistant}:
`;
  return {
    prompt: text3,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata23({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function isFileId(data, prefixes) {
  if (!prefixes) return false;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
async function convertToOpenAIResponsesInput({
  prompt,
  systemMessageMode,
  fileIdPrefixes,
  store,
  hasLocalShellTool = false
}) {
  var _a61, _b, _c, _d;
  const input = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            input.push({ role: "system", content });
            break;
          }
          case "developer": {
            input.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        input.push({
          role: "user",
          content: content.map((part, index) => {
            var _a217, _b2, _c2;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase645(part.data)}`
                    },
                    detail: (_b2 = (_a217 = part.providerOptions) == null ? void 0 : _a217.openai) == null ? void 0 : _b2.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    return {
                      type: "input_file",
                      file_url: part.data.toString()
                    };
                  }
                  return {
                    type: "input_file",
                    ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase645(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError7({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        const reasoningMessages = {};
        const toolCallParts = {};
        for (const part of content) {
          switch (part.type) {
            case "text": {
              const id = (_b = (_a61 = part.providerOptions) == null ? void 0 : _a61.openai) == null ? void 0 : _b.itemId;
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              input.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }],
                id
              });
              break;
            }
            case "tool-call": {
              toolCallParts[part.toolCallId] = part;
              if (part.providerExecuted) {
                break;
              }
              const id = (_d = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.itemId;
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              if (hasLocalShellTool && part.toolName === "local_shell") {
                const parsedInput = await validateTypes6({
                  value: part.input,
                  schema: localShellInputSchema
                });
                input.push({
                  type: "local_shell_call",
                  call_id: part.toolCallId,
                  id,
                  action: {
                    type: "exec",
                    command: parsedInput.action.command,
                    timeout_ms: parsedInput.action.timeoutMs,
                    user: parsedInput.action.user,
                    working_directory: parsedInput.action.workingDirectory,
                    env: parsedInput.action.env
                  }
                });
                break;
              }
              input.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                id
              });
              break;
            }
            // assistant tool result parts are from provider-executed tools:
            case "tool-result": {
              if (store) {
                input.push({ type: "item_reference", id: part.toolCallId });
              } else {
                warnings.push({
                  type: "other",
                  message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                });
              }
              break;
            }
            case "reasoning": {
              const providerOptions = await parseProviderOptions5({
                provider: "openai",
                providerOptions: part.providerOptions,
                schema: openaiResponsesReasoningProviderOptionsSchema
              });
              const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
              if (reasoningId != null) {
                const reasoningMessage = reasoningMessages[reasoningId];
                if (store) {
                  if (reasoningMessage === void 0) {
                    input.push({ type: "item_reference", id: reasoningId });
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      summary: []
                    };
                  }
                } else {
                  const summaryParts = [];
                  if (part.text.length > 0) {
                    summaryParts.push({
                      type: "summary_text",
                      text: part.text
                    });
                  } else if (reasoningMessage !== void 0) {
                    warnings.push({
                      type: "other",
                      message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                    });
                  }
                  if (reasoningMessage === void 0) {
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                      summary: summaryParts
                    };
                    input.push(reasoningMessages[reasoningId]);
                  } else {
                    reasoningMessage.summary.push(...summaryParts);
                    if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                      reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                    }
                  }
                }
              } else {
                warnings.push({
                  type: "other",
                  message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                });
              }
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          const output = part.output;
          if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
            const parsedOutput = await validateTypes6({
              value: output.value,
              schema: localShellOutputSchema
            });
            input.push({
              type: "local_shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output
            });
            break;
          }
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
            case "content":
              contentValue = output.value.map((item) => {
                switch (item.type) {
                  case "text": {
                    return { type: "input_text", text: item.text };
                  }
                  case "media": {
                    return item.mediaType.startsWith("image/") ? {
                      type: "input_image",
                      image_url: `data:${item.mediaType};base64,${item.data}`
                    } : {
                      type: "input_file",
                      filename: "data",
                      file_data: `data:${item.mediaType};base64,${item.data}`
                    };
                  }
                }
              });
              break;
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { input, warnings };
}
function mapOpenAIResponseFinishReason({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "unknown";
  }
}
async function prepareResponsesTools({
  tools,
  toolChoice,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool5 of tools) {
    switch (tool5.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          name: tool5.name,
          description: tool5.description,
          parameters: tool5.inputSchema,
          strict: strictJsonSchema
        });
        break;
      case "provider-defined": {
        switch (tool5.id) {
          case "openai.file_search": {
            const args = await validateTypes6({
              value: tool5.args,
              schema: fileSearchArgsSchema2
            });
            openaiTools2.push({
              type: "file_search",
              vector_store_ids: args.vectorStoreIds,
              max_num_results: args.maxNumResults,
              ranking_options: args.ranking ? {
                ranker: args.ranking.ranker,
                score_threshold: args.ranking.scoreThreshold
              } : void 0,
              filters: args.filters
            });
            break;
          }
          case "openai.local_shell": {
            openaiTools2.push({
              type: "local_shell"
            });
            break;
          }
          case "openai.web_search_preview": {
            const args = await validateTypes6({
              value: tool5.args,
              schema: webSearchPreviewArgsSchema
            });
            openaiTools2.push({
              type: "web_search_preview",
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.web_search": {
            const args = await validateTypes6({
              value: tool5.args,
              schema: webSearchArgsSchema
            });
            openaiTools2.push({
              type: "web_search",
              filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.code_interpreter": {
            const args = await validateTypes6({
              value: tool5.args,
              schema: codeInterpreterArgsSchema
            });
            openaiTools2.push({
              type: "code_interpreter",
              container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
            });
            break;
          }
          case "openai.image_generation": {
            const args = await validateTypes6({
              value: tool5.args,
              schema: imageGenerationArgsSchema
            });
            openaiTools2.push({
              type: "image_generation",
              background: args.background,
              input_fidelity: args.inputFidelity,
              input_image_mask: args.inputImageMask ? {
                file_id: args.inputImageMask.fileId,
                image_url: args.inputImageMask.imageUrl
              } : void 0,
              model: args.model,
              size: args.size,
              quality: args.quality,
              moderation: args.moderation,
              output_format: args.outputFormat,
              output_compression: args.outputCompression
            });
            break;
          }
        }
        break;
      }
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError7({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function getResponsesModelConfig(modelId) {
  const supportsFlexProcessing2 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsPriorityProcessing2 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  const defaults = {
    systemMessageMode: "system",
    supportsFlexProcessing: supportsFlexProcessing2,
    supportsPriorityProcessing: supportsPriorityProcessing2
  };
  if (modelId.startsWith("gpt-5-chat")) {
    return {
      ...defaults,
      isReasoningModel: false
    };
  }
  if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
    if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
      return {
        ...defaults,
        isReasoningModel: true,
        systemMessageMode: "remove"
      };
    }
    return {
      ...defaults,
      isReasoningModel: true,
      systemMessageMode: "developer"
    };
  }
  return {
    ...defaults,
    isReasoningModel: false
  };
}
function mapWebSearchOutput(action) {
  var _a61;
  switch (action.type) {
    case "search":
      return { action: { type: "search", query: (_a61 = action.query) != null ? _a61 : void 0 } };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find":
      return {
        action: { type: "find", url: action.url, pattern: action.pattern }
      };
  }
}
function createOpenAI(options = {}) {
  var _a61, _b;
  const baseURL = (_a61 = withoutTrailingSlash5(
    loadOptionalSetting({
      settingValue: options.baseURL,
      environmentVariableName: "OPENAI_BASE_URL"
    })
  )) != null ? _a61 : "https://api.openai.com/v1";
  const providerName = (_b = options.name) != null ? _b : "openai";
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix6(
    {
      Authorization: `Bearer ${loadApiKey4({
        apiKey: options.apiKey,
        environmentVariableName: "OPENAI_API_KEY",
        description: "OpenAI"
      })}`,
      "OpenAI-Organization": options.organization,
      "OpenAI-Project": options.project,
      ...options.headers
    },
    `ai-sdk/openai/${VERSION10}`
  ), "getHeaders");
  const createChatModel = /* @__PURE__ */ __name((modelId) => new OpenAIChatLanguageModel(modelId, {
    provider: `${providerName}.chat`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createChatModel");
  const createCompletionModel = /* @__PURE__ */ __name((modelId) => new OpenAICompletionLanguageModel(modelId, {
    provider: `${providerName}.completion`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createCompletionModel");
  const createEmbeddingModel = /* @__PURE__ */ __name((modelId) => new OpenAIEmbeddingModel(modelId, {
    provider: `${providerName}.embedding`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createEmbeddingModel");
  const createImageModel = /* @__PURE__ */ __name((modelId) => new OpenAIImageModel(modelId, {
    provider: `${providerName}.image`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createImageModel");
  const createTranscriptionModel = /* @__PURE__ */ __name((modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createTranscriptionModel");
  const createSpeechModel = /* @__PURE__ */ __name((modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    fetch: options.fetch
  }), "createSpeechModel");
  const createLanguageModel = /* @__PURE__ */ __name((modelId) => {
    if (new.target) {
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  }, "createLanguageModel");
  const createResponsesModel = /* @__PURE__ */ __name((modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
      headers: getHeaders,
      fetch: options.fetch,
      fileIdPrefixes: ["file-"]
    });
  }, "createResponsesModel");
  const provider = /* @__PURE__ */ __name(function(modelId) {
    return createLanguageModel(modelId);
  }, "provider");
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.responses = createResponsesModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.speechModel = createSpeechModel;
  provider.tools = openaiTools;
  return provider;
}
var openaiErrorDataSchema, openaiFailedResponseHandler, openaiChatResponseSchema, openaiChatChunkSchema, openaiChatLanguageModelOptions, OpenAIChatLanguageModel, reasoningModels, openaiCompletionResponseSchema, openaiCompletionChunkSchema, openaiCompletionProviderOptions, OpenAICompletionLanguageModel, openaiEmbeddingProviderOptions, openaiTextEmbeddingResponseSchema2, OpenAIEmbeddingModel, openaiImageResponseSchema, modelMaxImagesPerCall, hasDefaultResponseFormat, OpenAIImageModel, codeInterpreterInputSchema, codeInterpreterOutputSchema, codeInterpreterArgsSchema, codeInterpreterToolFactory, codeInterpreter, comparisonFilterSchema, compoundFilterSchema, fileSearchArgsSchema2, fileSearchOutputSchema, fileSearch2, imageGenerationArgsSchema, imageGenerationInputSchema, imageGenerationOutputSchema, imageGenerationToolFactory, imageGeneration, localShellInputSchema, localShellOutputSchema, localShell, webSearchArgsSchema, webSearchInputSchema, webSearchOutputSchema, webSearchToolFactory, webSearch, webSearchPreviewArgsSchema, webSearchPreviewInputSchema, webSearchPreviewOutputSchema, webSearchPreview, openaiTools, openaiResponsesReasoningProviderOptionsSchema, openaiResponsesChunkSchema, openaiResponsesResponseSchema, TOP_LOGPROBS_MAX, openaiResponsesReasoningModelIds, openaiResponsesModelIds, openaiResponsesProviderOptionsSchema, OpenAIResponsesLanguageModel, openaiSpeechProviderOptionsSchema, OpenAISpeechModel, openaiTranscriptionResponseSchema, openAITranscriptionProviderOptions, languageMap, OpenAITranscriptionModel, VERSION10, openai;
var init_dist17 = __esm({
  "node_modules/@ai-sdk/openai-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist16();
    init_dist15();
    init_dist16();
    init_v4();
    init_dist16();
    init_dist15();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist15();
    init_dist16();
    init_dist15();
    init_v4();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist15();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist15();
    init_dist16();
    init_dist15();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    init_dist15();
    init_dist16();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist16();
    init_dist16();
    init_v4();
    init_dist16();
    init_v4();
    openaiErrorDataSchema = external_exports.object({
      error: external_exports.object({
        message: external_exports.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: external_exports.string().nullish(),
        param: external_exports.any().nullish(),
        code: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
      })
    });
    openaiFailedResponseHandler = createJsonErrorResponseHandler5({
      errorSchema: openaiErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    });
    __name(convertToOpenAIChatMessages, "convertToOpenAIChatMessages");
    __name(getResponseMetadata3, "getResponseMetadata");
    __name(mapOpenAIFinishReason, "mapOpenAIFinishReason");
    openaiChatResponseSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          id: external_exports.string().nullish(),
          created: external_exports.number().nullish(),
          model: external_exports.string().nullish(),
          choices: external_exports.array(
            external_exports.object({
              message: external_exports.object({
                role: external_exports.literal("assistant").nullish(),
                content: external_exports.string().nullish(),
                tool_calls: external_exports.array(
                  external_exports.object({
                    id: external_exports.string().nullish(),
                    type: external_exports.literal("function"),
                    function: external_exports.object({
                      name: external_exports.string(),
                      arguments: external_exports.string()
                    })
                  })
                ).nullish(),
                annotations: external_exports.array(
                  external_exports.object({
                    type: external_exports.literal("url_citation"),
                    start_index: external_exports.number(),
                    end_index: external_exports.number(),
                    url: external_exports.string(),
                    title: external_exports.string()
                  })
                ).nullish()
              }),
              index: external_exports.number(),
              logprobs: external_exports.object({
                content: external_exports.array(
                  external_exports.object({
                    token: external_exports.string(),
                    logprob: external_exports.number(),
                    top_logprobs: external_exports.array(
                      external_exports.object({
                        token: external_exports.string(),
                        logprob: external_exports.number()
                      })
                    )
                  })
                ).nullish()
              }).nullish(),
              finish_reason: external_exports.string().nullish()
            })
          ),
          usage: external_exports.object({
            prompt_tokens: external_exports.number().nullish(),
            completion_tokens: external_exports.number().nullish(),
            total_tokens: external_exports.number().nullish(),
            prompt_tokens_details: external_exports.object({
              cached_tokens: external_exports.number().nullish()
            }).nullish(),
            completion_tokens_details: external_exports.object({
              reasoning_tokens: external_exports.number().nullish(),
              accepted_prediction_tokens: external_exports.number().nullish(),
              rejected_prediction_tokens: external_exports.number().nullish()
            }).nullish()
          }).nullish()
        })
      )
    );
    openaiChatChunkSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.union([
          external_exports.object({
            id: external_exports.string().nullish(),
            created: external_exports.number().nullish(),
            model: external_exports.string().nullish(),
            choices: external_exports.array(
              external_exports.object({
                delta: external_exports.object({
                  role: external_exports.enum(["assistant"]).nullish(),
                  content: external_exports.string().nullish(),
                  tool_calls: external_exports.array(
                    external_exports.object({
                      index: external_exports.number(),
                      id: external_exports.string().nullish(),
                      type: external_exports.literal("function").nullish(),
                      function: external_exports.object({
                        name: external_exports.string().nullish(),
                        arguments: external_exports.string().nullish()
                      })
                    })
                  ).nullish(),
                  annotations: external_exports.array(
                    external_exports.object({
                      type: external_exports.literal("url_citation"),
                      start_index: external_exports.number(),
                      end_index: external_exports.number(),
                      url: external_exports.string(),
                      title: external_exports.string()
                    })
                  ).nullish()
                }).nullish(),
                logprobs: external_exports.object({
                  content: external_exports.array(
                    external_exports.object({
                      token: external_exports.string(),
                      logprob: external_exports.number(),
                      top_logprobs: external_exports.array(
                        external_exports.object({
                          token: external_exports.string(),
                          logprob: external_exports.number()
                        })
                      )
                    })
                  ).nullish()
                }).nullish(),
                finish_reason: external_exports.string().nullish(),
                index: external_exports.number()
              })
            ),
            usage: external_exports.object({
              prompt_tokens: external_exports.number().nullish(),
              completion_tokens: external_exports.number().nullish(),
              total_tokens: external_exports.number().nullish(),
              prompt_tokens_details: external_exports.object({
                cached_tokens: external_exports.number().nullish()
              }).nullish(),
              completion_tokens_details: external_exports.object({
                reasoning_tokens: external_exports.number().nullish(),
                accepted_prediction_tokens: external_exports.number().nullish(),
                rejected_prediction_tokens: external_exports.number().nullish()
              }).nullish()
            }).nullish()
          }),
          openaiErrorDataSchema
        ])
      )
    );
    openaiChatLanguageModelOptions = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          /**
           * Modify the likelihood of specified tokens appearing in the completion.
           *
           * Accepts a JSON object that maps tokens (specified by their token ID in
           * the GPT tokenizer) to an associated bias value from -100 to 100.
           */
          logitBias: external_exports.record(external_exports.coerce.number(), external_exports.number()).optional(),
          /**
           * Return the log probabilities of the tokens.
           *
           * Setting to true will return the log probabilities of the tokens that
           * were generated.
           *
           * Setting to a number will return the log probabilities of the top n
           * tokens that were generated.
           */
          logprobs: external_exports.union([external_exports.boolean(), external_exports.number()]).optional(),
          /**
           * Whether to enable parallel function calling during tool use. Default to true.
           */
          parallelToolCalls: external_exports.boolean().optional(),
          /**
           * A unique identifier representing your end-user, which can help OpenAI to
           * monitor and detect abuse.
           */
          user: external_exports.string().optional(),
          /**
           * Reasoning effort for reasoning models. Defaults to `medium`.
           */
          reasoningEffort: external_exports.enum(["minimal", "low", "medium", "high"]).optional(),
          /**
           * Maximum number of completion tokens to generate. Useful for reasoning models.
           */
          maxCompletionTokens: external_exports.number().optional(),
          /**
           * Whether to enable persistence in responses API.
           */
          store: external_exports.boolean().optional(),
          /**
           * Metadata to associate with the request.
           */
          metadata: external_exports.record(external_exports.string().max(64), external_exports.string().max(512)).optional(),
          /**
           * Parameters for prediction mode.
           */
          prediction: external_exports.record(external_exports.string(), external_exports.any()).optional(),
          /**
           * Whether to use structured outputs.
           *
           * @default true
           */
          structuredOutputs: external_exports.boolean().optional(),
          /**
           * Service tier for the request.
           * - 'auto': Default service tier. The request will be processed with the service tier configured in the
           *           Project settings. Unless otherwise configured, the Project will use 'default'.
           * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
           * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
           * - 'default': The request will be processed with the standard pricing and performance for the selected model.
           *
           * @default 'auto'
           */
          serviceTier: external_exports.enum(["auto", "flex", "priority", "default"]).optional(),
          /**
           * Whether to use strict JSON schema validation.
           *
           * @default false
           */
          strictJsonSchema: external_exports.boolean().optional(),
          /**
           * Controls the verbosity of the model's responses.
           * Lower values will result in more concise responses, while higher values will result in more verbose responses.
           */
          textVerbosity: external_exports.enum(["low", "medium", "high"]).optional(),
          /**
           * A cache key for prompt caching. Allows manual control over prompt caching behavior.
           * Useful for improving cache hit rates and working around automatic caching issues.
           */
          promptCacheKey: external_exports.string().optional(),
          /**
           * A stable identifier used to help detect users of your application
           * that may be violating OpenAI's usage policies. The IDs should be a
           * string that uniquely identifies each user. We recommend hashing their
           * username or email address, in order to avoid sending us any identifying
           * information.
           */
          safetyIdentifier: external_exports.string().optional()
        })
      )
    );
    __name(prepareChatTools, "prepareChatTools");
    OpenAIChatLanguageModel = class {
      static {
        __name(this, "OpenAIChatLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        const openaiOptions = (_a61 = await parseProviderOptions5({
          provider: "openai",
          providerOptions,
          schema: openaiChatLanguageModelOptions
        })) != null ? _a61 : {};
        const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
        if (topK != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "topK"
          });
        }
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format schema is only supported with structuredOutputs"
          });
        }
        const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
          {
            prompt,
            systemMessageMode: getSystemMessageMode(this.modelId)
          }
        );
        warnings.push(...messageWarnings);
        const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
        const baseArgs = {
          // model id:
          model: this.modelId,
          // model specific settings:
          logit_bias: openaiOptions.logitBias,
          logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
          top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
          user: openaiOptions.user,
          parallel_tool_calls: openaiOptions.parallelToolCalls,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              schema: responseFormat.schema,
              strict: strictJsonSchema,
              name: (_d = responseFormat.name) != null ? _d : "response",
              description: responseFormat.description
            }
          } : { type: "json_object" } : void 0,
          stop: stopSequences,
          seed,
          verbosity: openaiOptions.textVerbosity,
          // openai specific settings:
          // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
          max_completion_tokens: openaiOptions.maxCompletionTokens,
          store: openaiOptions.store,
          metadata: openaiOptions.metadata,
          prediction: openaiOptions.prediction,
          reasoning_effort: openaiOptions.reasoningEffort,
          service_tier: openaiOptions.serviceTier,
          prompt_cache_key: openaiOptions.promptCacheKey,
          safety_identifier: openaiOptions.safetyIdentifier,
          // messages:
          messages
        };
        if (isReasoningModel(this.modelId)) {
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "temperature",
              details: "temperature is not supported for reasoning models"
            });
          }
          if (baseArgs.top_p != null) {
            baseArgs.top_p = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "topP",
              details: "topP is not supported for reasoning models"
            });
          }
          if (baseArgs.frequency_penalty != null) {
            baseArgs.frequency_penalty = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "frequencyPenalty",
              details: "frequencyPenalty is not supported for reasoning models"
            });
          }
          if (baseArgs.presence_penalty != null) {
            baseArgs.presence_penalty = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "presencePenalty",
              details: "presencePenalty is not supported for reasoning models"
            });
          }
          if (baseArgs.logit_bias != null) {
            baseArgs.logit_bias = void 0;
            warnings.push({
              type: "other",
              message: "logitBias is not supported for reasoning models"
            });
          }
          if (baseArgs.logprobs != null) {
            baseArgs.logprobs = void 0;
            warnings.push({
              type: "other",
              message: "logprobs is not supported for reasoning models"
            });
          }
          if (baseArgs.top_logprobs != null) {
            baseArgs.top_logprobs = void 0;
            warnings.push({
              type: "other",
              message: "topLogprobs is not supported for reasoning models"
            });
          }
          if (baseArgs.max_tokens != null) {
            if (baseArgs.max_completion_tokens == null) {
              baseArgs.max_completion_tokens = baseArgs.max_tokens;
            }
            baseArgs.max_tokens = void 0;
          }
        } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "temperature",
              details: "temperature is not supported for the search preview models and has been removed."
            });
          }
        }
        if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
          warnings.push({
            type: "unsupported-setting",
            setting: "serviceTier",
            details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
          });
          baseArgs.service_tier = void 0;
        }
        if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
          warnings.push({
            type: "unsupported-setting",
            setting: "serviceTier",
            details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
          });
          baseArgs.service_tier = void 0;
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = prepareChatTools({
          tools,
          toolChoice,
          structuredOutputs,
          strictJsonSchema
        });
        return {
          args: {
            ...baseArgs,
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        const { args: body, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi5({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = response.choices[0];
        const content = [];
        const text3 = choice.message.content;
        if (text3 != null && text3.length > 0) {
          content.push({ type: "text", text: text3 });
        }
        for (const toolCall of (_a61 = choice.message.tool_calls) != null ? _a61 : []) {
          content.push({
            type: "tool-call",
            toolCallId: (_b = toolCall.id) != null ? _b : generateId8(),
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
        for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
          content.push({
            type: "source",
            sourceType: "url",
            id: generateId8(),
            url: annotation.url,
            title: annotation.title
          });
        }
        const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
        const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
        const providerMetadata = { openai: {} };
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
          providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
        }
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
          providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
        }
        if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
          providerMetadata.openai.logprobs = choice.logprobs.content;
        }
        return {
          content,
          finishReason: mapOpenAIFinishReason(choice.finish_reason),
          usage: {
            inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
            outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
            totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
            reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
            cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
          },
          request: { body },
          response: {
            ...getResponseMetadata3(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings,
          providerMetadata
        };
      }
      async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const body = {
          ...args,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const { responseHeaders, value: response } = await postJsonToApi5({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler5(
            openaiChatChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let isFirstChunk = true;
        let isActiveText = false;
        const providerMetadata = { openai: {} };
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata3(value)
                  });
                }
                if (value.usage != null) {
                  usage.inputTokens = (_a61 = value.usage.prompt_tokens) != null ? _a61 : void 0;
                  usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                  usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                  usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
                  usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                  if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                    providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                  }
                  if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                    providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                  }
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenAIFinishReason(choice.finish_reason);
                }
                if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                  providerMetadata.openai.logprobs = choice.logprobs.content;
                }
                if ((choice == null ? void 0 : choice.delta) == null) {
                  return;
                }
                const delta = choice.delta;
                if (delta.content != null) {
                  if (!isActiveText) {
                    controller.enqueue({ type: "text-start", id: "0" });
                    isActiveText = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: delta.content
                  });
                }
                if (delta.tool_calls != null) {
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = toolCallDelta.index;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.type !== "function") {
                        throw new InvalidResponseDataError3({
                          data: toolCallDelta,
                          message: `Expected 'function' type.`
                        });
                      }
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError3({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                        throw new InvalidResponseDataError3({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCallDelta.id,
                        toolName: toolCallDelta.function.name
                      });
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                        },
                        hasFinished: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                        if (toolCall2.function.arguments.length > 0) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall2.id,
                            delta: toolCall2.function.arguments
                          });
                        }
                        if (isParsableJson2(toolCall2.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall2.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_q = toolCall2.id) != null ? _q : generateId8(),
                            toolName: toolCall2.function.name,
                            input: toolCall2.function.arguments
                          });
                          toolCall2.hasFinished = true;
                        }
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall.hasFinished) {
                      continue;
                    }
                    if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                      toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                    });
                    if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson2(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_x = toolCall.id) != null ? _x : generateId8(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                      toolCall.hasFinished = true;
                    }
                  }
                }
                if (delta.annotations != null) {
                  for (const annotation of delta.annotations) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: generateId8(),
                      url: annotation.url,
                      title: annotation.title
                    });
                  }
                }
              },
              flush(controller) {
                if (isActiveText) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  ...providerMetadata != null ? { providerMetadata } : {}
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    __name(isReasoningModel, "isReasoningModel");
    __name(supportsFlexProcessing, "supportsFlexProcessing");
    __name(supportsPriorityProcessing, "supportsPriorityProcessing");
    __name(getSystemMessageMode, "getSystemMessageMode");
    reasoningModels = {
      "o1-mini": {
        systemMessageMode: "remove"
      },
      "o1-mini-2024-09-12": {
        systemMessageMode: "remove"
      },
      "o1-preview": {
        systemMessageMode: "remove"
      },
      "o1-preview-2024-09-12": {
        systemMessageMode: "remove"
      },
      o3: {
        systemMessageMode: "developer"
      },
      "o3-2025-04-16": {
        systemMessageMode: "developer"
      },
      "o3-mini": {
        systemMessageMode: "developer"
      },
      "o3-mini-2025-01-31": {
        systemMessageMode: "developer"
      },
      "o4-mini": {
        systemMessageMode: "developer"
      },
      "o4-mini-2025-04-16": {
        systemMessageMode: "developer"
      }
    };
    __name(convertToOpenAICompletionPrompt, "convertToOpenAICompletionPrompt");
    __name(getResponseMetadata23, "getResponseMetadata2");
    __name(mapOpenAIFinishReason2, "mapOpenAIFinishReason2");
    openaiCompletionResponseSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          id: external_exports.string().nullish(),
          created: external_exports.number().nullish(),
          model: external_exports.string().nullish(),
          choices: external_exports.array(
            external_exports.object({
              text: external_exports.string(),
              finish_reason: external_exports.string(),
              logprobs: external_exports.object({
                tokens: external_exports.array(external_exports.string()),
                token_logprobs: external_exports.array(external_exports.number()),
                top_logprobs: external_exports.array(external_exports.record(external_exports.string(), external_exports.number())).nullish()
              }).nullish()
            })
          ),
          usage: external_exports.object({
            prompt_tokens: external_exports.number(),
            completion_tokens: external_exports.number(),
            total_tokens: external_exports.number()
          }).nullish()
        })
      )
    );
    openaiCompletionChunkSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.union([
          external_exports.object({
            id: external_exports.string().nullish(),
            created: external_exports.number().nullish(),
            model: external_exports.string().nullish(),
            choices: external_exports.array(
              external_exports.object({
                text: external_exports.string(),
                finish_reason: external_exports.string().nullish(),
                index: external_exports.number(),
                logprobs: external_exports.object({
                  tokens: external_exports.array(external_exports.string()),
                  token_logprobs: external_exports.array(external_exports.number()),
                  top_logprobs: external_exports.array(external_exports.record(external_exports.string(), external_exports.number())).nullish()
                }).nullish()
              })
            ),
            usage: external_exports.object({
              prompt_tokens: external_exports.number(),
              completion_tokens: external_exports.number(),
              total_tokens: external_exports.number()
            }).nullish()
          }),
          openaiErrorDataSchema
        ])
      )
    );
    openaiCompletionProviderOptions = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          /**
          Echo back the prompt in addition to the completion.
             */
          echo: external_exports.boolean().optional(),
          /**
          Modify the likelihood of specified tokens appearing in the completion.
          
          Accepts a JSON object that maps tokens (specified by their token ID in
          the GPT tokenizer) to an associated bias value from -100 to 100. You
          can use this tokenizer tool to convert text to token IDs. Mathematically,
          the bias is added to the logits generated by the model prior to sampling.
          The exact effect will vary per model, but values between -1 and 1 should
          decrease or increase likelihood of selection; values like -100 or 100
          should result in a ban or exclusive selection of the relevant token.
          
          As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
          token from being generated.
           */
          logitBias: external_exports.record(external_exports.string(), external_exports.number()).optional(),
          /**
          The suffix that comes after a completion of inserted text.
           */
          suffix: external_exports.string().optional(),
          /**
          A unique identifier representing your end-user, which can help OpenAI to
          monitor and detect abuse. Learn more.
           */
          user: external_exports.string().optional(),
          /**
          Return the log probabilities of the tokens. Including logprobs will increase
          the response size and can slow down response times. However, it can
          be useful to better understand how the model is behaving.
          Setting to true will return the log probabilities of the tokens that
          were generated.
          Setting to a number will return the log probabilities of the top n
          tokens that were generated.
             */
          logprobs: external_exports.union([external_exports.boolean(), external_exports.number()]).optional()
        })
      )
    );
    OpenAICompletionLanguageModel = class {
      static {
        __name(this, "OpenAICompletionLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.supportedUrls = {
          // No URLs are supported for completion models.
        };
        this.modelId = modelId;
        this.config = config4;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences: userStopSequences,
        responseFormat,
        tools,
        toolChoice,
        seed,
        providerOptions
      }) {
        const warnings = [];
        const openaiOptions = {
          ...await parseProviderOptions5({
            provider: "openai",
            providerOptions,
            schema: openaiCompletionProviderOptions
          }),
          ...await parseProviderOptions5({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompletionProviderOptions
          })
        };
        if (topK != null) {
          warnings.push({ type: "unsupported-setting", setting: "topK" });
        }
        if (tools == null ? void 0 : tools.length) {
          warnings.push({ type: "unsupported-setting", setting: "tools" });
        }
        if (toolChoice != null) {
          warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
        }
        if (responseFormat != null && responseFormat.type !== "text") {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format is not supported."
          });
        }
        const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
        const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            echo: openaiOptions.echo,
            logit_bias: openaiOptions.logitBias,
            logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
            suffix: openaiOptions.suffix,
            user: openaiOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            seed,
            // prompt:
            prompt: completionPrompt,
            // stop sequences:
            stop: stop.length > 0 ? stop : void 0
          },
          warnings
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c;
        const { args, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi5({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body: args,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = response.choices[0];
        const providerMetadata = { openai: {} };
        if (choice.logprobs != null) {
          providerMetadata.openai.logprobs = choice.logprobs;
        }
        return {
          content: [{ type: "text", text: choice.text }],
          usage: {
            inputTokens: (_a61 = response.usage) == null ? void 0 : _a61.prompt_tokens,
            outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
            totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
          },
          finishReason: mapOpenAIFinishReason2(choice.finish_reason),
          request: { body: args },
          response: {
            ...getResponseMetadata23(response),
            headers: responseHeaders,
            body: rawResponse
          },
          providerMetadata,
          warnings
        };
      }
      async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const body = {
          ...args,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const { responseHeaders, value: response } = await postJsonToApi5({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler5(
            openaiCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const providerMetadata = { openai: {} };
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let isFirstChunk = true;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata23(value)
                  });
                  controller.enqueue({ type: "text-start", id: "0" });
                }
                if (value.usage != null) {
                  usage.inputTokens = value.usage.prompt_tokens;
                  usage.outputTokens = value.usage.completion_tokens;
                  usage.totalTokens = value.usage.total_tokens;
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenAIFinishReason2(choice.finish_reason);
                }
                if ((choice == null ? void 0 : choice.logprobs) != null) {
                  providerMetadata.openai.logprobs = choice.logprobs;
                }
                if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: choice.text
                  });
                }
              },
              flush(controller) {
                if (!isFirstChunk) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  providerMetadata,
                  usage
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiEmbeddingProviderOptions = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          /**
          The number of dimensions the resulting output embeddings should have.
          Only supported in text-embedding-3 and later models.
             */
          dimensions: external_exports.number().optional(),
          /**
          A unique identifier representing your end-user, which can help OpenAI to
          monitor and detect abuse. Learn more.
          */
          user: external_exports.string().optional()
        })
      )
    );
    openaiTextEmbeddingResponseSchema2 = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          data: external_exports.array(external_exports.object({ embedding: external_exports.array(external_exports.number()) })),
          usage: external_exports.object({ prompt_tokens: external_exports.number() }).nullish()
        })
      )
    );
    OpenAIEmbeddingModel = class {
      static {
        __name(this, "OpenAIEmbeddingModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a61;
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError5({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const openaiOptions = (_a61 = await parseProviderOptions5({
          provider: "openai",
          providerOptions,
          schema: openaiEmbeddingProviderOptions
        })) != null ? _a61 : {};
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi5({
          url: this.config.url({
            path: "/embeddings",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), headers),
          body: {
            model: this.modelId,
            input: values,
            encoding_format: "float",
            dimensions: openaiOptions.dimensions,
            user: openaiOptions.user
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiTextEmbeddingResponseSchema2
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: response.data.map((item) => item.embedding),
          usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    openaiImageResponseSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          data: external_exports.array(
            external_exports.object({
              b64_json: external_exports.string(),
              revised_prompt: external_exports.string().optional()
            })
          )
        })
      )
    );
    modelMaxImagesPerCall = {
      "dall-e-3": 1,
      "dall-e-2": 10,
      "gpt-image-1": 10,
      "gpt-image-1-mini": 10
    };
    hasDefaultResponseFormat = /* @__PURE__ */ new Set([
      "gpt-image-1",
      "gpt-image-1-mini"
    ]);
    OpenAIImageModel = class {
      static {
        __name(this, "OpenAIImageModel");
      }
      constructor(modelId, config4) {
        this.modelId = modelId;
        this.config = config4;
        this.specificationVersion = "v2";
      }
      get maxImagesPerCall() {
        var _a61;
        return (_a61 = modelMaxImagesPerCall[this.modelId]) != null ? _a61 : 1;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        if (aspectRatio != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported-setting", setting: "seed" });
        }
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const { value: response, responseHeaders } = await postJsonToApi5({
          url: this.config.url({
            path: "/images/generations",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), headers),
          body: {
            model: this.modelId,
            prompt,
            n,
            size,
            ...(_d = providerOptions.openai) != null ? _d : {},
            ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.data.map((item) => item.b64_json),
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          },
          providerMetadata: {
            openai: {
              images: response.data.map(
                (item) => item.revised_prompt ? {
                  revisedPrompt: item.revised_prompt
                } : null
              )
            }
          }
        };
      }
    };
    codeInterpreterInputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          code: external_exports.string().nullish(),
          containerId: external_exports.string()
        })
      )
    );
    codeInterpreterOutputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          outputs: external_exports.array(
            external_exports.discriminatedUnion("type", [
              external_exports.object({ type: external_exports.literal("logs"), logs: external_exports.string() }),
              external_exports.object({ type: external_exports.literal("image"), url: external_exports.string() })
            ])
          ).nullish()
        })
      )
    );
    codeInterpreterArgsSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          container: external_exports.union([
            external_exports.string(),
            external_exports.object({
              fileIds: external_exports.array(external_exports.string()).optional()
            })
          ]).optional()
        })
      )
    );
    codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.code_interpreter",
      name: "code_interpreter",
      inputSchema: codeInterpreterInputSchema,
      outputSchema: codeInterpreterOutputSchema
    });
    codeInterpreter = /* @__PURE__ */ __name((args = {}) => {
      return codeInterpreterToolFactory(args);
    }, "codeInterpreter");
    comparisonFilterSchema = external_exports.object({
      key: external_exports.string(),
      type: external_exports.enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
      value: external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean()])
    });
    compoundFilterSchema = external_exports.object({
      type: external_exports.enum(["and", "or"]),
      filters: external_exports.array(
        external_exports.union([comparisonFilterSchema, external_exports.lazy(() => compoundFilterSchema)])
      )
    });
    fileSearchArgsSchema2 = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          vectorStoreIds: external_exports.array(external_exports.string()),
          maxNumResults: external_exports.number().optional(),
          ranking: external_exports.object({
            ranker: external_exports.string().optional(),
            scoreThreshold: external_exports.number().optional()
          }).optional(),
          filters: external_exports.union([comparisonFilterSchema, compoundFilterSchema]).optional()
        })
      )
    );
    fileSearchOutputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          queries: external_exports.array(external_exports.string()),
          results: external_exports.array(
            external_exports.object({
              attributes: external_exports.record(external_exports.string(), external_exports.unknown()),
              fileId: external_exports.string(),
              filename: external_exports.string(),
              score: external_exports.number(),
              text: external_exports.string()
            })
          ).nullable()
        })
      )
    );
    fileSearch2 = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.file_search",
      name: "file_search",
      inputSchema: external_exports.object({}),
      outputSchema: fileSearchOutputSchema
    });
    imageGenerationArgsSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          background: external_exports.enum(["auto", "opaque", "transparent"]).optional(),
          inputFidelity: external_exports.enum(["low", "high"]).optional(),
          inputImageMask: external_exports.object({
            fileId: external_exports.string().optional(),
            imageUrl: external_exports.string().optional()
          }).optional(),
          model: external_exports.string().optional(),
          moderation: external_exports.enum(["auto"]).optional(),
          outputCompression: external_exports.number().int().min(0).max(100).optional(),
          outputFormat: external_exports.enum(["png", "jpeg", "webp"]).optional(),
          partialImages: external_exports.number().int().min(0).max(3).optional(),
          quality: external_exports.enum(["auto", "low", "medium", "high"]).optional(),
          size: external_exports.enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
        }).strict()
      )
    );
    imageGenerationInputSchema = lazySchema3(() => zodSchema5(external_exports.object({})));
    imageGenerationOutputSchema = lazySchema3(
      () => zodSchema5(external_exports.object({ result: external_exports.string() }))
    );
    imageGenerationToolFactory = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.image_generation",
      name: "image_generation",
      inputSchema: imageGenerationInputSchema,
      outputSchema: imageGenerationOutputSchema
    });
    imageGeneration = /* @__PURE__ */ __name((args = {}) => {
      return imageGenerationToolFactory(args);
    }, "imageGeneration");
    localShellInputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          action: external_exports.object({
            type: external_exports.literal("exec"),
            command: external_exports.array(external_exports.string()),
            timeoutMs: external_exports.number().optional(),
            user: external_exports.string().optional(),
            workingDirectory: external_exports.string().optional(),
            env: external_exports.record(external_exports.string(), external_exports.string()).optional()
          })
        })
      )
    );
    localShellOutputSchema = lazySchema3(
      () => zodSchema5(external_exports.object({ output: external_exports.string() }))
    );
    localShell = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.local_shell",
      name: "local_shell",
      inputSchema: localShellInputSchema,
      outputSchema: localShellOutputSchema
    });
    webSearchArgsSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          filters: external_exports.object({ allowedDomains: external_exports.array(external_exports.string()).optional() }).optional(),
          searchContextSize: external_exports.enum(["low", "medium", "high"]).optional(),
          userLocation: external_exports.object({
            type: external_exports.literal("approximate"),
            country: external_exports.string().optional(),
            city: external_exports.string().optional(),
            region: external_exports.string().optional(),
            timezone: external_exports.string().optional()
          }).optional()
        })
      )
    );
    webSearchInputSchema = lazySchema3(() => zodSchema5(external_exports.object({})));
    webSearchOutputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          action: external_exports.discriminatedUnion("type", [
            external_exports.object({
              type: external_exports.literal("search"),
              query: external_exports.string().optional()
            }),
            external_exports.object({
              type: external_exports.literal("openPage"),
              url: external_exports.string()
            }),
            external_exports.object({
              type: external_exports.literal("find"),
              url: external_exports.string(),
              pattern: external_exports.string()
            })
          ])
        })
      )
    );
    webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.web_search",
      name: "web_search",
      inputSchema: webSearchInputSchema,
      outputSchema: webSearchOutputSchema
    });
    webSearch = /* @__PURE__ */ __name((args = {}) => webSearchToolFactory(args), "webSearch");
    webSearchPreviewArgsSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          searchContextSize: external_exports.enum(["low", "medium", "high"]).optional(),
          userLocation: external_exports.object({
            type: external_exports.literal("approximate"),
            country: external_exports.string().optional(),
            city: external_exports.string().optional(),
            region: external_exports.string().optional(),
            timezone: external_exports.string().optional()
          }).optional()
        })
      )
    );
    webSearchPreviewInputSchema = lazySchema3(
      () => zodSchema5(external_exports.object({}))
    );
    webSearchPreviewOutputSchema = lazySchema3(
      () => zodSchema5(
        external_exports.object({
          action: external_exports.discriminatedUnion("type", [
            external_exports.object({
              type: external_exports.literal("search"),
              query: external_exports.string().optional()
            }),
            external_exports.object({
              type: external_exports.literal("openPage"),
              url: external_exports.string()
            }),
            external_exports.object({
              type: external_exports.literal("find"),
              url: external_exports.string(),
              pattern: external_exports.string()
            })
          ])
        })
      )
    );
    webSearchPreview = createProviderDefinedToolFactoryWithOutputSchema3({
      id: "openai.web_search_preview",
      name: "web_search_preview",
      inputSchema: webSearchPreviewInputSchema,
      outputSchema: webSearchPreviewOutputSchema
    });
    openaiTools = {
      /**
       * The Code Interpreter tool allows models to write and run Python code in a
       * sandboxed environment to solve complex problems in domains like data analysis,
       * coding, and math.
       *
       * @param container - The container to use for the code interpreter.
       *
       * Must have name `code_interpreter`.
       */
      codeInterpreter,
      /**
       * File search is a tool available in the Responses API. It enables models to
       * retrieve information in a knowledge base of previously uploaded files through
       * semantic and keyword search.
       *
       * Must have name `file_search`.
       *
       * @param vectorStoreIds - The vector store IDs to use for the file search.
       * @param maxNumResults - The maximum number of results to return.
       * @param ranking - The ranking options to use for the file search.
       * @param filters - The filters to use for the file search.
       */
      fileSearch: fileSearch2,
      /**
       * The image generation tool allows you to generate images using a text prompt,
       * and optionally image inputs. It leverages the GPT Image model,
       * and automatically optimizes text inputs for improved performance.
       *
       * Must have name `image_generation`.
       *
       * @param size - Image dimensions (e.g., 1024x1024, 1024x1536)
       * @param quality - Rendering quality (e.g. low, medium, high)
       * @param format - File output format
       * @param compression - Compression level (0-100%) for JPEG and WebP formats
       * @param background - Transparent or opaque
       */
      imageGeneration,
      /**
       * Local shell is a tool that allows agents to run shell commands locally
       * on a machine you or the user provides.
       *
       * Supported models: `gpt-5-codex` and `codex-mini-latest`
       *
       * Must have name `local_shell`.
       */
      localShell,
      /**
       * Web search allows models to access up-to-date information from the internet
       * and provide answers with sourced citations.
       *
       * Must have name `web_search_preview`.
       *
       * @param searchContextSize - The search context size to use for the web search.
       * @param userLocation - The user location to use for the web search.
       *
       * @deprecated Use `webSearch` instead.
       */
      webSearchPreview,
      /**
       * Web search allows models to access up-to-date information from the internet
       * and provide answers with sourced citations.
       *
       * Must have name `web_search`.
       *
       * @param filters - The filters to use for the web search.
       * @param searchContextSize - The search context size to use for the web search.
       * @param userLocation - The user location to use for the web search.
       */
      webSearch
    };
    __name(isFileId, "isFileId");
    __name(convertToOpenAIResponsesInput, "convertToOpenAIResponsesInput");
    openaiResponsesReasoningProviderOptionsSchema = external_exports.object({
      itemId: external_exports.string().nullish(),
      reasoningEncryptedContent: external_exports.string().nullish()
    });
    __name(mapOpenAIResponseFinishReason, "mapOpenAIResponseFinishReason");
    openaiResponsesChunkSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.union([
          external_exports.object({
            type: external_exports.literal("response.output_text.delta"),
            item_id: external_exports.string(),
            delta: external_exports.string(),
            logprobs: external_exports.array(
              external_exports.object({
                token: external_exports.string(),
                logprob: external_exports.number(),
                top_logprobs: external_exports.array(
                  external_exports.object({
                    token: external_exports.string(),
                    logprob: external_exports.number()
                  })
                )
              })
            ).nullish()
          }),
          external_exports.object({
            type: external_exports.enum(["response.completed", "response.incomplete"]),
            response: external_exports.object({
              incomplete_details: external_exports.object({ reason: external_exports.string() }).nullish(),
              usage: external_exports.object({
                input_tokens: external_exports.number(),
                input_tokens_details: external_exports.object({ cached_tokens: external_exports.number().nullish() }).nullish(),
                output_tokens: external_exports.number(),
                output_tokens_details: external_exports.object({ reasoning_tokens: external_exports.number().nullish() }).nullish()
              }),
              service_tier: external_exports.string().nullish()
            })
          }),
          external_exports.object({
            type: external_exports.literal("response.created"),
            response: external_exports.object({
              id: external_exports.string(),
              created_at: external_exports.number(),
              model: external_exports.string(),
              service_tier: external_exports.string().nullish()
            })
          }),
          external_exports.object({
            type: external_exports.literal("response.output_item.added"),
            output_index: external_exports.number(),
            item: external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("message"),
                id: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("reasoning"),
                id: external_exports.string(),
                encrypted_content: external_exports.string().nullish()
              }),
              external_exports.object({
                type: external_exports.literal("function_call"),
                id: external_exports.string(),
                call_id: external_exports.string(),
                name: external_exports.string(),
                arguments: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("web_search_call"),
                id: external_exports.string(),
                status: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("computer_call"),
                id: external_exports.string(),
                status: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("file_search_call"),
                id: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("image_generation_call"),
                id: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("code_interpreter_call"),
                id: external_exports.string(),
                container_id: external_exports.string(),
                code: external_exports.string().nullable(),
                outputs: external_exports.array(
                  external_exports.discriminatedUnion("type", [
                    external_exports.object({ type: external_exports.literal("logs"), logs: external_exports.string() }),
                    external_exports.object({ type: external_exports.literal("image"), url: external_exports.string() })
                  ])
                ).nullable(),
                status: external_exports.string()
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("response.output_item.done"),
            output_index: external_exports.number(),
            item: external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("message"),
                id: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("reasoning"),
                id: external_exports.string(),
                encrypted_content: external_exports.string().nullish()
              }),
              external_exports.object({
                type: external_exports.literal("function_call"),
                id: external_exports.string(),
                call_id: external_exports.string(),
                name: external_exports.string(),
                arguments: external_exports.string(),
                status: external_exports.literal("completed")
              }),
              external_exports.object({
                type: external_exports.literal("code_interpreter_call"),
                id: external_exports.string(),
                code: external_exports.string().nullable(),
                container_id: external_exports.string(),
                outputs: external_exports.array(
                  external_exports.discriminatedUnion("type", [
                    external_exports.object({ type: external_exports.literal("logs"), logs: external_exports.string() }),
                    external_exports.object({ type: external_exports.literal("image"), url: external_exports.string() })
                  ])
                ).nullable()
              }),
              external_exports.object({
                type: external_exports.literal("image_generation_call"),
                id: external_exports.string(),
                result: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("web_search_call"),
                id: external_exports.string(),
                status: external_exports.string(),
                action: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("search"),
                    query: external_exports.string().nullish()
                  }),
                  external_exports.object({
                    type: external_exports.literal("open_page"),
                    url: external_exports.string()
                  }),
                  external_exports.object({
                    type: external_exports.literal("find"),
                    url: external_exports.string(),
                    pattern: external_exports.string()
                  })
                ])
              }),
              external_exports.object({
                type: external_exports.literal("file_search_call"),
                id: external_exports.string(),
                queries: external_exports.array(external_exports.string()),
                results: external_exports.array(
                  external_exports.object({
                    attributes: external_exports.record(external_exports.string(), external_exports.unknown()),
                    file_id: external_exports.string(),
                    filename: external_exports.string(),
                    score: external_exports.number(),
                    text: external_exports.string()
                  })
                ).nullish()
              }),
              external_exports.object({
                type: external_exports.literal("local_shell_call"),
                id: external_exports.string(),
                call_id: external_exports.string(),
                action: external_exports.object({
                  type: external_exports.literal("exec"),
                  command: external_exports.array(external_exports.string()),
                  timeout_ms: external_exports.number().optional(),
                  user: external_exports.string().optional(),
                  working_directory: external_exports.string().optional(),
                  env: external_exports.record(external_exports.string(), external_exports.string()).optional()
                })
              }),
              external_exports.object({
                type: external_exports.literal("computer_call"),
                id: external_exports.string(),
                status: external_exports.literal("completed")
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("response.function_call_arguments.delta"),
            item_id: external_exports.string(),
            output_index: external_exports.number(),
            delta: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("response.image_generation_call.partial_image"),
            item_id: external_exports.string(),
            output_index: external_exports.number(),
            partial_image_b64: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("response.code_interpreter_call_code.delta"),
            item_id: external_exports.string(),
            output_index: external_exports.number(),
            delta: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("response.code_interpreter_call_code.done"),
            item_id: external_exports.string(),
            output_index: external_exports.number(),
            code: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("response.output_text.annotation.added"),
            annotation: external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("url_citation"),
                url: external_exports.string(),
                title: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("file_citation"),
                file_id: external_exports.string(),
                filename: external_exports.string().nullish(),
                index: external_exports.number().nullish(),
                start_index: external_exports.number().nullish(),
                end_index: external_exports.number().nullish(),
                quote: external_exports.string().nullish()
              })
            ])
          }),
          external_exports.object({
            type: external_exports.literal("response.reasoning_summary_part.added"),
            item_id: external_exports.string(),
            summary_index: external_exports.number()
          }),
          external_exports.object({
            type: external_exports.literal("response.reasoning_summary_text.delta"),
            item_id: external_exports.string(),
            summary_index: external_exports.number(),
            delta: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("response.reasoning_summary_part.done"),
            item_id: external_exports.string(),
            summary_index: external_exports.number()
          }),
          external_exports.object({
            type: external_exports.literal("error"),
            code: external_exports.string(),
            message: external_exports.string(),
            param: external_exports.string().nullish(),
            sequence_number: external_exports.number()
          }),
          external_exports.object({ type: external_exports.string() }).loose().transform((value) => ({
            type: "unknown_chunk",
            message: value.type
          }))
          // fallback for unknown chunks
        ])
      )
    );
    openaiResponsesResponseSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          id: external_exports.string(),
          created_at: external_exports.number(),
          error: external_exports.object({
            code: external_exports.string(),
            message: external_exports.string()
          }).nullish(),
          model: external_exports.string(),
          output: external_exports.array(
            external_exports.discriminatedUnion("type", [
              external_exports.object({
                type: external_exports.literal("message"),
                role: external_exports.literal("assistant"),
                id: external_exports.string(),
                content: external_exports.array(
                  external_exports.object({
                    type: external_exports.literal("output_text"),
                    text: external_exports.string(),
                    logprobs: external_exports.array(
                      external_exports.object({
                        token: external_exports.string(),
                        logprob: external_exports.number(),
                        top_logprobs: external_exports.array(
                          external_exports.object({
                            token: external_exports.string(),
                            logprob: external_exports.number()
                          })
                        )
                      })
                    ).nullish(),
                    annotations: external_exports.array(
                      external_exports.discriminatedUnion("type", [
                        external_exports.object({
                          type: external_exports.literal("url_citation"),
                          start_index: external_exports.number(),
                          end_index: external_exports.number(),
                          url: external_exports.string(),
                          title: external_exports.string()
                        }),
                        external_exports.object({
                          type: external_exports.literal("file_citation"),
                          file_id: external_exports.string(),
                          filename: external_exports.string().nullish(),
                          index: external_exports.number().nullish(),
                          start_index: external_exports.number().nullish(),
                          end_index: external_exports.number().nullish(),
                          quote: external_exports.string().nullish()
                        }),
                        external_exports.object({
                          type: external_exports.literal("container_file_citation")
                        })
                      ])
                    )
                  })
                )
              }),
              external_exports.object({
                type: external_exports.literal("web_search_call"),
                id: external_exports.string(),
                status: external_exports.string(),
                action: external_exports.discriminatedUnion("type", [
                  external_exports.object({
                    type: external_exports.literal("search"),
                    query: external_exports.string().nullish()
                  }),
                  external_exports.object({
                    type: external_exports.literal("open_page"),
                    url: external_exports.string()
                  }),
                  external_exports.object({
                    type: external_exports.literal("find"),
                    url: external_exports.string(),
                    pattern: external_exports.string()
                  })
                ])
              }),
              external_exports.object({
                type: external_exports.literal("file_search_call"),
                id: external_exports.string(),
                queries: external_exports.array(external_exports.string()),
                results: external_exports.array(
                  external_exports.object({
                    attributes: external_exports.record(external_exports.string(), external_exports.unknown()),
                    file_id: external_exports.string(),
                    filename: external_exports.string(),
                    score: external_exports.number(),
                    text: external_exports.string()
                  })
                ).nullish()
              }),
              external_exports.object({
                type: external_exports.literal("code_interpreter_call"),
                id: external_exports.string(),
                code: external_exports.string().nullable(),
                container_id: external_exports.string(),
                outputs: external_exports.array(
                  external_exports.discriminatedUnion("type", [
                    external_exports.object({ type: external_exports.literal("logs"), logs: external_exports.string() }),
                    external_exports.object({ type: external_exports.literal("image"), url: external_exports.string() })
                  ])
                ).nullable()
              }),
              external_exports.object({
                type: external_exports.literal("image_generation_call"),
                id: external_exports.string(),
                result: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("local_shell_call"),
                id: external_exports.string(),
                call_id: external_exports.string(),
                action: external_exports.object({
                  type: external_exports.literal("exec"),
                  command: external_exports.array(external_exports.string()),
                  timeout_ms: external_exports.number().optional(),
                  user: external_exports.string().optional(),
                  working_directory: external_exports.string().optional(),
                  env: external_exports.record(external_exports.string(), external_exports.string()).optional()
                })
              }),
              external_exports.object({
                type: external_exports.literal("function_call"),
                call_id: external_exports.string(),
                name: external_exports.string(),
                arguments: external_exports.string(),
                id: external_exports.string()
              }),
              external_exports.object({
                type: external_exports.literal("computer_call"),
                id: external_exports.string(),
                status: external_exports.string().optional()
              }),
              external_exports.object({
                type: external_exports.literal("reasoning"),
                id: external_exports.string(),
                encrypted_content: external_exports.string().nullish(),
                summary: external_exports.array(
                  external_exports.object({
                    type: external_exports.literal("summary_text"),
                    text: external_exports.string()
                  })
                )
              })
            ])
          ),
          service_tier: external_exports.string().nullish(),
          incomplete_details: external_exports.object({ reason: external_exports.string() }).nullish(),
          usage: external_exports.object({
            input_tokens: external_exports.number(),
            input_tokens_details: external_exports.object({ cached_tokens: external_exports.number().nullish() }).nullish(),
            output_tokens: external_exports.number(),
            output_tokens_details: external_exports.object({ reasoning_tokens: external_exports.number().nullish() }).nullish()
          })
        })
      )
    );
    TOP_LOGPROBS_MAX = 20;
    openaiResponsesReasoningModelIds = [
      "o1",
      "o1-2024-12-17",
      "o3-mini",
      "o3-mini-2025-01-31",
      "o3",
      "o3-2025-04-16",
      "o4-mini",
      "o4-mini-2025-04-16",
      "codex-mini-latest",
      "computer-use-preview",
      "gpt-5",
      "gpt-5-2025-08-07",
      "gpt-5-codex",
      "gpt-5-mini",
      "gpt-5-mini-2025-08-07",
      "gpt-5-nano",
      "gpt-5-nano-2025-08-07",
      "gpt-5-pro",
      "gpt-5-pro-2025-10-06"
    ];
    openaiResponsesModelIds = [
      "gpt-4.1",
      "gpt-4.1-2025-04-14",
      "gpt-4.1-mini",
      "gpt-4.1-mini-2025-04-14",
      "gpt-4.1-nano",
      "gpt-4.1-nano-2025-04-14",
      "gpt-4o",
      "gpt-4o-2024-05-13",
      "gpt-4o-2024-08-06",
      "gpt-4o-2024-11-20",
      "gpt-4o-audio-preview",
      "gpt-4o-audio-preview-2024-10-01",
      "gpt-4o-audio-preview-2024-12-17",
      "gpt-4o-search-preview",
      "gpt-4o-search-preview-2025-03-11",
      "gpt-4o-mini-search-preview",
      "gpt-4o-mini-search-preview-2025-03-11",
      "gpt-4o-mini",
      "gpt-4o-mini-2024-07-18",
      "gpt-4-turbo",
      "gpt-4-turbo-2024-04-09",
      "gpt-4-turbo-preview",
      "gpt-4-0125-preview",
      "gpt-4-1106-preview",
      "gpt-4",
      "gpt-4-0613",
      "gpt-4.5-preview",
      "gpt-4.5-preview-2025-02-27",
      "gpt-3.5-turbo-0125",
      "gpt-3.5-turbo",
      "gpt-3.5-turbo-1106",
      "chatgpt-4o-latest",
      "gpt-5-chat-latest",
      ...openaiResponsesReasoningModelIds
    ];
    openaiResponsesProviderOptionsSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          include: external_exports.array(
            external_exports.enum([
              "reasoning.encrypted_content",
              // handled internally by default, only needed for unknown reasoning models
              "file_search_call.results",
              "message.output_text.logprobs"
            ])
          ).nullish(),
          instructions: external_exports.string().nullish(),
          /**
           * Return the log probabilities of the tokens.
           *
           * Setting to true will return the log probabilities of the tokens that
           * were generated.
           *
           * Setting to a number will return the log probabilities of the top n
           * tokens that were generated.
           *
           * @see https://platform.openai.com/docs/api-reference/responses/create
           * @see https://cookbook.openai.com/examples/using_logprobs
           */
          logprobs: external_exports.union([external_exports.boolean(), external_exports.number().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
          /**
           * The maximum number of total calls to built-in tools that can be processed in a response.
           * This maximum number applies across all built-in tool calls, not per individual tool.
           * Any further attempts to call a tool by the model will be ignored.
           */
          maxToolCalls: external_exports.number().nullish(),
          metadata: external_exports.any().nullish(),
          parallelToolCalls: external_exports.boolean().nullish(),
          previousResponseId: external_exports.string().nullish(),
          promptCacheKey: external_exports.string().nullish(),
          reasoningEffort: external_exports.string().nullish(),
          reasoningSummary: external_exports.string().nullish(),
          safetyIdentifier: external_exports.string().nullish(),
          serviceTier: external_exports.enum(["auto", "flex", "priority", "default"]).nullish(),
          store: external_exports.boolean().nullish(),
          strictJsonSchema: external_exports.boolean().nullish(),
          textVerbosity: external_exports.enum(["low", "medium", "high"]).nullish(),
          truncation: external_exports.enum(["auto", "disabled"]).nullish(),
          user: external_exports.string().nullish()
        })
      )
    );
    __name(prepareResponsesTools, "prepareResponsesTools");
    OpenAIResponsesLanguageModel = class {
      static {
        __name(this, "OpenAIResponsesLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/],
          "application/pdf": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        maxOutputTokens,
        temperature,
        stopSequences,
        topP,
        topK,
        presencePenalty,
        frequencyPenalty,
        seed,
        prompt,
        providerOptions,
        tools,
        toolChoice,
        responseFormat
      }) {
        var _a61, _b, _c, _d;
        const warnings = [];
        const modelConfig = getResponsesModelConfig(this.modelId);
        if (topK != null) {
          warnings.push({ type: "unsupported-setting", setting: "topK" });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported-setting", setting: "seed" });
        }
        if (presencePenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty"
          });
        }
        if (frequencyPenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty"
          });
        }
        if (stopSequences != null) {
          warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
        }
        const openaiOptions = await parseProviderOptions5({
          provider: "openai",
          providerOptions,
          schema: openaiResponsesProviderOptionsSchema
        });
        const { input, warnings: inputWarnings } = await convertToOpenAIResponsesInput({
          prompt,
          systemMessageMode: modelConfig.systemMessageMode,
          fileIdPrefixes: this.config.fileIdPrefixes,
          store: (_a61 = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a61 : true,
          hasLocalShellTool: hasOpenAITool("openai.local_shell")
        });
        warnings.push(...inputWarnings);
        const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
        let include = openaiOptions == null ? void 0 : openaiOptions.include;
        function addInclude(key) {
          if (include == null) {
            include = [key];
          } else if (!include.includes(key)) {
            include = [...include, key];
          }
        }
        __name(addInclude, "addInclude");
        function hasOpenAITool(id) {
          return (tools == null ? void 0 : tools.find(
            (tool5) => tool5.type === "provider-defined" && tool5.id === id
          )) != null;
        }
        __name(hasOpenAITool, "hasOpenAITool");
        const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
        if (topLogprobs) {
          addInclude("message.output_text.logprobs");
        }
        const webSearchToolName = (_c = tools == null ? void 0 : tools.find(
          (tool5) => tool5.type === "provider-defined" && (tool5.id === "openai.web_search" || tool5.id === "openai.web_search_preview")
        )) == null ? void 0 : _c.name;
        if (webSearchToolName) {
          addInclude("web_search_call.action.sources");
        }
        if (hasOpenAITool("openai.code_interpreter")) {
          addInclude("code_interpreter_call.outputs");
        }
        const store = openaiOptions == null ? void 0 : openaiOptions.store;
        if (store === false && modelConfig.isReasoningModel) {
          addInclude("reasoning.encrypted_content");
        }
        const baseArgs = {
          model: this.modelId,
          input,
          temperature,
          top_p: topP,
          max_output_tokens: maxOutputTokens,
          ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
            text: {
              ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
                format: responseFormat.schema != null ? {
                  type: "json_schema",
                  strict: strictJsonSchema,
                  name: (_d = responseFormat.name) != null ? _d : "response",
                  description: responseFormat.description,
                  schema: responseFormat.schema
                } : { type: "json_object" }
              },
              ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
                verbosity: openaiOptions.textVerbosity
              }
            }
          },
          // provider options:
          max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
          metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
          parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
          previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
          store,
          user: openaiOptions == null ? void 0 : openaiOptions.user,
          instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
          service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
          include,
          prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
          safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
          top_logprobs: topLogprobs,
          truncation: openaiOptions == null ? void 0 : openaiOptions.truncation,
          // model-specific settings:
          ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
            reasoning: {
              ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
                effort: openaiOptions.reasoningEffort
              },
              ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
                summary: openaiOptions.reasoningSummary
              }
            }
          }
        };
        if (modelConfig.isReasoningModel) {
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "temperature",
              details: "temperature is not supported for reasoning models"
            });
          }
          if (baseArgs.top_p != null) {
            baseArgs.top_p = void 0;
            warnings.push({
              type: "unsupported-setting",
              setting: "topP",
              details: "topP is not supported for reasoning models"
            });
          }
        } else {
          if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "reasoningEffort",
              details: "reasoningEffort is not supported for non-reasoning models"
            });
          }
          if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "reasoningSummary",
              details: "reasoningSummary is not supported for non-reasoning models"
            });
          }
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
          warnings.push({
            type: "unsupported-setting",
            setting: "serviceTier",
            details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
          });
          delete baseArgs.service_tier;
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
          warnings.push({
            type: "unsupported-setting",
            setting: "serviceTier",
            details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
          });
          delete baseArgs.service_tier;
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = await prepareResponsesTools({
          tools,
          toolChoice,
          strictJsonSchema
        });
        return {
          webSearchToolName,
          args: {
            ...baseArgs,
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings],
          store
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
        const {
          args: body,
          warnings,
          webSearchToolName
        } = await this.getArgs(options);
        const url3 = this.config.url({
          path: "/responses",
          modelId: this.modelId
        });
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi5({
          url: url3,
          headers: combineHeaders5(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiResponsesResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if (response.error) {
          throw new APICallError7({
            message: response.error.message,
            url: url3,
            requestBodyValues: body,
            statusCode: 400,
            responseHeaders,
            responseBody: rawResponse,
            isRetryable: false
          });
        }
        const content = [];
        const logprobs = [];
        let hasFunctionCall = false;
        for (const part of response.output) {
          switch (part.type) {
            case "reasoning": {
              if (part.summary.length === 0) {
                part.summary.push({ type: "summary_text", text: "" });
              }
              for (const summary of part.summary) {
                content.push({
                  type: "reasoning",
                  text: summary.text,
                  providerMetadata: {
                    openai: {
                      itemId: part.id,
                      reasoningEncryptedContent: (_a61 = part.encrypted_content) != null ? _a61 : null
                    }
                  }
                });
              }
              break;
            }
            case "image_generation_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: "image_generation",
                input: "{}",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: "image_generation",
                result: {
                  result: part.result
                },
                providerExecuted: true
              });
              break;
            }
            case "local_shell_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: "local_shell",
                input: JSON.stringify({
                  action: part.action
                }),
                providerMetadata: {
                  openai: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "message": {
              for (const contentPart of part.content) {
                if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                  logprobs.push(contentPart.logprobs);
                }
                content.push({
                  type: "text",
                  text: contentPart.text,
                  providerMetadata: {
                    openai: {
                      itemId: part.id
                    }
                  }
                });
                for (const annotation of contentPart.annotations) {
                  if (annotation.type === "url_citation") {
                    content.push({
                      type: "source",
                      sourceType: "url",
                      id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId8(),
                      url: annotation.url,
                      title: annotation.title
                    });
                  } else if (annotation.type === "file_citation") {
                    content.push({
                      type: "source",
                      sourceType: "document",
                      id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId8(),
                      mediaType: "text/plain",
                      title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                      filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                    });
                  }
                }
              }
              break;
            }
            case "function_call": {
              hasFunctionCall = true;
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: part.name,
                input: part.arguments,
                providerMetadata: {
                  openai: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "web_search_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                input: JSON.stringify({}),
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                result: mapWebSearchOutput(part.action),
                providerExecuted: true
              });
              break;
            }
            case "computer_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: "computer_use",
                input: "",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: "computer_use",
                result: {
                  type: "computer_use_tool_result",
                  status: part.status || "completed"
                },
                providerExecuted: true
              });
              break;
            }
            case "file_search_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: "file_search",
                input: "{}",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: "file_search",
                result: {
                  queries: part.queries,
                  results: (_n = (_m = part.results) == null ? void 0 : _m.map((result) => ({
                    attributes: result.attributes,
                    fileId: result.file_id,
                    filename: result.filename,
                    score: result.score,
                    text: result.text
                  }))) != null ? _n : null
                },
                providerExecuted: true
              });
              break;
            }
            case "code_interpreter_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: "code_interpreter",
                input: JSON.stringify({
                  code: part.code,
                  containerId: part.container_id
                }),
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: "code_interpreter",
                result: {
                  outputs: part.outputs
                },
                providerExecuted: true
              });
              break;
            }
          }
        }
        const providerMetadata = {
          openai: { responseId: response.id }
        };
        if (logprobs.length > 0) {
          providerMetadata.openai.logprobs = logprobs;
        }
        if (typeof response.service_tier === "string") {
          providerMetadata.openai.serviceTier = response.service_tier;
        }
        return {
          content,
          finishReason: mapOpenAIResponseFinishReason({
            finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
            hasFunctionCall
          }),
          usage: {
            inputTokens: response.usage.input_tokens,
            outputTokens: response.usage.output_tokens,
            totalTokens: response.usage.input_tokens + response.usage.output_tokens,
            reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
            cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
          },
          request: { body },
          response: {
            id: response.id,
            timestamp: new Date(response.created_at * 1e3),
            modelId: response.model,
            headers: responseHeaders,
            body: rawResponse
          },
          providerMetadata,
          warnings
        };
      }
      async doStream(options) {
        const {
          args: body,
          warnings,
          webSearchToolName,
          store
        } = await this.getArgs(options);
        const { responseHeaders, value: response } = await postJsonToApi5({
          url: this.config.url({
            path: "/responses",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body: {
            ...body,
            stream: true
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler5(
            openaiResponsesChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const self2 = this;
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        const logprobs = [];
        let responseId = null;
        const ongoingToolCalls = {};
        let hasFunctionCall = false;
        const activeReasoning = {};
        let serviceTier;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a61, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if (isResponseOutputItemAddedChunk(value)) {
                  if (value.item.type === "function_call") {
                    ongoingToolCalls[value.output_index] = {
                      toolName: value.item.name,
                      toolCallId: value.item.call_id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value.item.call_id,
                      toolName: value.item.name
                    });
                  } else if (value.item.type === "web_search_call") {
                    ongoingToolCalls[value.output_index] = {
                      toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                      toolCallId: value.item.id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value.item.id,
                      toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value.item.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.id,
                      toolName: "web_search",
                      input: JSON.stringify({}),
                      providerExecuted: true
                    });
                  } else if (value.item.type === "computer_call") {
                    ongoingToolCalls[value.output_index] = {
                      toolName: "computer_use",
                      toolCallId: value.item.id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value.item.id,
                      toolName: "computer_use",
                      providerExecuted: true
                    });
                  } else if (value.item.type === "code_interpreter_call") {
                    ongoingToolCalls[value.output_index] = {
                      toolName: "code_interpreter",
                      toolCallId: value.item.id,
                      codeInterpreter: {
                        containerId: value.item.container_id
                      }
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value.item.id,
                      toolName: "code_interpreter",
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: value.item.id,
                      delta: `{"containerId":"${value.item.container_id}","code":"`
                    });
                  } else if (value.item.type === "file_search_call") {
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.id,
                      toolName: "file_search",
                      input: "{}",
                      providerExecuted: true
                    });
                  } else if (value.item.type === "image_generation_call") {
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.id,
                      toolName: "image_generation",
                      input: "{}",
                      providerExecuted: true
                    });
                  } else if (value.item.type === "message") {
                    controller.enqueue({
                      type: "text-start",
                      id: value.item.id,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id
                        }
                      }
                    });
                  } else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning") {
                    activeReasoning[value.item.id] = {
                      encryptedContent: value.item.encrypted_content,
                      summaryParts: { 0: "active" }
                    };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `${value.item.id}:0`,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id,
                          reasoningEncryptedContent: (_a61 = value.item.encrypted_content) != null ? _a61 : null
                        }
                      }
                    });
                  }
                } else if (isResponseOutputItemDoneChunk(value)) {
                  if (value.item.type === "function_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    hasFunctionCall = true;
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value.item.call_id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.call_id,
                      toolName: value.item.name,
                      input: value.item.arguments,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id
                        }
                      }
                    });
                  } else if (value.item.type === "web_search_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value.item.id,
                      toolName: "web_search",
                      result: mapWebSearchOutput(value.item.action),
                      providerExecuted: true
                    });
                  } else if (value.item.type === "computer_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value.item.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.id,
                      toolName: "computer_use",
                      input: "",
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value.item.id,
                      toolName: "computer_use",
                      result: {
                        type: "computer_use_tool_result",
                        status: value.item.status || "completed"
                      },
                      providerExecuted: true
                    });
                  } else if (value.item.type === "file_search_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value.item.id,
                      toolName: "file_search",
                      result: {
                        queries: value.item.queries,
                        results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result) => ({
                          attributes: result.attributes,
                          fileId: result.file_id,
                          filename: result.filename,
                          score: result.score,
                          text: result.text
                        }))) != null ? _c : null
                      },
                      providerExecuted: true
                    });
                  } else if (value.item.type === "code_interpreter_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value.item.id,
                      toolName: "code_interpreter",
                      result: {
                        outputs: value.item.outputs
                      },
                      providerExecuted: true
                    });
                  } else if (value.item.type === "image_generation_call") {
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value.item.id,
                      toolName: "image_generation",
                      result: {
                        result: value.item.result
                      },
                      providerExecuted: true
                    });
                  } else if (value.item.type === "local_shell_call") {
                    ongoingToolCalls[value.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value.item.call_id,
                      toolName: "local_shell",
                      input: JSON.stringify({
                        action: {
                          type: "exec",
                          command: value.item.action.command,
                          timeoutMs: value.item.action.timeout_ms,
                          user: value.item.action.user,
                          workingDirectory: value.item.action.working_directory,
                          env: value.item.action.env
                        }
                      }),
                      providerMetadata: {
                        openai: { itemId: value.item.id }
                      }
                    });
                  } else if (value.item.type === "message") {
                    controller.enqueue({
                      type: "text-end",
                      id: value.item.id
                    });
                  } else if (value.item.type === "reasoning") {
                    const activeReasoningPart = activeReasoning[value.item.id];
                    const summaryPartIndices = Object.entries(
                      activeReasoningPart.summaryParts
                    ).filter(
                      ([_, status]) => status === "active" || status === "can-conclude"
                    ).map(([summaryIndex]) => summaryIndex);
                    for (const summaryIndex of summaryPartIndices) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: `${value.item.id}:${summaryIndex}`,
                        providerMetadata: {
                          openai: {
                            itemId: value.item.id,
                            reasoningEncryptedContent: (_d = value.item.encrypted_content) != null ? _d : null
                          }
                        }
                      });
                    }
                    delete activeReasoning[value.item.id];
                  }
                } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
                  const toolCall = ongoingToolCalls[value.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: value.delta
                    });
                  }
                } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
                  const toolCall = ongoingToolCalls[value.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      // The delta is code, which is embedding in a JSON string.
                      // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                      delta: JSON.stringify(value.delta).slice(1, -1)
                    });
                  }
                } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
                  const toolCall = ongoingToolCalls[value.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: '"}'
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall.toolCallId,
                      toolName: "code_interpreter",
                      input: JSON.stringify({
                        code: value.code,
                        containerId: toolCall.codeInterpreter.containerId
                      }),
                      providerExecuted: true
                    });
                  }
                } else if (isResponseCreatedChunk(value)) {
                  responseId = value.response.id;
                  controller.enqueue({
                    type: "response-metadata",
                    id: value.response.id,
                    timestamp: new Date(value.response.created_at * 1e3),
                    modelId: value.response.model
                  });
                } else if (isTextDeltaChunk(value)) {
                  controller.enqueue({
                    type: "text-delta",
                    id: value.item_id,
                    delta: value.delta
                  });
                  if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                    logprobs.push(value.logprobs);
                  }
                } else if (value.type === "response.reasoning_summary_part.added") {
                  if (value.summary_index > 0) {
                    const activeReasoningPart = activeReasoning[value.item_id];
                    activeReasoningPart.summaryParts[value.summary_index] = "active";
                    for (const summaryIndex of Object.keys(
                      activeReasoningPart.summaryParts
                    )) {
                      if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: `${value.item_id}:${summaryIndex}`,
                          providerMetadata: { openai: { itemId: value.item_id } }
                        });
                        activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                      }
                    }
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `${value.item_id}:${value.summary_index}`,
                      providerMetadata: {
                        openai: {
                          itemId: value.item_id,
                          reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                        }
                      }
                    });
                  }
                } else if (value.type === "response.reasoning_summary_text.delta") {
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: `${value.item_id}:${value.summary_index}`,
                    delta: value.delta,
                    providerMetadata: {
                      openai: {
                        itemId: value.item_id
                      }
                    }
                  });
                } else if (value.type === "response.reasoning_summary_part.done") {
                  if (store) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value.item_id}:${value.summary_index}`,
                      providerMetadata: {
                        openai: { itemId: value.item_id }
                      }
                    });
                    activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                  } else {
                    activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                  }
                } else if (isResponseFinishedChunk(value)) {
                  finishReason = mapOpenAIResponseFinishReason({
                    finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                    hasFunctionCall
                  });
                  usage.inputTokens = value.response.usage.input_tokens;
                  usage.outputTokens = value.response.usage.output_tokens;
                  usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                  usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                  usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                  if (typeof value.response.service_tier === "string") {
                    serviceTier = value.response.service_tier;
                  }
                } else if (isResponseAnnotationAddedChunk(value)) {
                  if (value.annotation.type === "url_citation") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: (_p = (_o = (_n = self2.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId8(),
                      url: value.annotation.url,
                      title: value.annotation.title
                    });
                  } else if (value.annotation.type === "file_citation") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "document",
                      id: (_s = (_r = (_q = self2.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId8(),
                      mediaType: "text/plain",
                      title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                      filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                    });
                  }
                } else if (isErrorChunk(value)) {
                  controller.enqueue({ type: "error", error: value });
                }
              },
              flush(controller) {
                const providerMetadata = {
                  openai: {
                    responseId
                  }
                };
                if (logprobs.length > 0) {
                  providerMetadata.openai.logprobs = logprobs;
                }
                if (serviceTier !== void 0) {
                  providerMetadata.openai.serviceTier = serviceTier;
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    __name(isTextDeltaChunk, "isTextDeltaChunk");
    __name(isResponseOutputItemDoneChunk, "isResponseOutputItemDoneChunk");
    __name(isResponseFinishedChunk, "isResponseFinishedChunk");
    __name(isResponseCreatedChunk, "isResponseCreatedChunk");
    __name(isResponseFunctionCallArgumentsDeltaChunk, "isResponseFunctionCallArgumentsDeltaChunk");
    __name(isResponseCodeInterpreterCallCodeDeltaChunk, "isResponseCodeInterpreterCallCodeDeltaChunk");
    __name(isResponseCodeInterpreterCallCodeDoneChunk, "isResponseCodeInterpreterCallCodeDoneChunk");
    __name(isResponseOutputItemAddedChunk, "isResponseOutputItemAddedChunk");
    __name(isResponseAnnotationAddedChunk, "isResponseAnnotationAddedChunk");
    __name(isErrorChunk, "isErrorChunk");
    __name(getResponsesModelConfig, "getResponsesModelConfig");
    __name(mapWebSearchOutput, "mapWebSearchOutput");
    openaiSpeechProviderOptionsSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          instructions: external_exports.string().nullish(),
          speed: external_exports.number().min(0.25).max(4).default(1).nullish()
        })
      )
    );
    OpenAISpeechModel = class {
      static {
        __name(this, "OpenAISpeechModel");
      }
      constructor(modelId, config4) {
        this.modelId = modelId;
        this.config = config4;
        this.specificationVersion = "v2";
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        text: text3,
        voice = "alloy",
        outputFormat = "mp3",
        speed,
        instructions,
        language,
        providerOptions
      }) {
        const warnings = [];
        const openAIOptions = await parseProviderOptions5({
          provider: "openai",
          providerOptions,
          schema: openaiSpeechProviderOptionsSchema
        });
        const requestBody = {
          model: this.modelId,
          input: text3,
          voice,
          response_format: "mp3",
          speed,
          instructions
        };
        if (outputFormat) {
          if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
            requestBody.response_format = outputFormat;
          } else {
            warnings.push({
              type: "unsupported-setting",
              setting: "outputFormat",
              details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
            });
          }
        }
        if (openAIOptions) {
          const speechModelOptions = {};
          for (const key in speechModelOptions) {
            const value = speechModelOptions[key];
            if (value !== void 0) {
              requestBody[key] = value;
            }
          }
        }
        if (language) {
          warnings.push({
            type: "unsupported-setting",
            setting: "language",
            details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
          });
        }
        return {
          requestBody,
          warnings
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c;
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const { requestBody, warnings } = await this.getArgs(options);
        const {
          value: audio,
          responseHeaders,
          rawValue: rawResponse
        } = await postJsonToApi5({
          url: this.config.url({
            path: "/audio/speech",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          body: requestBody,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createBinaryResponseHandler(),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        return {
          audio,
          warnings,
          request: {
            body: JSON.stringify(requestBody)
          },
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
    };
    openaiTranscriptionResponseSchema = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          text: external_exports.string(),
          language: external_exports.string().nullish(),
          duration: external_exports.number().nullish(),
          words: external_exports.array(
            external_exports.object({
              word: external_exports.string(),
              start: external_exports.number(),
              end: external_exports.number()
            })
          ).nullish(),
          segments: external_exports.array(
            external_exports.object({
              id: external_exports.number(),
              seek: external_exports.number(),
              start: external_exports.number(),
              end: external_exports.number(),
              text: external_exports.string(),
              tokens: external_exports.array(external_exports.number()),
              temperature: external_exports.number(),
              avg_logprob: external_exports.number(),
              compression_ratio: external_exports.number(),
              no_speech_prob: external_exports.number()
            })
          ).nullish()
        })
      )
    );
    openAITranscriptionProviderOptions = lazyValidator2(
      () => zodSchema5(
        external_exports.object({
          /**
           * Additional information to include in the transcription response.
           */
          include: external_exports.array(external_exports.string()).optional(),
          /**
           * The language of the input audio in ISO-639-1 format.
           */
          language: external_exports.string().optional(),
          /**
           * An optional text to guide the model's style or continue a previous audio segment.
           */
          prompt: external_exports.string().optional(),
          /**
           * The sampling temperature, between 0 and 1.
           * @default 0
           */
          temperature: external_exports.number().min(0).max(1).default(0).optional(),
          /**
           * The timestamp granularities to populate for this transcription.
           * @default ['segment']
           */
          timestampGranularities: external_exports.array(external_exports.enum(["word", "segment"])).default(["segment"]).optional()
        })
      )
    );
    languageMap = {
      afrikaans: "af",
      arabic: "ar",
      armenian: "hy",
      azerbaijani: "az",
      belarusian: "be",
      bosnian: "bs",
      bulgarian: "bg",
      catalan: "ca",
      chinese: "zh",
      croatian: "hr",
      czech: "cs",
      danish: "da",
      dutch: "nl",
      english: "en",
      estonian: "et",
      finnish: "fi",
      french: "fr",
      galician: "gl",
      german: "de",
      greek: "el",
      hebrew: "he",
      hindi: "hi",
      hungarian: "hu",
      icelandic: "is",
      indonesian: "id",
      italian: "it",
      japanese: "ja",
      kannada: "kn",
      kazakh: "kk",
      korean: "ko",
      latvian: "lv",
      lithuanian: "lt",
      macedonian: "mk",
      malay: "ms",
      marathi: "mr",
      maori: "mi",
      nepali: "ne",
      norwegian: "no",
      persian: "fa",
      polish: "pl",
      portuguese: "pt",
      romanian: "ro",
      russian: "ru",
      serbian: "sr",
      slovak: "sk",
      slovenian: "sl",
      spanish: "es",
      swahili: "sw",
      swedish: "sv",
      tagalog: "tl",
      tamil: "ta",
      thai: "th",
      turkish: "tr",
      ukrainian: "uk",
      urdu: "ur",
      vietnamese: "vi",
      welsh: "cy"
    };
    OpenAITranscriptionModel = class {
      static {
        __name(this, "OpenAITranscriptionModel");
      }
      constructor(modelId, config4) {
        this.modelId = modelId;
        this.config = config4;
        this.specificationVersion = "v2";
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        audio,
        mediaType,
        providerOptions
      }) {
        const warnings = [];
        const openAIOptions = await parseProviderOptions5({
          provider: "openai",
          providerOptions,
          schema: openAITranscriptionProviderOptions
        });
        const formData = new FormData();
        const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array3(audio)]);
        formData.append("model", this.modelId);
        const fileExtension = mediaTypeToExtension(mediaType);
        formData.append(
          "file",
          new File([blob], "audio", { type: mediaType }),
          `audio.${fileExtension}`
        );
        if (openAIOptions) {
          const transcriptionModelOptions = {
            include: openAIOptions.include,
            language: openAIOptions.language,
            prompt: openAIOptions.prompt,
            // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
            // prefer verbose_json to get segments for models that support it
            response_format: [
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ].includes(this.modelId) ? "json" : "verbose_json",
            temperature: openAIOptions.temperature,
            timestamp_granularities: openAIOptions.timestampGranularities
          };
          for (const [key, value] of Object.entries(transcriptionModelOptions)) {
            if (value != null) {
              if (Array.isArray(value)) {
                for (const item of value) {
                  formData.append(`${key}[]`, String(item));
                }
              } else {
                formData.append(key, String(value));
              }
            }
          }
        }
        return {
          formData,
          warnings
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c, _d, _e, _f, _g, _h;
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const { formData, warnings } = await this.getArgs(options);
        const {
          value: response,
          responseHeaders,
          rawValue: rawResponse
        } = await postFormDataToApi({
          url: this.config.url({
            path: "/audio/transcriptions",
            modelId: this.modelId
          }),
          headers: combineHeaders5(this.config.headers(), options.headers),
          formData,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler5(
            openaiTranscriptionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
        return {
          text: response.text,
          segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
            text: segment.text,
            startSecond: segment.start,
            endSecond: segment.end
          }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
            text: word.word,
            startSecond: word.start,
            endSecond: word.end
          }))) != null ? _g : [],
          language,
          durationInSeconds: (_h = response.duration) != null ? _h : void 0,
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
    };
    VERSION10 = true ? "2.0.53" : "0.0.0-test";
    __name(createOpenAI, "createOpenAI");
    openai = createOpenAI();
  }
});

// node_modules/@ai-sdk/openai-compatible/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage10(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker31, symbol40, _a40, _AISDKError17, AISDKError9, name31, marker212, symbol213, _a213, APICallError8, name212, marker311, symbol311, _a311, name311, marker411, symbol411, _a411, InvalidArgumentError10, name411, marker511, symbol511, _a511, name511, marker611, symbol611, _a611, name611, marker711, symbol711, _a711, JSONParseError8, name711, marker811, symbol811, _a811, name811, marker911, symbol911, _a911, name911, marker1011, symbol1011, _a1011, name1011, marker1111, symbol1111, _a1111, name1111, marker1211, symbol1211, _a1211, name1211, marker1311, symbol1311, _a1311, _TypeValidationError15, TypeValidationError8, name1311, marker1411, symbol1411, _a1411;
var init_dist18 = __esm({
  "node_modules/@ai-sdk/openai-compatible/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker31 = "vercel.ai.error";
    symbol40 = Symbol.for(marker31);
    _AISDKError17 = class _AISDKError18 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a40] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError18.hasMarker(error87, marker31);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a40 = symbol40;
    AISDKError9 = _AISDKError17;
    name31 = "AI_APICallError";
    marker212 = `vercel.ai.error.${name31}`;
    symbol213 = Symbol.for(marker212);
    APICallError8 = class extends AISDKError9 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name31, message, cause });
        this[_a213] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError9.hasMarker(error87, marker212);
      }
    };
    _a213 = symbol213;
    name212 = "AI_EmptyResponseBodyError";
    marker311 = `vercel.ai.error.${name212}`;
    symbol311 = Symbol.for(marker311);
    _a311 = symbol311;
    __name(getErrorMessage10, "getErrorMessage");
    name311 = "AI_InvalidArgumentError";
    marker411 = `vercel.ai.error.${name311}`;
    symbol411 = Symbol.for(marker411);
    InvalidArgumentError10 = class extends AISDKError9 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name311, message, cause });
        this[_a411] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError9.hasMarker(error87, marker411);
      }
    };
    _a411 = symbol411;
    name411 = "AI_InvalidPromptError";
    marker511 = `vercel.ai.error.${name411}`;
    symbol511 = Symbol.for(marker511);
    _a511 = symbol511;
    name511 = "AI_InvalidResponseDataError";
    marker611 = `vercel.ai.error.${name511}`;
    symbol611 = Symbol.for(marker611);
    _a611 = symbol611;
    name611 = "AI_JSONParseError";
    marker711 = `vercel.ai.error.${name611}`;
    symbol711 = Symbol.for(marker711);
    JSONParseError8 = class extends AISDKError9 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name611,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage10(cause)}`,
          cause
        });
        this[_a711] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError9.hasMarker(error87, marker711);
      }
    };
    _a711 = symbol711;
    name711 = "AI_LoadAPIKeyError";
    marker811 = `vercel.ai.error.${name711}`;
    symbol811 = Symbol.for(marker811);
    _a811 = symbol811;
    name811 = "AI_LoadSettingError";
    marker911 = `vercel.ai.error.${name811}`;
    symbol911 = Symbol.for(marker911);
    _a911 = symbol911;
    name911 = "AI_NoContentGeneratedError";
    marker1011 = `vercel.ai.error.${name911}`;
    symbol1011 = Symbol.for(marker1011);
    _a1011 = symbol1011;
    name1011 = "AI_NoSuchModelError";
    marker1111 = `vercel.ai.error.${name1011}`;
    symbol1111 = Symbol.for(marker1111);
    _a1111 = symbol1111;
    name1111 = "AI_TooManyEmbeddingValuesForCallError";
    marker1211 = `vercel.ai.error.${name1111}`;
    symbol1211 = Symbol.for(marker1211);
    _a1211 = symbol1211;
    name1211 = "AI_TypeValidationError";
    marker1311 = `vercel.ai.error.${name1211}`;
    symbol1311 = Symbol.for(marker1311);
    _TypeValidationError15 = class _TypeValidationError16 extends AISDKError9 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name1211,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage10(cause)}`,
          cause
        });
        this[_a1311] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError9.hasMarker(error87, marker1311);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError16.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError16({ value, cause });
      }
    };
    _a1311 = symbol1311;
    TypeValidationError8 = _TypeValidationError15;
    name1311 = "AI_UnsupportedFunctionalityError";
    marker1411 = `vercel.ai.error.${name1311}`;
    symbol1411 = Symbol.for(marker1411);
    _a1411 = symbol1411;
  }
});

// node_modules/@ai-sdk/openai-compatible/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders6(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders6(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError9(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError6({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError9(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES6.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError8({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent6(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries4(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix7(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries4(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
function _parse9(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx7.test(text3) === false && suspectConstructorRx7.test(text3) === false) {
    return obj;
  }
  return filter7(obj);
}
function filter7(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse7(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse9(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator8(validate) {
  return { [validatorSymbol9]: true, validate };
}
function isValidator8(value) {
  return typeof value === "object" && value !== null && validatorSymbol9 in value && value[validatorSymbol9] === true && "validate" in value;
}
function asValidator8(value) {
  return isValidator8(value) ? value : typeof value === "function" ? value() : standardSchemaValidator7(value);
}
function standardSchemaValidator7(standardSchema) {
  return validator8(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError8({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes7({
  value,
  schema
}) {
  const result = await safeValidateTypes8({ value, schema });
  if (!result.success) {
    throw TypeValidationError8.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes8({
  value,
  schema
}) {
  const validator22 = asValidator8(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError8.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError8.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON6({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse7(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes7({ value, schema });
  } catch (error87) {
    if (JSONParseError8.isInstance(error87) || TypeValidationError8.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError8({ text: text3, cause: error87 });
  }
}
async function safeParseJSON8({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse7(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes8({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError8.isInstance(error87) ? error87 : new JSONParseError8({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
var createIdGenerator9, generateId9, FETCH_FAILED_ERROR_MESSAGES6, VERSION11, suspectProtoRx7, suspectConstructorRx7, validatorSymbol9, getOriginalFetch26, postJsonToApi6, postToApi6, createJsonErrorResponseHandler6, createJsonResponseHandler6, ignoreOverride9, ALPHA_NUMERIC9, schemaSymbol9, btoa10, atob10;
var init_dist19 = __esm({
  "node_modules/@ai-sdk/openai-compatible/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist18();
    init_dist18();
    init_dist18();
    init_dist18();
    init_dist18();
    init_dist18();
    init_dist18();
    init_dist2();
    __name(combineHeaders6, "combineHeaders");
    __name(extractResponseHeaders6, "extractResponseHeaders");
    createIdGenerator9 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError10({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId9 = createIdGenerator9();
    __name(isAbortError9, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES6 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError6, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent6, "getRuntimeEnvironmentUserAgent");
    __name(removeUndefinedEntries4, "removeUndefinedEntries");
    __name(withUserAgentSuffix7, "withUserAgentSuffix");
    VERSION11 = true ? "3.0.12" : "0.0.0-test";
    suspectProtoRx7 = /"__proto__"\s*:/;
    suspectConstructorRx7 = /"constructor"\s*:/;
    __name(_parse9, "_parse");
    __name(filter7, "filter");
    __name(secureJsonParse7, "secureJsonParse");
    validatorSymbol9 = Symbol.for("vercel.ai.validator");
    __name(validator8, "validator");
    __name(isValidator8, "isValidator");
    __name(asValidator8, "asValidator");
    __name(standardSchemaValidator7, "standardSchemaValidator");
    __name(validateTypes7, "validateTypes");
    __name(safeValidateTypes8, "safeValidateTypes");
    __name(parseJSON6, "parseJSON");
    __name(safeParseJSON8, "safeParseJSON");
    getOriginalFetch26 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi6 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi6({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi6 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch26()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix7(
            headers,
            `ai-sdk/provider-utils/${VERSION11}`,
            getRuntimeEnvironmentUserAgent6()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders6(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError9(error87) || APICallError8.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError8({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError9(error87) || APICallError8.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError8({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError6({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    createJsonErrorResponseHandler6 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders6(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError8({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON6({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError8({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError8({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createJsonResponseHandler6 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON8({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders6(response);
      if (!parsedResult.success) {
        throw new APICallError8({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    ignoreOverride9 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    ALPHA_NUMERIC9 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    schemaSymbol9 = Symbol.for("vercel.ai.schema");
    ({ btoa: btoa10, atob: atob10 } = globalThis);
  }
});

// node_modules/@ai-sdk/openai-compatible/dist/index.mjs
var openaiCompatibleProviderOptions2, openaiCompatibleErrorDataSchema2, defaultOpenAICompatibleErrorStructure2, openaiCompatibleTokenUsageSchema2, OpenAICompatibleChatResponseSchema2, openaiCompatibleCompletionProviderOptions2, usageSchema3, openaiCompatibleCompletionResponseSchema2, openaiCompatibleEmbeddingProviderOptions2, openaiTextEmbeddingResponseSchema3, OpenAICompatibleImageModel2, openaiCompatibleImageResponseSchema2;
var init_dist20 = __esm({
  "node_modules/@ai-sdk/openai-compatible/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_dist19();
    init_v4();
    openaiCompatibleProviderOptions2 = external_exports.object({
      /**
       * A unique identifier representing your end-user, which can help the provider to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: external_exports.string().optional(),
      /**
       * Controls the verbosity of the generated text. Defaults to `medium`.
       */
      textVerbosity: external_exports.string().optional()
    });
    openaiCompatibleErrorDataSchema2 = external_exports.object({
      error: external_exports.object({
        message: external_exports.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: external_exports.string().nullish(),
        param: external_exports.any().nullish(),
        code: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
      })
    });
    defaultOpenAICompatibleErrorStructure2 = {
      errorSchema: openaiCompatibleErrorDataSchema2,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    };
    openaiCompatibleTokenUsageSchema2 = external_exports.object({
      prompt_tokens: external_exports.number().nullish(),
      completion_tokens: external_exports.number().nullish(),
      total_tokens: external_exports.number().nullish(),
      prompt_tokens_details: external_exports.object({
        cached_tokens: external_exports.number().nullish()
      }).nullish(),
      completion_tokens_details: external_exports.object({
        reasoning_tokens: external_exports.number().nullish(),
        accepted_prediction_tokens: external_exports.number().nullish(),
        rejected_prediction_tokens: external_exports.number().nullish()
      }).nullish()
    }).nullish();
    OpenAICompatibleChatResponseSchema2 = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          message: external_exports.object({
            role: external_exports.literal("assistant").nullish(),
            content: external_exports.string().nullish(),
            reasoning_content: external_exports.string().nullish(),
            reasoning: external_exports.string().nullish(),
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string().nullish(),
                function: external_exports.object({
                  name: external_exports.string(),
                  arguments: external_exports.string()
                })
              })
            ).nullish()
          }),
          finish_reason: external_exports.string().nullish()
        })
      ),
      usage: openaiCompatibleTokenUsageSchema2
    });
    openaiCompatibleCompletionProviderOptions2 = external_exports.object({
      /**
       * Echo back the prompt in addition to the completion.
       */
      echo: external_exports.boolean().optional(),
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: external_exports.record(external_exports.string(), external_exports.number()).optional(),
      /**
       * The suffix that comes after a completion of inserted text.
       */
      suffix: external_exports.string().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional()
    });
    usageSchema3 = external_exports.object({
      prompt_tokens: external_exports.number(),
      completion_tokens: external_exports.number(),
      total_tokens: external_exports.number()
    });
    openaiCompatibleCompletionResponseSchema2 = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          text: external_exports.string(),
          finish_reason: external_exports.string()
        })
      ),
      usage: usageSchema3.nullish()
    });
    openaiCompatibleEmbeddingProviderOptions2 = external_exports.object({
      /**
       * The number of dimensions the resulting output embeddings should have.
       * Only supported in text-embedding-3 and later models.
       */
      dimensions: external_exports.number().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: external_exports.string().optional()
    });
    openaiTextEmbeddingResponseSchema3 = external_exports.object({
      data: external_exports.array(external_exports.object({ embedding: external_exports.array(external_exports.number()) })),
      usage: external_exports.object({ prompt_tokens: external_exports.number() }).nullish(),
      providerMetadata: external_exports.record(external_exports.string(), external_exports.record(external_exports.string(), external_exports.any())).optional()
    });
    OpenAICompatibleImageModel2 = class {
      static {
        __name(this, "OpenAICompatibleImageModel");
      }
      constructor(modelId, config4) {
        this.modelId = modelId;
        this.config = config4;
        this.specificationVersion = "v2";
        this.maxImagesPerCall = 10;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a61, _b, _c, _d, _e;
        const warnings = [];
        if (aspectRatio != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported-setting", setting: "seed" });
        }
        const currentDate = (_c = (_b = (_a61 = this.config._internal) == null ? void 0 : _a61.currentDate) == null ? void 0 : _b.call(_a61)) != null ? _c : /* @__PURE__ */ new Date();
        const { value: response, responseHeaders } = await postJsonToApi6({
          url: this.config.url({
            path: "/images/generations",
            modelId: this.modelId
          }),
          headers: combineHeaders6(this.config.headers(), headers),
          body: {
            model: this.modelId,
            prompt,
            n,
            size,
            ...(_d = providerOptions.openai) != null ? _d : {},
            response_format: "b64_json"
          },
          failedResponseHandler: createJsonErrorResponseHandler6(
            (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure2
          ),
          successfulResponseHandler: createJsonResponseHandler6(
            openaiCompatibleImageResponseSchema2
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.data.map((item) => item.b64_json),
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    openaiCompatibleImageResponseSchema2 = external_exports.object({
      data: external_exports.array(external_exports.object({ b64_json: external_exports.string() }))
    });
  }
});

// node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage11(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
var marker40, symbol41, _a41, _AISDKError19, AISDKError10, name40, marker213, symbol214, _a214, APICallError9, name213, marker312, symbol312, _a312, EmptyResponseBodyError8, name312, marker412, symbol412, _a412, InvalidArgumentError11, name412, marker512, symbol512, _a512, name512, marker612, symbol612, _a612, name612, marker712, symbol712, _a712, JSONParseError9, name712, marker812, symbol812, _a812, LoadAPIKeyError6, name812, marker912, symbol912, _a912, name912, marker1012, symbol1012, _a1012, name1012, marker1112, symbol1112, _a1112, NoSuchModelError4, name1112, marker1212, symbol1212, _a1212, name1212, marker1312, symbol1312, _a1312, _TypeValidationError17, TypeValidationError9, name1312, marker1412, symbol1412, _a1412, UnsupportedFunctionalityError8;
var init_dist21 = __esm({
  "node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    marker40 = "vercel.ai.error";
    symbol41 = Symbol.for(marker40);
    _AISDKError19 = class _AISDKError20 extends Error {
      static {
        __name(this, "_AISDKError");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a41] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError20.hasMarker(error87, marker40);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a41 = symbol41;
    AISDKError10 = _AISDKError19;
    name40 = "AI_APICallError";
    marker213 = `vercel.ai.error.${name40}`;
    symbol214 = Symbol.for(marker213);
    APICallError9 = class extends AISDKError10 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name40, message, cause });
        this[_a214] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker213);
      }
    };
    _a214 = symbol214;
    name213 = "AI_EmptyResponseBodyError";
    marker312 = `vercel.ai.error.${name213}`;
    symbol312 = Symbol.for(marker312);
    EmptyResponseBodyError8 = class extends AISDKError10 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name213, message });
        this[_a312] = true;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker312);
      }
    };
    _a312 = symbol312;
    __name(getErrorMessage11, "getErrorMessage");
    name312 = "AI_InvalidArgumentError";
    marker412 = `vercel.ai.error.${name312}`;
    symbol412 = Symbol.for(marker412);
    InvalidArgumentError11 = class extends AISDKError10 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name312, message, cause });
        this[_a412] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker412);
      }
    };
    _a412 = symbol412;
    name412 = "AI_InvalidPromptError";
    marker512 = `vercel.ai.error.${name412}`;
    symbol512 = Symbol.for(marker512);
    _a512 = symbol512;
    name512 = "AI_InvalidResponseDataError";
    marker612 = `vercel.ai.error.${name512}`;
    symbol612 = Symbol.for(marker612);
    _a612 = symbol612;
    name612 = "AI_JSONParseError";
    marker712 = `vercel.ai.error.${name612}`;
    symbol712 = Symbol.for(marker712);
    JSONParseError9 = class extends AISDKError10 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name612,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage11(cause)}`,
          cause
        });
        this[_a712] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker712);
      }
    };
    _a712 = symbol712;
    name712 = "AI_LoadAPIKeyError";
    marker812 = `vercel.ai.error.${name712}`;
    symbol812 = Symbol.for(marker812);
    LoadAPIKeyError6 = class extends AISDKError10 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name712, message });
        this[_a812] = true;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker812);
      }
    };
    _a812 = symbol812;
    name812 = "AI_LoadSettingError";
    marker912 = `vercel.ai.error.${name812}`;
    symbol912 = Symbol.for(marker912);
    _a912 = symbol912;
    name912 = "AI_NoContentGeneratedError";
    marker1012 = `vercel.ai.error.${name912}`;
    symbol1012 = Symbol.for(marker1012);
    _a1012 = symbol1012;
    name1012 = "AI_NoSuchModelError";
    marker1112 = `vercel.ai.error.${name1012}`;
    symbol1112 = Symbol.for(marker1112);
    NoSuchModelError4 = class extends AISDKError10 {
      static {
        __name(this, "NoSuchModelError");
      }
      constructor({
        errorName = name1012,
        modelId,
        modelType,
        message = `No such ${modelType}: ${modelId}`
      }) {
        super({ name: errorName, message });
        this[_a1112] = true;
        this.modelId = modelId;
        this.modelType = modelType;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker1112);
      }
    };
    _a1112 = symbol1112;
    name1112 = "AI_TooManyEmbeddingValuesForCallError";
    marker1212 = `vercel.ai.error.${name1112}`;
    symbol1212 = Symbol.for(marker1212);
    _a1212 = symbol1212;
    name1212 = "AI_TypeValidationError";
    marker1312 = `vercel.ai.error.${name1212}`;
    symbol1312 = Symbol.for(marker1312);
    _TypeValidationError17 = class _TypeValidationError18 extends AISDKError10 {
      static {
        __name(this, "_TypeValidationError");
      }
      constructor({ value, cause }) {
        super({
          name: name1212,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage11(cause)}`,
          cause
        });
        this[_a1312] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker1312);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError18.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError18({ value, cause });
      }
    };
    _a1312 = symbol1312;
    TypeValidationError9 = _TypeValidationError17;
    name1312 = "AI_UnsupportedFunctionalityError";
    marker1412 = `vercel.ai.error.${name1312}`;
    symbol1412 = Symbol.for(marker1412);
    UnsupportedFunctionalityError8 = class extends AISDKError10 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name1312, message });
        this[_a1412] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError10.hasMarker(error87, marker1412);
      }
    };
    _a1412 = symbol1412;
  }
});

// node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders7(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders7(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError10(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError7({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError10(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES7.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError9({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function getRuntimeEnvironmentUserAgent7(globalThisAny = globalThis) {
  var _a61, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a61 = globalThisAny.navigator) == null ? void 0 : _a61.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries5(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix8(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries5(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
function loadApiKey5({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError6({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError6({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError6({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError6({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse10(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx8.test(text3) === false && suspectConstructorRx8.test(text3) === false) {
    return obj;
  }
  return filter8(obj);
}
function filter8(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse8(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse10(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator9(validate) {
  return { [validatorSymbol10]: true, validate };
}
function isValidator9(value) {
  return typeof value === "object" && value !== null && validatorSymbol10 in value && value[validatorSymbol10] === true && "validate" in value;
}
function asValidator9(value) {
  return isValidator9(value) ? value : typeof value === "function" ? value() : standardSchemaValidator8(value);
}
function standardSchemaValidator8(standardSchema) {
  return validator9(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError9({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes8({
  value,
  schema
}) {
  const result = await safeValidateTypes9({ value, schema });
  if (!result.success) {
    throw TypeValidationError9.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes9({
  value,
  schema
}) {
  const validator22 = asValidator9(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError9.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError9.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON7({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse8(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes8({ value, schema });
  } catch (error87) {
    if (JSONParseError9.isInstance(error87) || TypeValidationError9.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError9({ text: text3, cause: error87 });
  }
}
async function safeParseJSON9({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse8(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes9({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError9.isInstance(error87) ? error87 : new JSONParseError9({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream7({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON9({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions6({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes9({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError11({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function convertUint8ArrayToBase648(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa11(latin1string);
}
function convertToBase646(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase648(value) : value;
}
function withoutTrailingSlash6(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
var createIdGenerator10, generateId10, FETCH_FAILED_ERROR_MESSAGES7, VERSION12, suspectProtoRx8, suspectConstructorRx8, validatorSymbol10, getOriginalFetch27, postJsonToApi7, postToApi7, createJsonErrorResponseHandler7, createEventSourceResponseHandler6, createJsonResponseHandler7, ignoreOverride10, ALPHA_NUMERIC10, schemaSymbol10, btoa11, atob11;
var init_dist22 = __esm({
  "node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist21();
    init_dist21();
    init_dist21();
    init_dist21();
    init_dist21();
    init_dist21();
    init_stream();
    init_dist21();
    init_dist21();
    init_dist21();
    init_dist2();
    __name(combineHeaders7, "combineHeaders");
    __name(extractResponseHeaders7, "extractResponseHeaders");
    createIdGenerator10 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError11({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId10 = createIdGenerator10();
    __name(isAbortError10, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES7 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError7, "handleFetchError");
    __name(getRuntimeEnvironmentUserAgent7, "getRuntimeEnvironmentUserAgent");
    __name(removeUndefinedEntries5, "removeUndefinedEntries");
    __name(withUserAgentSuffix8, "withUserAgentSuffix");
    VERSION12 = true ? "3.0.12" : "0.0.0-test";
    __name(loadApiKey5, "loadApiKey");
    suspectProtoRx8 = /"__proto__"\s*:/;
    suspectConstructorRx8 = /"constructor"\s*:/;
    __name(_parse10, "_parse");
    __name(filter8, "filter");
    __name(secureJsonParse8, "secureJsonParse");
    validatorSymbol10 = Symbol.for("vercel.ai.validator");
    __name(validator9, "validator");
    __name(isValidator9, "isValidator");
    __name(asValidator9, "asValidator");
    __name(standardSchemaValidator8, "standardSchemaValidator");
    __name(validateTypes8, "validateTypes");
    __name(safeValidateTypes9, "safeValidateTypes");
    __name(parseJSON7, "parseJSON");
    __name(safeParseJSON9, "safeParseJSON");
    __name(parseJsonEventStream7, "parseJsonEventStream");
    __name(parseProviderOptions6, "parseProviderOptions");
    getOriginalFetch27 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi7 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi7({
      url: url3,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi7 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch27()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: withUserAgentSuffix8(
            headers,
            `ai-sdk/provider-utils/${VERSION12}`,
            getRuntimeEnvironmentUserAgent7()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders7(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError10(error87) || APICallError9.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError9({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError10(error87) || APICallError9.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError9({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError7({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    createJsonErrorResponseHandler7 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders7(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError9({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON7({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError9({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError9({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler6 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders7(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError8({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream7({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler7 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON9({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders7(response);
      if (!parsedResult.success) {
        throw new APICallError9({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    ignoreOverride10 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    ALPHA_NUMERIC10 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    schemaSymbol10 = Symbol.for("vercel.ai.schema");
    ({ btoa: btoa11, atob: atob11 } = globalThis);
    __name(convertUint8ArrayToBase648, "convertUint8ArrayToBase64");
    __name(convertToBase646, "convertToBase64");
    __name(withoutTrailingSlash6, "withoutTrailingSlash");
  }
});

// node_modules/@ai-sdk/xai-v5/dist/index.mjs
function convertToXaiChatMessages(prompt) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase646(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError8({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text3 = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text3 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text3,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata4({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}
function prepareTools5({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools = [];
  for (const tool5 of tools) {
    if (tool5.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool5 });
    } else {
      xaiTools.push({
        type: "function",
        function: {
          name: tool5.name,
          description: tool5.description,
          parameters: tool5.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError8({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function createXai(options = {}) {
  var _a61;
  const baseURL = withoutTrailingSlash6(
    (_a61 = options.baseURL) != null ? _a61 : "https://api.x.ai/v1"
  );
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix8(
    {
      Authorization: `Bearer ${loadApiKey5({
        apiKey: options.apiKey,
        environmentVariableName: "XAI_API_KEY",
        description: "xAI API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/xai/${VERSION13}`
  ), "getHeaders");
  const createLanguageModel = /* @__PURE__ */ __name((modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId: generateId10,
      fetch: options.fetch
    });
  }, "createLanguageModel");
  const createImageModel = /* @__PURE__ */ __name((modelId) => {
    return new OpenAICompatibleImageModel2(modelId, {
      provider: "xai.image",
      url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  }, "createImageModel");
  const provider = /* @__PURE__ */ __name((modelId) => createLanguageModel(modelId), "provider");
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new NoSuchModelError4({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = createImageModel;
  provider.image = createImageModel;
  return provider;
}
var webSourceSchema, xSourceSchema, newsSourceSchema, rssSourceSchema, searchSourceSchema, xaiProviderOptions, xaiErrorDataSchema, xaiFailedResponseHandler, XaiChatLanguageModel, xaiUsageSchema, xaiChatResponseSchema, xaiChatChunkSchema, VERSION13, xaiErrorStructure, xai;
var init_dist23 = __esm({
  "node_modules/@ai-sdk/xai-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_dist20();
    init_dist21();
    init_dist22();
    init_dist22();
    init_v4();
    init_dist21();
    init_dist22();
    init_v4();
    init_dist22();
    init_v4();
    init_dist21();
    __name(convertToXaiChatMessages, "convertToXaiChatMessages");
    __name(getResponseMetadata4, "getResponseMetadata");
    __name(mapXaiFinishReason, "mapXaiFinishReason");
    webSourceSchema = external_exports.object({
      type: external_exports.literal("web"),
      country: external_exports.string().length(2).optional(),
      excludedWebsites: external_exports.array(external_exports.string()).max(5).optional(),
      allowedWebsites: external_exports.array(external_exports.string()).max(5).optional(),
      safeSearch: external_exports.boolean().optional()
    });
    xSourceSchema = external_exports.object({
      type: external_exports.literal("x"),
      excludedXHandles: external_exports.array(external_exports.string()).optional(),
      includedXHandles: external_exports.array(external_exports.string()).optional(),
      postFavoriteCount: external_exports.number().int().optional(),
      postViewCount: external_exports.number().int().optional(),
      /**
       * @deprecated use `includedXHandles` instead
       */
      xHandles: external_exports.array(external_exports.string()).optional()
    });
    newsSourceSchema = external_exports.object({
      type: external_exports.literal("news"),
      country: external_exports.string().length(2).optional(),
      excludedWebsites: external_exports.array(external_exports.string()).max(5).optional(),
      safeSearch: external_exports.boolean().optional()
    });
    rssSourceSchema = external_exports.object({
      type: external_exports.literal("rss"),
      links: external_exports.array(external_exports.string().url()).max(1)
      // currently only supports one RSS link
    });
    searchSourceSchema = external_exports.discriminatedUnion("type", [
      webSourceSchema,
      xSourceSchema,
      newsSourceSchema,
      rssSourceSchema
    ]);
    xaiProviderOptions = external_exports.object({
      reasoningEffort: external_exports.enum(["low", "high"]).optional(),
      searchParameters: external_exports.object({
        /**
         * search mode preference
         * - "off": disables search completely
         * - "auto": model decides whether to search (default)
         * - "on": always enables search
         */
        mode: external_exports.enum(["off", "auto", "on"]),
        /**
         * whether to return citations in the response
         * defaults to true
         */
        returnCitations: external_exports.boolean().optional(),
        /**
         * start date for search data (ISO8601 format: YYYY-MM-DD)
         */
        fromDate: external_exports.string().optional(),
        /**
         * end date for search data (ISO8601 format: YYYY-MM-DD)
         */
        toDate: external_exports.string().optional(),
        /**
         * maximum number of search results to consider
         * defaults to 20
         */
        maxSearchResults: external_exports.number().min(1).max(50).optional(),
        /**
         * data sources to search from
         * defaults to ["web", "x"] if not specified
         */
        sources: external_exports.array(searchSourceSchema).optional()
      }).optional()
    });
    xaiErrorDataSchema = external_exports.object({
      error: external_exports.object({
        message: external_exports.string(),
        type: external_exports.string().nullish(),
        param: external_exports.any().nullish(),
        code: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
      })
    });
    xaiFailedResponseHandler = createJsonErrorResponseHandler7({
      errorSchema: xaiErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    });
    __name(prepareTools5, "prepareTools");
    XaiChatLanguageModel = class {
      static {
        __name(this, "XaiChatLanguageModel");
      }
      constructor(modelId, config4) {
        this.specificationVersion = "v2";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config4;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        seed,
        responseFormat,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a61, _b, _c;
        const warnings = [];
        const options = (_a61 = await parseProviderOptions6({
          provider: "xai",
          providerOptions,
          schema: xaiProviderOptions
        })) != null ? _a61 : {};
        if (topK != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "topK"
          });
        }
        if (frequencyPenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty"
          });
        }
        if (presencePenalty != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty"
          });
        }
        if (stopSequences != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "stopSequences"
          });
        }
        if (responseFormat != null && responseFormat.type === "json" && responseFormat.schema != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format schema is not supported"
          });
        }
        const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
        warnings.push(...messageWarnings);
        const {
          tools: xaiTools,
          toolChoice: xaiToolChoice,
          toolWarnings
        } = prepareTools5({
          tools,
          toolChoice
        });
        warnings.push(...toolWarnings);
        const baseArgs = {
          // model id
          model: this.modelId,
          // standard generation settings
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          seed,
          reasoning_effort: options.reasoningEffort,
          // response format
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              name: (_b = responseFormat.name) != null ? _b : "response",
              schema: responseFormat.schema,
              strict: true
            }
          } : { type: "json_object" } : void 0,
          // search parameters
          search_parameters: options.searchParameters ? {
            mode: options.searchParameters.mode,
            return_citations: options.searchParameters.returnCitations,
            from_date: options.searchParameters.fromDate,
            to_date: options.searchParameters.toDate,
            max_search_results: options.searchParameters.maxSearchResults,
            sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
              var _a217;
              return {
                type: source.type,
                ...source.type === "web" && {
                  country: source.country,
                  excluded_websites: source.excludedWebsites,
                  allowed_websites: source.allowedWebsites,
                  safe_search: source.safeSearch
                },
                ...source.type === "x" && {
                  excluded_x_handles: source.excludedXHandles,
                  included_x_handles: (_a217 = source.includedXHandles) != null ? _a217 : source.xHandles,
                  post_favorite_count: source.postFavoriteCount,
                  post_view_count: source.postViewCount
                },
                ...source.type === "news" && {
                  country: source.country,
                  excluded_websites: source.excludedWebsites,
                  safe_search: source.safeSearch
                },
                ...source.type === "rss" && {
                  links: source.links
                }
              };
            })
          } : void 0,
          // messages in xai format
          messages,
          // tools in xai format
          tools: xaiTools,
          tool_choice: xaiToolChoice
        };
        return {
          args: baseArgs,
          warnings
        };
      }
      async doGenerate(options) {
        var _a61, _b, _c;
        const { args: body, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi7({
          url: `${(_a61 = this.config.baseURL) != null ? _a61 : "https://api.x.ai/v1"}/chat/completions`,
          headers: combineHeaders7(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler7(
            xaiChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice = response.choices[0];
        const content = [];
        if (choice.message.content != null && choice.message.content.length > 0) {
          let text3 = choice.message.content;
          const lastMessage = body.messages[body.messages.length - 1];
          if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text3 === lastMessage.content) {
            text3 = "";
          }
          if (text3.length > 0) {
            content.push({ type: "text", text: text3 });
          }
        }
        if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
          content.push({
            type: "reasoning",
            text: choice.message.reasoning_content
          });
        }
        if (choice.message.tool_calls != null) {
          for (const toolCall of choice.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        if (response.citations != null) {
          for (const url3 of response.citations) {
            content.push({
              type: "source",
              sourceType: "url",
              id: this.config.generateId(),
              url: url3
            });
          }
        }
        return {
          content,
          finishReason: mapXaiFinishReason(choice.finish_reason),
          usage: {
            inputTokens: response.usage.prompt_tokens,
            outputTokens: response.usage.completion_tokens,
            totalTokens: response.usage.total_tokens,
            reasoningTokens: (_c = (_b = response.usage.completion_tokens_details) == null ? void 0 : _b.reasoning_tokens) != null ? _c : void 0
          },
          request: { body },
          response: {
            ...getResponseMetadata4(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        var _a61;
        const { args, warnings } = await this.getArgs(options);
        const body = {
          ...args,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const { responseHeaders, value: response } = await postJsonToApi7({
          url: `${(_a61 = this.config.baseURL) != null ? _a61 : "https://api.x.ai/v1"}/chat/completions`,
          headers: combineHeaders7(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler6(xaiChatChunkSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "unknown";
        const usage = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0
        };
        let isFirstChunk = true;
        const contentBlocks = {};
        const lastReasoningDeltas = {};
        const self2 = this;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a217, _b;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if (isFirstChunk) {
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata4(value)
                  });
                  isFirstChunk = false;
                }
                if (value.citations != null) {
                  for (const url3 of value.citations) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: self2.config.generateId(),
                      url: url3
                    });
                  }
                }
                if (value.usage != null) {
                  usage.inputTokens = value.usage.prompt_tokens;
                  usage.outputTokens = value.usage.completion_tokens;
                  usage.totalTokens = value.usage.total_tokens;
                  usage.reasoningTokens = (_b = (_a217 = value.usage.completion_tokens_details) == null ? void 0 : _a217.reasoning_tokens) != null ? _b : void 0;
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapXaiFinishReason(choice.finish_reason);
                }
                if ((choice == null ? void 0 : choice.delta) == null) {
                  return;
                }
                const delta = choice.delta;
                const choiceIndex = choice.index;
                if (delta.content != null && delta.content.length > 0) {
                  const textContent = delta.content;
                  const lastMessage = body.messages[body.messages.length - 1];
                  if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                    return;
                  }
                  const blockId = `text-${value.id || choiceIndex}`;
                  if (contentBlocks[blockId] == null) {
                    contentBlocks[blockId] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: blockId
                    });
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: blockId,
                    delta: textContent
                  });
                }
                if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
                  const blockId = `reasoning-${value.id || choiceIndex}`;
                  if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                    return;
                  }
                  lastReasoningDeltas[blockId] = delta.reasoning_content;
                  if (contentBlocks[blockId] == null) {
                    contentBlocks[blockId] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: blockId
                    });
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: blockId,
                    delta: delta.reasoning_content
                  });
                }
                if (delta.tool_calls != null) {
                  for (const toolCall of delta.tool_calls) {
                    const toolCallId = toolCall.id;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallId,
                      toolName: toolCall.function.name
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCallId,
                      delta: toolCall.function.arguments
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                  }
                }
              },
              flush(controller) {
                for (const [blockId, block] of Object.entries(contentBlocks)) {
                  controller.enqueue({
                    type: block.type === "text" ? "text-end" : "reasoning-end",
                    id: blockId
                  });
                }
                controller.enqueue({ type: "finish", finishReason, usage });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    xaiUsageSchema = external_exports.object({
      prompt_tokens: external_exports.number(),
      completion_tokens: external_exports.number(),
      total_tokens: external_exports.number(),
      completion_tokens_details: external_exports.object({
        reasoning_tokens: external_exports.number().nullish()
      }).nullish()
    });
    xaiChatResponseSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          message: external_exports.object({
            role: external_exports.literal("assistant"),
            content: external_exports.string().nullish(),
            reasoning_content: external_exports.string().nullish(),
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string(),
                type: external_exports.literal("function"),
                function: external_exports.object({
                  name: external_exports.string(),
                  arguments: external_exports.string()
                })
              })
            ).nullish()
          }),
          index: external_exports.number(),
          finish_reason: external_exports.string().nullish()
        })
      ),
      object: external_exports.literal("chat.completion"),
      usage: xaiUsageSchema,
      citations: external_exports.array(external_exports.string().url()).nullish()
    });
    xaiChatChunkSchema = external_exports.object({
      id: external_exports.string().nullish(),
      created: external_exports.number().nullish(),
      model: external_exports.string().nullish(),
      choices: external_exports.array(
        external_exports.object({
          delta: external_exports.object({
            role: external_exports.enum(["assistant"]).optional(),
            content: external_exports.string().nullish(),
            reasoning_content: external_exports.string().nullish(),
            tool_calls: external_exports.array(
              external_exports.object({
                id: external_exports.string(),
                type: external_exports.literal("function"),
                function: external_exports.object({
                  name: external_exports.string(),
                  arguments: external_exports.string()
                })
              })
            ).nullish()
          }),
          finish_reason: external_exports.string().nullish(),
          index: external_exports.number()
        })
      ),
      usage: xaiUsageSchema.nullish(),
      citations: external_exports.array(external_exports.string().url()).nullish()
    });
    VERSION13 = true ? "2.0.26" : "0.0.0-test";
    xaiErrorStructure = {
      errorSchema: xaiErrorDataSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    };
    __name(createXai, "createXai");
    xai = createXai();
  }
});

// node_modules/@openrouter/ai-sdk-provider-v5/dist/index.mjs
function getErrorMessage12(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
function noop2(_arg) {
}
function createParser2(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop2, onError = noop2, onRetry = noop2, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  __name(feed, "feed");
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  __name(parseLine, "parseLine");
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError2(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError2(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  __name(processField, "processField");
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  __name(dispatchEvent, "dispatchEvent");
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  __name(reset, "reset");
  return { feed, reset };
}
function splitLines2(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
function combineHeaders8(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders8(response) {
  return Object.fromEntries([...response.headers]);
}
function isAbortError11(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
function handleFetchError8({
  error: error87,
  url: url3,
  requestBodyValues
}) {
  if (isAbortError11(error87)) {
    return error87;
  }
  if (error87 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES8.includes(error87.message.toLowerCase())) {
    const cause = error87.cause;
    if (cause != null) {
      return new APICallError10({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url3,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error87;
}
function removeUndefinedEntries6(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([_key, value]) => value != null)
  );
}
function loadApiKey6({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError7({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError7({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError7({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError7({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse11(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx9.test(text3) === false && suspectConstructorRx9.test(text3) === false) {
    return obj;
  }
  return filter9(obj);
}
function filter9(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse9(text3) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse11(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function validator10(validate) {
  return { [validatorSymbol11]: true, validate };
}
function isValidator10(value) {
  return typeof value === "object" && value !== null && validatorSymbol11 in value && value[validatorSymbol11] === true && "validate" in value;
}
function asValidator10(value) {
  return isValidator10(value) ? value : standardSchemaValidator9(value);
}
function standardSchemaValidator9(standardSchema) {
  return validator10(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError10({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes9({
  value,
  schema
}) {
  const result = await safeValidateTypes10({ value, schema });
  if (!result.success) {
    throw TypeValidationError10.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes10({
  value,
  schema
}) {
  const validator22 = asValidator10(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError10.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError10.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
async function parseJSON8({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse9(text3);
    if (schema == null) {
      return value;
    }
    return validateTypes9({ value, schema });
  } catch (error87) {
    if (JSONParseError10.isInstance(error87) || TypeValidationError10.isInstance(error87)) {
      throw error87;
    }
    throw new JSONParseError10({ text: text3, cause: error87 });
  }
}
async function safeParseJSON10({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse9(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes10({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError10.isInstance(error87) ? error87 : new JSONParseError10({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
function isParsableJson3(input) {
  try {
    secureJsonParse9(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream8({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON10({ text: data, schema }));
      }
    })
  );
}
function convertUint8ArrayToBase649(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa12(latin1string);
}
function withoutTrailingSlash7(url3) {
  return url3 == null ? void 0 : url3.replace(/\/$/, "");
}
function isDefinedOrNotNull(value) {
  return value !== null && value !== void 0;
}
function mapOpenRouterFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function isUrl({
  url: url3,
  protocols
}) {
  try {
    const urlObj = new URL(url3);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a154, _b;
  if (part.data instanceof Uint8Array) {
    const base646 = convertUint8ArrayToBase649(part.data);
    return `data:${(_a154 = part.mediaType) != null ? _a154 : defaultMediaType};base64,${base646}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a154;
  const match2 = dataUrl.match(/^data:([^;]+)/);
  return match2 ? (_a154 = match2[1]) != null ? _a154 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match2 = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match2 ? match2[1] : dataUrl;
}
function getCacheControl2(providerMetadata) {
  var _a154, _b, _c;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
  return (_c = (_b = (_a154 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a154 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _c : anthropic2 == null ? void 0 : anthropic2.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a154, _b, _c, _d, _e;
  const messages = [];
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl2(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a154 = content[0]) == null ? void 0 : _a154.type) === "text") {
          const cacheControl = (_b = getCacheControl2(providerOptions)) != null ? _b : getCacheControl2(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl2(providerOptions);
        const contentParts = content.map(
          (part) => {
            var _a163, _b2, _c2, _d2, _e2, _f;
            const cacheControl = (_a163 = getCacheControl2(part.providerOptions)) != null ? _a163 : messageCacheControl;
            switch (part.type) {
              case "text":
                return {
                  type: "text",
                  text: part.text,
                  // For text parts, only use part-specific cache control
                  cache_control: cacheControl
                };
              case "file": {
                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith("image/")) {
                  const url3 = getFileUrl({
                    part,
                    defaultMediaType: "image/jpeg"
                  });
                  return {
                    type: "image_url",
                    image_url: {
                      url: url3
                    },
                    // For image parts, use part-specific or message-level cache control
                    cache_control: cacheControl
                  };
                }
                const fileName = String(
                  (_f = (_e2 = (_d2 = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d2.filename) != null ? _e2 : part.filename) != null ? _f : ""
                );
                const fileData = getFileUrl({
                  part,
                  defaultMediaType: "application/pdf"
                });
                if (isUrl({
                  url: fileData,
                  protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                })) {
                  return {
                    type: "file",
                    file: {
                      filename: fileName,
                      file_data: fileData
                    }
                  };
                }
                return {
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  },
                  cache_control: cacheControl
                };
              }
              default: {
                return {
                  type: "text",
                  text: "",
                  cache_control: cacheControl
                };
              }
            }
          }
        );
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text3 = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text3 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "file":
              break;
            default: {
              break;
            }
          }
        }
        const parsedProviderOptions = OpenRouterProviderOptionsSchema.safeParse(providerOptions);
        const preservedReasoningDetails = parsedProviderOptions.success ? (_d = (_c = parsedProviderOptions.data) == null ? void 0 : _c.openrouter) == null ? void 0 : _d.reasoning_details : void 0;
        messages.push({
          role: "assistant",
          content: text3,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          reasoning: reasoning || void 0,
          // Only include reasoning_details if we have the preserved original version
          reasoning_details: preservedReasoningDetails && Array.isArray(preservedReasoningDetails) && preservedReasoningDetails.length > 0 ? preservedReasoningDetails : void 0,
          cache_control: getCacheControl2(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_e = getCacheControl2(providerOptions)) != null ? _e : getCacheControl2(toolResponse.providerOptions)
          });
        }
        break;
      }
      default: {
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  return input.output.type === "text" ? input.output.value : JSON.stringify(input.output.value);
}
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      toolChoice;
      throw new InvalidArgumentError12({
        argument: "toolChoice",
        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`
      });
    }
  }
}
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (inputFormat === "prompt" && prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text3 = "";
  if (prompt[0] && prompt[0].role === "system") {
    text3 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError5({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError9({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text3 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map(
          (part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError9({
                  functionality: "tool-call messages"
                });
              }
              case "tool-result": {
                throw new UnsupportedFunctionalityError9({
                  functionality: "tool-result messages"
                });
              }
              case "reasoning": {
                throw new UnsupportedFunctionalityError9({
                  functionality: "reasoning messages"
                });
              }
              case "file": {
                throw new UnsupportedFunctionalityError9({
                  functionality: "file attachments"
                });
              }
              default: {
                return "";
              }
            }
          }
        ).join("");
        text3 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError9({
          functionality: "tool messages"
        });
      }
      default: {
        break;
      }
    }
  }
  text3 += `${assistant}:
`;
  return {
    prompt: text3
  };
}
function removeUndefinedEntries22(record3) {
  return Object.fromEntries(
    Object.entries(record3).filter(([, value]) => value !== null)
  );
}
function withUserAgentSuffix9(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries22(
    headers != null ? headers : {}
  );
  const currentUserAgentHeader = cleanedHeaders["user-agent"] || "";
  const newUserAgent = [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ");
  return __spreadProps(__spreadValues({}, cleanedHeaders), {
    "user-agent": newUserAgent
  });
}
function createOpenRouter(options = {}) {
  var _a154, _b, _c;
  const baseURL = (_b = withoutTrailingSlash7((_a154 = options.baseURL) != null ? _a154 : options.baseUrl)) != null ? _b : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = /* @__PURE__ */ __name(() => withUserAgentSuffix9(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey6({
        apiKey: options.apiKey,
        environmentVariableName: "OPENROUTER_API_KEY",
        description: "OpenRouter"
      })}`
    }, options.headers),
    `ai-sdk/openrouter/${VERSION14}`
  ), "getHeaders");
  const createChatModel = /* @__PURE__ */ __name((modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  }), "createChatModel");
  const createCompletionModel = /* @__PURE__ */ __name((modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: /* @__PURE__ */ __name(({ path: path3 }) => `${baseURL}${path3}`, "url"),
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  }), "createCompletionModel");
  const createLanguageModel = /* @__PURE__ */ __name((modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  }, "createLanguageModel");
  const provider = /* @__PURE__ */ __name((modelId, settings) => createLanguageModel(modelId, settings), "provider");
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  return provider;
}
var __defProp5, __defProps, __getOwnPropDescs, __getOwnPropSymbols, __hasOwnProp3, __propIsEnum, __defNormalProp2, __spreadValues, __spreadProps, marker41, symbol50, _a50, _AISDKError21, AISDKError11, name41, marker214, symbol215, _a215, APICallError10, name214, marker313, symbol313, _a313, EmptyResponseBodyError9, name313, marker413, symbol413, _a413, InvalidArgumentError12, name413, marker513, symbol513, _a513, InvalidPromptError5, name513, marker613, symbol613, _a613, InvalidResponseDataError4, name613, marker713, symbol713, _a713, JSONParseError10, name713, marker813, symbol813, _a813, LoadAPIKeyError7, name813, marker913, symbol913, _a913, name913, marker1013, symbol1013, _a1013, NoContentGeneratedError2, name1013, marker1113, symbol1113, _a1113, name1113, marker1213, symbol1213, _a1213, name1213, marker1313, symbol1313, _a1313, _TypeValidationError19, TypeValidationError10, name1313, marker1413, symbol1413, _a1413, UnsupportedFunctionalityError9, ParseError2, EventSourceParserStream2, ignoreOverride11, ALPHA_NUMERIC11, createIdGenerator11, generateId11, FETCH_FAILED_ERROR_MESSAGES8, suspectProtoRx9, suspectConstructorRx9, validatorSymbol11, getOriginalFetch28, postJsonToApi8, postToApi8, createJsonErrorResponseHandler8, createEventSourceResponseHandler7, createJsonResponseHandler8, schemaSymbol11, btoa12, atob12, ReasoningFormat, CommonReasoningDetailSchema, ReasoningDetailSummarySchema, ReasoningDetailEncryptedSchema, ReasoningDetailTextSchema, ReasoningDetailUnionSchema, ReasoningDetailsWithUnknownSchema, ReasoningDetailArraySchema, OutputUnionToReasoningDetailsSchema, OpenRouterErrorResponseSchema, openrouterFailedResponseHandler, OpenRouterProviderMetadataSchema, OpenRouterProviderOptionsSchema, ChatCompletionToolChoiceSchema, ImageResponseSchema, ImageResponseWithUnknownSchema, ImageResponseArraySchema, OpenRouterChatCompletionBaseResponseSchema, OpenRouterNonStreamChatCompletionResponseSchema, OpenRouterStreamChatCompletionChunkSchema, OpenRouterChatLanguageModel, OpenRouterCompletionChunkSchema, OpenRouterCompletionLanguageModel, VERSION14, openrouter;
var init_dist24 = __esm({
  "node_modules/@openrouter/ai-sdk-provider-v5/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    init_v4();
    __defProp5 = Object.defineProperty;
    __defProps = Object.defineProperties;
    __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    __getOwnPropSymbols = Object.getOwnPropertySymbols;
    __hasOwnProp3 = Object.prototype.hasOwnProperty;
    __propIsEnum = Object.prototype.propertyIsEnumerable;
    __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
    __spreadValues = /* @__PURE__ */ __name((a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp3.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    }, "__spreadValues");
    __spreadProps = /* @__PURE__ */ __name((a, b) => __defProps(a, __getOwnPropDescs(b)), "__spreadProps");
    marker41 = "vercel.ai.error";
    symbol50 = Symbol.for(marker41);
    _AISDKError21 = class _AISDKError22 extends Error {
      static {
        __name(this, "_AISDKError2");
      }
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a50] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error87) {
        return _AISDKError22.hasMarker(error87, marker41);
      }
      static hasMarker(error87, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
      }
    };
    _a50 = symbol50;
    AISDKError11 = _AISDKError21;
    name41 = "AI_APICallError";
    marker214 = `vercel.ai.error.${name41}`;
    symbol215 = Symbol.for(marker214);
    APICallError10 = class extends AISDKError11 {
      static {
        __name(this, "APICallError");
      }
      constructor({
        message,
        url: url3,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name41, message, cause });
        this[_a215] = true;
        this.url = url3;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker214);
      }
    };
    _a215 = symbol215;
    name214 = "AI_EmptyResponseBodyError";
    marker313 = `vercel.ai.error.${name214}`;
    symbol313 = Symbol.for(marker313);
    EmptyResponseBodyError9 = class extends AISDKError11 {
      static {
        __name(this, "EmptyResponseBodyError");
      }
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name214, message });
        this[_a313] = true;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker313);
      }
    };
    _a313 = symbol313;
    __name(getErrorMessage12, "getErrorMessage");
    name313 = "AI_InvalidArgumentError";
    marker413 = `vercel.ai.error.${name313}`;
    symbol413 = Symbol.for(marker413);
    InvalidArgumentError12 = class extends AISDKError11 {
      static {
        __name(this, "InvalidArgumentError");
      }
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name313, message, cause });
        this[_a413] = true;
        this.argument = argument;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker413);
      }
    };
    _a413 = symbol413;
    name413 = "AI_InvalidPromptError";
    marker513 = `vercel.ai.error.${name413}`;
    symbol513 = Symbol.for(marker513);
    InvalidPromptError5 = class extends AISDKError11 {
      static {
        __name(this, "InvalidPromptError");
      }
      constructor({
        prompt,
        message,
        cause
      }) {
        super({ name: name413, message: `Invalid prompt: ${message}`, cause });
        this[_a513] = true;
        this.prompt = prompt;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker513);
      }
    };
    _a513 = symbol513;
    name513 = "AI_InvalidResponseDataError";
    marker613 = `vercel.ai.error.${name513}`;
    symbol613 = Symbol.for(marker613);
    InvalidResponseDataError4 = class extends AISDKError11 {
      static {
        __name(this, "InvalidResponseDataError");
      }
      constructor({
        data,
        message = `Invalid response data: ${JSON.stringify(data)}.`
      }) {
        super({ name: name513, message });
        this[_a613] = true;
        this.data = data;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker613);
      }
    };
    _a613 = symbol613;
    name613 = "AI_JSONParseError";
    marker713 = `vercel.ai.error.${name613}`;
    symbol713 = Symbol.for(marker713);
    JSONParseError10 = class extends AISDKError11 {
      static {
        __name(this, "JSONParseError");
      }
      constructor({ text: text3, cause }) {
        super({
          name: name613,
          message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage12(cause)}`,
          cause
        });
        this[_a713] = true;
        this.text = text3;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker713);
      }
    };
    _a713 = symbol713;
    name713 = "AI_LoadAPIKeyError";
    marker813 = `vercel.ai.error.${name713}`;
    symbol813 = Symbol.for(marker813);
    LoadAPIKeyError7 = class extends AISDKError11 {
      static {
        __name(this, "LoadAPIKeyError");
      }
      // used in isInstance
      constructor({ message }) {
        super({ name: name713, message });
        this[_a813] = true;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker813);
      }
    };
    _a813 = symbol813;
    name813 = "AI_LoadSettingError";
    marker913 = `vercel.ai.error.${name813}`;
    symbol913 = Symbol.for(marker913);
    _a913 = symbol913;
    name913 = "AI_NoContentGeneratedError";
    marker1013 = `vercel.ai.error.${name913}`;
    symbol1013 = Symbol.for(marker1013);
    NoContentGeneratedError2 = class extends AISDKError11 {
      static {
        __name(this, "NoContentGeneratedError");
      }
      // used in isInstance
      constructor({
        message = "No content generated."
      } = {}) {
        super({ name: name913, message });
        this[_a1013] = true;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker1013);
      }
    };
    _a1013 = symbol1013;
    name1013 = "AI_NoSuchModelError";
    marker1113 = `vercel.ai.error.${name1013}`;
    symbol1113 = Symbol.for(marker1113);
    _a1113 = symbol1113;
    name1113 = "AI_TooManyEmbeddingValuesForCallError";
    marker1213 = `vercel.ai.error.${name1113}`;
    symbol1213 = Symbol.for(marker1213);
    _a1213 = symbol1213;
    name1213 = "AI_TypeValidationError";
    marker1313 = `vercel.ai.error.${name1213}`;
    symbol1313 = Symbol.for(marker1313);
    _TypeValidationError19 = class _TypeValidationError22 extends AISDKError11 {
      static {
        __name(this, "_TypeValidationError2");
      }
      constructor({ value, cause }) {
        super({
          name: name1213,
          message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage12(cause)}`,
          cause
        });
        this[_a1313] = true;
        this.value = value;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker1313);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value,
        cause
      }) {
        return _TypeValidationError22.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError22({ value, cause });
      }
    };
    _a1313 = symbol1313;
    TypeValidationError10 = _TypeValidationError19;
    name1313 = "AI_UnsupportedFunctionalityError";
    marker1413 = `vercel.ai.error.${name1313}`;
    symbol1413 = Symbol.for(marker1413);
    UnsupportedFunctionalityError9 = class extends AISDKError11 {
      static {
        __name(this, "UnsupportedFunctionalityError");
      }
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name1313, message });
        this[_a1413] = true;
        this.functionality = functionality;
      }
      static isInstance(error87) {
        return AISDKError11.hasMarker(error87, marker1413);
      }
    };
    _a1413 = symbol1413;
    ParseError2 = class extends Error {
      static {
        __name(this, "ParseError");
      }
      constructor(message, options) {
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
      }
    };
    __name(noop2, "noop");
    __name(createParser2, "createParser");
    __name(splitLines2, "splitLines");
    EventSourceParserStream2 = class extends TransformStream {
      static {
        __name(this, "EventSourceParserStream");
      }
      constructor({ onError, onRetry, onComment } = {}) {
        let parser;
        super({
          start(controller) {
            parser = createParser2({
              onEvent: /* @__PURE__ */ __name((event) => {
                controller.enqueue(event);
              }, "onEvent"),
              onError(error87) {
                onError === "terminate" ? controller.error(error87) : typeof onError == "function" && onError(error87);
              },
              onRetry,
              onComment
            });
          },
          transform(chunk) {
            parser.feed(chunk);
          }
        });
      }
    };
    ignoreOverride11 = Symbol("Let zodToJsonSchema decide on which parser to use");
    ALPHA_NUMERIC11 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    __name(combineHeaders8, "combineHeaders");
    __name(extractResponseHeaders8, "extractResponseHeaders");
    createIdGenerator11 = /* @__PURE__ */ __name(({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = /* @__PURE__ */ __name(() => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      }, "generator");
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError12({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    }, "createIdGenerator");
    generateId11 = createIdGenerator11();
    __name(isAbortError11, "isAbortError");
    FETCH_FAILED_ERROR_MESSAGES8 = ["fetch failed", "failed to fetch"];
    __name(handleFetchError8, "handleFetchError");
    __name(removeUndefinedEntries6, "removeUndefinedEntries");
    __name(loadApiKey6, "loadApiKey");
    suspectProtoRx9 = /"__proto__"\s*:/;
    suspectConstructorRx9 = /"constructor"\s*:/;
    __name(_parse11, "_parse");
    __name(filter9, "filter");
    __name(secureJsonParse9, "secureJsonParse");
    validatorSymbol11 = Symbol.for("vercel.ai.validator");
    __name(validator10, "validator");
    __name(isValidator10, "isValidator");
    __name(asValidator10, "asValidator");
    __name(standardSchemaValidator9, "standardSchemaValidator");
    __name(validateTypes9, "validateTypes");
    __name(safeValidateTypes10, "safeValidateTypes");
    __name(parseJSON8, "parseJSON");
    __name(safeParseJSON10, "safeParseJSON");
    __name(isParsableJson3, "isParsableJson");
    __name(parseJsonEventStream8, "parseJsonEventStream");
    getOriginalFetch28 = /* @__PURE__ */ __name(() => globalThis.fetch, "getOriginalFetch2");
    postJsonToApi8 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi8({
      url: url3,
      headers: __spreadValues({
        "Content-Type": "application/json"
      }, headers),
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }), "postJsonToApi");
    postToApi8 = /* @__PURE__ */ __name(async ({
      url: url3,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch28()
    }) => {
      try {
        const response = await fetch2(url3, {
          method: "POST",
          headers: removeUndefinedEntries6(headers),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders8(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url: url3,
              requestBodyValues: body.values
            });
          } catch (error87) {
            if (isAbortError11(error87) || APICallError10.isInstance(error87)) {
              throw error87;
            }
            throw new APICallError10({
              message: "Failed to process error response",
              cause: error87,
              statusCode: response.status,
              url: url3,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url: url3,
            requestBodyValues: body.values
          });
        } catch (error87) {
          if (error87 instanceof Error) {
            if (isAbortError11(error87) || APICallError10.isInstance(error87)) {
              throw error87;
            }
          }
          throw new APICallError10({
            message: "Failed to process successful response",
            cause: error87,
            statusCode: response.status,
            url: url3,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error87) {
        throw handleFetchError8({ error: error87, url: url3, requestBodyValues: body.values });
      }
    }, "postToApi");
    createJsonErrorResponseHandler8 = /* @__PURE__ */ __name(({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders8(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError10({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON8({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError10({
            message: errorToMessage(parsedError),
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError10({
            message: response.statusText,
            url: url3,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    }, "createJsonErrorResponseHandler");
    createEventSourceResponseHandler7 = /* @__PURE__ */ __name((chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders8(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError9({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream8({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    }, "createEventSourceResponseHandler");
    createJsonResponseHandler8 = /* @__PURE__ */ __name((responseSchema2) => async ({ response, url: url3, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON10({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders8(response);
      if (!parsedResult.success) {
        throw new APICallError10({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url: url3,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    }, "createJsonResponseHandler");
    schemaSymbol11 = Symbol.for("vercel.ai.schema");
    ({ btoa: btoa12, atob: atob12 } = globalThis);
    __name(convertUint8ArrayToBase649, "convertUint8ArrayToBase64");
    __name(withoutTrailingSlash7, "withoutTrailingSlash");
    __name(isDefinedOrNotNull, "isDefinedOrNotNull");
    ReasoningFormat = /* @__PURE__ */ ((ReasoningFormat2) => {
      ReasoningFormat2["Unknown"] = "unknown";
      ReasoningFormat2["OpenAIResponsesV1"] = "openai-responses-v1";
      ReasoningFormat2["XAIResponsesV1"] = "xai-responses-v1";
      ReasoningFormat2["AnthropicClaudeV1"] = "anthropic-claude-v1";
      return ReasoningFormat2;
    })(ReasoningFormat || {});
    CommonReasoningDetailSchema = external_exports.object({
      id: external_exports.string().nullish(),
      format: external_exports.nativeEnum(ReasoningFormat).nullish(),
      index: external_exports.number().optional()
    }).passthrough();
    ReasoningDetailSummarySchema = external_exports.object({
      type: external_exports.literal(
        "reasoning.summary"
        /* Summary */
      ),
      summary: external_exports.string()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailEncryptedSchema = external_exports.object({
      type: external_exports.literal(
        "reasoning.encrypted"
        /* Encrypted */
      ),
      data: external_exports.string()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailTextSchema = external_exports.object({
      type: external_exports.literal(
        "reasoning.text"
        /* Text */
      ),
      text: external_exports.string().nullish(),
      signature: external_exports.string().nullish()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailUnionSchema = external_exports.union([
      ReasoningDetailSummarySchema,
      ReasoningDetailEncryptedSchema,
      ReasoningDetailTextSchema
    ]);
    ReasoningDetailsWithUnknownSchema = external_exports.union([
      ReasoningDetailUnionSchema,
      external_exports.unknown().transform(() => null)
    ]);
    ReasoningDetailArraySchema = external_exports.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
    OutputUnionToReasoningDetailsSchema = external_exports.union([
      external_exports.object({
        delta: external_exports.object({
          reasoning_details: external_exports.array(ReasoningDetailsWithUnknownSchema)
        })
      }).transform(
        (data) => data.delta.reasoning_details.filter(isDefinedOrNotNull)
      ),
      external_exports.object({
        message: external_exports.object({
          reasoning_details: external_exports.array(ReasoningDetailsWithUnknownSchema)
        })
      }).transform(
        (data) => data.message.reasoning_details.filter(isDefinedOrNotNull)
      ),
      external_exports.object({
        text: external_exports.string(),
        reasoning_details: external_exports.array(ReasoningDetailsWithUnknownSchema)
      }).transform((data) => data.reasoning_details.filter(isDefinedOrNotNull))
    ]);
    OpenRouterErrorResponseSchema = external_exports.object({
      error: external_exports.object({
        code: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional().default(null),
        message: external_exports.string(),
        type: external_exports.string().nullable().optional().default(null),
        param: external_exports.any().nullable().optional().default(null)
      }).passthrough()
    }).passthrough();
    openrouterFailedResponseHandler = createJsonErrorResponseHandler8({
      errorSchema: OpenRouterErrorResponseSchema,
      errorToMessage: /* @__PURE__ */ __name((data) => data.error.message, "errorToMessage")
    });
    OpenRouterProviderMetadataSchema = external_exports.object({
      provider: external_exports.string(),
      reasoning_details: external_exports.array(ReasoningDetailUnionSchema).optional(),
      usage: external_exports.object({
        promptTokens: external_exports.number(),
        promptTokensDetails: external_exports.object({
          cachedTokens: external_exports.number()
        }).passthrough().optional(),
        completionTokens: external_exports.number(),
        completionTokensDetails: external_exports.object({
          reasoningTokens: external_exports.number()
        }).passthrough().optional(),
        totalTokens: external_exports.number(),
        cost: external_exports.number().optional(),
        costDetails: external_exports.object({
          upstreamInferenceCost: external_exports.number()
        }).passthrough()
      }).passthrough()
    }).passthrough();
    OpenRouterProviderOptionsSchema = external_exports.object({
      openrouter: external_exports.object({
        reasoning_details: external_exports.array(ReasoningDetailUnionSchema).optional()
      }).optional()
    }).optional();
    __name(mapOpenRouterFinishReason, "mapOpenRouterFinishReason");
    __name(isUrl, "isUrl");
    __name(getFileUrl, "getFileUrl");
    __name(getMediaType, "getMediaType");
    __name(getBase64FromDataUrl, "getBase64FromDataUrl");
    __name(getCacheControl2, "getCacheControl");
    __name(convertToOpenRouterChatMessages, "convertToOpenRouterChatMessages");
    __name(getToolResultContent, "getToolResultContent");
    ChatCompletionToolChoiceSchema = external_exports.union([
      external_exports.literal("auto"),
      external_exports.literal("none"),
      external_exports.literal("required"),
      external_exports.object({
        type: external_exports.literal("function"),
        function: external_exports.object({
          name: external_exports.string()
        })
      })
    ]);
    __name(getChatCompletionToolChoice, "getChatCompletionToolChoice");
    ImageResponseSchema = external_exports.object({
      type: external_exports.literal("image_url"),
      image_url: external_exports.object({
        url: external_exports.string()
      }).passthrough()
    }).passthrough();
    ImageResponseWithUnknownSchema = external_exports.union([
      ImageResponseSchema,
      external_exports.unknown().transform(() => null)
    ]);
    ImageResponseArraySchema = external_exports.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
    OpenRouterChatCompletionBaseResponseSchema = external_exports.object({
      id: external_exports.string().optional(),
      model: external_exports.string().optional(),
      provider: external_exports.string().optional(),
      usage: external_exports.object({
        prompt_tokens: external_exports.number(),
        prompt_tokens_details: external_exports.object({
          cached_tokens: external_exports.number()
        }).passthrough().nullish(),
        completion_tokens: external_exports.number(),
        completion_tokens_details: external_exports.object({
          reasoning_tokens: external_exports.number()
        }).passthrough().nullish(),
        total_tokens: external_exports.number(),
        cost: external_exports.number().optional(),
        cost_details: external_exports.object({
          upstream_inference_cost: external_exports.number().nullish()
        }).passthrough().nullish()
      }).passthrough().nullish()
    }).passthrough();
    OpenRouterNonStreamChatCompletionResponseSchema = external_exports.union([
      // Success response with choices
      OpenRouterChatCompletionBaseResponseSchema.extend({
        choices: external_exports.array(
          external_exports.object({
            message: external_exports.object({
              role: external_exports.literal("assistant"),
              content: external_exports.string().nullable().optional(),
              reasoning: external_exports.string().nullable().optional(),
              reasoning_details: ReasoningDetailArraySchema.nullish(),
              images: ImageResponseArraySchema.nullish(),
              tool_calls: external_exports.array(
                external_exports.object({
                  id: external_exports.string().optional().nullable(),
                  type: external_exports.literal("function"),
                  function: external_exports.object({
                    name: external_exports.string(),
                    arguments: external_exports.string()
                  }).passthrough()
                }).passthrough()
              ).optional(),
              annotations: external_exports.array(
                external_exports.union([
                  // URL citation from web search
                  external_exports.object({
                    type: external_exports.literal("url_citation"),
                    url_citation: external_exports.object({
                      end_index: external_exports.number(),
                      start_index: external_exports.number(),
                      title: external_exports.string(),
                      url: external_exports.string(),
                      content: external_exports.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (old format)
                  external_exports.object({
                    type: external_exports.literal("file_annotation"),
                    file_annotation: external_exports.object({
                      file_id: external_exports.string(),
                      quote: external_exports.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (new format)
                  external_exports.object({
                    type: external_exports.literal("file"),
                    file: external_exports.object({
                      hash: external_exports.string(),
                      name: external_exports.string(),
                      content: external_exports.array(
                        external_exports.object({
                          type: external_exports.string(),
                          text: external_exports.string()
                        }).passthrough()
                      ).optional()
                    }).passthrough()
                  }).passthrough()
                ])
              ).nullish()
            }).passthrough(),
            index: external_exports.number().nullish(),
            logprobs: external_exports.object({
              content: external_exports.array(
                external_exports.object({
                  token: external_exports.string(),
                  logprob: external_exports.number(),
                  top_logprobs: external_exports.array(
                    external_exports.object({
                      token: external_exports.string(),
                      logprob: external_exports.number()
                    }).passthrough()
                  )
                }).passthrough()
              ).nullable()
            }).passthrough().nullable().optional(),
            finish_reason: external_exports.string().optional().nullable()
          }).passthrough()
        )
      }),
      // Error response (HTTP 200 with error payload)
      OpenRouterErrorResponseSchema.extend({
        user_id: external_exports.string().optional()
      })
    ]);
    OpenRouterStreamChatCompletionChunkSchema = external_exports.union([
      OpenRouterChatCompletionBaseResponseSchema.extend({
        choices: external_exports.array(
          external_exports.object({
            delta: external_exports.object({
              role: external_exports.enum(["assistant"]).optional(),
              content: external_exports.string().nullish(),
              reasoning: external_exports.string().nullish().optional(),
              reasoning_details: ReasoningDetailArraySchema.nullish(),
              images: ImageResponseArraySchema.nullish(),
              tool_calls: external_exports.array(
                external_exports.object({
                  index: external_exports.number().nullish(),
                  id: external_exports.string().nullish(),
                  type: external_exports.literal("function").optional(),
                  function: external_exports.object({
                    name: external_exports.string().nullish(),
                    arguments: external_exports.string().nullish()
                  }).passthrough()
                }).passthrough()
              ).nullish(),
              annotations: external_exports.array(
                external_exports.union([
                  // URL citation from web search
                  external_exports.object({
                    type: external_exports.literal("url_citation"),
                    url_citation: external_exports.object({
                      end_index: external_exports.number(),
                      start_index: external_exports.number(),
                      title: external_exports.string(),
                      url: external_exports.string(),
                      content: external_exports.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (old format)
                  external_exports.object({
                    type: external_exports.literal("file_annotation"),
                    file_annotation: external_exports.object({
                      file_id: external_exports.string(),
                      quote: external_exports.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (new format)
                  external_exports.object({
                    type: external_exports.literal("file"),
                    file: external_exports.object({
                      hash: external_exports.string(),
                      name: external_exports.string(),
                      content: external_exports.array(
                        external_exports.object({
                          type: external_exports.string(),
                          text: external_exports.string()
                        }).passthrough()
                      ).optional()
                    }).passthrough()
                  }).passthrough()
                ])
              ).nullish()
            }).passthrough().nullish(),
            logprobs: external_exports.object({
              content: external_exports.array(
                external_exports.object({
                  token: external_exports.string(),
                  logprob: external_exports.number(),
                  top_logprobs: external_exports.array(
                    external_exports.object({
                      token: external_exports.string(),
                      logprob: external_exports.number()
                    }).passthrough()
                  )
                }).passthrough()
              ).nullable()
            }).passthrough().nullish(),
            finish_reason: external_exports.string().nullable().optional(),
            index: external_exports.number().nullish()
          }).passthrough()
        )
      }),
      OpenRouterErrorResponseSchema
    ]);
    OpenRouterChatLanguageModel = class {
      static {
        __name(this, "OpenRouterChatLanguageModel");
      }
      constructor(modelId, settings, config4) {
        this.specificationVersion = "v2";
        this.provider = "openrouter";
        this.defaultObjectGenerationMode = "tool";
        this.supportedUrls = {
          "image/*": [
            /^data:image\/[a-zA-Z]+;base64,/,
            /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
          ],
          // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
          "application/*": [/^data:application\//, /^https?:\/\/.+$/]
        };
        this.modelId = modelId;
        this.settings = settings;
        this.config = config4;
      }
      getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        frequencyPenalty,
        presencePenalty,
        seed,
        stopSequences,
        responseFormat,
        topK,
        tools,
        toolChoice
      }) {
        var _a154;
        const baseArgs = __spreadValues(__spreadValues({
          // model id:
          model: this.modelId,
          models: this.settings.models,
          // model specific settings:
          logit_bias: this.settings.logitBias,
          logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
          top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
          user: this.settings.user,
          parallel_tool_calls: this.settings.parallelToolCalls,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          stop: stopSequences,
          response_format: responseFormat,
          top_k: topK,
          // messages:
          messages: convertToOpenRouterChatMessages(prompt),
          // OpenRouter specific settings:
          include_reasoning: this.settings.includeReasoning,
          reasoning: this.settings.reasoning,
          usage: this.settings.usage,
          // Web search settings:
          plugins: this.settings.plugins,
          web_search_options: this.settings.web_search_options,
          // Provider routing settings:
          provider: this.settings.provider
        }, this.config.extraBody), this.settings.extraBody);
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null) {
          return __spreadProps(__spreadValues({}, baseArgs), {
            response_format: {
              type: "json_schema",
              json_schema: __spreadValues({
                schema: responseFormat.schema,
                strict: true,
                name: (_a154 = responseFormat.name) != null ? _a154 : "response"
              }, responseFormat.description && {
                description: responseFormat.description
              })
            }
          });
        }
        if (tools && tools.length > 0) {
          const mappedTools = tools.filter((tool5) => tool5.type === "function").map((tool5) => ({
            type: "function",
            function: {
              name: tool5.name,
              description: tool5.description,
              parameters: tool5.inputSchema
            }
          }));
          return __spreadProps(__spreadValues({}, baseArgs), {
            tools: mappedTools,
            tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
          });
        }
        return baseArgs;
      }
      async doGenerate(options) {
        var _a154, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: responseValue, responseHeaders } = await postJsonToApi8({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders8(this.config.headers(), options.headers),
          body: args,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler8(
            OpenRouterNonStreamChatCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if ("error" in responseValue) {
          const errorData = responseValue.error;
          throw new APICallError10({
            message: errorData.message,
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId
            }),
            requestBodyValues: args,
            statusCode: 200,
            responseHeaders,
            data: errorData
          });
        }
        const response = responseValue;
        const choice = response.choices[0];
        if (!choice) {
          throw new NoContentGeneratedError2({
            message: "No choice in response"
          });
        }
        const usageInfo = response.usage ? {
          inputTokens: (_a154 = response.usage.prompt_tokens) != null ? _a154 : 0,
          outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,
          totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),
          reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,
          cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0
        } : {
          inputTokens: 0,
          outputTokens: 0,
          totalTokens: 0,
          reasoningTokens: 0,
          cachedInputTokens: 0
        };
        const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];
        const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
          switch (detail.type) {
            case "reasoning.text": {
              if (detail.text) {
                return {
                  type: "reasoning",
                  text: detail.text
                };
              }
              break;
            }
            case "reasoning.summary": {
              if (detail.summary) {
                return {
                  type: "reasoning",
                  text: detail.summary
                };
              }
              break;
            }
            case "reasoning.encrypted": {
              if (detail.data) {
                return {
                  type: "reasoning",
                  text: "[REDACTED]"
                };
              }
              break;
            }
            default: {
              detail;
            }
          }
          return null;
        }).filter((p) => p !== null) : choice.message.reasoning ? [
          {
            type: "reasoning",
            text: choice.message.reasoning
          }
        ] : [];
        const content = [];
        content.push(...reasoning);
        if (choice.message.content) {
          content.push({
            type: "text",
            text: choice.message.content
          });
        }
        if (choice.message.tool_calls) {
          for (const toolCall of choice.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: (_j = toolCall.id) != null ? _j : generateId11(),
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        if (choice.message.images) {
          for (const image of choice.message.images) {
            content.push({
              type: "file",
              mediaType: getMediaType(image.image_url.url, "image/jpeg"),
              data: getBase64FromDataUrl(image.image_url.url)
            });
          }
        }
        if (choice.message.annotations) {
          for (const annotation of choice.message.annotations) {
            if (annotation.type === "url_citation") {
              content.push({
                type: "source",
                sourceType: "url",
                id: annotation.url_citation.url,
                url: annotation.url_citation.url,
                title: annotation.url_citation.title,
                providerMetadata: {
                  openrouter: {
                    content: annotation.url_citation.content || ""
                  }
                }
              });
            }
          }
        }
        return {
          content,
          finishReason: mapOpenRouterFinishReason(choice.finish_reason),
          usage: usageInfo,
          warnings: [],
          providerMetadata: {
            openrouter: OpenRouterProviderMetadataSchema.parse({
              provider: (_k = response.provider) != null ? _k : "",
              reasoning_details: (_l = choice.message.reasoning_details) != null ? _l : [],
              usage: {
                promptTokens: (_m = usageInfo.inputTokens) != null ? _m : 0,
                completionTokens: (_n = usageInfo.outputTokens) != null ? _n : 0,
                totalTokens: (_o = usageInfo.totalTokens) != null ? _o : 0,
                cost: (_p = response.usage) == null ? void 0 : _p.cost,
                promptTokensDetails: {
                  cachedTokens: (_s = (_r = (_q = response.usage) == null ? void 0 : _q.prompt_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : 0
                },
                completionTokensDetails: {
                  reasoningTokens: (_v = (_u = (_t = response.usage) == null ? void 0 : _t.completion_tokens_details) == null ? void 0 : _u.reasoning_tokens) != null ? _v : 0
                },
                costDetails: {
                  upstreamInferenceCost: (_y = (_x = (_w = response.usage) == null ? void 0 : _w.cost_details) == null ? void 0 : _x.upstream_inference_cost) != null ? _y : 0
                }
              }
            })
          },
          request: { body: args },
          response: {
            id: response.id,
            modelId: response.model,
            headers: responseHeaders
          }
        };
      }
      async doStream(options) {
        var _a154;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi8({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders8(this.config.headers(), options.headers),
          body: __spreadProps(__spreadValues({}, args), {
            stream: true,
            // only include stream_options when in strict compatibility mode:
            stream_options: this.config.compatibility === "strict" ? __spreadValues({
              include_usage: true
            }, ((_a154 = this.settings.usage) == null ? void 0 : _a154.include) ? { include_usage: true } : {}) : void 0
          }),
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler7(
            OpenRouterStreamChatCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = "other";
        const usage = {
          inputTokens: Number.NaN,
          outputTokens: Number.NaN,
          totalTokens: Number.NaN,
          reasoningTokens: Number.NaN,
          cachedInputTokens: Number.NaN
        };
        const openrouterUsage = {};
        const accumulatedReasoningDetails = [];
        let textStarted = false;
        let reasoningStarted = false;
        let textId;
        let reasoningId;
        let openrouterResponseId;
        let provider;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                var _a163, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                if (value.provider) {
                  provider = value.provider;
                }
                if (value.id) {
                  openrouterResponseId = value.id;
                  controller.enqueue({
                    type: "response-metadata",
                    id: value.id
                  });
                }
                if (value.model) {
                  controller.enqueue({
                    type: "response-metadata",
                    modelId: value.model
                  });
                }
                if (value.usage != null) {
                  usage.inputTokens = value.usage.prompt_tokens;
                  usage.outputTokens = value.usage.completion_tokens;
                  usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
                  openrouterUsage.promptTokens = value.usage.prompt_tokens;
                  if (value.usage.prompt_tokens_details) {
                    const cachedInputTokens = (_a163 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a163 : 0;
                    usage.cachedInputTokens = cachedInputTokens;
                    openrouterUsage.promptTokensDetails = {
                      cachedTokens: cachedInputTokens
                    };
                  }
                  openrouterUsage.completionTokens = value.usage.completion_tokens;
                  if (value.usage.completion_tokens_details) {
                    const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                    usage.reasoningTokens = reasoningTokens;
                    openrouterUsage.completionTokensDetails = {
                      reasoningTokens
                    };
                  }
                  openrouterUsage.cost = value.usage.cost;
                  openrouterUsage.totalTokens = value.usage.total_tokens;
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenRouterFinishReason(choice.finish_reason);
                }
                if ((choice == null ? void 0 : choice.delta) == null) {
                  return;
                }
                const delta = choice.delta;
                const emitReasoningChunk = /* @__PURE__ */ __name((chunkText) => {
                  if (!reasoningStarted) {
                    reasoningId = openrouterResponseId || generateId11();
                    controller.enqueue({
                      type: "reasoning-start",
                      id: reasoningId
                    });
                    reasoningStarted = true;
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    delta: chunkText,
                    id: reasoningId || generateId11()
                  });
                }, "emitReasoningChunk");
                if (delta.reasoning_details && delta.reasoning_details.length > 0) {
                  accumulatedReasoningDetails.push(...delta.reasoning_details);
                  for (const detail of delta.reasoning_details) {
                    switch (detail.type) {
                      case "reasoning.text": {
                        if (detail.text) {
                          emitReasoningChunk(detail.text);
                        }
                        break;
                      }
                      case "reasoning.encrypted": {
                        if (detail.data) {
                          emitReasoningChunk("[REDACTED]");
                        }
                        break;
                      }
                      case "reasoning.summary": {
                        if (detail.summary) {
                          emitReasoningChunk(detail.summary);
                        }
                        break;
                      }
                      default: {
                        detail;
                        break;
                      }
                    }
                  }
                } else if (delta.reasoning) {
                  emitReasoningChunk(delta.reasoning);
                }
                if (delta.content) {
                  if (reasoningStarted && !textStarted) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: reasoningId || generateId11()
                    });
                    reasoningStarted = false;
                  }
                  if (!textStarted) {
                    textId = openrouterResponseId || generateId11();
                    controller.enqueue({
                      type: "text-start",
                      id: textId
                    });
                    textStarted = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    delta: delta.content,
                    id: textId || generateId11()
                  });
                }
                if (delta.annotations) {
                  for (const annotation of delta.annotations) {
                    if (annotation.type === "url_citation") {
                      controller.enqueue({
                        type: "source",
                        sourceType: "url",
                        id: annotation.url_citation.url,
                        url: annotation.url_citation.url,
                        title: annotation.url_citation.title,
                        providerMetadata: {
                          openrouter: {
                            content: annotation.url_citation.content || ""
                          }
                        }
                      });
                    }
                  }
                }
                if (delta.tool_calls != null) {
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.type !== "function") {
                        throw new InvalidResponseDataError4({
                          data: toolCallDelta,
                          message: `Expected 'function' type.`
                        });
                      }
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError4({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {
                        throw new InvalidResponseDataError4({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                        },
                        inputStarted: false,
                        sent: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (toolCall2 == null) {
                        throw new InvalidResponseDataError4({
                          data: { index, toolCallsLength: toolCalls.length },
                          message: `Tool call at index ${index} is missing after creation.`
                        });
                      }
                      if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson3(toolCall2.function.arguments)) {
                        toolCall2.inputStarted = true;
                        controller.enqueue({
                          type: "tool-input-start",
                          id: toolCall2.id,
                          toolName: toolCall2.function.name
                        });
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: toolCall2.id,
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.sent = true;
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall == null) {
                      throw new InvalidResponseDataError4({
                        data: {
                          index,
                          toolCallsLength: toolCalls.length,
                          toolCallDelta
                        },
                        message: `Tool call at index ${index} is missing during merge.`
                      });
                    }
                    if (!toolCall.inputStarted) {
                      toolCall.inputStarted = true;
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCall.id,
                        toolName: toolCall.function.name
                      });
                    }
                    if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {
                      toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_k = toolCallDelta.function.arguments) != null ? _k : ""
                    });
                    if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson3(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_n = toolCall.id) != null ? _n : generateId11(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                      toolCall.sent = true;
                    }
                  }
                }
                if (delta.images != null) {
                  for (const image of delta.images) {
                    controller.enqueue({
                      type: "file",
                      mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                      data: getBase64FromDataUrl(image.image_url.url)
                    });
                  }
                }
              },
              flush(controller) {
                var _a163;
                if (finishReason === "tool-calls") {
                  for (const toolCall of toolCalls) {
                    if (toolCall && !toolCall.sent) {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_a163 = toolCall.id) != null ? _a163 : generateId11(),
                        toolName: toolCall.function.name,
                        // Coerce invalid arguments to an empty JSON object
                        input: isParsableJson3(toolCall.function.arguments) ? toolCall.function.arguments : "{}"
                      });
                      toolCall.sent = true;
                    }
                  }
                }
                if (reasoningStarted) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: reasoningId || generateId11()
                  });
                }
                if (textStarted) {
                  controller.enqueue({
                    type: "text-end",
                    id: textId || generateId11()
                  });
                }
                const openrouterMetadata = {
                  usage: openrouterUsage
                };
                if (provider !== void 0) {
                  openrouterMetadata.provider = provider;
                }
                if (accumulatedReasoningDetails.length > 0) {
                  openrouterMetadata.reasoning_details = accumulatedReasoningDetails;
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    openrouter: openrouterMetadata
                  }
                });
              }
            })
          ),
          warnings: [],
          request: { body: args },
          response: { headers: responseHeaders }
        };
      }
    };
    __name(convertToOpenRouterCompletionPrompt, "convertToOpenRouterCompletionPrompt");
    OpenRouterCompletionChunkSchema = external_exports.union([
      external_exports.object({
        id: external_exports.string().optional(),
        model: external_exports.string().optional(),
        choices: external_exports.array(
          external_exports.object({
            text: external_exports.string(),
            reasoning: external_exports.string().nullish().optional(),
            reasoning_details: ReasoningDetailArraySchema.nullish(),
            finish_reason: external_exports.string().nullish(),
            index: external_exports.number().nullish(),
            logprobs: external_exports.object({
              tokens: external_exports.array(external_exports.string()),
              token_logprobs: external_exports.array(external_exports.number()),
              top_logprobs: external_exports.array(external_exports.record(external_exports.string(), external_exports.number())).nullable()
            }).passthrough().nullable().optional()
          }).passthrough()
        ),
        usage: external_exports.object({
          prompt_tokens: external_exports.number(),
          prompt_tokens_details: external_exports.object({
            cached_tokens: external_exports.number()
          }).passthrough().nullish(),
          completion_tokens: external_exports.number(),
          completion_tokens_details: external_exports.object({
            reasoning_tokens: external_exports.number()
          }).passthrough().nullish(),
          total_tokens: external_exports.number(),
          cost: external_exports.number().optional()
        }).passthrough().nullish()
      }).passthrough(),
      OpenRouterErrorResponseSchema
    ]);
    OpenRouterCompletionLanguageModel = class {
      static {
        __name(this, "OpenRouterCompletionLanguageModel");
      }
      constructor(modelId, settings, config4) {
        this.specificationVersion = "v2";
        this.provider = "openrouter";
        this.supportedUrls = {
          "image/*": [
            /^data:image\/[a-zA-Z]+;base64,/,
            /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
          ],
          "text/*": [/^data:text\//, /^https?:\/\/.+$/],
          "application/*": [/^data:application\//, /^https?:\/\/.+$/]
        };
        this.defaultObjectGenerationMode = void 0;
        this.modelId = modelId;
        this.settings = settings;
        this.config = config4;
      }
      getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        frequencyPenalty,
        presencePenalty,
        seed,
        responseFormat,
        topK,
        stopSequences,
        tools,
        toolChoice
      }) {
        const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
          prompt,
          inputFormat: "prompt"
        });
        if (tools == null ? void 0 : tools.length) {
          throw new UnsupportedFunctionalityError9({
            functionality: "tools"
          });
        }
        if (toolChoice) {
          throw new UnsupportedFunctionalityError9({
            functionality: "toolChoice"
          });
        }
        return __spreadValues(__spreadValues({
          // model id:
          model: this.modelId,
          models: this.settings.models,
          // model specific settings:
          logit_bias: this.settings.logitBias,
          logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
          suffix: this.settings.suffix,
          user: this.settings.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          stop: stopSequences,
          response_format: responseFormat,
          top_k: topK,
          // prompt:
          prompt: completionPrompt,
          // OpenRouter specific settings:
          include_reasoning: this.settings.includeReasoning,
          reasoning: this.settings.reasoning
        }, this.config.extraBody), this.settings.extraBody);
      }
      async doGenerate(options) {
        var _a154, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi8({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders8(this.config.headers(), options.headers),
          body: args,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler8(
            OpenRouterCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if ("error" in response) {
          const errorData = response.error;
          throw new APICallError10({
            message: errorData.message,
            url: this.config.url({
              path: "/completions",
              modelId: this.modelId
            }),
            requestBodyValues: args,
            statusCode: 200,
            responseHeaders,
            data: errorData
          });
        }
        const choice = response.choices[0];
        if (!choice) {
          throw new NoContentGeneratedError2({
            message: "No choice in OpenRouter completion response"
          });
        }
        return {
          content: [
            {
              type: "text",
              text: (_a154 = choice.text) != null ? _a154 : ""
            }
          ],
          finishReason: mapOpenRouterFinishReason(choice.finish_reason),
          usage: {
            inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,
            outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,
            totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),
            reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,
            cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0
          },
          warnings: [],
          response: {
            headers: responseHeaders
          }
        };
      }
      async doStream(options) {
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi8({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders8(this.config.headers(), options.headers),
          body: __spreadProps(__spreadValues({}, args), {
            stream: true,
            // only include stream_options when in strict compatibility mode:
            stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
          }),
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler7(
            OpenRouterCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = "other";
        const usage = {
          inputTokens: Number.NaN,
          outputTokens: Number.NaN,
          totalTokens: Number.NaN,
          reasoningTokens: Number.NaN,
          cachedInputTokens: Number.NaN
        };
        const openrouterUsage = {};
        return {
          stream: response.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                var _a154, _b;
                if (!chunk.success) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value = chunk.value;
                if ("error" in value) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                if (value.usage != null) {
                  usage.inputTokens = value.usage.prompt_tokens;
                  usage.outputTokens = value.usage.completion_tokens;
                  usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
                  openrouterUsage.promptTokens = value.usage.prompt_tokens;
                  if (value.usage.prompt_tokens_details) {
                    const cachedInputTokens = (_a154 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a154 : 0;
                    usage.cachedInputTokens = cachedInputTokens;
                    openrouterUsage.promptTokensDetails = {
                      cachedTokens: cachedInputTokens
                    };
                  }
                  openrouterUsage.completionTokens = value.usage.completion_tokens;
                  if (value.usage.completion_tokens_details) {
                    const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                    usage.reasoningTokens = reasoningTokens;
                    openrouterUsage.completionTokensDetails = {
                      reasoningTokens
                    };
                  }
                  openrouterUsage.cost = value.usage.cost;
                  openrouterUsage.totalTokens = value.usage.total_tokens;
                }
                const choice = value.choices[0];
                if ((choice == null ? void 0 : choice.finish_reason) != null) {
                  finishReason = mapOpenRouterFinishReason(choice.finish_reason);
                }
                if ((choice == null ? void 0 : choice.text) != null) {
                  controller.enqueue({
                    type: "text-delta",
                    delta: choice.text,
                    id: generateId11()
                  });
                }
              },
              flush(controller) {
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    openrouter: {
                      usage: openrouterUsage
                    }
                  }
                });
              }
            })
          ),
          response: {
            headers: responseHeaders
          }
        };
      }
    };
    __name(removeUndefinedEntries22, "removeUndefinedEntries2");
    __name(withUserAgentSuffix9, "withUserAgentSuffix");
    VERSION14 = false ? "0.0.0-test" : "1.2.3";
    __name(createOpenRouter, "createOpenRouter");
    openrouter = createOpenRouter({
      compatibility: "strict"
      // strict for OpenRouter API
    });
  }
});

// node_modules/@mastra/core/dist/chunk-R6XC4DV5.js
function parseModelRouterId(routerId, gatewayPrefix) {
  if (gatewayPrefix && !routerId.startsWith(`${gatewayPrefix}/`)) {
    throw new Error(`Expected ${gatewayPrefix}/ in model router ID ${routerId}`);
  }
  const idParts = routerId.split("/");
  if (gatewayPrefix && idParts.length < 3) {
    throw new Error(
      `Expected atleast 3 id parts ${gatewayPrefix}/provider/model, but only saw ${idParts.length} in ${routerId}`
    );
  }
  const providerId = idParts.at(gatewayPrefix ? 1 : 0);
  const modelId = idParts.slice(gatewayPrefix ? 2 : 1).join(`/`);
  if (!routerId.includes(`/`) || !providerId || !modelId) {
    throw new Error(
      `Attempted to parse provider/model from ${routerId} but this ID doesn't appear to contain a provider`
    );
  }
  return {
    providerId,
    modelId
  };
}
var PROVIDERS_WITH_INSTALLED_PACKAGES, EXCLUDED_PROVIDERS, OPENAI_COMPATIBLE_OVERRIDES, ModelsDevGateway;
var init_chunk_R6XC4DV5 = __esm({
  "node_modules/@mastra/core/dist/chunk-R6XC4DV5.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_BJ6XIEC6();
    init_dist5();
    init_dist8();
    init_dist11();
    init_dist14();
    init_dist17();
    init_dist23();
    init_dist24();
    __name(parseModelRouterId, "parseModelRouterId");
    PROVIDERS_WITH_INSTALLED_PACKAGES = ["anthropic", "google", "mistral", "openai", "openrouter", "xai"];
    EXCLUDED_PROVIDERS = ["github-copilot"];
    OPENAI_COMPATIBLE_OVERRIDES = {
      cerebras: {
        url: "https://api.cerebras.ai/v1"
      },
      mistral: {
        url: "https://api.mistral.ai/v1"
      },
      groq: {
        url: "https://api.groq.com/openai/v1"
      },
      togetherai: {
        url: "https://api.together.xyz/v1"
      },
      deepinfra: {
        url: "https://api.deepinfra.com/v1/openai"
      },
      perplexity: {
        url: "https://api.perplexity.ai"
      },
      vercel: {
        url: "https://ai-gateway.vercel.sh/v1",
        apiKeyEnvVar: "AI_GATEWAY_API_KEY"
      }
    };
    ModelsDevGateway = class extends MastraModelGateway {
      static {
        __name(this, "ModelsDevGateway");
      }
      id = "models.dev";
      name = "models.dev";
      providerConfigs = {};
      constructor(providerConfigs) {
        super();
        if (providerConfigs) this.providerConfigs = providerConfigs;
      }
      async fetchProviders() {
        const response = await fetch("https://models.dev/api.json");
        if (!response.ok) {
          throw new Error(`Failed to fetch from models.dev: ${response.statusText}`);
        }
        const data = await response.json();
        const providerConfigs = {};
        for (const [providerId, providerInfo] of Object.entries(data)) {
          if (EXCLUDED_PROVIDERS.includes(providerId)) continue;
          if (!providerInfo || typeof providerInfo !== "object" || !providerInfo.models) continue;
          const normalizedId = providerId;
          const isOpenAICompatible = providerInfo.npm === "@ai-sdk/openai-compatible" || providerInfo.npm === "@ai-sdk/gateway" || // Vercel AI Gateway is OpenAI-compatible
          normalizedId in OPENAI_COMPATIBLE_OVERRIDES;
          const hasInstalledPackage = PROVIDERS_WITH_INSTALLED_PACKAGES.includes(providerId);
          const hasApiAndEnv = providerInfo.api && providerInfo.env && providerInfo.env.length > 0;
          if (isOpenAICompatible || hasInstalledPackage || hasApiAndEnv) {
            const modelIds = Object.keys(providerInfo.models).sort();
            const url3 = providerInfo.api || OPENAI_COMPATIBLE_OVERRIDES[normalizedId]?.url;
            if (!hasInstalledPackage && !url3) {
              continue;
            }
            const apiKeyEnvVar = providerInfo.env?.[0] || `${normalizedId.toUpperCase().replace(/-/g, "_")}_API_KEY`;
            const apiKeyHeader = !hasInstalledPackage ? OPENAI_COMPATIBLE_OVERRIDES[normalizedId]?.apiKeyHeader || "Authorization" : void 0;
            providerConfigs[normalizedId] = {
              url: url3,
              apiKeyEnvVar,
              apiKeyHeader,
              name: providerInfo.name || providerId.charAt(0).toUpperCase() + providerId.slice(1),
              models: modelIds,
              docUrl: providerInfo.doc,
              // Include documentation URL if available
              gateway: `models.dev`
            };
          }
        }
        this.providerConfigs = providerConfigs;
        return providerConfigs;
      }
      buildUrl(routerId, envVars) {
        const { providerId } = parseModelRouterId(routerId);
        const config4 = this.providerConfigs[providerId];
        if (!config4?.url) {
          return;
        }
        const baseUrlEnvVar = `${providerId.toUpperCase().replace(/-/g, "_")}_BASE_URL`;
        const customBaseUrl = envVars?.[baseUrlEnvVar] || process.env[baseUrlEnvVar];
        return customBaseUrl || config4.url;
      }
      getApiKey(modelId) {
        const [provider, model] = modelId.split("/");
        if (!provider || !model) {
          throw new Error(`Could not identify provider from model id ${modelId}`);
        }
        const config4 = this.providerConfigs[provider];
        if (!config4) {
          throw new Error(`Could not find config for provider ${provider} with model id ${modelId}`);
        }
        const apiKey = typeof config4.apiKeyEnvVar === `string` ? process.env[config4.apiKeyEnvVar] : void 0;
        if (!apiKey) {
          throw new Error(`Could not find API key process.env.${config4.apiKeyEnvVar} for model id ${modelId}`);
        }
        return Promise.resolve(apiKey);
      }
      async resolveLanguageModel({
        modelId,
        providerId,
        apiKey,
        headers
      }) {
        const baseURL = this.buildUrl(`${providerId}/${modelId}`);
        switch (providerId) {
          case "openai":
            return createOpenAI({ apiKey }).responses(modelId);
          case "gemini":
          case "google":
            return createGoogleGenerativeAI({
              apiKey
            }).chat(modelId);
          case "anthropic":
            return createAnthropic({ apiKey })(modelId);
          case "mistral":
            return createMistral({ apiKey })(modelId);
          case "openrouter":
            return createOpenRouter({ apiKey, headers })(modelId);
          case "xai":
            return createXai({
              apiKey
            })(modelId);
          default:
            if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
            return createOpenAICompatible({ name: providerId, apiKey, baseURL, supportsStructuredOutputs: true }).chatModel(
              modelId
            );
        }
      }
    };
  }
});

// node_modules/@mastra/core/dist/models-dev-LJ4O6FNF.js
var models_dev_LJ4O6FNF_exports = {};
__export(models_dev_LJ4O6FNF_exports, {
  ModelsDevGateway: () => ModelsDevGateway
});
var init_models_dev_LJ4O6FNF = __esm({
  "node_modules/@mastra/core/dist/models-dev-LJ4O6FNF.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_R6XC4DV5();
  }
});

// node_modules/@isaacs/ttlcache/index.js
var require_ttlcache = __commonJS({
  "node_modules/@isaacs/ttlcache/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var now2 = /* @__PURE__ */ __name(() => perf.now(), "now");
    var isPosInt = /* @__PURE__ */ __name((n) => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt");
    var isPosIntOrInf = /* @__PURE__ */ __name((n) => n === Infinity || isPosInt(n), "isPosIntOrInf");
    var TTLCache2 = class _TTLCache {
      static {
        __name(this, "TTLCache");
      }
      constructor({
        max = Infinity,
        ttl,
        updateAgeOnGet = false,
        checkAgeOnGet = false,
        noUpdateTTL = false,
        dispose,
        noDisposeOnSet = false
      } = {}) {
        this.expirations = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ new Map();
        this.expirationMap = /* @__PURE__ */ new Map();
        if (ttl !== void 0 && !isPosIntOrInf(ttl)) {
          throw new TypeError(
            "ttl must be positive integer or Infinity if set"
          );
        }
        if (!isPosIntOrInf(max)) {
          throw new TypeError("max must be positive integer or Infinity");
        }
        this.ttl = ttl;
        this.max = max;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.checkAgeOnGet = !!checkAgeOnGet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDisposeOnSet = !!noDisposeOnSet;
        if (dispose !== void 0) {
          if (typeof dispose !== "function") {
            throw new TypeError("dispose must be function if set");
          }
          this.dispose = dispose;
        }
        this.timer = void 0;
        this.timerExpiration = void 0;
      }
      setTimer(expiration, ttl) {
        if (this.timerExpiration < expiration) {
          return;
        }
        if (this.timer) {
          clearTimeout(this.timer);
        }
        const t = setTimeout(() => {
          this.timer = void 0;
          this.timerExpiration = void 0;
          this.purgeStale();
          for (const exp in this.expirations) {
            this.setTimer(exp, exp - now2());
            break;
          }
        }, ttl);
        if (t.unref) t.unref();
        this.timerExpiration = expiration;
        this.timer = t;
      }
      // hang onto the timer so we can clearTimeout if all items
      // are deleted.  Deno doesn't have Timer.unref(), so it
      // hangs otherwise.
      cancelTimer() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timerExpiration = void 0;
          this.timer = void 0;
        }
      }
      /* istanbul ignore next */
      cancelTimers() {
        process.emitWarning(
          'TTLCache.cancelTimers has been renamed to TTLCache.cancelTimer (no "s"), and will be removed in the next major version update'
        );
        return this.cancelTimer();
      }
      clear() {
        const entries = this.dispose !== _TTLCache.prototype.dispose ? [...this] : [];
        this.data.clear();
        this.expirationMap.clear();
        this.cancelTimer();
        this.expirations = /* @__PURE__ */ Object.create(null);
        for (const [key, val] of entries) {
          this.dispose(val, key, "delete");
        }
      }
      setTTL(key, ttl = this.ttl) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const exp = this.expirations[current];
          if (!exp || exp.length <= 1) {
            delete this.expirations[current];
          } else {
            this.expirations[current] = exp.filter((k) => k !== key);
          }
        }
        if (ttl !== Infinity) {
          const expiration = Math.floor(now2() + ttl);
          this.expirationMap.set(key, expiration);
          if (!this.expirations[expiration]) {
            this.expirations[expiration] = [];
            this.setTimer(expiration, ttl);
          }
          this.expirations[expiration].push(key);
        } else {
          this.expirationMap.set(key, Infinity);
        }
      }
      set(key, val, {
        ttl = this.ttl,
        noUpdateTTL = this.noUpdateTTL,
        noDisposeOnSet = this.noDisposeOnSet
      } = {}) {
        if (!isPosIntOrInf(ttl)) {
          throw new TypeError("ttl must be positive integer or Infinity");
        }
        if (this.expirationMap.has(key)) {
          if (!noUpdateTTL) {
            this.setTTL(key, ttl);
          }
          const oldValue = this.data.get(key);
          if (oldValue !== val) {
            this.data.set(key, val);
            if (!noDisposeOnSet) {
              this.dispose(oldValue, key, "set");
            }
          }
        } else {
          this.setTTL(key, ttl);
          this.data.set(key, val);
        }
        while (this.size > this.max) {
          this.purgeToCapacity();
        }
        return this;
      }
      has(key) {
        return this.data.has(key);
      }
      getRemainingTTL(key) {
        const expiration = this.expirationMap.get(key);
        return expiration === Infinity ? expiration : expiration !== void 0 ? Math.max(0, Math.ceil(expiration - now2())) : 0;
      }
      get(key, {
        updateAgeOnGet = this.updateAgeOnGet,
        ttl = this.ttl,
        checkAgeOnGet = this.checkAgeOnGet
      } = {}) {
        const val = this.data.get(key);
        if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {
          this.delete(key);
          return void 0;
        }
        if (updateAgeOnGet) {
          this.setTTL(key, ttl);
        }
        return val;
      }
      dispose(_, __) {
      }
      delete(key) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const value = this.data.get(key);
          this.data.delete(key);
          this.expirationMap.delete(key);
          const exp = this.expirations[current];
          if (exp) {
            if (exp.length <= 1) {
              delete this.expirations[current];
            } else {
              this.expirations[current] = exp.filter((k) => k !== key);
            }
          }
          this.dispose(value, key, "delete");
          if (this.size === 0) {
            this.cancelTimer();
          }
          return true;
        }
        return false;
      }
      purgeToCapacity() {
        for (const exp in this.expirations) {
          const keys = this.expirations[exp];
          if (this.size - keys.length >= this.max) {
            delete this.expirations[exp];
            const entries = [];
            for (const key of keys) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
          } else {
            const s = this.size - this.max;
            const entries = [];
            for (const key of keys.splice(0, s)) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
            return;
          }
        }
      }
      get size() {
        return this.data.size;
      }
      purgeStale() {
        const n = Math.ceil(now2());
        for (const exp in this.expirations) {
          if (exp === "Infinity" || exp > n) {
            return;
          }
          const keys = [...this.expirations[exp] || []];
          const entries = [];
          delete this.expirations[exp];
          for (const key of keys) {
            entries.push([key, this.data.get(key)]);
            this.data.delete(key);
            this.expirationMap.delete(key);
          }
          for (const [key, val] of entries) {
            this.dispose(val, key, "stale");
          }
        }
        if (this.size === 0) {
          this.cancelTimer();
        }
      }
      *entries() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield [key, this.data.get(key)];
          }
        }
      }
      *keys() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield key;
          }
        }
      }
      *values() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield this.data.get(key);
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
    module.exports = TTLCache2;
  }
});

// node_modules/@mastra/core/dist/chunk-3NTOFNIU.js
var import_ttlcache, MastraServerCache, InMemoryServerCache;
var init_chunk_3NTOFNIU = __esm({
  "node_modules/@mastra/core/dist/chunk-3NTOFNIU.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_VQASQG5D();
    import_ttlcache = __toESM(require_ttlcache(), 1);
    MastraServerCache = class extends MastraBase {
      static {
        __name(this, "MastraServerCache");
      }
      constructor({ name: name51 }) {
        super({
          component: "SERVER_CACHE",
          name: name51
        });
      }
    };
    InMemoryServerCache = class extends MastraServerCache {
      static {
        __name(this, "InMemoryServerCache");
      }
      cache = new import_ttlcache.default({
        max: 1e3,
        ttl: 1e3 * 60 * 5
      });
      constructor() {
        super({ name: "InMemoryServerCache" });
      }
      async get(key) {
        return this.cache.get(key);
      }
      async set(key, value) {
        this.cache.set(key, value);
      }
      async listLength(key) {
        const list = this.cache.get(key);
        if (!Array.isArray(list)) {
          throw new Error(`${key} is not an array`);
        }
        return list.length;
      }
      async listPush(key, value) {
        const list = this.cache.get(key);
        if (Array.isArray(list)) {
          list.push(value);
        } else {
          this.cache.set(key, [value]);
        }
      }
      async listFromTo(key, from, to = -1) {
        const list = this.cache.get(key);
        if (Array.isArray(list)) {
          const endIndex = to === -1 ? void 0 : to + 1;
          return list.slice(from, endIndex);
        }
        return [];
      }
      async delete(key) {
        this.cache.delete(key);
      }
      async clear() {
        this.cache.clear();
      }
    };
  }
});

// node_modules/@mastra/core/dist/chunk-HSX2K7HB.js
var NetlifyGateway;
var init_chunk_HSX2K7HB = __esm({
  "node_modules/@mastra/core/dist/chunk-HSX2K7HB.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_BJ6XIEC6();
    init_chunk_3NTOFNIU();
    init_chunk_PZUZNPFM();
    init_dist5();
    init_dist8();
    init_dist14();
    init_dist17();
    NetlifyGateway = class extends MastraModelGateway {
      static {
        __name(this, "NetlifyGateway");
      }
      id = "netlify";
      name = "Netlify AI Gateway";
      tokenCache = new InMemoryServerCache();
      async fetchProviders() {
        const response = await fetch("https://api.netlify.com/api/v1/ai-gateway/providers");
        if (!response.ok) {
          throw new Error(`Failed to fetch from Netlify: ${response.statusText}`);
        }
        const data = await response.json();
        const config4 = {
          apiKeyEnvVar: ["NETLIFY_TOKEN", "NETLIFY_SITE_ID"],
          apiKeyHeader: "Authorization",
          name: `Netlify`,
          gateway: `netlify`,
          models: [],
          docUrl: "https://docs.netlify.com/build/ai-gateway/overview/"
        };
        for (const [providerId, provider] of Object.entries(data.providers)) {
          for (const model of provider.models) {
            config4.models.push(`${providerId}/${model}`);
          }
        }
        return { netlify: config4 };
      }
      async buildUrl(routerId, envVars) {
        const siteId = envVars?.["NETLIFY_SITE_ID"] || process.env["NETLIFY_SITE_ID"];
        const netlifyToken = envVars?.["NETLIFY_TOKEN"] || process.env["NETLIFY_TOKEN"];
        if (!netlifyToken) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_NO_TOKEN",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Missing NETLIFY_TOKEN environment variable required for model: ${routerId}`
          });
        }
        if (!siteId) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_NO_SITE_ID",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Missing NETLIFY_SITE_ID environment variable required for model: ${routerId}`
          });
        }
        try {
          const tokenData = await this.getOrFetchToken(siteId, netlifyToken);
          return tokenData.url.endsWith(`/`) ? tokenData.url.substring(0, tokenData.url.length - 1) : tokenData.url;
        } catch (error87) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_TOKEN_ERROR",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Failed to get Netlify AI Gateway token for model ${routerId}: ${error87 instanceof Error ? error87.message : String(error87)}`
          });
        }
      }
      /**
       * Get cached token or fetch a new site-specific AI Gateway token from Netlify
       */
      async getOrFetchToken(siteId, netlifyToken) {
        const cacheKey = `netlify-token:${siteId}:${netlifyToken}`;
        const cached3 = await this.tokenCache.get(cacheKey);
        if (cached3 && cached3.expiresAt > Date.now() / 1e3 + 60) {
          return { token: cached3.token, url: cached3.url };
        }
        const response = await fetch(`https://api.netlify.com/api/v1/sites/${siteId}/ai-gateway/token`, {
          method: "GET",
          headers: {
            Authorization: `Bearer ${netlifyToken}`
          }
        });
        if (!response.ok) {
          const error87 = await response.text();
          throw new Error(`Failed to get Netlify AI Gateway token: ${response.status} ${error87}`);
        }
        const tokenResponse = await response.json();
        await this.tokenCache.set(cacheKey, {
          token: tokenResponse.token,
          url: tokenResponse.url,
          expiresAt: tokenResponse.expires_at
        });
        return { token: tokenResponse.token, url: tokenResponse.url };
      }
      /**
       * Get cached token or fetch a new site-specific AI Gateway token from Netlify
       */
      async getApiKey(modelId) {
        const siteId = process.env["NETLIFY_SITE_ID"];
        const netlifyToken = process.env["NETLIFY_TOKEN"];
        if (!netlifyToken) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_NO_TOKEN",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Missing NETLIFY_TOKEN environment variable required for model: ${modelId}`
          });
        }
        if (!siteId) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_NO_SITE_ID",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Missing NETLIFY_SITE_ID environment variable required for model: ${modelId}`
          });
        }
        try {
          return (await this.getOrFetchToken(siteId, netlifyToken)).token;
        } catch (error87) {
          throw new MastraError({
            id: "NETLIFY_GATEWAY_TOKEN_ERROR",
            domain: "LLM",
            category: "UNKNOWN",
            text: `Failed to get Netlify AI Gateway token for model ${modelId}: ${error87 instanceof Error ? error87.message : String(error87)}`
          });
        }
      }
      async resolveLanguageModel({
        modelId,
        providerId,
        apiKey,
        headers
      }) {
        const baseURL = await this.buildUrl(`${providerId}/${modelId}`);
        switch (providerId) {
          case "openai":
            return createOpenAI({ apiKey, baseURL, headers }).responses(modelId);
          case "gemini":
            return createGoogleGenerativeAI({
              baseURL: `${baseURL}/v1beta/`,
              apiKey,
              headers: {
                "user-agent": "google-genai-sdk/",
                ...headers ? headers : {}
              }
            }).chat(modelId);
          case "anthropic":
            return createAnthropic({
              apiKey,
              baseURL: `${baseURL}/v1/`,
              headers: {
                "anthropic-version": "2023-06-01",
                "user-agent": "anthropic/",
                ...headers ? headers : {}
              }
            })(modelId);
          default:
            return createOpenAICompatible({ name: providerId, apiKey, baseURL, supportsStructuredOutputs: true }).chatModel(
              modelId
            );
        }
      }
    };
  }
});

// node_modules/@mastra/core/dist/netlify-L7AZ74PV.js
var netlify_L7AZ74PV_exports = {};
__export(netlify_L7AZ74PV_exports, {
  NetlifyGateway: () => NetlifyGateway
});
var init_netlify_L7AZ74PV = __esm({
  "node_modules/@mastra/core/dist/netlify-L7AZ74PV.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_chunk_HSX2K7HB();
  }
});

// node_modules/@mastra/core/dist/registry-generator-I6S4ARS6.js
var registry_generator_I6S4ARS6_exports = {};
__export(registry_generator_I6S4ARS6_exports, {
  atomicWriteFile: () => atomicWriteFile,
  fetchProvidersFromGateways: () => fetchProvidersFromGateways,
  generateTypesContent: () => generateTypesContent,
  writeRegistryFiles: () => writeRegistryFiles
});
import fs from "fs/promises";
import path from "path";
async function atomicWriteFile(filePath, content, encoding = "utf-8") {
  const randomSuffix = Math.random().toString(36).substring(2, 15);
  const tempPath = `${filePath}.${process.pid}.${Date.now()}.${randomSuffix}.tmp`;
  try {
    await fs.writeFile(tempPath, content, encoding);
    await fs.rename(tempPath, filePath);
  } catch (error87) {
    try {
      await fs.unlink(tempPath);
    } catch {
    }
    throw error87;
  }
}
async function fetchProvidersFromGateways(gateways) {
  const allProviders = {};
  const allModels = {};
  const maxRetries = 3;
  for (const gateway of gateways) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const providers = await gateway.fetchProviders();
        const isProviderRegistry = gateway.id === "models.dev";
        for (const [providerId, config4] of Object.entries(providers)) {
          const typeProviderId = isProviderRegistry ? providerId : providerId === gateway.id ? gateway.id : `${gateway.id}/${providerId}`;
          allProviders[typeProviderId] = config4;
          allModels[typeProviderId] = config4.models.sort();
        }
        lastError = null;
        break;
      } catch (error87) {
        lastError = error87 instanceof Error ? error87 : new Error(String(error87));
        if (attempt < maxRetries) {
          const delayMs = Math.min(1e3 * Math.pow(2, attempt - 1), 5e3);
          await new Promise((resolve3) => setTimeout(resolve3, delayMs));
        }
      }
    }
    if (lastError) {
      throw lastError;
    }
  }
  return { providers: allProviders, models: allModels };
}
function generateTypesContent(models) {
  const providerModelsEntries = Object.entries(models).map(([provider, modelList]) => {
    const modelsList = modelList.map((m) => `'${m}'`);
    const needsQuotes = /[^a-zA-Z0-9_$]/.test(provider);
    const providerKey = needsQuotes ? `'${provider}'` : provider;
    const singleLine = `  readonly ${providerKey}: readonly [${modelsList.join(", ")}];`;
    if (singleLine.length > 120) {
      const formattedModels = modelList.map((m) => `    '${m}',`).join("\n");
      return `  readonly ${providerKey}: readonly [
${formattedModels}
  ];`;
    }
    return singleLine;
  }).join("\n");
  return `/**
 * THIS FILE IS AUTO-GENERATED - DO NOT EDIT
 * Generated from model gateway providers
 */

/**
 * Provider models mapping type
 * This is derived from the JSON data and provides type-safe access
 */
export type ProviderModelsMap = {
${providerModelsEntries}
};

/**
 * Union type of all registered provider IDs
 */
export type Provider = keyof ProviderModelsMap;

/**
 * Provider models mapping interface
 */
export interface ProviderModels {
  [key: string]: string[];
}

/**
 * OpenAI-compatible model ID type
 * Dynamically derived from ProviderModelsMap
 * Full provider/model paths (e.g., "openai/gpt-4o", "anthropic/claude-3-5-sonnet-20241022")
 */
export type ModelRouterModelId =
  | {
      [P in Provider]: \`\${P}/\${ProviderModelsMap[P][number]}\`;
    }[Provider]
  | (string & {});

/**
 * Extract the model part from a ModelRouterModelId for a specific provider
 * Dynamically derived from ProviderModelsMap
 * Example: ModelForProvider<'openai'> = 'gpt-4o' | 'gpt-4-turbo' | ...
 */
export type ModelForProvider<P extends Provider> = ProviderModelsMap[P][number];
`;
}
async function writeRegistryFiles(jsonPath, typesPath, providers, models) {
  const jsonDir = path.dirname(jsonPath);
  const typesDir = path.dirname(typesPath);
  await fs.mkdir(jsonDir, { recursive: true });
  await fs.mkdir(typesDir, { recursive: true });
  const registryData2 = {
    providers,
    models,
    version: "1.0.0"
  };
  await atomicWriteFile(jsonPath, JSON.stringify(registryData2, null, 2), "utf-8");
  const typeContent = generateTypesContent(models);
  await atomicWriteFile(typesPath, typeContent, "utf-8");
}
var init_registry_generator_I6S4ARS6 = __esm({
  "node_modules/@mastra/core/dist/registry-generator-I6S4ARS6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    __name(atomicWriteFile, "atomicWriteFile");
    __name(fetchProvidersFromGateways, "fetchProvidersFromGateways");
    __name(generateTypesContent, "generateTypesContent");
    __name(writeRegistryFiles, "writeRegistryFiles");
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// node_modules/is-network-error/index.js
function isNetworkError(error87) {
  const isValid2 = error87 && isError(error87) && error87.name === "TypeError" && typeof error87.message === "string";
  if (!isValid2) {
    return false;
  }
  const { message, stack } = error87;
  if (message === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error87;
  }
  if (message.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message);
}
var objectToString, isError, errorMessages;
var init_is_network_error = __esm({
  "node_modules/is-network-error/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    objectToString = Object.prototype.toString;
    isError = /* @__PURE__ */ __name((value) => objectToString.call(value) === "[object Error]", "isError");
    errorMessages = /* @__PURE__ */ new Set([
      "network error",
      // Chrome
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari 16
      "Network request failed",
      // `cross-fetch`
      "fetch failed",
      // Undici (Node.js)
      "terminated",
      // Undici (Node.js)
      " A network error occurred.",
      // Bun (WebKit)
      "Network connection lost"
      // Cloudflare Workers (fetch)
    ]);
    __name(isNetworkError, "isNetworkError");
  }
});

// node_modules/p-retry/index.js
var p_retry_exports = {};
__export(p_retry_exports, {
  AbortError: () => AbortError,
  default: () => pRetry,
  makeRetriable: () => makeRetriable
});
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name51, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name51}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name51}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name51}\` to be \u2265 ${min}.`);
  }
}
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start);
}
async function onAttemptFailure({ error: error87, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error87 instanceof Error ? error87 : new TypeError(`Non-error was thrown: "${error87}". You should only throw errors.`);
  if (normalizedError instanceof AbortError) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context3 = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context3);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context3);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context3)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  options.signal?.throwIfAborted();
  if (finalDelay > 0) {
    await new Promise((resolve3, reject) => {
      const onAbort = /* @__PURE__ */ __name(() => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      }, "onAbort");
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve3();
      }, finalDelay);
      if (options.unref) {
        timeoutToken.unref?.();
      }
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1e3;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {
  };
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
  validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
  validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
  validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error87) {
      if (await onAttemptFailure({
        error: error87,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
function makeRetriable(function_, options) {
  return function(...arguments_) {
    return pRetry(() => function_.apply(this, arguments_), options);
  };
}
var AbortError;
var init_p_retry = __esm({
  "node_modules/p-retry/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_performance2();
    init_is_network_error();
    __name(validateRetries, "validateRetries");
    __name(validateNumberOption, "validateNumberOption");
    AbortError = class extends Error {
      static {
        __name(this, "AbortError");
      }
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    __name(calculateDelay, "calculateDelay");
    __name(calculateRemainingTime, "calculateRemainingTime");
    __name(onAttemptFailure, "onAttemptFailure");
    __name(pRetry, "pRetry");
    __name(makeRetriable, "makeRetriable");
  }
});

// src/main.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/hono.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/hono-base.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/compose.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context3, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError2 = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context3.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context3, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context3.error = err;
            res = await onError(err, context3);
            isError2 = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context3.finalized === false && onNotFound) {
          res = await onNotFound(context3);
        }
      }
      if (res && (context3.finalized === false || isError2)) {
        context3.res = res;
      }
      return context3;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/context.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/request.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/http-exception.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/request/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var GET_MATCH_RESULT = /* @__PURE__ */ Symbol();

// node_modules/hono/dist/utils/body.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/hono/dist/utils/url.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var splitPath = /* @__PURE__ */ __name((path3) => {
  const paths = path3.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path: path3 } = extractGroupsFromPath(routePath);
  const paths = splitPath(path3);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path3) => {
  const groups = [];
  path3 = path3.replace(/\{[^}]+\}/g, (match2, index) => {
    const mark = `@${index}`;
    groups.push([mark, match2]);
    return mark;
  });
  return { groups, path: path3 };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match2 = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match2) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match2[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match2[1], new RegExp(`^${match2[2]}(?=/${next})`)] : [label, match2[1], new RegExp(`^${match2[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match2[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match2) => {
      try {
        return decoder(match2);
      } catch {
        return match2;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url3 = request.url;
  const start = url3.indexOf("/", url3.indexOf(":") + 4);
  let i = start;
  for (; i < url3.length; i++) {
    const charCode = url3.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url3.indexOf("?", i);
      const path3 = url3.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path3.includes("%25") ? path3.replace(/%25/g, "%2525") : path3);
    } else if (charCode === 63) {
      break;
    }
  }
  return url3.slice(start, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path3) => {
  if (path3.charCodeAt(path3.length - 1) !== 63 || !path3.includes(":")) {
    return null;
  }
  const segments = path3.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url3, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url3.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return void 0;
    }
    if (!url3.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url3.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url3.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url3.indexOf("&", valueIndex);
        return _decodeURI(url3.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url3.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url3);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url3);
  let keyIndex = url3.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url3.indexOf("&", keyIndex + 1);
    let valueIndex = url3.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name51 = url3.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name51 = _decodeURI(name51);
    }
    keyIndex = nextKeyIndex;
    if (name51 === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url3.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name51] && Array.isArray(results[name51]))) {
        results[name51] = [];
      }
      ;
      results[name51].push(value);
    } else {
      results[name51] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url3, key) => {
  return _getQueryParam(url3, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  /**
   * `.raw` can get the raw Request object.
   *
   * @see {@link https://hono.dev/docs/api/request#raw}
   *
   * @example
   * ```ts
   * // For Cloudflare Workers
   * app.post('/', async (c) => {
   *   const metadata = c.req.raw.cf?.hostMetadata?
   *   ...
   * })
   * ```
   */
  raw;
  #validatedData;
  // Short name of validatedData
  #matchResult;
  routeIndex = 0;
  /**
   * `.path` can get the pathname of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#path}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const pathname = c.req.path // `/about/me`
   * })
   * ```
   */
  path;
  bodyCache = {};
  constructor(request, path3 = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path3;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== void 0) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name51) {
    if (name51) {
      return this.raw.headers.get(name51) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  /**
   * `.json()` can parse Request body of type `application/json`
   *
   * @see {@link https://hono.dev/docs/api/request#json}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.json()
   * })
   * ```
   */
  json() {
    return this.#cachedBody("text").then((text3) => JSON.parse(text3));
  }
  /**
   * `.text()` can parse Request body of type `text/plain`
   *
   * @see {@link https://hono.dev/docs/api/request#text}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.text()
   * })
   * ```
   */
  text() {
    return this.#cachedBody("text");
  }
  /**
   * `.arrayBuffer()` parse Request body as an `ArrayBuffer`
   *
   * @see {@link https://hono.dev/docs/api/request#arraybuffer}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.arrayBuffer()
   * })
   * ```
   */
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  /**
   * Parses the request body as a `Blob`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.blob();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#blob
   */
  blob() {
    return this.#cachedBody("blob");
  }
  /**
   * Parses the request body as `FormData`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.formData();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#formdata
   */
  formData() {
    return this.#cachedBody("formData");
  }
  /**
   * Adds validated data to the request.
   *
   * @param target - The target of the validation.
   * @param data - The validated data to add.
   */
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  /**
   * `.url()` can get the request url strings.
   *
   * @see {@link https://hono.dev/docs/api/request#url}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const url = c.req.url // `http://localhost:8787/about/me`
   *   ...
   * })
   * ```
   */
  get url() {
    return this.raw.url;
  }
  /**
   * `.method()` can get the method name of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#method}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const method = c.req.method // `GET`
   * })
   * ```
   */
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  /**
   * `.matchedRoutes()` can return a matched route in the handler
   *
   * @deprecated
   *
   * Use matchedRoutes helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#matchedroutes}
   *
   * @example
   * ```ts
   * app.use('*', async function logger(c, next) {
   *   await next()
   *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
   *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')
   *     console.log(
   *       method,
   *       ' ',
   *       path,
   *       ' '.repeat(Math.max(10 - path.length, 0)),
   *       name,
   *       i === c.req.routeIndex ? '<- respond from here' : ''
   *     )
   *   })
   * })
   * ```
   */
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  /**
   * `routePath()` can retrieve the path registered within the handler
   *
   * @deprecated
   *
   * Use routePath helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#routepath}
   *
   * @example
   * ```ts
   * app.get('/posts/:id', (c) => {
   *   return c.json({ path: c.req.routePath })
   * })
   * ```
   */
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context3, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context: context3 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context3, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  /**
   * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.
   *
   * @see {@link https://hono.dev/docs/api/context#env}
   *
   * @example
   * ```ts
   * // Environment object for Cloudflare Workers
   * app.get('*', async c => {
   *   const counter = c.env.COUNTER
   * })
   * ```
   */
  env = {};
  #var;
  finalized = false;
  /**
   * `.error` can get the error object from the middleware if the Handler throws an error.
   *
   * @see {@link https://hono.dev/docs/api/context#error}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   await next()
   *   if (c.error) {
   *     // do something...
   *   }
   * })
   * ```
   */
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  /**
   * Creates an instance of the Context class.
   *
   * @param req - The Request object.
   * @param options - Optional configuration options for the context.
   */
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  /**
   * `.req` is the instance of {@link HonoRequest}.
   */
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#event}
   * The FetchEvent associated with the current request.
   *
   * @throws Will throw an error if the context does not have a FetchEvent.
   */
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#executionctx}
   * The ExecutionContext associated with the current request.
   *
   * @throws Will throw an error if the context does not have an ExecutionContext.
   */
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#res}
   * The Response object for the current request.
   */
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  /**
   * Sets the Response object for the current request.
   *
   * @param _res - The Response object to set.
   */
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  /**
   * `.render()` can create a response within a layout.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   return c.render('Hello!')
   * })
   * ```
   */
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  /**
   * Sets the layout for the response.
   *
   * @param layout - The layout to set.
   * @returns The layout function.
   */
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  /**
   * Gets the current layout for the response.
   *
   * @returns The current layout function.
   */
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  /**
   * `.setRenderer()` can set the layout in the custom middleware.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```tsx
   * app.use('*', async (c, next) => {
   *   c.setRenderer((content) => {
   *     return c.html(
   *       <html>
   *         <body>
   *           <p>{content}</p>
   *         </body>
   *       </html>
   *     )
   *   })
   *   await next()
   * })
   * ```
   */
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  /**
   * `.header()` can set headers.
   *
   * @see {@link https://hono.dev/docs/api/context#header}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  header = /* @__PURE__ */ __name((name51, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name51);
    } else if (options?.append) {
      headers.append(name51, value);
    } else {
      headers.set(name51, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  /**
   * `.set()` can set the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   c.set('message', 'Hono is hot!!')
   *   await next()
   * })
   * ```
   */
  set = /* @__PURE__ */ __name((key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  }, "set");
  /**
   * `.get()` can use the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   const message = c.get('message')
   *   return c.text(`The message is "${message}"`)
   * })
   * ```
   */
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  /**
   * `.var` can access the value of a variable.
   *
   * @see {@link https://hono.dev/docs/api/context#var}
   *
   * @example
   * ```ts
   * const result = c.var.client.oneMethod()
   * ```
   */
  // c.var.propName is a read-only
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  /**
   * `.body()` can return the HTTP response.
   * You can set headers with `.header()` and set HTTP status code with `.status`.
   * This can also be set in `.text()`, `.json()` and so on.
   *
   * @see {@link https://hono.dev/docs/api/context#body}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *   // Set HTTP status code
   *   c.status(201)
   *
   *   // Return the response body
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
  /**
   * `.text()` can render text as `Content-Type:text/plain`.
   *
   * @see {@link https://hono.dev/docs/api/context#text}
   *
   * @example
   * ```ts
   * app.get('/say', (c) => {
   *   return c.text('Hello!')
   * })
   * ```
   */
  text = /* @__PURE__ */ __name((text3, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text3) : this.#newResponse(
      text3,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  /**
   * `.json()` can render JSON as `Content-Type:application/json`.
   *
   * @see {@link https://hono.dev/docs/api/context#json}
   *
   * @example
   * ```ts
   * app.get('/api', (c) => {
   *   return c.json({ message: 'Hello!' })
   * })
   * ```
   */
  json = /* @__PURE__ */ __name((object5, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object5),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  /**
   * `.redirect()` can Redirect, default status code is 302.
   *
   * @see {@link https://hono.dev/docs/api/context#redirect}
   *
   * @example
   * ```ts
   * app.get('/redirect', (c) => {
   *   return c.redirect('/')
   * })
   * app.get('/redirect-permanently', (c) => {
   *   return c.redirect('/', 301)
   * })
   * ```
   */
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      // Multibyes should be encoded
      // eslint-disable-next-line no-control-regex
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  /**
   * `.notFound()` can return the Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/context#notfound}
   *
   * @example
   * ```ts
   * app.get('/notfound', (c) => {
   *   return c.notFound()
   * })
   * ```
   */
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/hono/dist/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class _Hono {
  static {
    __name(this, "_Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  /*
    This class is like an abstract class and does not have a router.
    To use it, inherit the class and implement router in the constructor.
  */
  router;
  getPath;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path3, ...handlers) => {
      for (const p of [path3].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone3 = new _Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone3.errorHandler = this.errorHandler;
    clone3.#notFoundHandler = this.#notFoundHandler;
    clone3.routes = this.routes;
    return clone3;
  }
  #notFoundHandler = notFoundHandler;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  errorHandler = errorHandler;
  /**
   * `.route()` allows grouping other Hono instance in routes.
   *
   * @see {@link https://hono.dev/docs/api/routing#grouping}
   *
   * @param {string} path - base Path
   * @param {Hono} app - other Hono instance
   * @returns {Hono} routed Hono instance
   *
   * @example
   * ```ts
   * const app = new Hono()
   * const app2 = new Hono()
   *
   * app2.get("/user", (c) => c.text("user"))
   * app.route("/api", app2) // GET /api/user
   * ```
   */
  route(path3, app2) {
    const subApp = this.basePath(path3);
    app2.routes.map((r) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  /**
   * `.basePath()` allows base paths to be specified.
   *
   * @see {@link https://hono.dev/docs/api/routing#base-path}
   *
   * @param {string} path - base Path
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * const api = new Hono().basePath('/api')
   * ```
   */
  basePath(path3) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path3);
    return subApp;
  }
  /**
   * `.onError()` handles an error and returns a customized Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#error-handling}
   *
   * @param {ErrorHandler} handler - request Handler for error
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.onError((err, c) => {
   *   console.error(`${err}`)
   *   return c.text('Custom Error Message', 500)
   * })
   * ```
   */
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  /**
   * `.notFound()` allows you to customize a Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#not-found}
   *
   * @param {NotFoundHandler} handler - request handler for not-found
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.notFound((c) => {
   *   return c.text('Custom 404 Message', 404)
   * })
   * ```
   */
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  /**
   * `.mount()` allows you to mount applications built with other frameworks into your Hono application.
   *
   * @see {@link https://hono.dev/docs/api/hono#mount}
   *
   * @param {string} path - base Path
   * @param {Function} applicationHandler - other Request Handler
   * @param {MountOptions} [options] - options of `.mount()`
   * @returns {Hono} mounted Hono instance
   *
   * @example
   * ```ts
   * import { Router as IttyRouter } from 'itty-router'
   * import { Hono } from 'hono'
   * // Create itty-router application
   * const ittyRouter = IttyRouter()
   * // GET /itty-router/hello
   * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))
   *
   * const app = new Hono()
   * app.mount('/itty-router', ittyRouter.handle)
   * ```
   *
   * @example
   * ```ts
   * const app = new Hono()
   * // Send the request to another application without modification.
   * app.mount('/app', anotherApp, {
   *   replaceRequest: (req) => req,
   * })
   * ```
   */
  mount(path3, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path3);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url3 = new URL(request.url);
        url3.pathname = url3.pathname.slice(pathPrefixLength) || "/";
        return new Request(url3, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path3, "*"), handler);
    return this;
  }
  #addRoute(method, path3, handler) {
    method = method.toUpperCase();
    path3 = mergePath(this._basePath, path3);
    const r = { basePath: this._basePath, path: path3, method, handler };
    this.router.add(method, path3, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path3 = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path3);
    const c = new Context(request, {
      path: path3,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context3 = await composed(c);
        if (!context3.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context3.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  /**
   * `.fetch()` will be entry point of your app.
   *
   * @see {@link https://hono.dev/docs/api/hono#fetch}
   *
   * @param {Request} request - request Object of request
   * @param {Env} Env - env Object
   * @param {ExecutionContext} - context of execution
   * @returns {Response | Promise<Response>} response of request
   *
   */
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  /**
   * `.request()` is a useful method for testing.
   * You can pass a URL or pathname to send a GET request.
   * app will return a Response object.
   * ```ts
   * test('GET /hello is ok', async () => {
   *   const res = await app.request('/hello')
   *   expect(res.status).toBe(200)
   * })
   * ```
   * @see https://hono.dev/docs/api/hono#request
   */
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  /**
   * `.fire()` automatically adds a global fetch event listener.
   * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
   * @deprecated
   * Use `fire` from `hono/service-worker` instead.
   * ```ts
   * import { Hono } from 'hono'
   * import { fire } from 'hono/service-worker'
   *
   * const app = new Hono()
   * // ...
   * fire(app)
   * ```
   * @see https://hono.dev/docs/api/hono#fire
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
   * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
   */
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/matcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var emptyParam = [];
function match(method, path3) {
  const matchers = this.buildAllMatchers();
  const match2 = /* @__PURE__ */ __name(((method2, path22) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path22];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path22.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  }), "match2");
  this.match = match2;
  return match2(method, path3);
}
__name(match, "match");

// node_modules/hono/dist/router/reg-exp-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = /* @__PURE__ */ Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class _Node {
  static {
    __name(this, "_Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context3, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name51 = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name51 && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new _Node();
        if (name51 !== "") {
          node.#varIndex = context3.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name51 !== "") {
        paramMap.push([name51, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new _Node();
      }
    }
    node.insert(restTokens, index, paramMap, context3, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path3, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path3 = path3.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path3.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path3) {
  return wildcardRegExpCache[path3] ??= new RegExp(
    path3 === "*" ? "" : `^${path3.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path3, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path3] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path3, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path3) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map3 = handlerData[i][j]?.[1];
      if (!map3) {
        continue;
      }
      const keys = Object.keys(map3);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map3[keys[k]] = paramReplacementMap[map3[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path3) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path3)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path3, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path3 === "/*") {
      path3 = "*";
    }
    const paramCount = (path3.match(/\/:/g) || []).length;
    if (/\*$/.test(path3)) {
      const re = buildWildcardRegExp(path3);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path3] ||= findMiddleware(middleware[m], path3) || findMiddleware(middleware[METHOD_NAME_ALL], path3) || [];
        });
      } else {
        middleware[method][path3] ||= findMiddleware(middleware[method], path3) || findMiddleware(middleware[METHOD_NAME_ALL], path3) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path3) || [path3];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path22 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path22] ||= [
            ...findMiddleware(middleware[m], path22) || findMiddleware(middleware[METHOD_NAME_ALL], path22) || []
          ];
          routes[m][path22].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path3) => [path3, r[method][path3]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path3) => [path3, r[METHOD_NAME_ALL][path3]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/reg-exp-router/prepared-router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/smart-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/smart-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path3, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path3, handler]);
  }
  match(method, path3) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path3);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/trie-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/hono/dist/router/trie-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node2 {
  static {
    __name(this, "_Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path3, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path3);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new _Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path3) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path3);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name51, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name51] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name51] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path3, handler) {
    const results = checkOptionalParameter(path3);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path3, handler);
  }
  match(method, path3) {
    return this.#node.search(method, path3);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  /**
   * Creates an instance of the Hono class.
   *
   * @param options - Optional configuration options for the Hono instance.
   */
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// src/agents/agent-config.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/agent/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-GSQD3QNR.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-GEHKQTB2.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-5S5X3QPR.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-PA6Z5V6U.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var DEFAULT_SERIALIZATION_LIMITS = Object.freeze({
  maxAttrChars: 1024,
  maxDepth: 6,
  maxKeys: 50,
  maxArrayItems: 50,
  maxTotalChars: 8192
});
function truncateString(s, maxChars) {
  if (s.length <= maxChars) return s;
  return s.slice(0, maxChars) + "\u2026[truncated]";
}
__name(truncateString, "truncateString");
var DEFAULT_KEYS_TO_STRIP = /* @__PURE__ */ new Set([
  "logger",
  "experimental_providerMetadata",
  "providerMetadata",
  "steps",
  "tracingContext"
]);
var NO_KEYS_TO_STRIP = /* @__PURE__ */ new Set();
function deepClean(value, options = {}) {
  const {
    keysToStrip = DEFAULT_KEYS_TO_STRIP,
    maxDepth = DEFAULT_SERIALIZATION_LIMITS.maxDepth,
    maxStringLength = DEFAULT_SERIALIZATION_LIMITS.maxAttrChars,
    maxArrayLength = DEFAULT_SERIALIZATION_LIMITS.maxArrayItems,
    maxObjectKeys = DEFAULT_SERIALIZATION_LIMITS.maxKeys
  } = options;
  const seen = /* @__PURE__ */ new WeakSet();
  function helper(val, depth) {
    if (depth > maxDepth) {
      return "[MaxDepth]";
    }
    if (val === null || val === void 0) {
      return val;
    }
    if (typeof val === "string") {
      return truncateString(val, maxStringLength);
    }
    if (typeof val === "number" || typeof val === "boolean") {
      return val;
    }
    if (typeof val === "bigint") {
      return `${val}n`;
    }
    if (typeof val === "function") {
      return "[Function]";
    }
    if (typeof val === "symbol") {
      return val.description ? `[Symbol(${val.description})]` : "[Symbol]";
    }
    if (val instanceof Date) {
      return val;
    }
    if (val instanceof Error) {
      return {
        name: val.name,
        message: val.message ? truncateString(val.message, maxStringLength) : void 0
      };
    }
    if (typeof val === "object") {
      if (seen.has(val)) {
        return "[Circular]";
      }
      seen.add(val);
    }
    if (Array.isArray(val)) {
      const limitedArray = val.slice(0, maxArrayLength);
      const cleaned2 = limitedArray.map((item) => helper(item, depth + 1));
      if (val.length > maxArrayLength) {
        cleaned2.push(`[\u2026${val.length - maxArrayLength} more items]`);
      }
      return cleaned2;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(val)) {
      return `[Buffer length=${val.length}]`;
    }
    if (ArrayBuffer.isView(val)) {
      const ctor = val.constructor?.name ?? "TypedArray";
      const byteLength = val.byteLength ?? "?";
      return `[${ctor} byteLength=${byteLength}]`;
    }
    if (val instanceof ArrayBuffer) {
      return `[ArrayBuffer byteLength=${val.byteLength}]`;
    }
    const cleaned = {};
    const entries = Object.entries(val);
    let keyCount = 0;
    for (const [key, v] of entries) {
      if (keysToStrip.has(key)) {
        continue;
      }
      if (keyCount >= maxObjectKeys) {
        cleaned["__truncated"] = `${entries.length - keyCount} more keys omitted`;
        break;
      }
      try {
        cleaned[key] = helper(v, depth + 1);
        keyCount++;
      } catch (error87) {
        cleaned[key] = `[${error87 instanceof Error ? error87.message : String(error87)}]`;
        keyCount++;
      }
    }
    return cleaned;
  }
  __name(helper, "helper");
  return helper(value, 0);
}
__name(deepClean, "deepClean");
function boundedStringify(value) {
  const cleaned = deepClean(value, { keysToStrip: NO_KEYS_TO_STRIP });
  try {
    const json3 = JSON.stringify(cleaned);
    if (json3.length > DEFAULT_SERIALIZATION_LIMITS.maxTotalChars) {
      return json3.slice(0, DEFAULT_SERIALIZATION_LIMITS.maxTotalChars) + "\u2026[truncated]";
    }
    return json3;
  } catch {
    return "[Not Serializable]";
  }
}
__name(boundedStringify, "boundedStringify");

// node_modules/@mastra/core/dist/chunk-5S5X3QPR.js
init_chunk_PZUZNPFM();
var import_api = __toESM(require_src(), 1);
function hasActiveTelemetry(tracerName = "default-tracer") {
  try {
    return !!import_api.trace.getTracer(tracerName);
  } catch {
    return false;
  }
}
__name(hasActiveTelemetry, "hasActiveTelemetry");
function getBaggageValues(ctx) {
  const currentBaggage = import_api.propagation.getBaggage(ctx);
  const requestId = currentBaggage?.getEntry("http.request_id")?.value;
  const componentName = currentBaggage?.getEntry("componentName")?.value;
  const runId = currentBaggage?.getEntry("runId")?.value;
  const threadId = currentBaggage?.getEntry("threadId")?.value;
  const resourceId = currentBaggage?.getEntry("resourceId")?.value;
  return {
    requestId,
    componentName,
    runId,
    threadId,
    resourceId
  };
}
__name(getBaggageValues, "getBaggageValues");
function endSpanOnce(span) {
  if (span.__mastraEnded) return;
  span.__mastraEnded = true;
  try {
    span.end();
  } catch {
  }
}
__name(endSpanOnce, "endSpanOnce");
function isStreamingMethod(methodName) {
  return methodName === "stream" || methodName === "streamLegacy";
}
__name(isStreamingMethod, "isStreamingMethod");
function enhanceStreamingArgumentsWithTelemetry(args, span, spanName) {
  const enhancedArgs = [...args];
  const isPlainObject3 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && !Array.isArray(val), "isPlainObject");
  const createEnhancedOnFinish = /* @__PURE__ */ __name((originalOnFinish) => {
    const enhancedOnFinish = /* @__PURE__ */ __name(async (finishData) => {
      const telemetryData = {
        text: finishData.text,
        usage: finishData.usage,
        finishReason: finishData.finishReason,
        toolCalls: finishData.toolCalls,
        toolResults: finishData.toolResults,
        warnings: finishData.warnings,
        ...finishData.object !== void 0 && { object: finishData.object }
      };
      span.setAttribute(`${spanName}.result`, boundedStringify(telemetryData));
      span.setStatus({ code: import_api.SpanStatusCode.OK });
      endSpanOnce(span);
      if (originalOnFinish) return await originalOnFinish(finishData);
    }, "enhancedOnFinish");
    enhancedOnFinish.__hasOriginalOnFinish = !!originalOnFinish;
    return enhancedOnFinish;
  }, "createEnhancedOnFinish");
  if (enhancedArgs.length === 1 && isPlainObject3(enhancedArgs[0])) {
    const singleArg = enhancedArgs[0];
    const originalOnFinish = singleArg.onFinish;
    enhancedArgs[0] = {
      ...singleArg,
      onFinish: createEnhancedOnFinish(originalOnFinish)
    };
  } else {
    const streamOptions = enhancedArgs.length > 1 && isPlainObject3(enhancedArgs[1]) ? enhancedArgs[1] : {};
    const originalOnFinish = streamOptions.onFinish;
    enhancedArgs[1] = {
      ...streamOptions,
      onFinish: createEnhancedOnFinish(originalOnFinish)
    };
  }
  span.__mastraStreamingSpan = true;
  return enhancedArgs;
}
__name(enhanceStreamingArgumentsWithTelemetry, "enhanceStreamingArgumentsWithTelemetry");
function withSpan(options) {
  return function(_target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor === "number") return;
    const originalMethod = descriptor.value;
    const methodName = String(propertyKey);
    descriptor.value = function(...args) {
      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {
        return originalMethod.apply(this, args);
      }
      const tracer = import_api.trace.getTracer(options?.tracerName ?? "default-tracer");
      let spanName;
      let spanKind;
      if (typeof options === "string") {
        spanName = options;
      } else if (options) {
        spanName = options.spanName || methodName;
        spanKind = options.spanKind;
      } else {
        spanName = methodName;
      }
      const span = tracer.startSpan(spanName, { kind: spanKind });
      let ctx = import_api.trace.setSpan(import_api.context.active(), span);
      args.forEach((arg, index) => {
        span.setAttribute(`${spanName}.argument.${index}`, boundedStringify(arg));
      });
      const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);
      if (requestId) {
        span.setAttribute("http.request_id", requestId);
      }
      if (threadId) {
        span.setAttribute("threadId", threadId);
      }
      if (resourceId) {
        span.setAttribute("resourceId", resourceId);
      }
      if (componentName) {
        span.setAttribute("componentName", componentName);
        if (runId) {
          span.setAttribute("runId", runId);
        }
      } else if (this && typeof this === "object" && "name" in this) {
        const contextObj = this;
        span.setAttribute("componentName", contextObj.name);
        if (contextObj.runId) span.setAttribute("runId", contextObj.runId);
        const baggageEntries = {};
        baggageEntries.componentName = { value: contextObj.name };
        if (contextObj.runId) {
          baggageEntries.runId = { value: contextObj.runId };
        }
        if (requestId) {
          baggageEntries["http.request_id"] = { value: requestId };
        }
        if (threadId) {
          baggageEntries.threadId = { value: threadId };
        }
        if (resourceId) {
          baggageEntries.resourceId = { value: resourceId };
        }
        ctx = import_api.propagation.setBaggage(ctx, import_api.propagation.createBaggage(baggageEntries));
      }
      try {
        const enhancedArgs = isStreamingMethod(methodName) ? enhanceStreamingArgumentsWithTelemetry(args, span, spanName) : args;
        const result = import_api.context.with(ctx, () => originalMethod.apply(this, enhancedArgs));
        if (result instanceof Promise) {
          return result.then((resolvedValue) => {
            if (isStreamingMethod(methodName)) {
              return resolvedValue;
            }
            span.setAttribute(`${spanName}.result`, boundedStringify(resolvedValue));
            span.setStatus({ code: import_api.SpanStatusCode.OK });
            return resolvedValue;
          }).catch((err) => {
            span.setStatus({
              code: import_api.SpanStatusCode.ERROR,
              message: err instanceof Error ? err.message : "Unknown error"
            });
            if (err instanceof Error) {
              span.recordException(err);
            }
            endSpanOnce(span);
            throw err;
          }).finally(() => {
            if (!span.__mastraStreamingSpan) endSpanOnce(span);
          });
        }
        if (!isStreamingMethod(methodName)) {
          span.setAttribute(`${spanName}.result`, boundedStringify(result));
        }
        span.setStatus({ code: import_api.SpanStatusCode.OK });
        return result;
      } catch (error87) {
        span.setStatus({
          code: import_api.SpanStatusCode.ERROR,
          message: error87 instanceof Error ? error87.message : "Unknown error"
        });
        if (error87 instanceof Error) {
          span.recordException(error87);
        }
        endSpanOnce(span);
        throw error87;
      } finally {
        if (!isStreamingMethod(methodName) && !span.__mastraEnded) {
          endSpanOnce(span);
        }
      }
    };
    return descriptor;
  };
}
__name(withSpan, "withSpan");
function InstrumentClass(options) {
  return function(target) {
    const methods = Object.getOwnPropertyNames(target.prototype);
    methods.forEach((method) => {
      if (options?.excludeMethods?.includes(method) || method === "constructor") return;
      if (options?.methodFilter && !options.methodFilter(method)) return;
      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);
      if (descriptor && typeof descriptor.value === "function") {
        Object.defineProperty(
          target.prototype,
          method,
          withSpan({
            spanName: options?.prefix ? `${options.prefix}.${method}` : method,
            skipIfNoTelemetry: true,
            spanKind: options?.spanKind || import_api.SpanKind.INTERNAL,
            tracerName: options?.tracerName
          })(target, method, descriptor)
        );
      }
    });
    return target;
  };
}
__name(InstrumentClass, "InstrumentClass");
var Telemetry = class _Telemetry {
  static {
    __name(this, "_Telemetry");
  }
  tracer = import_api.trace.getTracer("default");
  name = "default-service";
  constructor(config4) {
    this.name = config4.serviceName ?? "default-service";
    this.tracer = import_api.trace.getTracer(this.name);
  }
  /**
   * @deprecated This method does not do anything
   */
  async shutdown() {
  }
  /**
   * Initialize telemetry with the given configuration
   * @param config - Optional telemetry configuration object
   * @returns Telemetry instance that can be used for tracing
   */
  static init(config4 = {}) {
    try {
      if (!globalThis.__TELEMETRY__) {
        globalThis.__TELEMETRY__ = new _Telemetry(config4);
      }
      return globalThis.__TELEMETRY__;
    } catch (error87) {
      const wrappedError = new MastraError(
        {
          id: "TELEMETRY_INIT_FAILED",
          text: "Failed to initialize telemetry",
          domain: "MASTRA_TELEMETRY",
          category: "SYSTEM"
          /* SYSTEM */
        },
        error87
      );
      throw wrappedError;
    }
  }
  static getActiveSpan() {
    const span = import_api.trace.getActiveSpan();
    return span;
  }
  /**
   * Get the global telemetry instance
   * @throws {Error} If telemetry has not been initialized
   * @returns {Telemetry} The global telemetry instance
   */
  static get() {
    if (!globalThis.__TELEMETRY__) {
      throw new MastraError({
        id: "TELEMETRY_GETTER_FAILED_GLOBAL_TELEMETRY_NOT_INITIALIZED",
        text: "Telemetry not initialized",
        domain: "MASTRA_TELEMETRY",
        category: "USER"
        /* USER */
      });
    }
    return globalThis.__TELEMETRY__;
  }
  /**
   * Wraps a class instance with telemetry tracing
   * @param instance The class instance to wrap
   * @param options Optional configuration for tracing
   * @returns Wrapped instance with all methods traced
   */
  traceClass(instance, options = {}) {
    const { skipIfNoTelemetry = true } = options;
    if (skipIfNoTelemetry && !hasActiveTelemetry()) {
      return instance;
    }
    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;
    return new Proxy(instance, {
      get: /* @__PURE__ */ __name((target, prop) => {
        const value = target[prop];
        if (typeof value === "function" && prop !== "constructor" && !prop.toString().startsWith("_") && !excludeMethods.includes(prop.toString())) {
          return this.traceMethod(value.bind(target), {
            spanName: `${spanNamePrefix}.${prop.toString()}`,
            attributes: {
              ...attributes,
              [`${spanNamePrefix}.name`]: target.constructor.name,
              [`${spanNamePrefix}.method.name`]: prop.toString()
            }
          });
        }
        return value;
      }, "get")
    });
  }
  static setBaggage(baggage, ctx = import_api.context.active()) {
    const currentBaggage = Object.fromEntries(import_api.propagation.getBaggage(ctx)?.getAllEntries() ?? []);
    const newCtx = import_api.propagation.setBaggage(
      ctx,
      import_api.propagation.createBaggage({
        ...currentBaggage,
        ...baggage
      })
    );
    return newCtx;
  }
  static withContext(ctx, fn) {
    return import_api.context.with(ctx, fn);
  }
  /**
   * method to trace individual methods with proper context
   * @param method The method to trace
   * @param context Additional context for the trace
   * @returns Wrapped method with tracing
   */
  traceMethod(method, context3) {
    let ctx = import_api.context.active();
    const { skipIfNoTelemetry = true } = context3;
    if (skipIfNoTelemetry && !hasActiveTelemetry()) {
      return method;
    }
    return ((...args) => {
      const span = this.tracer.startSpan(context3.spanName);
      function handleError(error87) {
        span.recordException(error87);
        span.setStatus({
          code: import_api.SpanStatusCode.ERROR,
          message: error87.message
        });
        span.end();
        throw error87;
      }
      __name(handleError, "handleError");
      try {
        let recordResult2 = /* @__PURE__ */ __name(function(res) {
          span.setAttribute(`${context3.spanName}.result`, boundedStringify(res));
          span.end();
          return res;
        }, "recordResult2");
        const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);
        if (context3.attributes) {
          span.setAttributes(context3.attributes);
        }
        if (requestId) {
          span.setAttribute("http.request_id", requestId);
        }
        if (threadId) {
          span.setAttribute("threadId", threadId);
        }
        if (resourceId) {
          span.setAttribute("resourceId", resourceId);
        }
        if (context3.attributes?.componentName) {
          ctx = import_api.propagation.setBaggage(
            ctx,
            import_api.propagation.createBaggage({
              componentName: { value: context3.attributes.componentName },
              // @ts-ignore
              runId: { value: context3.attributes.runId },
              // @ts-ignore
              "http.request_id": { value: requestId }
            })
          );
        } else {
          if (componentName) {
            span.setAttribute("componentName", componentName);
            span.setAttribute("runId", runId);
          } else if (this && this.name) {
            span.setAttribute("componentName", this.name);
            span.setAttribute("runId", this.runId);
            ctx = import_api.propagation.setBaggage(
              ctx,
              import_api.propagation.createBaggage({
                componentName: { value: this.name },
                // @ts-ignore
                runId: { value: this.runId },
                // @ts-ignore
                "http.request_id": { value: requestId },
                // @ts-ignore
                threadId: { value: threadId },
                // @ts-ignore
                resourceId: { value: resourceId }
              })
            );
          }
        }
        args.forEach((arg, index) => {
          span.setAttribute(`${context3.spanName}.argument.${index}`, boundedStringify(arg));
        });
        let result;
        import_api.context.with(import_api.trace.setSpan(ctx, span), () => {
          result = method(...args);
        });
        if (result instanceof Promise) {
          return result.then(recordResult2).catch(handleError);
        } else {
          return recordResult2(result);
        }
      } catch (error87) {
        handleError(error87);
      }
    });
  }
  getBaggageTracer() {
    return new BaggageTracer(this.tracer);
  }
};
var BaggageTracer = class {
  static {
    __name(this, "BaggageTracer");
  }
  _tracer;
  constructor(tracer) {
    this._tracer = tracer;
  }
  startSpan(name51, options = {}, ctx) {
    ctx = ctx ?? import_api.context.active();
    const span = this._tracer.startSpan(name51, options, ctx);
    const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(ctx);
    span.setAttribute("componentName", componentName);
    span.setAttribute("runId", runId);
    span.setAttribute("http.request_id", requestId);
    span.setAttribute("threadId", threadId);
    span.setAttribute("resourceId", resourceId);
    return span;
  }
  startActiveSpan(name51, optionsOrFn, ctxOrFn, fn) {
    if (typeof optionsOrFn === "function") {
      const wrappedFn2 = /* @__PURE__ */ __name((span) => {
        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(import_api.context.active());
        span.setAttribute("componentName", componentName);
        span.setAttribute("runId", runId);
        span.setAttribute("http.request_id", requestId);
        span.setAttribute("threadId", threadId);
        span.setAttribute("resourceId", resourceId);
        return optionsOrFn(span);
      }, "wrappedFn2");
      return this._tracer.startActiveSpan(name51, {}, import_api.context.active(), wrappedFn2);
    }
    if (typeof ctxOrFn === "function") {
      const wrappedFn2 = /* @__PURE__ */ __name((span) => {
        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(import_api.context.active());
        span.setAttribute("componentName", componentName);
        span.setAttribute("runId", runId);
        span.setAttribute("http.request_id", requestId);
        span.setAttribute("threadId", threadId);
        span.setAttribute("resourceId", resourceId);
        return ctxOrFn(span);
      }, "wrappedFn2");
      return this._tracer.startActiveSpan(name51, optionsOrFn, import_api.context.active(), wrappedFn2);
    }
    const wrappedFn = /* @__PURE__ */ __name((span) => {
      const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(
        ctxOrFn ?? import_api.context.active()
      );
      span.setAttribute("componentName", componentName);
      span.setAttribute("runId", runId);
      span.setAttribute("http.request_id", requestId);
      span.setAttribute("threadId", threadId);
      span.setAttribute("resourceId", resourceId);
      return fn(span);
    }, "wrappedFn");
    return this._tracer.startActiveSpan(name51, optionsOrFn, ctxOrFn, wrappedFn);
  }
};

// node_modules/@mastra/core/dist/chunk-GEHKQTB2.js
init_chunk_PZUZNPFM();
init_chunk_VQASQG5D();

// node_modules/@mastra/core/dist/chunk-3HXBPDKN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __knownSymbol = /* @__PURE__ */ __name((name51, symbol60) => (symbol60 = Symbol[name51]) ? symbol60 : Symbol.for("Symbol." + name51), "__knownSymbol");
var __typeError = /* @__PURE__ */ __name((msg) => {
  throw TypeError(msg);
}, "__typeError");
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value, "__defNormalProp");
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", {
  value,
  configurable: true
}), "__name");
var __commonJS2 = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {
    exports: {}
  }).exports, mod), mod.exports;
}, "__require"), "__commonJS");
var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
      get: /* @__PURE__ */ __name(() => from[key], "get"),
      enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
    });
  }
  return to;
}, "__copyProps");
var __toESM2 = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
    value: mod,
    enumerable: true
  }) : target,
  mod
)), "__toESM");
var __decoratorStart = /* @__PURE__ */ __name((base) => [, , , __create2(base?.[__knownSymbol("metadata")] ?? null)], "__decoratorStart");
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = /* @__PURE__ */ __name((fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn, "__expectFn");
var __decoratorContext = /* @__PURE__ */ __name((kind, name51, done, metadata, fns) => ({
  kind: __decoratorStrings[kind],
  name: name51,
  metadata,
  addInitializer: /* @__PURE__ */ __name((fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)), "addInitializer")
}), "__decoratorContext");
var __decoratorMetadata = /* @__PURE__ */ __name((array3, target) => __defNormalProp(target, __knownSymbol("metadata"), array3[3]), "__decoratorMetadata");
var __runInitializers = /* @__PURE__ */ __name((array3, flags, self2, value) => {
  for (var i = 0, fns = array3[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
}, "__runInitializers");
var __decorateElement = /* @__PURE__ */ __name((array3, flags, name51, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array3.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array3[j - 1] = []), extraInitializers = array3[j] || (array3[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc2(k < 4 ? target : {
    get [name51]() {
      return __privateGet(this, extra);
    },
    set [name51](x) {
      return __privateSet(this, extra, x);
    }
  }, name51));
  k ? p && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name51) : __name2(target, name51);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name51, done = {}, array3[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = {
        has: p ? (x) => __privateIn(target, x) : (x) => name51 in x
      };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name51];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name51] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : {
      get: desc.get,
      set: desc.set
    } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array3, target), desc && __defProp2(target, name51, desc), p ? k ^ 4 ? extra : desc : target;
}, "__decorateElement");
var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
var __privateIn = /* @__PURE__ */ __name((member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj), "__privateIn");
var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
var __privateSet = /* @__PURE__ */ __name((obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), "__privateSet");
var __privateMethod = /* @__PURE__ */ __name((obj, member, method) => (__accessCheck(obj, member, "access private method"), method), "__privateMethod");

// node_modules/@mastra/core/dist/chunk-GEHKQTB2.js
import { PassThrough } from "stream";

// node_modules/ai-v5/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/ai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/ai-v5/node_modules/@ai-sdk/provider/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var marker = "vercel.ai.error";
var symbol2 = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  static {
    __name(this, "_AISDKError");
  }
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error87) {
    return _AISDKError2.hasMarker(error87, marker);
  }
  static hasMarker(error87, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
  }
};
_a = symbol2;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol22 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
  static {
    __name(this, "APICallError");
  }
  constructor({
    message,
    url: url3,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url3;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker2);
  }
};
_a2 = symbol22;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
_a3 = symbol3;
function getErrorMessage(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
__name(getErrorMessage, "getErrorMessage");
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  static {
    __name(this, "JSONParseError");
  }
  constructor({ text: text3, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text3;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
_a8 = symbol8;
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
_a12 = symbol12;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  static {
    __name(this, "_TypeValidationError");
  }
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
_a14 = symbol14;

// node_modules/ai-v5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
init_v4();
init_v3();
init_v3();
init_v3();
init_dist2();
var createIdGenerator = /* @__PURE__ */ __name(({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = /* @__PURE__ */ __name(() => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  }, "generator");
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
}, "createIdGenerator");
var generateId = createIdGenerator();
function getErrorMessage2(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
__name(getErrorMessage2, "getErrorMessage");
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse2(text3) {
  const obj = JSON.parse(text3);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text3) === false && suspectConstructorRx.test(text3) === false) {
    return obj;
  }
  return filter(obj);
}
__name(_parse2, "_parse");
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
__name(filter, "filter");
function secureJsonParse(text3) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse2(text3);
  }
  try {
    return _parse2(text3);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
__name(secureJsonParse, "secureJsonParse");
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
__name(validator, "validator");
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
__name(isValidator, "isValidator");
function lazyValidator(createValidator) {
  let validator22;
  return () => {
    if (validator22 == null) {
      validator22 = createValidator();
    }
    return validator22;
  };
}
__name(lazyValidator, "lazyValidator");
function asValidator(value) {
  return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
__name(asValidator, "asValidator");
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError({
        value,
        cause: result.issues
      })
    };
  });
}
__name(standardSchemaValidator, "standardSchemaValidator");
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
__name(validateTypes, "validateTypes");
async function safeValidateTypes({
  value,
  schema
}) {
  const validator22 = asValidator(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error87 }),
      rawValue: value
    };
  }
}
__name(safeValidateTypes, "safeValidateTypes");
async function safeParseJSON({
  text: text3,
  schema
}) {
  try {
    const value = secureJsonParse(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError.isInstance(error87) ? error87 : new JSONParseError({ text: text3, cause: error87 }),
      rawValue: void 0
    };
  }
}
__name(safeParseJSON, "safeParseJSON");
function tool(tool22) {
  return tool22;
}
__name(tool, "tool");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
}, "getDefaultOptions");
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");
function parseArrayDef(def, refs) {
  var _a61, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a61 = def.type) == null ? void 0 : _a61._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");
function parseBooleanDef() {
  return { type: "boolean" };
}
__name(parseBooleanDef, "parseBooleanDef");
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        res.minimum = check3.value;
        break;
      case "max":
        res.maximum = check3.value;
        break;
    }
  }
  return res;
}, "integerDateParser");
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef, "parseDefaultDef");
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
__name(parseEffectsDef, "parseEffectsDef");
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
__name(parseEnumDef, "parseEnumDef");
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");
function parseLiteralDef(def) {
  const parsedType5 = typeof def.value;
  if (parsedType5 !== "bigint" && parsedType5 !== "number" && parsedType5 !== "boolean" && parsedType5 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType5 === "bigint" ? "integer" : parsedType5,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: /* @__PURE__ */ __name(() => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex2;
  }, "emoji"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check3 of def.checks) {
      switch (check3.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check3.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check3.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check3.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check3.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check3.message, refs);
          break;
        case "regex":
          addPattern(res, check3.regex, check3.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check3.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check3.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check3.value, refs)}`),
            check3.message,
            refs
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check3.value, refs)}$`),
            check3.message,
            refs
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check3.message, refs);
          break;
        case "date":
          addFormat(res, "date", check3.message, refs);
          break;
        case "time":
          addFormat(res, "time", check3.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check3.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check3.value, refs)),
            check3.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check3.version !== "v6") {
            addFormat(res, "ipv4", check3.message, refs);
          }
          if (check3.version !== "v4") {
            addFormat(res, "ipv6", check3.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check3.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check3.message, refs);
          break;
        case "cidr": {
          if (check3.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check3.message, refs);
          }
          if (check3.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check3.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check3.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check3.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check3.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check3.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check3.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check3);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
function escapeLiteralCheckValue(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal3) : literal3;
}
__name(escapeLiteralCheckValue, "escapeLiteralCheckValue");
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
__name(escapeNonAlphaNumeric, "escapeNonAlphaNumeric");
function addFormat(schema, value, message, refs) {
  var _a61;
  if (schema.format || ((_a61 = schema.anyOf) == null ? void 0 : _a61.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
__name(addFormat, "addFormat");
function addPattern(schema, regex, message, refs) {
  var _a61;
  if (schema.pattern || ((_a61 = schema.allOf) == null ? void 0 : _a61.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
__name(addPattern, "addPattern");
function stringifyRegExpWithFlags(regex, refs) {
  var _a61;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a61 = source[i + 2]) == null ? void 0 : _a61.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
__name(stringifyRegExpWithFlags, "stringifyRegExpWithFlags");
function parseRecordDef(def, refs) {
  var _a61, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a61 = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a61 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef();
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");
function parseNativeEnumDef(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");
function parseNeverDef() {
  return { not: parseAnyDef() };
}
__name(parseNeverDef, "parseNeverDef");
function parseNullDef() {
  return {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asAnyOf = /* @__PURE__ */ __name((def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
}, "asAnyOf");
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check3.inclusive) {
          res.minimum = check3.value;
        } else {
          res.exclusiveMinimum = check3.value;
        }
        break;
      case "max":
        if (check3.inclusive) {
          res.maximum = check3.value;
        } else {
          res.exclusiveMaximum = check3.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check3.value;
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
__name(parseObjectDef, "parseObjectDef");
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
__name(decideAdditionalProperties, "decideAdditionalProperties");
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
__name(safeIsOptional, "safeIsOptional");
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a61;
  if (refs.currentPath.toString() === ((_a61 = refs.propertyPath) == null ? void 0 : _a61.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
}, "parseOptionalDef");
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
__name(parseTupleDef, "parseTupleDef");
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");
function parseUnknownDef() {
  return parseAnyDef();
}
__name(parseUnknownDef, "parseUnknownDef");
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
function parseDef(def, refs, forceResolution = false) {
  var _a61;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a61 = refs.override) == null ? void 0 : _a61.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
}, "get$ref");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema22) => {
  if (def.description) {
    jsonSchema22.description = def.description;
  }
  return jsonSchema22;
}, "addMeta");
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name51, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name51],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, "getRefs");
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  var _a61;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name216, schema2]) => {
      var _a217;
      return {
        ...acc,
        [name216]: (_a217 = parseDef(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name216]
          },
          true
        )) != null ? _a217 : parseAnyDef()
      };
    },
    {}
  ) : void 0;
  const name51 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a61 = parseDef(
    schema._def,
    name51 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name51]
    },
    false
  )) != null ? _a61 : parseAnyDef();
  const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title2 !== void 0) {
    main.title = title2;
  }
  const combined = name51 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name51
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name51]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
}, "zodToJsonSchema");
var zod_to_json_schema_default = zodToJsonSchema;
function zod3Schema(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
__name(zod3Schema, "zod3Schema");
function zod4Schema(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await safeParseAsync2(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
__name(zod4Schema, "zod4Schema");
function isZod4Schema(zodSchema22) {
  return "_zod" in zodSchema22;
}
__name(isZod4Schema, "isZod4Schema");
function zodSchema(zodSchema22, options) {
  if (isZod4Schema(zodSchema22)) {
    return zod4Schema(zodSchema22, options);
  } else {
    return zod3Schema(zodSchema22, options);
  }
}
__name(zodSchema, "zodSchema");
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
__name(jsonSchema, "jsonSchema");
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
__name(isSchema, "isSchema");
function asSchema(schema) {
  return schema == null ? jsonSchema({
    properties: {},
    additionalProperties: false
  }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);
}
__name(asSchema, "asSchema");
var { btoa: btoa2, atob: atob2 } = globalThis;

// node_modules/ai-v5/dist/index.mjs
init_v4();
init_v4();
init_v4();
init_v4();
init_v4();
init_v4();
init_v4();
var __defProp3 = Object.defineProperty;
var __export2 = /* @__PURE__ */ __name((target, all) => {
  for (var name163 in all)
    __defProp3(target, name163, { get: all[name163], enumerable: true });
}, "__export");
var name14 = "AI_NoOutputSpecifiedError";
var marker15 = `vercel.ai.error.${name14}`;
var symbol15 = Symbol.for(marker15);
var _a15;
_a15 = symbol15;
var name22 = "AI_InvalidArgumentError";
var marker22 = `vercel.ai.error.${name22}`;
var symbol23 = Symbol.for(marker22);
var _a22;
_a22 = symbol23;
var name32 = "AI_InvalidStreamPartError";
var marker32 = `vercel.ai.error.${name32}`;
var symbol32 = Symbol.for(marker32);
var _a32;
_a32 = symbol32;
var name42 = "AI_InvalidToolInputError";
var marker42 = `vercel.ai.error.${name42}`;
var symbol42 = Symbol.for(marker42);
var _a42;
_a42 = symbol42;
var name52 = "AI_NoImageGeneratedError";
var marker52 = `vercel.ai.error.${name52}`;
var symbol52 = Symbol.for(marker52);
var _a52;
_a52 = symbol52;
var name62 = "AI_NoObjectGeneratedError";
var marker62 = `vercel.ai.error.${name62}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var NoObjectGeneratedError = class extends AISDKError {
  static {
    __name(this, "NoObjectGeneratedError");
  }
  constructor({
    message = "No object generated.",
    cause,
    text: text22,
    response,
    usage,
    finishReason
  }) {
    super({ name: name62, message, cause });
    this[_a62] = true;
    this.text = text22;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker62);
  }
};
_a62 = symbol62;
var name72 = "AI_NoOutputGeneratedError";
var marker72 = `vercel.ai.error.${name72}`;
var symbol72 = Symbol.for(marker72);
var _a72;
_a72 = symbol72;
var name82 = "AI_NoSuchToolError";
var marker82 = `vercel.ai.error.${name82}`;
var symbol82 = Symbol.for(marker82);
var _a82;
_a82 = symbol82;
var name92 = "AI_ToolCallRepairError";
var marker92 = `vercel.ai.error.${name92}`;
var symbol92 = Symbol.for(marker92);
var _a92;
_a92 = symbol92;
var name102 = "AI_InvalidDataContentError";
var marker102 = `vercel.ai.error.${name102}`;
var symbol102 = Symbol.for(marker102);
var _a102;
_a102 = symbol102;
var name112 = "AI_InvalidMessageRoleError";
var marker112 = `vercel.ai.error.${name112}`;
var symbol112 = Symbol.for(marker112);
var _a112;
_a112 = symbol112;
var name122 = "AI_MessageConversionError";
var marker122 = `vercel.ai.error.${name122}`;
var symbol122 = Symbol.for(marker122);
var _a122;
var MessageConversionError = class extends AISDKError {
  static {
    __name(this, "MessageConversionError");
  }
  constructor({
    originalMessage,
    message
  }) {
    super({ name: name122, message });
    this[_a122] = true;
    this.originalMessage = originalMessage;
  }
  static isInstance(error87) {
    return AISDKError.hasMarker(error87, marker122);
  }
};
_a122 = symbol122;
var name132 = "AI_DownloadError";
var marker132 = `vercel.ai.error.${name132}`;
var symbol132 = Symbol.for(marker132);
var _a132;
_a132 = symbol132;
var name142 = "AI_RetryError";
var marker142 = `vercel.ai.error.${name142}`;
var symbol142 = Symbol.for(marker142);
var _a142;
_a142 = symbol142;
var dataContentSchema = external_exports.union([
  external_exports.string(),
  external_exports.instanceof(Uint8Array),
  external_exports.instanceof(ArrayBuffer),
  external_exports.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a163, _b;
      return (_b = (_a163 = globalThis.Buffer) == null ? void 0 : _a163.isBuffer(value)) != null ? _b : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema = external_exports.lazy(
  () => external_exports.union([
    external_exports.null(),
    external_exports.string(),
    external_exports.number(),
    external_exports.boolean(),
    external_exports.record(external_exports.string(), jsonValueSchema),
    external_exports.array(jsonValueSchema)
  ])
);
var providerMetadataSchema = external_exports.record(
  external_exports.string(),
  external_exports.record(external_exports.string(), jsonValueSchema)
);
var textPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var imagePartSchema = external_exports.object({
  type: external_exports.literal("image"),
  image: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
  mediaType: external_exports.string().optional(),
  providerOptions: providerMetadataSchema.optional()
});
var filePartSchema = external_exports.object({
  type: external_exports.literal("file"),
  data: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
  filename: external_exports.string().optional(),
  mediaType: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var reasoningPartSchema = external_exports.object({
  type: external_exports.literal("reasoning"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var toolCallPartSchema = external_exports.object({
  type: external_exports.literal("tool-call"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  input: external_exports.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  providerExecuted: external_exports.boolean().optional()
});
var outputSchema = external_exports.discriminatedUnion("type", [
  external_exports.object({
    type: external_exports.literal("text"),
    value: external_exports.string()
  }),
  external_exports.object({
    type: external_exports.literal("json"),
    value: jsonValueSchema
  }),
  external_exports.object({
    type: external_exports.literal("error-text"),
    value: external_exports.string()
  }),
  external_exports.object({
    type: external_exports.literal("error-json"),
    value: jsonValueSchema
  }),
  external_exports.object({
    type: external_exports.literal("content"),
    value: external_exports.array(
      external_exports.union([
        external_exports.object({
          type: external_exports.literal("text"),
          text: external_exports.string()
        }),
        external_exports.object({
          type: external_exports.literal("media"),
          data: external_exports.string(),
          mediaType: external_exports.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema = external_exports.object({
  type: external_exports.literal("tool-result"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema.optional()
});
var systemModelMessageSchema = external_exports.object(
  {
    role: external_exports.literal("system"),
    content: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  }
);
var userModelMessageSchema = external_exports.object({
  role: external_exports.literal("user"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(external_exports.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var assistantModelMessageSchema = external_exports.object({
  role: external_exports.literal("assistant"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(
      external_exports.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        toolCallPartSchema,
        toolResultPartSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var toolModelMessageSchema = external_exports.object({
  role: external_exports.literal("tool"),
  content: external_exports.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional()
});
var modelMessageSchema = external_exports.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
__name(stepCountIs, "stepCountIs");
function createToolModelOutput({
  output,
  tool: tool22,
  errorMode
}) {
  if (errorMode === "text") {
    return { type: "error-text", value: getErrorMessage(output) };
  } else if (errorMode === "json") {
    return { type: "error-json", value: toJSONValue(output) };
  }
  if (tool22 == null ? void 0 : tool22.toModelOutput) {
    return tool22.toModelOutput(output);
  }
  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
}
__name(createToolModelOutput, "createToolModelOutput");
function toJSONValue(value) {
  return value === void 0 ? null : value;
}
__name(toJSONValue, "toJSONValue");
var originalGenerateId = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
function prepareHeaders(headers, defaultHeaders) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  for (const [key, value] of Object.entries(defaultHeaders)) {
    if (!responseHeaders.has(key)) {
      responseHeaders.set(key, value);
    }
  }
  return responseHeaders;
}
__name(prepareHeaders, "prepareHeaders");
function createTextStreamResponse({
  status,
  statusText,
  headers,
  textStream
}) {
  return new Response(textStream.pipeThrough(new TextEncoderStream()), {
    status: status != null ? status : 200,
    statusText,
    headers: prepareHeaders(headers, {
      "content-type": "text/plain; charset=utf-8"
    })
  });
}
__name(createTextStreamResponse, "createTextStreamResponse");
var JsonToSseTransformStream = class extends TransformStream {
  static {
    __name(this, "JsonToSseTransformStream");
  }
  constructor() {
    super({
      transform(part, controller) {
        controller.enqueue(`data: ${JSON.stringify(part)}

`);
      },
      flush(controller) {
        controller.enqueue("data: [DONE]\n\n");
      }
    });
  }
};
var UI_MESSAGE_STREAM_HEADERS = {
  "content-type": "text/event-stream",
  "cache-control": "no-cache",
  connection: "keep-alive",
  "x-vercel-ai-ui-message-stream": "v1",
  "x-accel-buffering": "no"
  // disable nginx buffering
};
function createUIMessageStreamResponse({
  status,
  statusText,
  headers,
  stream,
  consumeSseStream
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
  if (consumeSseStream) {
    const [stream1, stream2] = sseStream.tee();
    sseStream = stream1;
    consumeSseStream({ stream: stream2 });
  }
  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
    status,
    statusText,
    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
  });
}
__name(createUIMessageStreamResponse, "createUIMessageStreamResponse");
var uiMessageChunkSchema = lazyValidator(
  () => zodSchema(
    external_exports.union([
      external_exports.strictObject({
        type: external_exports.literal("text-start"),
        id: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("text-delta"),
        id: external_exports.string(),
        delta: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("text-end"),
        id: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("error"),
        errorText: external_exports.string()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-input-start"),
        toolCallId: external_exports.string(),
        toolName: external_exports.string(),
        providerExecuted: external_exports.boolean().optional(),
        dynamic: external_exports.boolean().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-input-delta"),
        toolCallId: external_exports.string(),
        inputTextDelta: external_exports.string()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-input-available"),
        toolCallId: external_exports.string(),
        toolName: external_exports.string(),
        input: external_exports.unknown(),
        providerExecuted: external_exports.boolean().optional(),
        providerMetadata: providerMetadataSchema.optional(),
        dynamic: external_exports.boolean().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-input-error"),
        toolCallId: external_exports.string(),
        toolName: external_exports.string(),
        input: external_exports.unknown(),
        providerExecuted: external_exports.boolean().optional(),
        providerMetadata: providerMetadataSchema.optional(),
        dynamic: external_exports.boolean().optional(),
        errorText: external_exports.string()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-output-available"),
        toolCallId: external_exports.string(),
        output: external_exports.unknown(),
        providerExecuted: external_exports.boolean().optional(),
        dynamic: external_exports.boolean().optional(),
        preliminary: external_exports.boolean().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("tool-output-error"),
        toolCallId: external_exports.string(),
        errorText: external_exports.string(),
        providerExecuted: external_exports.boolean().optional(),
        dynamic: external_exports.boolean().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("reasoning-start"),
        id: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("reasoning-delta"),
        id: external_exports.string(),
        delta: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("reasoning-end"),
        id: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("source-url"),
        sourceId: external_exports.string(),
        url: external_exports.string(),
        title: external_exports.string().optional(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("source-document"),
        sourceId: external_exports.string(),
        mediaType: external_exports.string(),
        title: external_exports.string(),
        filename: external_exports.string().optional(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("file"),
        url: external_exports.string(),
        mediaType: external_exports.string(),
        providerMetadata: providerMetadataSchema.optional()
      }),
      external_exports.strictObject({
        type: external_exports.custom(
          (value) => typeof value === "string" && value.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: external_exports.string().optional(),
        data: external_exports.unknown(),
        transient: external_exports.boolean().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("start-step")
      }),
      external_exports.strictObject({
        type: external_exports.literal("finish-step")
      }),
      external_exports.strictObject({
        type: external_exports.literal("start"),
        messageId: external_exports.string().optional(),
        messageMetadata: external_exports.unknown().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("finish"),
        finishReason: external_exports.enum([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other",
          "unknown"
        ]).optional(),
        messageMetadata: external_exports.unknown().optional()
      }),
      external_exports.strictObject({
        type: external_exports.literal("abort")
      }),
      external_exports.strictObject({
        type: external_exports.literal("message-metadata"),
        messageMetadata: external_exports.unknown()
      })
    ])
  )
);
function isDataUIMessageChunk(chunk) {
  return chunk.type.startsWith("data-");
}
__name(isDataUIMessageChunk, "isDataUIMessageChunk");
function mergeObjects(base, overrides) {
  if (base === void 0 && overrides === void 0) {
    return void 0;
  }
  if (base === void 0) {
    return overrides;
  }
  if (overrides === void 0) {
    return base;
  }
  const result = { ...base };
  for (const key in overrides) {
    if (Object.prototype.hasOwnProperty.call(overrides, key)) {
      const overridesValue = overrides[key];
      if (overridesValue === void 0)
        continue;
      const baseValue = key in base ? base[key] : void 0;
      const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
      if (isSourceObject && isTargetObject) {
        result[key] = mergeObjects(
          baseValue,
          overridesValue
        );
      } else {
        result[key] = overridesValue;
      }
    }
  }
  return result;
}
__name(mergeObjects, "mergeObjects");
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  __name(processValueStart, "processValueStart");
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterObjectValue, "processAfterObjectValue");
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterArrayValue, "processAfterArrayValue");
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
__name(fixJson, "fixJson");
async function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
__name(parsePartialJson, "parsePartialJson");
function isDataUIPart(part) {
  return part.type.startsWith("data-");
}
__name(isDataUIPart, "isDataUIPart");
function isTextUIPart(part) {
  return part.type === "text";
}
__name(isTextUIPart, "isTextUIPart");
function isFileUIPart(part) {
  return part.type === "file";
}
__name(isFileUIPart, "isFileUIPart");
function isReasoningUIPart(part) {
  return part.type === "reasoning";
}
__name(isReasoningUIPart, "isReasoningUIPart");
function isToolUIPart(part) {
  return part.type.startsWith("tool-");
}
__name(isToolUIPart, "isToolUIPart");
function isDynamicToolUIPart(part) {
  return part.type === "dynamic-tool";
}
__name(isDynamicToolUIPart, "isDynamicToolUIPart");
function isToolOrDynamicToolUIPart(part) {
  return isToolUIPart(part) || isDynamicToolUIPart(part);
}
__name(isToolOrDynamicToolUIPart, "isToolOrDynamicToolUIPart");
function getToolName(part) {
  return part.type.split("-").slice(1).join("-");
}
__name(getToolName, "getToolName");
function getToolOrDynamicToolName(part) {
  return isDynamicToolUIPart(part) ? part.toolName : getToolName(part);
}
__name(getToolOrDynamicToolName, "getToolOrDynamicToolName");
function createStreamingUIMessageState({
  lastMessage,
  messageId
}) {
  return {
    message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
      id: messageId,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
__name(createStreamingUIMessageState, "createStreamingUIMessageState");
function processUIMessageStream({
  stream,
  messageMetadataSchema,
  dataPartSchemas,
  runUpdateMessageJob,
  onError,
  onToolCall,
  onData
}) {
  return stream.pipeThrough(
    new TransformStream({
      async transform(chunk, controller) {
        await runUpdateMessageJob(async ({ state, write }) => {
          var _a163, _b, _c, _d;
          function getToolInvocation(toolCallId) {
            const toolInvocations = state.message.parts.filter(isToolUIPart);
            const toolInvocation = toolInvocations.find(
              (invocation) => invocation.toolCallId === toolCallId
            );
            if (toolInvocation == null) {
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            }
            return toolInvocation;
          }
          __name(getToolInvocation, "getToolInvocation");
          function getDynamicToolInvocation(toolCallId) {
            const toolInvocations = state.message.parts.filter(
              (part) => part.type === "dynamic-tool"
            );
            const toolInvocation = toolInvocations.find(
              (invocation) => invocation.toolCallId === toolCallId
            );
            if (toolInvocation == null) {
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            }
            return toolInvocation;
          }
          __name(getDynamicToolInvocation, "getDynamicToolInvocation");
          function updateToolPart(options) {
            var _a172;
            const part = state.message.parts.find(
              (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput = anyOptions.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              anyPart.providerExecuted = (_a172 = anyOptions.providerExecuted) != null ? _a172 : part.providerExecuted;
              if (anyOptions.providerMetadata != null && part.state === "input-available") {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: `tool-${options.toolName}`,
                toolCallId: options.toolCallId,
                state: options.state,
                input: anyOptions.input,
                output: anyOptions.output,
                rawInput: anyOptions.rawInput,
                errorText: anyOptions.errorText,
                providerExecuted: anyOptions.providerExecuted,
                preliminary: anyOptions.preliminary,
                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
              });
            }
          }
          __name(updateToolPart, "updateToolPart");
          function updateDynamicToolPart(options) {
            var _a172, _b2;
            const part = state.message.parts.find(
              (part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.toolName = options.toolName;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput = (_a172 = anyOptions.rawInput) != null ? _a172 : anyPart.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;
              if (anyOptions.providerMetadata != null && part.state === "input-available") {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: "dynamic-tool",
                toolName: options.toolName,
                toolCallId: options.toolCallId,
                state: options.state,
                input: anyOptions.input,
                output: anyOptions.output,
                errorText: anyOptions.errorText,
                preliminary: anyOptions.preliminary,
                providerExecuted: anyOptions.providerExecuted,
                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
              });
            }
          }
          __name(updateDynamicToolPart, "updateDynamicToolPart");
          async function updateMessageMetadata(metadata) {
            if (metadata != null) {
              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
              if (messageMetadataSchema != null) {
                await validateTypes({
                  value: mergedMetadata,
                  schema: messageMetadataSchema
                });
              }
              state.message.metadata = mergedMetadata;
            }
          }
          __name(updateMessageMetadata, "updateMessageMetadata");
          switch (chunk.type) {
            case "text-start": {
              const textPart = {
                type: "text",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming"
              };
              state.activeTextParts[chunk.id] = textPart;
              state.message.parts.push(textPart);
              write();
              break;
            }
            case "text-delta": {
              const textPart = state.activeTextParts[chunk.id];
              textPart.text += chunk.delta;
              textPart.providerMetadata = (_a163 = chunk.providerMetadata) != null ? _a163 : textPart.providerMetadata;
              write();
              break;
            }
            case "text-end": {
              const textPart = state.activeTextParts[chunk.id];
              textPart.state = "done";
              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;
              delete state.activeTextParts[chunk.id];
              write();
              break;
            }
            case "reasoning-start": {
              const reasoningPart = {
                type: "reasoning",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming"
              };
              state.activeReasoningParts[chunk.id] = reasoningPart;
              state.message.parts.push(reasoningPart);
              write();
              break;
            }
            case "reasoning-delta": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              reasoningPart.text += chunk.delta;
              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;
              write();
              break;
            }
            case "reasoning-end": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;
              reasoningPart.state = "done";
              delete state.activeReasoningParts[chunk.id];
              write();
              break;
            }
            case "file": {
              state.message.parts.push({
                type: "file",
                mediaType: chunk.mediaType,
                url: chunk.url
              });
              write();
              break;
            }
            case "source-url": {
              state.message.parts.push({
                type: "source-url",
                sourceId: chunk.sourceId,
                url: chunk.url,
                title: chunk.title,
                providerMetadata: chunk.providerMetadata
              });
              write();
              break;
            }
            case "source-document": {
              state.message.parts.push({
                type: "source-document",
                sourceId: chunk.sourceId,
                mediaType: chunk.mediaType,
                title: chunk.title,
                filename: chunk.filename,
                providerMetadata: chunk.providerMetadata
              });
              write();
              break;
            }
            case "tool-input-start": {
              const toolInvocations = state.message.parts.filter(isToolUIPart);
              state.partialToolCalls[chunk.toolCallId] = {
                text: "",
                toolName: chunk.toolName,
                index: toolInvocations.length,
                dynamic: chunk.dynamic
              };
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                  providerExecuted: chunk.providerExecuted
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                  providerExecuted: chunk.providerExecuted
                });
              }
              write();
              break;
            }
            case "tool-input-delta": {
              const partialToolCall = state.partialToolCalls[chunk.toolCallId];
              partialToolCall.text += chunk.inputTextDelta;
              const { value: partialArgs } = await parsePartialJson(
                partialToolCall.text
              );
              if (partialToolCall.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs
                });
              }
              write();
              break;
            }
            case "tool-input-available": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              }
              write();
              if (onToolCall && !chunk.providerExecuted) {
                await onToolCall({
                  toolCall: chunk
                });
              }
              break;
            }
            case "tool-input-error": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: chunk.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: void 0,
                  rawInput: chunk.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              }
              write();
              break;
            }
            case "tool-output-available": {
              if (chunk.dynamic) {
                const toolInvocation = getDynamicToolInvocation(
                  chunk.toolCallId
                );
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  preliminary: chunk.preliminary
                });
              } else {
                const toolInvocation = getToolInvocation(chunk.toolCallId);
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getToolName(toolInvocation),
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  providerExecuted: chunk.providerExecuted,
                  preliminary: chunk.preliminary
                });
              }
              write();
              break;
            }
            case "tool-output-error": {
              if (chunk.dynamic) {
                const toolInvocation = getDynamicToolInvocation(
                  chunk.toolCallId
                );
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-error",
                  input: toolInvocation.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted
                });
              } else {
                const toolInvocation = getToolInvocation(chunk.toolCallId);
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getToolName(toolInvocation),
                  state: "output-error",
                  input: toolInvocation.input,
                  rawInput: toolInvocation.rawInput,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted
                });
              }
              write();
              break;
            }
            case "start-step": {
              state.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              state.activeTextParts = {};
              state.activeReasoningParts = {};
              break;
            }
            case "start": {
              if (chunk.messageId != null) {
                state.message.id = chunk.messageId;
              }
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageId != null || chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "finish": {
              if (chunk.finishReason != null) {
                state.finishReason = chunk.finishReason;
              }
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "message-metadata": {
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "error": {
              onError == null ? void 0 : onError(new Error(chunk.errorText));
              break;
            }
            default: {
              if (isDataUIMessageChunk(chunk)) {
                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                  await validateTypes({
                    value: chunk.data,
                    schema: dataPartSchemas[chunk.type]
                  });
                }
                const dataChunk = chunk;
                if (dataChunk.transient) {
                  onData == null ? void 0 : onData(dataChunk);
                  break;
                }
                const existingUIPart = dataChunk.id != null ? state.message.parts.find(
                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id
                ) : void 0;
                if (existingUIPart != null) {
                  existingUIPart.data = dataChunk.data;
                } else {
                  state.message.parts.push(dataChunk);
                }
                onData == null ? void 0 : onData(dataChunk);
                write();
              }
            }
          }
          controller.enqueue(chunk);
        });
      }
    })
  );
}
__name(processUIMessageStream, "processUIMessageStream");
function handleUIMessageStreamFinish({
  messageId,
  originalMessages = [],
  onFinish,
  onError,
  stream
}) {
  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
  if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
    lastMessage = void 0;
  } else {
    messageId = lastMessage.id;
  }
  let isAborted2 = false;
  const idInjectedStream = stream.pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        if (chunk.type === "start") {
          const startChunk = chunk;
          if (startChunk.messageId == null && messageId != null) {
            startChunk.messageId = messageId;
          }
        }
        if (chunk.type === "abort") {
          isAborted2 = true;
        }
        controller.enqueue(chunk);
      }
    })
  );
  if (onFinish == null) {
    return idInjectedStream;
  }
  const state = createStreamingUIMessageState({
    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
    messageId: messageId != null ? messageId : ""
    // will be overridden by the stream
  });
  const runUpdateMessageJob = /* @__PURE__ */ __name(async (job) => {
    await job({ state, write: /* @__PURE__ */ __name(() => {
    }, "write") });
  }, "runUpdateMessageJob");
  let finishCalled = false;
  const callOnFinish = /* @__PURE__ */ __name(async () => {
    if (finishCalled || !onFinish) {
      return;
    }
    finishCalled = true;
    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
    await onFinish({
      isAborted: isAborted2,
      isContinuation,
      responseMessage: state.message,
      messages: [
        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
        state.message
      ],
      finishReason: state.finishReason
    });
  }, "callOnFinish");
  return processUIMessageStream({
    stream: idInjectedStream,
    runUpdateMessageJob,
    onError
  }).pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
      },
      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
      async cancel() {
        await callOnFinish();
      },
      async flush() {
        await callOnFinish();
      }
    })
  );
}
__name(handleUIMessageStreamFinish, "handleUIMessageStreamFinish");
var originalGenerateId2 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
function convertToModelMessages(messages, options) {
  const modelMessages = [];
  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {
    messages = messages.map((message) => ({
      ...message,
      parts: message.parts.filter(
        (part) => !isToolOrDynamicToolUIPart(part) || part.state !== "input-streaming" && part.state !== "input-available"
      )
    }));
  }
  for (const message of messages) {
    switch (message.role) {
      case "system": {
        const textParts = message.parts.filter(
          (part) => part.type === "text"
        );
        const providerMetadata = textParts.reduce((acc, part) => {
          if (part.providerMetadata != null) {
            return { ...acc, ...part.providerMetadata };
          }
          return acc;
        }, {});
        modelMessages.push({
          role: "system",
          content: textParts.map((part) => part.text).join(""),
          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}
        });
        break;
      }
      case "user": {
        modelMessages.push({
          role: "user",
          content: message.parts.map((part) => {
            var _a163;
            if (isTextUIPart(part)) {
              return {
                type: "text",
                text: part.text,
                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
              };
            }
            if (isFileUIPart(part)) {
              return {
                type: "file",
                mediaType: part.mediaType,
                filename: part.filename,
                data: part.url,
                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
              };
            }
            if (isDataUIPart(part)) {
              return (_a163 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a163.call(
                options,
                part
              );
            }
          }).filter((part) => part != null)
        });
        break;
      }
      case "assistant": {
        if (message.parts != null) {
          let processBlock2 = /* @__PURE__ */ __name(function() {
            var _a163, _b, _c;
            if (block.length === 0) {
              return;
            }
            const content = [];
            for (const part of block) {
              if (isTextUIPart(part)) {
                content.push({
                  type: "text",
                  text: part.text,
                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
                });
              } else if (isFileUIPart(part)) {
                content.push({
                  type: "file",
                  mediaType: part.mediaType,
                  filename: part.filename,
                  data: part.url
                });
              } else if (isReasoningUIPart(part)) {
                content.push({
                  type: "reasoning",
                  text: part.text,
                  providerOptions: part.providerMetadata
                });
              } else if (isDynamicToolUIPart(part)) {
                const toolName = part.toolName;
                if (part.state !== "input-streaming") {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName,
                    input: part.input,
                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}
                  });
                }
              } else if (isToolUIPart(part)) {
                const toolName = getToolName(part);
                if (part.state !== "input-streaming") {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName,
                    input: part.state === "output-error" ? (_a163 = part.input) != null ? _a163 : part.rawInput : part.input,
                    providerExecuted: part.providerExecuted,
                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}
                  });
                  if (part.providerExecuted === true && (part.state === "output-available" || part.state === "output-error")) {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.toolCallId,
                      toolName,
                      output: createToolModelOutput({
                        output: part.state === "output-error" ? part.errorText : part.output,
                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],
                        errorMode: part.state === "output-error" ? "json" : "none"
                      })
                    });
                  }
                }
              } else if (isDataUIPart(part)) {
                const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(
                  options,
                  part
                );
                if (dataPart != null) {
                  content.push(dataPart);
                }
              } else {
                const _exhaustiveCheck = part;
                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
              }
            }
            modelMessages.push({
              role: "assistant",
              content
            });
            const toolParts = block.filter(
              (part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === "dynamic-tool"
            );
            if (toolParts.length > 0) {
              modelMessages.push({
                role: "tool",
                content: toolParts.map((toolPart) => {
                  var _a172;
                  switch (toolPart.state) {
                    case "output-error":
                    case "output-available": {
                      const toolName = getToolOrDynamicToolName(toolPart);
                      return {
                        type: "tool-result",
                        toolCallId: toolPart.toolCallId,
                        toolName,
                        output: createToolModelOutput({
                          output: toolPart.state === "output-error" ? toolPart.errorText : toolPart.output,
                          tool: (_a172 = options == null ? void 0 : options.tools) == null ? void 0 : _a172[toolName],
                          errorMode: toolPart.state === "output-error" ? "text" : "none"
                        })
                      };
                    }
                    default: {
                      return null;
                    }
                  }
                }).filter(
                  (output) => output != null
                )
              });
            }
            block = [];
          }, "processBlock2");
          var processBlock = processBlock2;
          let block = [];
          for (const part of message.parts) {
            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolOrDynamicToolUIPart(part) || isDataUIPart(part)) {
              block.push(part);
            } else if (part.type === "step-start") {
              processBlock2();
            }
          }
          processBlock2();
          break;
        }
        break;
      }
      default: {
        const _exhaustiveCheck = message.role;
        throw new MessageConversionError({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return modelMessages;
}
__name(convertToModelMessages, "convertToModelMessages");
var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
function isDeepEqualData(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (obj1 == null || obj2 == null)
    return false;
  if (typeof obj1 !== "object" && typeof obj2 !== "object")
    return obj1 === obj2;
  if (obj1.constructor !== obj2.constructor)
    return false;
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length)
      return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!isDeepEqualData(obj1[i], obj2[i]))
        return false;
    }
    return true;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    if (!keys2.includes(key))
      return false;
    if (!isDeepEqualData(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
__name(isDeepEqualData, "isDeepEqualData");
var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
var output_exports = {};
__export2(output_exports, {
  object: /* @__PURE__ */ __name(() => object2, "object"),
  text: /* @__PURE__ */ __name(() => text, "text")
});
var text = /* @__PURE__ */ __name(() => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text22 }) {
    return { partial: text22 };
  },
  async parseOutput({ text: text22 }) {
    return text22;
  }
}), "text");
var object2 = /* @__PURE__ */ __name(({
  schema: inputSchema
}) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text22 }) {
      const result = await parsePartialJson(text22);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text22 }, context3) {
      const parseResult = await safeParseJSON({ text: text22 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text22,
          response: context3.response,
          usage: context3.usage,
          finishReason: context3.finishReason
        });
      }
      const validationResult = await safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text22,
          response: context3.response,
          usage: context3.usage,
          finishReason: context3.finishReason
        });
      }
      return validationResult.value;
    }
  };
}, "object");
var name15 = "AI_NoSuchProviderError";
var marker152 = `vercel.ai.error.${name15}`;
var symbol152 = Symbol.for(marker152);
var _a152;
_a152 = symbol152;
var uiMessagesSchema = lazyValidator(
  () => zodSchema(
    external_exports.array(
      external_exports.object({
        id: external_exports.string(),
        role: external_exports.enum(["system", "user", "assistant"]),
        metadata: external_exports.unknown().optional(),
        parts: external_exports.array(
          external_exports.union([
            external_exports.object({
              type: external_exports.literal("text"),
              text: external_exports.string(),
              state: external_exports.enum(["streaming", "done"]).optional(),
              providerMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("reasoning"),
              text: external_exports.string(),
              state: external_exports.enum(["streaming", "done"]).optional(),
              providerMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("source-url"),
              sourceId: external_exports.string(),
              url: external_exports.string(),
              title: external_exports.string().optional(),
              providerMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("source-document"),
              sourceId: external_exports.string(),
              mediaType: external_exports.string(),
              title: external_exports.string(),
              filename: external_exports.string().optional(),
              providerMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("file"),
              mediaType: external_exports.string(),
              filename: external_exports.string().optional(),
              url: external_exports.string(),
              providerMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("step-start")
            }),
            external_exports.object({
              type: external_exports.string().startsWith("data-"),
              id: external_exports.string().optional(),
              data: external_exports.unknown()
            }),
            external_exports.object({
              type: external_exports.literal("dynamic-tool"),
              toolName: external_exports.string(),
              toolCallId: external_exports.string(),
              state: external_exports.literal("input-streaming"),
              input: external_exports.unknown().optional(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional()
            }),
            external_exports.object({
              type: external_exports.literal("dynamic-tool"),
              toolName: external_exports.string(),
              toolCallId: external_exports.string(),
              state: external_exports.literal("input-available"),
              input: external_exports.unknown(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.literal("dynamic-tool"),
              toolName: external_exports.string(),
              toolCallId: external_exports.string(),
              state: external_exports.literal("output-available"),
              input: external_exports.unknown(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.unknown(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              preliminary: external_exports.boolean().optional()
            }),
            external_exports.object({
              type: external_exports.literal("dynamic-tool"),
              toolName: external_exports.string(),
              toolCallId: external_exports.string(),
              state: external_exports.literal("output-error"),
              input: external_exports.unknown(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.string(),
              callProviderMetadata: providerMetadataSchema.optional()
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("input-streaming"),
              providerExecuted: external_exports.boolean().optional(),
              input: external_exports.unknown().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              approval: external_exports.never().optional()
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("input-available"),
              providerExecuted: external_exports.boolean().optional(),
              input: external_exports.unknown(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              approval: external_exports.never().optional()
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("approval-requested"),
              input: external_exports.unknown(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              approval: external_exports.object({
                id: external_exports.string(),
                approved: external_exports.never().optional(),
                reason: external_exports.never().optional()
              })
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("approval-responded"),
              input: external_exports.unknown(),
              providerExecuted: external_exports.boolean().optional(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              approval: external_exports.object({
                id: external_exports.string(),
                approved: external_exports.boolean(),
                reason: external_exports.string().optional()
              })
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("output-available"),
              providerExecuted: external_exports.boolean().optional(),
              input: external_exports.unknown(),
              output: external_exports.unknown(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              preliminary: external_exports.boolean().optional(),
              approval: external_exports.object({
                id: external_exports.string(),
                approved: external_exports.literal(true),
                reason: external_exports.string().optional()
              }).optional()
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("output-error"),
              providerExecuted: external_exports.boolean().optional(),
              input: external_exports.unknown(),
              output: external_exports.never().optional(),
              errorText: external_exports.string(),
              callProviderMetadata: providerMetadataSchema.optional(),
              approval: external_exports.object({
                id: external_exports.string(),
                approved: external_exports.literal(true),
                reason: external_exports.string().optional()
              }).optional()
            }),
            external_exports.object({
              type: external_exports.string().startsWith("tool-"),
              toolCallId: external_exports.string(),
              state: external_exports.literal("output-denied"),
              providerExecuted: external_exports.boolean().optional(),
              input: external_exports.unknown(),
              output: external_exports.never().optional(),
              errorText: external_exports.never().optional(),
              callProviderMetadata: providerMetadataSchema.optional(),
              approval: external_exports.object({
                id: external_exports.string(),
                approved: external_exports.literal(false),
                reason: external_exports.string().optional()
              })
            })
          ])
        ).nonempty("Message must contain at least one part")
      })
    ).nonempty("Messages array must not be empty")
  )
);
function createUIMessageStream({
  execute: execute2,
  onError = getErrorMessage2,
  originalMessages,
  onFinish,
  generateId: generateId32 = generateId
}) {
  let controller;
  const ongoingStreamPromises = [];
  const stream = new ReadableStream({
    start(controllerArg) {
      controller = controllerArg;
    }
  });
  function safeEnqueue(data) {
    try {
      controller.enqueue(data);
    } catch (error87) {
    }
  }
  __name(safeEnqueue, "safeEnqueue");
  try {
    const result = execute2({
      writer: {
        write(part) {
          safeEnqueue(part);
        },
        merge(streamArg) {
          ongoingStreamPromises.push(
            (async () => {
              const reader = streamArg.getReader();
              while (true) {
                const { done, value } = await reader.read();
                if (done)
                  break;
                safeEnqueue(value);
              }
            })().catch((error87) => {
              safeEnqueue({
                type: "error",
                errorText: onError(error87)
              });
            })
          );
        },
        onError
      }
    });
    if (result) {
      ongoingStreamPromises.push(
        result.catch((error87) => {
          safeEnqueue({
            type: "error",
            errorText: onError(error87)
          });
        })
      );
    }
  } catch (error87) {
    safeEnqueue({
      type: "error",
      errorText: onError(error87)
    });
  }
  const waitForStreams = new Promise(async (resolve22) => {
    while (ongoingStreamPromises.length > 0) {
      await ongoingStreamPromises.shift();
    }
    resolve22();
  });
  waitForStreams.finally(() => {
    try {
      controller.close();
    } catch (error87) {
    }
  });
  return handleUIMessageStreamFinish({
    stream,
    messageId: generateId32(),
    originalMessages,
    onFinish,
    onError
  });
}
__name(createUIMessageStream, "createUIMessageStream");

// node_modules/@mastra/core/dist/chunk-GEHKQTB2.js
var _MastraVoice_decorators;
var _init;
var _a16;
_MastraVoice_decorators = [InstrumentClass({
  prefix: "voice",
  excludeMethods: ["__setTools", "__setLogger", "__setTelemetry", "#log"]
})];
var MastraVoice = class extends (_a16 = MastraBase) {
  static {
    __name(this, "MastraVoice");
  }
  listeningModel;
  speechModel;
  speaker;
  realtimeConfig;
  constructor({
    listeningModel,
    speechModel,
    speaker,
    realtimeConfig,
    name: name51
  } = {}) {
    super({
      component: "VOICE",
      name: name51
    });
    this.listeningModel = listeningModel;
    this.speechModel = speechModel;
    this.speaker = speaker;
    this.realtimeConfig = realtimeConfig;
  }
  traced(method, methodName) {
    return this.telemetry?.traceMethod(method, {
      spanName: `voice.${methodName}`,
      attributes: {
        "voice.type": this.speechModel?.name || this.listeningModel?.name || "unknown"
      }
    }) ?? method;
  }
  updateConfig(_options) {
    this.logger.warn("updateConfig not implemented by this voice provider");
  }
  /**
   * Initializes a WebSocket or WebRTC connection for real-time communication
   * @returns Promise that resolves when the connection is established
   */
  connect(_options) {
    this.logger.warn("connect not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Relay audio data to the voice provider for real-time processing
   * @param audioData Audio data to relay
   */
  send(_audioData) {
    this.logger.warn("relay not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Trigger voice providers to respond
   */
  answer(_options) {
    this.logger.warn("answer not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Equip the voice provider with instructions
   * @param instructions Instructions to add
   */
  addInstructions(_instructions) {
  }
  /**
   * Equip the voice provider with tools
   * @param tools Array of tools to add
   */
  addTools(_tools) {
  }
  /**
   * Disconnect from the WebSocket or WebRTC connection
   */
  close() {
    this.logger.warn("close not implemented by this voice provider");
  }
  /**
   * Register an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function that receives event data
   */
  on(_event, _callback) {
    this.logger.warn("on not implemented by this voice provider");
  }
  /**
   * Remove an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function to remove
   */
  off(_event, _callback) {
    this.logger.warn("off not implemented by this voice provider");
  }
  /**
   * Get available speakers/voices
   * @returns Array of available voice IDs and their metadata
   */
  getSpeakers() {
    this.logger.warn("getSpeakers not implemented by this voice provider");
    return Promise.resolve([]);
  }
  /**
   * Get available speakers/voices
   * @returns Array of available voice IDs and their metadata
   */
  getListener() {
    this.logger.warn("getListener not implemented by this voice provider");
    return Promise.resolve({
      enabled: false
    });
  }
};
MastraVoice = /* @__PURE__ */ ((_) => {
  _init = __decoratorStart(_a16);
  MastraVoice = __decorateElement(_init, 0, "MastraVoice", _MastraVoice_decorators, MastraVoice);
  __runInitializers(_init, 1, MastraVoice);
  return MastraVoice;
})();
var DefaultVoice = class extends MastraVoice {
  static {
    __name(this, "DefaultVoice");
  }
  constructor() {
    super();
  }
  async speak(_input) {
    throw new MastraError({
      id: "VOICE_DEFAULT_NO_SPEAK_PROVIDER",
      text: "No voice provider configured",
      domain: "MASTRA_VOICE",
      category: "USER"
      /* USER */
    });
  }
  async listen(_input) {
    throw new MastraError({
      id: "VOICE_DEFAULT_NO_LISTEN_PROVIDER",
      text: "No voice provider configured",
      domain: "MASTRA_VOICE",
      category: "USER"
      /* USER */
    });
  }
  async getSpeakers() {
    throw new MastraError({
      id: "VOICE_DEFAULT_NO_SPEAKERS_PROVIDER",
      text: "No voice provider configured",
      domain: "MASTRA_VOICE",
      category: "USER"
      /* USER */
    });
  }
  async getListener() {
    throw new MastraError({
      id: "VOICE_DEFAULT_NO_LISTENER_PROVIDER",
      text: "No voice provider configured",
      domain: "MASTRA_VOICE",
      category: "USER"
      /* USER */
    });
  }
};

// node_modules/@mastra/core/dist/chunk-NLNKQD2T.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var EMITTER_SYMBOL = Symbol("emitter");
var STREAM_FORMAT_SYMBOL = Symbol("stream_format");

// node_modules/@mastra/core/dist/chunk-NFJJ6B6P.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-BBE22VBK.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-HLRWYUFN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var RuntimeContext = class {
  static {
    __name(this, "RuntimeContext");
  }
  registry = /* @__PURE__ */ new Map();
  constructor(iterable) {
    this.registry = new Map(iterable);
  }
  /**
   * set a value with strict typing if `Values` is a Record and the key exists in it.
   */
  set(key, value) {
    this.registry.set(key, value);
  }
  /**
   * Get a value with its type
   */
  get(key) {
    return this.registry.get(key);
  }
  /**
   * Check if a key exists in the container
   */
  has(key) {
    return this.registry.has(key);
  }
  /**
   * Delete a value by key
   */
  delete(key) {
    return this.registry.delete(key);
  }
  /**
   * Clear all values from the container
   */
  clear() {
    this.registry.clear();
  }
  /**
   * Get all keys in the container
   */
  keys() {
    return this.registry.keys();
  }
  /**
   * Get all values in the container
   */
  values() {
    return this.registry.values();
  }
  /**
   * Get all entries in the container
   */
  entries() {
    return this.registry.entries();
  }
  /**
   * Get the size of the container
   */
  size() {
    return this.registry.size;
  }
  /**
   * Execute a function for each entry in the container
   */
  forEach(callbackfn) {
    this.registry.forEach(callbackfn);
  }
  /**
   * Custom JSON serialization method
   * Converts the internal Map to a plain object for proper JSON serialization
   */
  toJSON() {
    return Object.fromEntries(this.registry);
  }
};

// node_modules/@mastra/core/dist/chunk-BBE22VBK.js
init_chunk_PZUZNPFM();

// node_modules/@mastra/core/dist/chunk-5O52O25J.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
import { WritableStream as WritableStream2 } from "stream/web";
var ToolStream = class extends WritableStream2 {
  static {
    __name(this, "ToolStream");
  }
  originalStream;
  writeQueue = Promise.resolve();
  constructor({
    prefix,
    callId,
    name: name51,
    runId
  }, originalStream) {
    super({
      async write(chunk) {
        const writer = originalStream?.getWriter();
        try {
          await writer?.write({
            type: `${prefix}-output`,
            runId,
            from: "USER",
            payload: {
              output: chunk,
              ...prefix === "workflow-step" ? {
                runId,
                stepName: name51
              } : {
                [`${prefix}CallId`]: callId,
                [`${prefix}Name`]: name51
              }
            }
          });
        } finally {
          writer?.releaseLock();
        }
      }
    });
    this.originalStream = originalStream;
  }
  async write(data) {
    const writer = this.getWriter();
    try {
      await writer.write(data);
    } finally {
      writer.releaseLock();
    }
  }
  async custom(data) {
    this.writeQueue = this.writeQueue.then(async () => {
      if (!this.originalStream) {
        return;
      }
      const writer = this.originalStream.getWriter();
      try {
        await writer.write(data);
      } finally {
        writer.releaseLock();
      }
    });
    return this.writeQueue;
  }
};

// node_modules/@mastra/core/dist/chunk-WM4RO23J.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function validateToolInput(schema, input, toolId) {
  if (!schema || !("safeParse" in schema)) {
    return { data: input };
  }
  const validationAttempts = [];
  const directValidation = schema.safeParse(input);
  validationAttempts.push({
    result: directValidation,
    data: input,
    structure: "direct"
  });
  if (directValidation.success) {
    return { data: input };
  }
  if (input && typeof input === "object" && "context" in input) {
    const contextData = input.context;
    const contextValidation = schema.safeParse(contextData);
    validationAttempts.push({
      result: contextValidation,
      data: contextData,
      structure: "context"
    });
    if (contextValidation.success) {
      return { data: { ...input, context: contextValidation.data } };
    }
    if (contextData && typeof contextData === "object" && "inputData" in contextData) {
      const inputDataValue = contextData.inputData;
      const inputDataValidation = schema.safeParse(inputDataValue);
      validationAttempts.push({
        result: inputDataValidation,
        data: inputDataValue,
        structure: "inputData"
      });
      if (inputDataValidation.success) {
        const contextKeys = Object.keys(contextData);
        if (contextKeys.length === 1 && contextKeys[0] === "inputData") {
          return { data: { ...input, context: { inputData: inputDataValidation.data } } };
        } else {
          return { data: inputDataValidation.data };
        }
      }
    }
  }
  let bestAttempt = validationAttempts[0];
  for (const attempt of validationAttempts) {
    if (!attempt.result.success && attempt.result.error.issues.length > 0) {
      bestAttempt = attempt;
    }
  }
  if (bestAttempt && !bestAttempt.result.success) {
    const errorMessages2 = bestAttempt.result.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
    const error87 = {
      error: true,
      message: `Tool validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages2}

Provided arguments: ${JSON.stringify(bestAttempt.data, null, 2)}`,
      validationErrors: bestAttempt.result.error.format()
    };
    return { data: input, error: error87 };
  }
  return { data: input };
}
__name(validateToolInput, "validateToolInput");
var Tool = class {
  static {
    __name(this, "Tool");
  }
  /** Unique identifier for the tool */
  id;
  /** Description of what the tool does */
  description;
  /** Schema for validating input parameters */
  inputSchema;
  /** Schema for validating output structure */
  outputSchema;
  /** Schema for suspend operation data */
  suspendSchema;
  /** Schema for resume operation data */
  resumeSchema;
  /**
   * Function that performs the tool's action
   * @param context - Execution context with validated input
   * @param options - Invocation options including suspend/resume data
   * @returns Promise resolving to tool output
   */
  execute;
  /** Parent Mastra instance for accessing shared resources */
  mastra;
  /**
   * Whether the tool requires explicit user approval before execution
   * @example
   * ```typescript
   * // For destructive operations
   * requireApproval: true
   * ```
   */
  requireApproval;
  /**
   * Creates a new Tool instance with input validation wrapper.
   *
   * @param opts - Tool configuration and execute function
   * @example
   * ```typescript
   * const tool = new Tool({
   *   id: 'my-tool',
   *   description: 'Does something useful',
   *   inputSchema: z.object({ name: z.string() }),
   *   execute: async ({ context }) => ({ greeting: `Hello ${context.name}` })
   * });
   * ```
   */
  constructor(opts) {
    this.id = opts.id;
    this.description = opts.description;
    this.inputSchema = opts.inputSchema;
    this.outputSchema = opts.outputSchema;
    this.suspendSchema = opts.suspendSchema;
    this.resumeSchema = opts.resumeSchema;
    this.mastra = opts.mastra;
    this.requireApproval = opts.requireApproval || false;
    if (opts.execute) {
      const originalExecute = opts.execute;
      this.execute = async (context3, options) => {
        const { resumeData, suspend } = options ?? {};
        const { data, error: error87 } = validateToolInput(this.inputSchema, context3, this.id);
        if (error87) {
          return error87;
        }
        return originalExecute({ ...data, suspend, resumeData }, options);
      };
    }
  }
};
function createTool(opts) {
  return new Tool(opts);
}
__name(createTool, "createTool");
function isVercelTool(tool5) {
  return !!(tool5 && !(tool5 instanceof Tool) && "parameters" in tool5);
}
__name(isVercelTool, "isVercelTool");

// node_modules/@mastra/core/dist/chunk-BBE22VBK.js
init_chunk_VQASQG5D();
import { createHash } from "crypto";

// node_modules/@mastra/schema-compat/dist/json-to-zod.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/Types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseAnyOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.anyOf.length ? schema.anyOf.length === 1 ? parseSchema(schema.anyOf[0], {
    ...refs,
    path: [...refs.path, "anyOf", 0]
  }) : `z.union([${schema.anyOf.map((schema2, i) => parseSchema(schema2, { ...refs, path: [...refs.path, "anyOf", i] })).join(", ")}])` : `z.any()`;
}, "parseAnyOf");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseBoolean = /* @__PURE__ */ __name((_schema) => {
  return "z.boolean()";
}, "parseBoolean");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseDefault = /* @__PURE__ */ __name((_schema) => {
  return "z.any()";
}, "parseDefault");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseMultipleType = /* @__PURE__ */ __name((schema, refs) => {
  return `z.union([${schema.type.map((type) => parseSchema({ ...schema, type }, { ...refs, withoutDefaults: true })).join(", ")}])`;
}, "parseMultipleType");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseNot = /* @__PURE__ */ __name((schema, refs) => {
  return `z.any().refine((value) => !${parseSchema(schema.not, {
    ...refs,
    path: [...refs.path, "not"]
  })}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
}, "parseNot");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseNull = /* @__PURE__ */ __name((_schema) => {
  return "z.null()";
}, "parseNull");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/utils/half.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var half = /* @__PURE__ */ __name((arr) => {
  return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
}, "half");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js
var originalIndex = Symbol("Original index");
var ensureOriginalIndex = /* @__PURE__ */ __name((arr) => {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (typeof item === "boolean") {
      newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
    } else if (originalIndex in item) {
      return arr;
    } else {
      newArr.push({ ...item, [originalIndex]: i });
    }
  }
  return newArr;
}, "ensureOriginalIndex");
function parseAllOf(schema, refs) {
  if (schema.allOf.length === 0) {
    return "z.never()";
  } else if (schema.allOf.length === 1) {
    const item = schema.allOf[0];
    return parseSchema(item, {
      ...refs,
      path: [...refs.path, "allOf", item[originalIndex]]
    });
  } else {
    const [left, right] = half(ensureOriginalIndex(schema.allOf));
    return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf({
      allOf: right
    }, refs)})`;
  }
}
__name(parseAllOf, "parseAllOf");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function withMessage(schema, key, get2) {
  const value = schema[key];
  let r = "";
  if (value !== void 0) {
    const got = get2({ value, json: JSON.stringify(value) });
    if (got) {
      const opener = got[0];
      const prefix = got.length === 3 ? got[1] : "";
      const closer = got.length === 3 ? got[2] : got[1];
      r += opener;
      if (schema.errorMessage?.[key] !== void 0) {
        r += prefix + JSON.stringify(schema.errorMessage[key]);
      }
      r;
      r += closer;
    }
  }
  return r;
}
__name(withMessage, "withMessage");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js
var parseArray = /* @__PURE__ */ __name((schema, refs) => {
  if (Array.isArray(schema.items)) {
    return `z.tuple([${schema.items.map((v, i) => parseSchema(v, { ...refs, path: [...refs.path, "items", i] }))}])`;
  }
  let r = !schema.items ? "z.array(z.any())" : `z.array(${parseSchema(schema.items, {
    ...refs,
    path: [...refs.path, "items"]
  })})`;
  r += withMessage(schema, "minItems", ({ json: json3 }) => [
    `.min(${json3}`,
    ", ",
    ")"
  ]);
  r += withMessage(schema, "maxItems", ({ json: json3 }) => [
    `.max(${json3}`,
    ", ",
    ")"
  ]);
  if (schema.uniqueItems === true) {
    r += withMessage(schema, "uniqueItems", () => [
      ".unique(",
      "",
      ")"
    ]);
  }
  return r;
}, "parseArray");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseConst = /* @__PURE__ */ __name((schema) => {
  return `z.literal(${JSON.stringify(schema.const)})`;
}, "parseConst");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseEnum = /* @__PURE__ */ __name((schema) => {
  if (schema.enum.length === 0) {
    return "z.never()";
  } else if (schema.enum.length === 1) {
    return `z.literal(${JSON.stringify(schema.enum[0])})`;
  } else if (schema.enum.every((x) => typeof x === "string")) {
    return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;
  } else {
    return `z.union([${schema.enum.map((x) => `z.literal(${JSON.stringify(x)})`).join(", ")}])`;
  }
}, "parseEnum");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseIfThenElse = /* @__PURE__ */ __name((schema, refs) => {
  const $if = parseSchema(schema.if, { ...refs, path: [...refs.path, "if"] });
  const $then = parseSchema(schema.then, {
    ...refs,
    path: [...refs.path, "then"]
  });
  const $else = parseSchema(schema.else, {
    ...refs,
    path: [...refs.path, "else"]
  });
  return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseNumber = /* @__PURE__ */ __name((schema) => {
  let r = "z.number()";
  if (schema.type === "integer") {
    r += withMessage(schema, "type", () => [".int(", ")"]);
  } else {
    r += withMessage(schema, "format", ({ value }) => {
      if (value === "int64") {
        return [".int(", ")"];
      }
    });
  }
  r += withMessage(schema, "multipleOf", ({ value, json: json3 }) => {
    if (value === 1) {
      if (r.startsWith("z.number().int(")) {
        return;
      }
      return [".int(", ")"];
    }
    return [`.multipleOf(${json3}`, ", ", ")"];
  });
  if (typeof schema.minimum === "number") {
    if (schema.exclusiveMinimum === true) {
      r += withMessage(schema, "minimum", ({ json: json3 }) => [
        `.gt(${json3}`,
        ", ",
        ")"
      ]);
    } else {
      r += withMessage(schema, "minimum", ({ json: json3 }) => [
        `.gte(${json3}`,
        ", ",
        ")"
      ]);
    }
  } else if (typeof schema.exclusiveMinimum === "number") {
    r += withMessage(schema, "exclusiveMinimum", ({ json: json3 }) => [
      `.gt(${json3}`,
      ", ",
      ")"
    ]);
  }
  if (typeof schema.maximum === "number") {
    if (schema.exclusiveMaximum === true) {
      r += withMessage(schema, "maximum", ({ json: json3 }) => [
        `.lt(${json3}`,
        ", ",
        ")"
      ]);
    } else {
      r += withMessage(schema, "maximum", ({ json: json3 }) => [
        `.lte(${json3}`,
        ", ",
        ")"
      ]);
    }
  } else if (typeof schema.exclusiveMaximum === "number") {
    r += withMessage(schema, "exclusiveMaximum", ({ json: json3 }) => [
      `.lt(${json3}`,
      ", ",
      ")"
    ]);
  }
  return r;
}, "parseNumber");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseOneOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.oneOf.length ? schema.oneOf.length === 1 ? parseSchema(schema.oneOf[0], {
    ...refs,
    path: [...refs.path, "oneOf", 0]
  }) : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf.map((schema2, i) => parseSchema(schema2, {
    ...refs,
    path: [...refs.path, "oneOf", i]
  })).join(", ")}];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()";
}, "parseOneOf");

// node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var expandJsdocs = /* @__PURE__ */ __name((jsdocs) => {
  const lines = jsdocs.split("\n");
  const result = lines.length === 1 ? lines[0] : `
${lines.map((x) => `* ${x}`).join("\n")}
`;
  return `/**${result}*/
`;
}, "expandJsdocs");
var addJsdocs = /* @__PURE__ */ __name((schema, parsed) => {
  const description = schema.description;
  if (!description) {
    return parsed;
  }
  return `
${expandJsdocs(description)}${parsed}`;
}, "addJsdocs");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js
function parseObject(objectSchema, refs) {
  let properties = void 0;
  if (objectSchema.properties) {
    if (!Object.keys(objectSchema.properties).length) {
      properties = "z.object({})";
    } else {
      properties = "z.object({ ";
      properties += Object.keys(objectSchema.properties).map((key) => {
        const propSchema = objectSchema.properties[key];
        let result = `${JSON.stringify(key)}: ${parseSchema(propSchema, {
          ...refs,
          path: [...refs.path, "properties", key]
        })}`;
        if (refs.withJsdocs && typeof propSchema === "object") {
          result = addJsdocs(propSchema, result);
        }
        const hasDefault = typeof propSchema === "object" && propSchema.default !== void 0;
        const required3 = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
        const optional3 = !hasDefault && !required3;
        return optional3 ? `${result}.optional()` : result;
      }).join(", ");
      properties += " })";
    }
  }
  const additionalProperties = objectSchema.additionalProperties !== void 0 ? parseSchema(objectSchema.additionalProperties, {
    ...refs,
    path: [...refs.path, "additionalProperties"]
  }) : void 0;
  let patternProperties = void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(Object.entries(objectSchema.patternProperties).map(([key, value]) => {
      return [
        key,
        parseSchema(value, {
          ...refs,
          path: [...refs.path, "patternProperties", key]
        })
      ];
    }, {}));
    patternProperties = "";
    if (properties) {
      if (additionalProperties) {
        patternProperties += `.catchall(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
      }
    } else {
      if (additionalProperties) {
        patternProperties += `z.record(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
      }
    }
    patternProperties += ".superRefine((value, ctx) => {\n";
    patternProperties += "for (const key in value) {\n";
    if (additionalProperties) {
      if (objectSchema.properties) {
        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key) => JSON.stringify(key)).join(", ")}].includes(key)
`;
      } else {
        patternProperties += `let evaluated = false
`;
      }
    }
    for (const key in objectSchema.patternProperties) {
      patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
      if (additionalProperties) {
        patternProperties += "evaluated = true\n";
      }
      patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    if (additionalProperties) {
      patternProperties += "if (!evaluated) {\n";
      patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    patternProperties += "}\n";
    patternProperties += "})";
  }
  let output = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
  if (its.an.anyOf(objectSchema)) {
    output += `.and(${parseAnyOf({
      ...objectSchema,
      anyOf: objectSchema.anyOf.map((x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x)
    }, refs)})`;
  }
  if (its.a.oneOf(objectSchema)) {
    output += `.and(${parseOneOf({
      ...objectSchema,
      oneOf: objectSchema.oneOf.map((x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x)
    }, refs)})`;
  }
  if (its.an.allOf(objectSchema)) {
    output += `.and(${parseAllOf({
      ...objectSchema,
      allOf: objectSchema.allOf.map((x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x)
    }, refs)})`;
  }
  return output;
}
__name(parseObject, "parseObject");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseString = /* @__PURE__ */ __name((schema) => {
  let r = "z.string()";
  r += withMessage(schema, "format", ({ value }) => {
    switch (value) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime({ offset: true", ", message: ", " })"];
      case "time":
        return [".time(", ")"];
      case "date":
        return [".date(", ")"];
      case "binary":
        return [".base64(", ")"];
      case "duration":
        return [".duration(", ")"];
    }
  });
  r += withMessage(schema, "pattern", ({ json: json3 }) => [
    `.regex(new RegExp(${json3})`,
    ", ",
    ")"
  ]);
  r += withMessage(schema, "minLength", ({ json: json3 }) => [
    `.min(${json3}`,
    ", ",
    ")"
  ]);
  r += withMessage(schema, "maxLength", ({ json: json3 }) => [
    `.max(${json3}`,
    ", ",
    ")"
  ]);
  r += withMessage(schema, "contentEncoding", ({ value }) => {
    if (value === "base64") {
      return [".base64(", ")"];
    }
  });
  const contentMediaType = withMessage(schema, "contentMediaType", ({ value }) => {
    if (value === "application/json") {
      return [
        '.transform((str, ctx) => { try { return JSON.parse(str); } catch (err) { ctx.addIssue({ code: "custom", message: "Invalid JSON" }); }}',
        ", ",
        ")"
      ];
    }
  });
  if (contentMediaType != "") {
    r += contentMediaType;
    r += withMessage(schema, "contentSchema", ({ value }) => {
      if (value && value instanceof Object) {
        return [
          `.pipe(${parseSchema(value)}`,
          ", ",
          ")"
        ];
      }
    });
  }
  return r;
}, "parseString");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseSimpleDiscriminatedOneOf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseSimpleDiscriminatedOneOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.oneOf.length ? schema.oneOf.length === 1 ? parseSchema(schema.oneOf[0], {
    ...refs,
    path: [...refs.path, "oneOf", 0]
  }) : `z.discriminatedUnion("${schema.discriminator.propertyName}", [${schema.oneOf.map((schema2, i) => parseSchema(schema2, {
    ...refs,
    path: [...refs.path, "oneOf", i]
  })).join(", ")}])` : "z.any()";
}, "parseSimpleDiscriminatedOneOf");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/json-schema-to-zod/dist/esm/utils/omit.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var omit2 = /* @__PURE__ */ __name((obj, ...keys) => Object.keys(obj).reduce((acc, key) => {
  if (!keys.includes(key)) {
    acc[key] = obj[key];
  }
  return acc;
}, {}), "omit");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js
var parseNullable = /* @__PURE__ */ __name((schema, refs) => {
  return `${parseSchema(omit2(schema, "nullable"), refs, true)}.nullable()`;
}, "parseNullable");

// node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js
var parseSchema = /* @__PURE__ */ __name((schema, refs = { seen: /* @__PURE__ */ new Map(), path: [] }, blockMeta) => {
  if (typeof schema !== "object")
    return schema ? "z.any()" : "z.never()";
  if (refs.parserOverride) {
    const custom4 = refs.parserOverride(schema, refs);
    if (typeof custom4 === "string") {
      return custom4;
    }
  }
  let seen = refs.seen.get(schema);
  if (seen) {
    if (seen.r !== void 0) {
      return seen.r;
    }
    if (refs.depth === void 0 || seen.n >= refs.depth) {
      return "z.any()";
    }
    seen.n += 1;
  } else {
    seen = { r: void 0, n: 0 };
    refs.seen.set(schema, seen);
  }
  let parsed = selectParser2(schema, refs);
  if (!blockMeta) {
    if (!refs.withoutDescribes) {
      parsed = addDescribes(schema, parsed);
    }
    if (!refs.withoutDefaults) {
      parsed = addDefaults(schema, parsed);
    }
    parsed = addAnnotations(schema, parsed);
  }
  seen.r = parsed;
  return parsed;
}, "parseSchema");
var addDescribes = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
}, "addDescribes");
var addDefaults = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.default !== void 0) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
}, "addDefaults");
var addAnnotations = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.readOnly) {
    parsed += ".readonly()";
  }
  return parsed;
}, "addAnnotations");
var selectParser2 = /* @__PURE__ */ __name((schema, refs) => {
  if (its.a.nullable(schema)) {
    return parseNullable(schema, refs);
  } else if (its.an.object(schema)) {
    return parseObject(schema, refs);
  } else if (its.an.array(schema)) {
    return parseArray(schema, refs);
  } else if (its.an.anyOf(schema)) {
    return parseAnyOf(schema, refs);
  } else if (its.an.allOf(schema)) {
    return parseAllOf(schema, refs);
  } else if (its.a.simpleDiscriminatedOneOf(schema)) {
    return parseSimpleDiscriminatedOneOf(schema, refs);
  } else if (its.a.oneOf(schema)) {
    return parseOneOf(schema, refs);
  } else if (its.a.not(schema)) {
    return parseNot(schema, refs);
  } else if (its.an.enum(schema)) {
    return parseEnum(schema);
  } else if (its.a.const(schema)) {
    return parseConst(schema);
  } else if (its.a.multipleType(schema)) {
    return parseMultipleType(schema, refs);
  } else if (its.a.primitive(schema, "string")) {
    return parseString(schema);
  } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
    return parseNumber(schema);
  } else if (its.a.primitive(schema, "boolean")) {
    return parseBoolean(schema);
  } else if (its.a.primitive(schema, "null")) {
    return parseNull(schema);
  } else if (its.a.conditional(schema)) {
    return parseIfThenElse(schema, refs);
  } else {
    return parseDefault(schema);
  }
}, "selectParser");
var its = {
  an: {
    object: /* @__PURE__ */ __name((x) => x.type === "object", "object"),
    array: /* @__PURE__ */ __name((x) => x.type === "array", "array"),
    anyOf: /* @__PURE__ */ __name((x) => x.anyOf !== void 0, "anyOf"),
    allOf: /* @__PURE__ */ __name((x) => x.allOf !== void 0, "allOf"),
    enum: /* @__PURE__ */ __name((x) => x.enum !== void 0, "enum")
  },
  a: {
    nullable: /* @__PURE__ */ __name((x) => x.nullable === true, "nullable"),
    multipleType: /* @__PURE__ */ __name((x) => Array.isArray(x.type), "multipleType"),
    not: /* @__PURE__ */ __name((x) => x.not !== void 0, "not"),
    const: /* @__PURE__ */ __name((x) => x.const !== void 0, "const"),
    primitive: /* @__PURE__ */ __name((x, p) => x.type === p, "primitive"),
    conditional: /* @__PURE__ */ __name((x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else), "conditional"),
    simpleDiscriminatedOneOf: /* @__PURE__ */ __name((x) => {
      if (!x.oneOf || !Array.isArray(x.oneOf) || x.oneOf.length === 0 || !x.discriminator || typeof x.discriminator !== "object" || !("propertyName" in x.discriminator) || typeof x.discriminator.propertyName !== "string") {
        return false;
      }
      const discriminatorProp = x.discriminator.propertyName;
      return x.oneOf.every((schema) => {
        if (!schema || typeof schema !== "object" || schema.type !== "object" || !schema.properties || typeof schema.properties !== "object" || !(discriminatorProp in schema.properties)) {
          return false;
        }
        const property = schema.properties[discriminatorProp];
        return property && typeof property === "object" && property.type === "string" && // Ensure discriminator has a constant value (const or single-value enum)
        (property.const !== void 0 || property.enum && Array.isArray(property.enum) && property.enum.length === 1) && // Ensure discriminator property is required
        Array.isArray(schema.required) && schema.required.includes(discriminatorProp);
      });
    }, "simpleDiscriminatedOneOf"),
    oneOf: /* @__PURE__ */ __name((x) => x.oneOf !== void 0, "oneOf")
  }
};

// node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js
var jsonSchemaToZod = /* @__PURE__ */ __name((schema, { module, name: name51, type, noImport, ...rest } = {}) => {
  if (type && (!name51 || module !== "esm")) {
    throw new Error("Option `type` requires `name` to be set and `module` to be `esm`");
  }
  let result = parseSchema(schema, {
    module,
    name: name51,
    path: [],
    seen: /* @__PURE__ */ new Map(),
    ...rest
  });
  const jsdocs = rest.withJsdocs && typeof schema !== "boolean" && schema.description ? expandJsdocs(schema.description) : "";
  if (module === "cjs") {
    result = `${jsdocs}module.exports = ${name51 ? `{ ${JSON.stringify(name51)}: ${result} }` : result}
`;
    if (!noImport) {
      result = `${jsdocs}const { z } = require("zod")

${result}`;
    }
  } else if (module === "esm") {
    result = `${jsdocs}export ${name51 ? `const ${name51} =` : `default`} ${result}
`;
    if (!noImport) {
      result = `import { z } from "zod"

${result}`;
    }
  } else if (name51) {
    result = `${jsdocs}const ${name51} = ${result}`;
  }
  if (type && name51) {
    let typeName = typeof type === "string" ? type : `${name51[0].toUpperCase()}${name51.substring(1)}`;
    result += `export type ${typeName} = z.infer<typeof ${name51}>
`;
  }
  return result;
}, "jsonSchemaToZod");

// node_modules/json-schema-to-zod/dist/esm/index.js
var esm_default = jsonSchemaToZod;

// node_modules/@mastra/schema-compat/dist/json-to-zod.js
function parseObject2(objectSchema, refs) {
  let properties = void 0;
  if (objectSchema.properties) {
    if (!Object.keys(objectSchema.properties).length) {
      properties = "z.object({})";
    } else {
      properties = "z.object({ ";
      properties += Object.keys(objectSchema.properties).map((key) => {
        const propSchema = objectSchema.properties[key];
        let result = `${JSON.stringify(key)}: ${parseSchema(propSchema, {
          ...refs,
          path: [...refs.path, "properties", key]
        })}`;
        if (refs.withJsdocs && typeof propSchema === "object") {
          result = addJsdocs(propSchema, result);
        }
        const hasDefault = typeof propSchema === "object" && propSchema.default !== void 0;
        const required3 = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
        const optional3 = !hasDefault && !required3;
        return optional3 ? `${result}.optional()` : result;
      }).join(", ");
      properties += " })";
    }
  }
  const additionalProperties = objectSchema.additionalProperties !== void 0 && objectSchema.additionalProperties !== false ? parseSchema(objectSchema.additionalProperties, {
    ...refs,
    path: [...refs.path, "additionalProperties"]
  }) : void 0;
  let patternProperties = void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(
      Object.entries(objectSchema.patternProperties).map(([key, value]) => {
        return [
          key,
          parseSchema(value, {
            ...refs,
            path: [...refs.path, "patternProperties", key]
          })
        ];
      }, {})
    );
    patternProperties = "";
    if (properties) {
      if (additionalProperties) {
        patternProperties += `.catchall(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
      }
    } else {
      if (additionalProperties) {
        patternProperties += `z.record(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
      }
    }
    patternProperties += ".superRefine((value, ctx) => {\n";
    patternProperties += "for (const key in value) {\n";
    if (additionalProperties) {
      if (objectSchema.properties) {
        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key) => JSON.stringify(key)).join(", ")}].includes(key)
`;
      } else {
        patternProperties += `let evaluated = false
`;
      }
    }
    for (const key in objectSchema.patternProperties) {
      patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
      if (additionalProperties) {
        patternProperties += "evaluated = true\n";
      }
      patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    if (additionalProperties) {
      patternProperties += "if (!evaluated) {\n";
      patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    patternProperties += "}\n";
    patternProperties += "})";
  }
  let output = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
  if (its.an.anyOf(objectSchema)) {
    output += `.and(${parseAnyOf(
      {
        ...objectSchema,
        anyOf: objectSchema.anyOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x
        )
      },
      refs
    )})`;
  }
  if (its.a.oneOf(objectSchema)) {
    output += `.and(${parseOneOf(
      {
        ...objectSchema,
        oneOf: objectSchema.oneOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x
        )
      },
      refs
    )})`;
  }
  if (its.an.allOf(objectSchema)) {
    output += `.and(${parseAllOf(
      {
        ...objectSchema,
        allOf: objectSchema.allOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? { ...x, type: "object" } : x
        )
      },
      refs
    )})`;
  }
  return output;
}
__name(parseObject2, "parseObject");
var parserOverride = /* @__PURE__ */ __name((schema, refs) => {
  let parsed = "";
  let seen = refs.seen.get(schema);
  if (its.an.anyOf(schema)) {
    const allObjects = schema.anyOf.every(
      (item) => typeof item === "object" && its.an.object(item) && item.properties !== void 0
    );
    if (schema.anyOf.length > 1 && allObjects) {
      const propertiesWithConst = schema.anyOf.reduce((acc, item) => {
        if (typeof item === "object" && its.an.object(item)) {
          const propertyWithConst = Object.entries(item.properties ?? {}).filter(
            ([_, value]) => typeof value === "object" && value?.const !== void 0
          );
          if (propertyWithConst?.length) {
            const ppties = propertyWithConst.map(([key, _]) => key);
            acc.push(ppties);
          }
        }
        return acc;
      }, []);
      if (propertiesWithConst.length === schema.anyOf.length) {
        if (seen) {
          if (seen.r !== void 0) {
            return seen.r;
          }
          if (refs.depth === void 0 || seen.n >= refs.depth) {
            return "z.any()";
          }
          seen.n += 1;
        } else {
          seen = { r: void 0, n: 0 };
          refs.seen.set(schema, seen);
        }
        const discriminators = propertiesWithConst.length > 0 && propertiesWithConst[0] ? propertiesWithConst.reduce((common, properties) => {
          return common.filter((prop) => properties.includes(prop));
        }, propertiesWithConst[0]) : [];
        if (discriminators.length > 0) {
          const discriminator = discriminators[0];
          if (discriminator) {
            parsed = `z.discriminatedUnion("${discriminator}", [${schema.anyOf.map(
              (schema2, i) => parseSchema(schema2, {
                ...refs,
                path: [...refs.path, "anyOf", i]
              })
            ).join(", ")}])`;
          }
        }
      }
    }
  } else if (its.an.object(schema)) {
    if (seen) {
      if (seen.r !== void 0) {
        return seen.r;
      }
      if (refs.depth === void 0 || seen.n >= refs.depth) {
        return "z.any()";
      }
      seen.n += 1;
    } else {
      seen = { r: void 0, n: 0 };
      refs.seen.set(schema, seen);
    }
    parsed = parseObject2(schema, refs);
  }
  if (parsed) {
    if (!refs.withoutDescribes) {
      parsed = addDescribes2(schema, parsed);
    }
    if (!refs.withoutDefaults) {
      parsed = addDefaults2(schema, parsed);
    }
    parsed = addAnnotations2(schema, parsed);
    if (seen) {
      seen.r = parsed;
    }
    return parsed;
  }
}, "parserOverride");
var addDescribes2 = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
}, "addDescribes");
var addDefaults2 = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.default !== void 0) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
}, "addDefaults");
var addAnnotations2 = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.readOnly) {
    parsed += ".readonly()";
  }
  return parsed;
}, "addAnnotations");
function jsonSchemaToZod2(schema, options = {}) {
  return esm_default(schema, { ...options, parserOverride });
}
__name(jsonSchemaToZod2, "jsonSchemaToZod");

// node_modules/@mastra/core/dist/chunk-BBE22VBK.js
init_zod();

// node_modules/@mastra/schema-compat/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/schema-compat/dist/chunk-U2HXWNAF.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_zod();

// node_modules/zod-to-json-schema/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/Options.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var ignoreOverride2 = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions2 = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
}, "getDefaultOptions");

// node_modules/zod-to-json-schema/dist/esm/Refs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var getRefs2 = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions2(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name51, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name51],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, "getRefs");

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var getRelativePath2 = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_v3();

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseAnyDef2(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath2(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
__name(parseAnyDef2, "parseAnyDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_v3();
function parseArrayDef2(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef2, "parseArrayDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check3.inclusive) {
            setResponseValueAndErrors(res, "minimum", check3.value, check3.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check3.value, check3.message, refs);
          }
        } else {
          if (!check3.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check3.value, check3.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check3.inclusive) {
            setResponseValueAndErrors(res, "maximum", check3.value, check3.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check3.value, check3.message, refs);
          }
        } else {
          if (!check3.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check3.value, check3.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check3.value, check3.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef2, "parseBigintDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseBooleanDef2() {
  return {
    type: "boolean"
  };
}
__name(parseBooleanDef2, "parseBooleanDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
__name(parseBrandedDef2, "parseBrandedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseCatchDef2 = /* @__PURE__ */ __name((def, refs) => {
  return parseDef2(def.innerType._def, refs);
}, "parseCatchDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
__name(parseDateDef2, "parseDateDef");
var integerDateParser2 = /* @__PURE__ */ __name((def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check3.value,
          // This is in milliseconds
          check3.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check3.value,
          // This is in milliseconds
          check3.message,
          refs
        );
        break;
    }
  }
  return res;
}, "integerDateParser");

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef2, "parseDefaultDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2(refs);
}
__name(parseEffectsDef2, "parseEffectsDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
__name(parseEnumDef2, "parseEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var isJsonSchema7AllOfType2 = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
__name(parseIntersectionDef2, "parseIntersectionDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseLiteralDef2(def, refs) {
  const parsedType5 = typeof def.value;
  if (parsedType5 !== "bigint" && parsedType5 !== "number" && parsedType5 !== "boolean" && parsedType5 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType5 === "bigint" ? "integer" : parsedType5,
      enum: [def.value]
    };
  }
  return {
    type: parsedType5 === "bigint" ? "integer" : parsedType5,
    const: def.value
  };
}
__name(parseLiteralDef2, "parseLiteralDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_v3();

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var emojiRegex3 = void 0;
var zodPatterns2 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: /* @__PURE__ */ __name(() => {
    if (emojiRegex3 === void 0) {
      emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex3;
  }, "emoji"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check3 of def.checks) {
      switch (check3.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value, check3.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value, check3.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check3.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check3.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check3.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check3.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check3.message, refs);
          break;
        case "regex":
          addPattern2(res, check3.regex, check3.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check3.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check3.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check3.value, refs)}`), check3.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check3.value, refs)}$`), check3.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check3.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check3.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check3.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check3.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check3.value) : check3.value, check3.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check3.value) : check3.value, check3.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(escapeLiteralCheckValue2(check3.value, refs)), check3.message, refs);
          break;
        }
        case "ip": {
          if (check3.version !== "v6") {
            addFormat2(res, "ipv4", check3.message, refs);
          }
          if (check3.version !== "v4") {
            addFormat2(res, "ipv6", check3.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check3.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check3.message, refs);
          break;
        case "cidr": {
          if (check3.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check3.message, refs);
          }
          if (check3.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check3.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check3.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check3.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check3.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check3.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check3.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check3.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check3);
      }
    }
  }
  return res;
}
__name(parseStringDef2, "parseStringDef");
function escapeLiteralCheckValue2(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal3) : literal3;
}
__name(escapeLiteralCheckValue2, "escapeLiteralCheckValue");
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC2.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
__name(escapeNonAlphaNumeric2, "escapeNonAlphaNumeric");
function addFormat2(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
__name(addFormat2, "addFormat");
function addPattern2(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags2(regex, refs), message, refs);
  }
}
__name(addPattern2, "addPattern");
function stringifyRegExpWithFlags2(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}
__name(stringifyRegExpWithFlags2, "stringifyRegExpWithFlags");

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef2(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef2(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef2(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
__name(parseRecordDef2, "parseRecordDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef2(refs);
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef2(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef2, "parseMapDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseNativeEnumDef2(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef2, "parseNativeEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseNeverDef2(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef2({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
__name(parseNeverDef2, "parseNeverDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseNullDef2(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef2, "parseNullDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf2(def, refs);
}
__name(parseUnionDef2, "parseUnionDef");
var asAnyOf2 = /* @__PURE__ */ __name((def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef2(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
}, "asAnyOf");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef2, "parseNullableDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseNumberDef2(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check3 of def.checks) {
    switch (check3.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check3.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check3.inclusive) {
            setResponseValueAndErrors(res, "minimum", check3.value, check3.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check3.value, check3.message, refs);
          }
        } else {
          if (!check3.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check3.value, check3.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check3.inclusive) {
            setResponseValueAndErrors(res, "maximum", check3.value, check3.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check3.value, check3.message, refs);
          }
        } else {
          if (!check3.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check3.value, check3.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check3.value, check3.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef2, "parseNumberDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseObjectDef2(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional2(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
__name(parseObjectDef2, "parseObjectDef");
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
__name(decideAdditionalProperties2, "decideAdditionalProperties");
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
__name(safeIsOptional2, "safeIsOptional");

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseOptionalDef2 = /* @__PURE__ */ __name((def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef2(def.innerType._def, refs);
  }
  const innerSchema = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef2(refs)
      },
      innerSchema
    ]
  } : parseAnyDef2(refs);
}, "parseOptionalDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parsePipelineDef2 = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef2(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef2(def.out._def, refs);
  }
  const a = parseDef2(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef2(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
__name(parsePromiseDef2, "parsePromiseDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef2, "parseSetDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef2, "parseTupleDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseUndefinedDef2(refs) {
  return {
    not: parseAnyDef2(refs)
  };
}
__name(parseUndefinedDef2, "parseUndefinedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function parseUnknownDef2(refs) {
  return parseAnyDef2(refs);
}
__name(parseUnknownDef2, "parseUnknownDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var parseReadonlyDef2 = /* @__PURE__ */ __name((def, refs) => {
  return parseDef2(def.innerType._def, refs);
}, "parseReadonlyDef");

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser3 = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser3(def, def.typeName, refs);
  const jsonSchema6 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema6) {
    addMeta2(def, refs, jsonSchema6);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema6, def, refs);
    newItem.jsonSchema = jsonSchema6;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema6;
  return jsonSchema6;
}
__name(parseDef2, "parseDef");
var get$ref2 = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef2(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2(refs) : void 0;
    }
  }
}, "get$ref");
var addMeta2 = /* @__PURE__ */ __name((def, refs, jsonSchema6) => {
  if (def.description) {
    jsonSchema6.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema6.markdownDescription = def.description;
    }
  }
  return jsonSchema6;
}, "addMeta");

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var zodToJsonSchema2 = /* @__PURE__ */ __name((schema, options) => {
  const refs = getRefs2(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name60, schema2]) => ({
    ...acc,
    [name60]: parseDef2(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name60]
    }, true) ?? parseAnyDef2(refs)
  }), {}) : void 0;
  const name51 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef2(schema._def, name51 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name51]
  }, false) ?? parseAnyDef2(refs);
  const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title2 !== void 0) {
    main.title = title2;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name51 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name51
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name51]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
}, "zodToJsonSchema");

// node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default2 = zodToJsonSchema2;

// node_modules/@mastra/schema-compat/dist/chunk-U2HXWNAF.js
var PATCHED = Symbol("__mastra_patched__");
function patchRecordSchemas(schema) {
  if (!schema || typeof schema !== "object") return schema;
  if (schema[PATCHED]) return schema;
  schema[PATCHED] = true;
  const def = schema._zod?.def;
  if (def?.type === "record" && def.keyType && !def.valueType) {
    def.valueType = def.keyType;
    def.keyType = external_exports2.string();
  }
  if (!def) return schema;
  if (def.type === "object" && def.shape) {
    const shape = typeof def.shape === "function" ? def.shape() : def.shape;
    for (const key of Object.keys(shape)) {
      patchRecordSchemas(shape[key]);
    }
  }
  if (def.type === "array" && def.element) {
    patchRecordSchemas(def.element);
  }
  if (def.type === "union" && def.options) {
    def.options.forEach(patchRecordSchemas);
  }
  if (def.type === "record") {
    if (def.keyType) patchRecordSchemas(def.keyType);
    if (def.valueType) patchRecordSchemas(def.valueType);
  }
  if (def.type === "intersection") {
    if (def.left) patchRecordSchemas(def.left);
    if (def.right) patchRecordSchemas(def.right);
  }
  if (def.type === "lazy") {
    if (def.getter && typeof def.getter === "function") {
      const originalGetter = def.getter;
      def.getter = function() {
        const innerSchema = originalGetter();
        if (innerSchema) {
          patchRecordSchemas(innerSchema);
        }
        return innerSchema;
      };
    }
  }
  if (def.innerType) {
    patchRecordSchemas(def.innerType);
  }
  return schema;
}
__name(patchRecordSchemas, "patchRecordSchemas");
function zodToJsonSchema3(zodSchema6, target = "jsonSchema7", strategy = "relative") {
  const fn = "toJSONSchema";
  if (fn in external_exports2) {
    patchRecordSchemas(zodSchema6);
    return external_exports2[fn](zodSchema6, {
      unrepresentable: "any",
      override: /* @__PURE__ */ __name((ctx) => {
        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;
        if (def && (def.typeName === "ZodDate" || def.type === "date")) {
          ctx.jsonSchema.type = "string";
          ctx.jsonSchema.format = "date-time";
        }
      }, "override")
    });
  } else {
    return esm_default2(zodSchema6, {
      $refStrategy: strategy,
      target
    });
  }
}
__name(zodToJsonSchema3, "zodToJsonSchema");

// node_modules/@mastra/schema-compat/dist/index.js
init_zod();

// node_modules/ai/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@ai-sdk/provider/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var marker16 = "vercel.ai.error";
var symbol16 = Symbol.for(marker16);
var _a17;
var _AISDKError3 = class _AISDKError4 extends Error {
  static {
    __name(this, "_AISDKError");
  }
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a17] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error87) {
    return _AISDKError4.hasMarker(error87, marker16);
  }
  static hasMarker(error87, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
  }
};
_a17 = symbol16;
var AISDKError2 = _AISDKError3;
var name16 = "AI_APICallError";
var marker23 = `vercel.ai.error.${name16}`;
var symbol24 = Symbol.for(marker23);
var _a23;
var APICallError2 = class extends AISDKError2 {
  static {
    __name(this, "APICallError");
  }
  constructor({
    message,
    url: url3,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name16, message, cause });
    this[_a23] = true;
    this.url = url3;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker23);
  }
};
_a23 = symbol24;
var name23 = "AI_EmptyResponseBodyError";
var marker33 = `vercel.ai.error.${name23}`;
var symbol33 = Symbol.for(marker33);
var _a33;
_a33 = symbol33;
function getErrorMessage3(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
__name(getErrorMessage3, "getErrorMessage");
var name33 = "AI_InvalidArgumentError";
var marker43 = `vercel.ai.error.${name33}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidArgumentError2 = class extends AISDKError2 {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name33, message, cause });
    this[_a43] = true;
    this.argument = argument;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker43);
  }
};
_a43 = symbol43;
var name43 = "AI_InvalidPromptError";
var marker53 = `vercel.ai.error.${name43}`;
var symbol53 = Symbol.for(marker53);
var _a53;
var InvalidPromptError2 = class extends AISDKError2 {
  static {
    __name(this, "InvalidPromptError");
  }
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name43, message: `Invalid prompt: ${message}`, cause });
    this[_a53] = true;
    this.prompt = prompt;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker53);
  }
};
_a53 = symbol53;
var name53 = "AI_InvalidResponseDataError";
var marker63 = `vercel.ai.error.${name53}`;
var symbol63 = Symbol.for(marker63);
var _a63;
_a63 = symbol63;
var name63 = "AI_JSONParseError";
var marker73 = `vercel.ai.error.${name63}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var JSONParseError2 = class extends AISDKError2 {
  static {
    __name(this, "JSONParseError");
  }
  constructor({ text: text3, cause }) {
    super({
      name: name63,
      message: `JSON parsing failed: Text: ${text3}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a73] = true;
    this.text = text3;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker73);
  }
};
_a73 = symbol73;
var name73 = "AI_LoadAPIKeyError";
var marker83 = `vercel.ai.error.${name73}`;
var symbol83 = Symbol.for(marker83);
var _a83;
_a83 = symbol83;
var name83 = "AI_LoadSettingError";
var marker93 = `vercel.ai.error.${name83}`;
var symbol93 = Symbol.for(marker93);
var _a93;
_a93 = symbol93;
var name93 = "AI_NoContentGeneratedError";
var marker103 = `vercel.ai.error.${name93}`;
var symbol103 = Symbol.for(marker103);
var _a103;
_a103 = symbol103;
var name103 = "AI_NoSuchModelError";
var marker113 = `vercel.ai.error.${name103}`;
var symbol113 = Symbol.for(marker113);
var _a113;
_a113 = symbol113;
var name113 = "AI_TooManyEmbeddingValuesForCallError";
var marker123 = `vercel.ai.error.${name113}`;
var symbol123 = Symbol.for(marker123);
var _a123;
_a123 = symbol123;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError3 = class _TypeValidationError4 extends AISDKError2 {
  static {
    __name(this, "_TypeValidationError");
  }
  constructor({ value, cause }) {
    super({
      name: name123,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a133] = true;
    this.value = value;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker133);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError4.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError4({ value, cause });
  }
};
_a133 = symbol133;
var TypeValidationError2 = _TypeValidationError3;
var name133 = "AI_UnsupportedFunctionalityError";
var marker143 = `vercel.ai.error.${name133}`;
var symbol143 = Symbol.for(marker143);
var _a143;
var UnsupportedFunctionalityError2 = class extends AISDKError2 {
  static {
    __name(this, "UnsupportedFunctionalityError");
  }
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name133, message });
    this[_a143] = true;
    this.functionality = functionality;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker143);
  }
};
_a143 = symbol143;
function isJSONValue(value) {
  if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isJSONValue);
  }
  if (typeof value === "object") {
    return Object.entries(value).every(
      ([key, val]) => typeof key === "string" && isJSONValue(val)
    );
  }
  return false;
}
__name(isJSONValue, "isJSONValue");
function isJSONArray(value) {
  return Array.isArray(value) && value.every(isJSONValue);
}
__name(isJSONArray, "isJSONArray");
function isJSONObject(value) {
  return value != null && typeof value === "object" && Object.entries(value).every(
    ([key, val]) => typeof key === "string" && isJSONValue(val)
  );
}
__name(isJSONObject, "isJSONObject");

// node_modules/nanoid/non-secure/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var customAlphabet = /* @__PURE__ */ __name((alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
}, "customAlphabet");

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);
function convertAsyncIteratorToReadableStream(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error87) {
        controller.error(error87);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}
__name(convertAsyncIteratorToReadableStream, "convertAsyncIteratorToReadableStream");
async function delay(delayInMs) {
  return delayInMs == null ? Promise.resolve() : new Promise((resolve22) => setTimeout(resolve22, delayInMs));
}
__name(delay, "delay");
var createIdGenerator2 = /* @__PURE__ */ __name(({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError2({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
}, "createIdGenerator");
var generateId2 = createIdGenerator2();
function getErrorMessage4(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
__name(getErrorMessage4, "getErrorMessage");
function isAbortError2(error87) {
  return error87 instanceof Error && (error87.name === "AbortError" || error87.name === "TimeoutError");
}
__name(isAbortError2, "isAbortError");
var validatorSymbol2 = Symbol.for("vercel.ai.validator");
function validator2(validate) {
  return { [validatorSymbol2]: true, validate };
}
__name(validator2, "validator");
function isValidator2(value) {
  return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
__name(isValidator2, "isValidator");
function asValidator2(value) {
  return isValidator2(value) ? value : zodValidator(value);
}
__name(asValidator2, "asValidator");
function zodValidator(zodSchema6) {
  return validator2((value) => {
    const result = zodSchema6.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
__name(zodValidator, "zodValidator");
function safeValidateTypes2({
  value,
  schema
}) {
  const validator22 = asValidator2(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value };
    }
    const result = validator22.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: result.error })
    };
  } catch (error87) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: error87 })
    };
  }
}
__name(safeValidateTypes2, "safeValidateTypes");
function safeParseJSON2({
  text: text3,
  schema
}) {
  try {
    const value = import_secure_json_parse.default.parse(text3);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes2({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error87) {
    return {
      success: false,
      error: JSONParseError2.isInstance(error87) ? error87 : new JSONParseError2({ text: text3, cause: error87 })
    };
  }
}
__name(safeParseJSON2, "safeParseJSON");
var { btoa: btoa3, atob: atob3 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob3(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
__name(convertBase64ToUint8Array, "convertBase64ToUint8Array");
function convertUint8ArrayToBase64(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa3(latin1string);
}
__name(convertUint8ArrayToBase64, "convertUint8ArrayToBase64");

// node_modules/@ai-sdk/ui-utils/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var textStreamPart = {
  code: "0",
  name: "text",
  parse: /* @__PURE__ */ __name((value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }, "parse")
};
var errorStreamPart = {
  code: "3",
  name: "error",
  parse: /* @__PURE__ */ __name((value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }, "parse")
};
var assistantMessageStreamPart = {
  code: "4",
  name: "assistant_message",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("id" in value) || !("role" in value) || !("content" in value) || typeof value.id !== "string" || typeof value.role !== "string" || value.role !== "assistant" || !Array.isArray(value.content) || !value.content.every(
      (item) => item != null && typeof item === "object" && "type" in item && item.type === "text" && "text" in item && item.text != null && typeof item.text === "object" && "value" in item.text && typeof item.text.value === "string"
    )) {
      throw new Error(
        '"assistant_message" parts expect an object with an "id", "role", and "content" property.'
      );
    }
    return {
      type: "assistant_message",
      value
    };
  }, "parse")
};
var assistantControlDataStreamPart = {
  code: "5",
  name: "assistant_control_data",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("threadId" in value) || !("messageId" in value) || typeof value.threadId !== "string" || typeof value.messageId !== "string") {
      throw new Error(
        '"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.'
      );
    }
    return {
      type: "assistant_control_data",
      value: {
        threadId: value.threadId,
        messageId: value.messageId
      }
    };
  }, "parse")
};
var dataMessageStreamPart = {
  code: "6",
  name: "data_message",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("role" in value) || !("data" in value) || typeof value.role !== "string" || value.role !== "data") {
      throw new Error(
        '"data_message" parts expect an object with a "role" and "data" property.'
      );
    }
    return {
      type: "data_message",
      value
    };
  }, "parse")
};
var assistantStreamParts = [
  textStreamPart,
  errorStreamPart,
  assistantMessageStreamPart,
  assistantControlDataStreamPart,
  dataMessageStreamPart
];
var assistantStreamPartsByCode = {
  [textStreamPart.code]: textStreamPart,
  [errorStreamPart.code]: errorStreamPart,
  [assistantMessageStreamPart.code]: assistantMessageStreamPart,
  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
  [dataMessageStreamPart.code]: dataMessageStreamPart
};
var StreamStringPrefixes = {
  [textStreamPart.name]: textStreamPart.code,
  [errorStreamPart.name]: errorStreamPart.code,
  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
  [dataMessageStreamPart.name]: dataMessageStreamPart.code
};
var validCodes = assistantStreamParts.map((part) => part.code);
function fixJson2(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  __name(processValueStart, "processValueStart");
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterObjectValue, "processAfterObjectValue");
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterArrayValue, "processAfterArrayValue");
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
__name(fixJson2, "fixJson");
function parsePartialJson2(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON2({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON2({ text: fixJson2(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
__name(parsePartialJson2, "parsePartialJson");
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: /* @__PURE__ */ __name((value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }, "parse")
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: /* @__PURE__ */ __name((value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }, "parse")
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: /* @__PURE__ */ __name((value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }, "parse")
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: /* @__PURE__ */ __name((value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }, "parse")
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }, "parse")
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }, "parse")
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }, "parse")
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }, "parse")
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }, "parse")
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }, "parse")
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }, "parse")
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: /* @__PURE__ */ __name((value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }, "parse")
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }, "parse")
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }, "parse")
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }, "parse")
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: /* @__PURE__ */ __name((value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }, "parse")
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
var dataStreamPartsByCode = Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
var DataStreamStringPrefixes = Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
var validCodes2 = dataStreamParts.map((part) => part.code);
function formatDataStreamPart(type, value) {
  const streamPart = dataStreamParts.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
__name(formatDataStreamPart, "formatDataStreamPart");
var NEWLINE = "\n".charCodeAt(0);
function isDeepEqualData2(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (obj1 == null || obj2 == null)
    return false;
  if (typeof obj1 !== "object" && typeof obj2 !== "object")
    return obj1 === obj2;
  if (obj1.constructor !== obj2.constructor)
    return false;
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length)
      return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!isDeepEqualData2(obj1[i], obj2[i]))
        return false;
    }
    return true;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    if (!keys2.includes(key))
      return false;
    if (!isDeepEqualData2(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
__name(isDeepEqualData2, "isDeepEqualData");
var NEWLINE2 = "\n".charCodeAt(0);
function zodSchema2(zodSchema22, options) {
  var _a61;
  const useReferences = (_a61 = options == null ? void 0 : options.useReferences) != null ? _a61 : false;
  return jsonSchema2(
    esm_default2(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: /* @__PURE__ */ __name((value) => {
        const result = zodSchema22.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
__name(zodSchema2, "zodSchema");
var schemaSymbol2 = Symbol.for("vercel.ai.schema");
function jsonSchema2(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol2]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol2]: true,
    jsonSchema: jsonSchema22,
    validate
  };
}
__name(jsonSchema2, "jsonSchema");
function isSchema2(value) {
  return typeof value === "object" && value !== null && schemaSymbol2 in value && value[schemaSymbol2] === true && "jsonSchema" in value && "validate" in value;
}
__name(isSchema2, "isSchema");
function asSchema2(schema) {
  return isSchema2(schema) ? schema : zodSchema2(schema);
}
__name(asSchema2, "asSchema");

// node_modules/ai/dist/index.mjs
var import_api3 = __toESM(require_src(), 1);
var import_api4 = __toESM(require_src(), 1);
init_zod();
init_zod();
init_zod();
init_zod();
init_zod();
init_zod();
init_zod();
init_zod();
init_zod();
var __defProp4 = Object.defineProperty;
var __export3 = /* @__PURE__ */ __name((target, all) => {
  for (var name172 in all)
    __defProp4(target, name172, { get: all[name172], enumerable: true });
}, "__export");
function prepareResponseHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  if (dataStreamVersion !== void 0) {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}
__name(prepareResponseHeaders, "prepareResponseHeaders");
function prepareOutgoingHttpHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const outgoingHeaders = {};
  if (headers != null) {
    for (const [key, value] of Object.entries(headers)) {
      outgoingHeaders[key] = value;
    }
  }
  if (outgoingHeaders["Content-Type"] == null) {
    outgoingHeaders["Content-Type"] = contentType;
  }
  if (dataStreamVersion !== void 0) {
    outgoingHeaders["X-Vercel-AI-Data-Stream"] = dataStreamVersion;
  }
  return outgoingHeaders;
}
__name(prepareOutgoingHttpHeaders, "prepareOutgoingHttpHeaders");
function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream
}) {
  response.writeHead(status != null ? status : 200, statusText, headers);
  const reader = stream.getReader();
  const read = /* @__PURE__ */ __name(async () => {
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        response.write(value);
      }
    } catch (error87) {
      throw error87;
    } finally {
      response.end();
    }
  }, "read");
  read();
}
__name(writeToServerResponse, "writeToServerResponse");
var UnsupportedModelVersionError = class extends AISDKError2 {
  static {
    __name(this, "UnsupportedModelVersionError");
  }
  constructor() {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version. AI SDK 4 only supports models that implement specification version "v1". Please upgrade to AI SDK 5 to use this model.`
    });
  }
};
var name17 = "AI_InvalidArgumentError";
var marker17 = `vercel.ai.error.${name17}`;
var symbol17 = Symbol.for(marker17);
var _a18;
var InvalidArgumentError3 = class extends AISDKError2 {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name17,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a18] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker17);
  }
};
_a18 = symbol17;
var name24 = "AI_RetryError";
var marker24 = `vercel.ai.error.${name24}`;
var symbol25 = Symbol.for(marker24);
var _a24;
var RetryError = class extends AISDKError2 {
  static {
    __name(this, "RetryError");
  }
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name24, message });
    this[_a24] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker24);
  }
};
_a24 = symbol25;
var retryWithExponentialBackoff = /* @__PURE__ */ __name(({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor
}), "retryWithExponentialBackoff");
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor
}, errors = []) {
  try {
    return await f();
  } catch (error87) {
    if (isAbortError2(error87)) {
      throw error87;
    }
    if (maxRetries === 0) {
      throw error87;
    }
    const errorMessage = getErrorMessage4(error87);
    const newErrors = [...errors, error87];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error87 instanceof Error && APICallError2.isInstance(error87) && error87.isRetryable === true && tryNumber <= maxRetries) {
      await delay(delayInMs);
      return _retryWithExponentialBackoff(
        f,
        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error87;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
__name(_retryWithExponentialBackoff, "_retryWithExponentialBackoff");
function prepareRetries({
  maxRetries
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError3({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError3({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })
  };
}
__name(prepareRetries, "prepareRetries");
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
__name(assembleOperationName, "assembleOperationName");
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a172;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a172 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a172 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
__name(getBaseTelemetryAttributes, "getBaseTelemetryAttributes");
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name172, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  }
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return import_api3.trace.getTracer("ai");
}
__name(getTracer, "getTracer");
function recordSpan({
  name: name172,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name172, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error87) {
      try {
        recordErrorOnSpan(span, error87);
      } finally {
        span.end();
      }
      throw error87;
    }
  });
}
__name(recordSpan, "recordSpan");
function recordErrorOnSpan(span, error87) {
  if (error87 instanceof Error) {
    span.recordException({
      name: error87.name,
      message: error87.message,
      stack: error87.stack
    });
    span.setStatus({
      code: import_api4.SpanStatusCode.ERROR,
      message: error87.message
    });
  } else {
    span.setStatus({ code: import_api4.SpanStatusCode.ERROR });
  }
}
__name(recordErrorOnSpan, "recordErrorOnSpan");
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value === void 0) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
__name(selectTelemetryAttributes, "selectTelemetryAttributes");
var name34 = "AI_NoImageGeneratedError";
var marker34 = `vercel.ai.error.${name34}`;
var symbol34 = Symbol.for(marker34);
var _a34;
_a34 = symbol34;
var DefaultGeneratedFile = class {
  static {
    __name(this, "DefaultGeneratedFile");
  }
  constructor({
    data,
    mimeType
  }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data;
    this.uint8ArrayData = isUint8Array ? data : void 0;
    this.mimeType = mimeType;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
  static {
    __name(this, "DefaultGeneratedFileWithType");
  }
  constructor(options) {
    super(options);
    this.type = "file";
  }
};
var imageMimeTypeSignatures = [
  {
    mimeType: "image/gif",
    bytesPrefix: [71, 73, 70],
    base64Prefix: "R0lG"
  },
  {
    mimeType: "image/png",
    bytesPrefix: [137, 80, 78, 71],
    base64Prefix: "iVBORw"
  },
  {
    mimeType: "image/jpeg",
    bytesPrefix: [255, 216],
    base64Prefix: "/9j/"
  },
  {
    mimeType: "image/webp",
    bytesPrefix: [82, 73, 70, 70],
    base64Prefix: "UklGRg"
  },
  {
    mimeType: "image/bmp",
    bytesPrefix: [66, 77],
    base64Prefix: "Qk"
  },
  {
    mimeType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0],
    base64Prefix: "SUkqAA"
  },
  {
    mimeType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42],
    base64Prefix: "TU0AKg"
  },
  {
    mimeType: "image/avif",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      97,
      118,
      105,
      102
    ],
    base64Prefix: "AAAAIGZ0eXBhdmlm"
  },
  {
    mimeType: "image/heic",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      104,
      101,
      105,
      99
    ],
    base64Prefix: "AAAAIGZ0eXBoZWlj"
  }
];
var stripID3 = /* @__PURE__ */ __name((data) => {
  const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
  return bytes.slice(id3Size + 10);
}, "stripID3");
function stripID3TagsIfPresent(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
  data[1] === 68 && // 'D'
  data[2] === 51;
  return hasId3 ? stripID3(data) : data;
}
__name(stripID3TagsIfPresent, "stripID3TagsIfPresent");
function detectMimeType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent(data);
  for (const signature of signatures) {
    if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(
      (byte, index) => processedData[index] === byte
    )) {
      return signature.mimeType;
    }
  }
  return void 0;
}
__name(detectMimeType, "detectMimeType");
var name44 = "AI_NoObjectGeneratedError";
var marker44 = `vercel.ai.error.${name44}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var NoObjectGeneratedError2 = class extends AISDKError2 {
  static {
    __name(this, "NoObjectGeneratedError");
  }
  constructor({
    message = "No object generated.",
    cause,
    text: text22,
    response,
    usage,
    finishReason
  }) {
    super({ name: name44, message, cause });
    this[_a44] = true;
    this.text = text22;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker44);
  }
};
_a44 = symbol44;
var name54 = "AI_DownloadError";
var marker54 = `vercel.ai.error.${name54}`;
var symbol54 = Symbol.for(marker54);
var _a54;
var DownloadError = class extends AISDKError2 {
  static {
    __name(this, "DownloadError");
  }
  constructor({
    url: url3,
    statusCode,
    statusText,
    cause,
    message = cause == null ? `Failed to download ${url3}: ${statusCode} ${statusText}` : `Failed to download ${url3}: ${cause}`
  }) {
    super({ name: name54, message, cause });
    this[_a54] = true;
    this.url = url3;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker54);
  }
};
_a54 = symbol54;
async function download({ url: url3 }) {
  var _a172;
  const urlText = url3.toString();
  try {
    const response = await fetch(urlText);
    if (!response.ok) {
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mimeType: (_a172 = response.headers.get("content-type")) != null ? _a172 : void 0
    };
  } catch (error87) {
    if (DownloadError.isInstance(error87)) {
      throw error87;
    }
    throw new DownloadError({ url: urlText, cause: error87 });
  }
}
__name(download, "download");
var name64 = "AI_InvalidDataContentError";
var marker64 = `vercel.ai.error.${name64}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var InvalidDataContentError = class extends AISDKError2 {
  static {
    __name(this, "InvalidDataContentError");
  }
  constructor({
    content,
    cause,
    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`
  }) {
    super({ name: name64, message, cause });
    this[_a64] = true;
    this.content = content;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker64);
  }
};
_a64 = symbol64;
var dataContentSchema2 = external_exports2.union([
  external_exports2.string(),
  external_exports2.instanceof(Uint8Array),
  external_exports2.instanceof(ArrayBuffer),
  external_exports2.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b;
      return (_b = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b : false;
    },
    { message: "Must be a Buffer" }
  )
]);
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
__name(convertDataContentToBase64String, "convertDataContentToBase64String");
function convertDataContentToUint8Array(content) {
  if (content instanceof Uint8Array) {
    return content;
  }
  if (typeof content === "string") {
    try {
      return convertBase64ToUint8Array(content);
    } catch (error87) {
      throw new InvalidDataContentError({
        message: "Invalid data content. Content string is not a base64-encoded media.",
        content,
        cause: error87
      });
    }
  }
  if (content instanceof ArrayBuffer) {
    return new Uint8Array(content);
  }
  throw new InvalidDataContentError({ content });
}
__name(convertDataContentToUint8Array, "convertDataContentToUint8Array");
function convertUint8ArrayToText(uint8Array) {
  try {
    return new TextDecoder().decode(uint8Array);
  } catch (error87) {
    throw new Error("Error decoding Uint8Array to text");
  }
}
__name(convertUint8ArrayToText, "convertUint8ArrayToText");
var name74 = "AI_InvalidMessageRoleError";
var marker74 = `vercel.ai.error.${name74}`;
var symbol74 = Symbol.for(marker74);
var _a74;
var InvalidMessageRoleError = class extends AISDKError2 {
  static {
    __name(this, "InvalidMessageRoleError");
  }
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
  }) {
    super({ name: name74, message });
    this[_a74] = true;
    this.role = role;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker74);
  }
};
_a74 = symbol74;
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mimeType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error87) {
    return {
      mimeType: void 0,
      base64Content: void 0
    };
  }
}
__name(splitDataUrl, "splitDataUrl");
async function convertToLanguageModelPrompt({
  prompt,
  modelSupportsImageUrls = true,
  modelSupportsUrl = /* @__PURE__ */ __name(() => false, "modelSupportsUrl"),
  downloadImplementation = download
}) {
  const downloadedAssets = await downloadAssets(
    prompt.messages,
    downloadImplementation,
    modelSupportsImageUrls,
    modelSupportsUrl
  );
  return [
    ...prompt.system != null ? [{ role: "system", content: prompt.system }] : [],
    ...prompt.messages.map(
      (message) => convertToLanguageModelMessage(message, downloadedAssets)
    )
  ];
}
__name(convertToLanguageModelPrompt, "convertToLanguageModelPrompt");
function convertToLanguageModelMessage(message, downloadedAssets) {
  var _a172, _b, _c, _d, _e, _f;
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerMetadata: (_a172 = message.providerOptions) != null ? _a172 : message.experimental_providerMetadata
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerMetadata: (_b = message.providerOptions) != null ? _b : message.experimental_providerMetadata
        };
      }
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerMetadata: (_c = message.providerOptions) != null ? _c : message.experimental_providerMetadata
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerMetadata: (_d = message.providerOptions) != null ? _d : message.experimental_providerMetadata
        };
      }
      return {
        role: "assistant",
        content: message.content.filter(
          // remove empty text parts:
          (part) => part.type !== "text" || part.text !== ""
        ).map((part) => {
          var _a182;
          const providerOptions = (_a182 = part.providerOptions) != null ? _a182 : part.experimental_providerMetadata;
          switch (part.type) {
            case "file": {
              return {
                type: "file",
                data: part.data instanceof URL ? part.data : convertDataContentToBase64String(part.data),
                filename: part.filename,
                mimeType: part.mimeType,
                providerMetadata: providerOptions
              };
            }
            case "reasoning": {
              return {
                type: "reasoning",
                text: part.text,
                signature: part.signature,
                providerMetadata: providerOptions
              };
            }
            case "redacted-reasoning": {
              return {
                type: "redacted-reasoning",
                data: part.data,
                providerMetadata: providerOptions
              };
            }
            case "text": {
              return {
                type: "text",
                text: part.text,
                providerMetadata: providerOptions
              };
            }
            case "tool-call": {
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                args: part.args,
                providerMetadata: providerOptions
              };
            }
          }
        }),
        providerMetadata: (_e = message.providerOptions) != null ? _e : message.experimental_providerMetadata
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.map((part) => {
          var _a182;
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            result: part.result,
            content: part.experimental_content,
            isError: part.isError,
            providerMetadata: (_a182 = part.providerOptions) != null ? _a182 : part.experimental_providerMetadata
          };
        }),
        providerMetadata: (_f = message.providerOptions) != null ? _f : message.experimental_providerMetadata
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
__name(convertToLanguageModelMessage, "convertToLanguageModelMessage");
async function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {
  const urls = messages.filter((message) => message.role === "user").map((message) => message.content).filter(
    (content) => Array.isArray(content)
  ).flat().filter(
    (part) => part.type === "image" || part.type === "file"
  ).filter(
    (part) => !(part.type === "image" && modelSupportsImageUrls === true)
  ).map((part) => part.type === "image" ? part.image : part.data).map(
    (part) => (
      // support string urls:
      typeof part === "string" && (part.startsWith("http:") || part.startsWith("https:")) ? new URL(part) : part
    )
  ).filter((image) => image instanceof URL).filter((url3) => !modelSupportsUrl(url3));
  const downloadedImages = await Promise.all(
    urls.map(async (url3) => ({
      url: url3,
      data: await downloadImplementation({ url: url3 })
    }))
  );
  return Object.fromEntries(
    downloadedImages.map(({ url: url3, data }) => [url3.toString(), data])
  );
}
__name(downloadAssets, "downloadAssets");
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a172, _b, _c, _d;
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerMetadata: (_a172 = part.providerOptions) != null ? _a172 : part.experimental_providerMetadata
    };
  }
  let mimeType = part.mimeType;
  let data;
  let content;
  let normalizedData;
  const type = part.type;
  switch (type) {
    case "image":
      data = part.image;
      break;
    case "file":
      data = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  try {
    content = typeof data === "string" ? new URL(data) : data;
  } catch (error87) {
    content = data;
  }
  if (content instanceof URL) {
    if (content.protocol === "data:") {
      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(
        content.toString()
      );
      if (dataUrlMimeType == null || base64Content == null) {
        throw new Error(`Invalid data URL format in part ${type}`);
      }
      mimeType = dataUrlMimeType;
      normalizedData = convertDataContentToUint8Array(base64Content);
    } else {
      const downloadedFile = downloadedAssets[content.toString()];
      if (downloadedFile) {
        normalizedData = downloadedFile.data;
        mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;
      } else {
        normalizedData = content;
      }
    }
  } else {
    normalizedData = convertDataContentToUint8Array(content);
  }
  switch (type) {
    case "image": {
      if (normalizedData instanceof Uint8Array) {
        mimeType = (_b = detectMimeType({
          data: normalizedData,
          signatures: imageMimeTypeSignatures
        })) != null ? _b : mimeType;
      }
      return {
        type: "image",
        image: normalizedData,
        mimeType,
        providerMetadata: (_c = part.providerOptions) != null ? _c : part.experimental_providerMetadata
      };
    }
    case "file": {
      if (mimeType == null) {
        throw new Error(`Mime type is missing for file part`);
      }
      return {
        type: "file",
        data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,
        filename: part.filename,
        mimeType,
        providerMetadata: (_d = part.providerOptions) != null ? _d : part.experimental_providerMetadata
      };
    }
  }
}
__name(convertPartToLanguageModelPart, "convertPartToLanguageModelPart");
function prepareCallSettings({
  maxTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  stopSequences,
  seed
}) {
  if (maxTokens != null) {
    if (!Number.isInteger(maxTokens)) {
      throw new InvalidArgumentError3({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be an integer"
      });
    }
    if (maxTokens < 1) {
      throw new InvalidArgumentError3({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be >= 1"
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError3({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError3({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError3({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError3({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError3({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError3({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
    }
  }
  return {
    maxTokens,
    // TODO v5 remove default 0 for temperature
    temperature: temperature != null ? temperature : 0,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,
    seed
  };
}
__name(prepareCallSettings, "prepareCallSettings");
function attachmentsToParts(attachments) {
  var _a172, _b, _c;
  const parts = [];
  for (const attachment of attachments) {
    let url3;
    try {
      url3 = new URL(attachment.url);
    } catch (error87) {
      throw new Error(`Invalid URL: ${attachment.url}`);
    }
    switch (url3.protocol) {
      case "http:":
      case "https:": {
        if ((_a172 = attachment.contentType) == null ? void 0 : _a172.startsWith("image/")) {
          parts.push({ type: "image", image: url3 });
        } else {
          if (!attachment.contentType) {
            throw new Error(
              "If the attachment is not an image, it must specify a content type"
            );
          }
          parts.push({
            type: "file",
            data: url3,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      case "data:": {
        let header;
        let base64Content;
        let mimeType;
        try {
          [header, base64Content] = attachment.url.split(",");
          mimeType = header.split(";")[0].split(":")[1];
        } catch (error87) {
          throw new Error(`Error processing data URL: ${attachment.url}`);
        }
        if (mimeType == null || base64Content == null) {
          throw new Error(`Invalid data URL format: ${attachment.url}`);
        }
        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith("image/")) {
          parts.push({
            type: "image",
            image: convertDataContentToUint8Array(base64Content)
          });
        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith("text/")) {
          parts.push({
            type: "text",
            text: convertUint8ArrayToText(
              convertDataContentToUint8Array(base64Content)
            )
          });
        } else {
          if (!attachment.contentType) {
            throw new Error(
              "If the attachment is not an image or text, it must specify a content type"
            );
          }
          parts.push({
            type: "file",
            data: base64Content,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      default: {
        throw new Error(`Unsupported URL protocol: ${url3.protocol}`);
      }
    }
  }
  return parts;
}
__name(attachmentsToParts, "attachmentsToParts");
var name84 = "AI_MessageConversionError";
var marker84 = `vercel.ai.error.${name84}`;
var symbol84 = Symbol.for(marker84);
var _a84;
var MessageConversionError2 = class extends AISDKError2 {
  static {
    __name(this, "MessageConversionError");
  }
  constructor({
    originalMessage,
    message
  }) {
    super({ name: name84, message });
    this[_a84] = true;
    this.originalMessage = originalMessage;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker84);
  }
};
_a84 = symbol84;
function convertToCoreMessages(messages, options) {
  var _a172, _b;
  const tools = (_a172 = options == null ? void 0 : options.tools) != null ? _a172 : {};
  const coreMessages = [];
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const isLastMessage = i === messages.length - 1;
    const { role, content, experimental_attachments } = message;
    switch (role) {
      case "system": {
        coreMessages.push({
          role: "system",
          content
        });
        break;
      }
      case "user": {
        if (message.parts == null) {
          coreMessages.push({
            role: "user",
            content: experimental_attachments ? [
              { type: "text", text: content },
              ...attachmentsToParts(experimental_attachments)
            ] : content
          });
        } else {
          const textParts = message.parts.filter((part) => part.type === "text").map((part) => ({
            type: "text",
            text: part.text
          }));
          coreMessages.push({
            role: "user",
            content: experimental_attachments ? [...textParts, ...attachmentsToParts(experimental_attachments)] : textParts
          });
        }
        break;
      }
      case "assistant": {
        if (message.parts != null) {
          let processBlock2 = /* @__PURE__ */ __name(function() {
            const content2 = [];
            for (const part of block) {
              switch (part.type) {
                case "file":
                case "text": {
                  content2.push(part);
                  break;
                }
                case "reasoning": {
                  for (const detail of part.details) {
                    switch (detail.type) {
                      case "text":
                        content2.push({
                          type: "reasoning",
                          text: detail.text,
                          signature: detail.signature
                        });
                        break;
                      case "redacted":
                        content2.push({
                          type: "redacted-reasoning",
                          data: detail.data
                        });
                        break;
                    }
                  }
                  break;
                }
                case "tool-invocation":
                  content2.push({
                    type: "tool-call",
                    toolCallId: part.toolInvocation.toolCallId,
                    toolName: part.toolInvocation.toolName,
                    args: part.toolInvocation.args
                  });
                  break;
                default: {
                  const _exhaustiveCheck = part;
                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
                }
              }
            }
            coreMessages.push({
              role: "assistant",
              content: content2
            });
            const stepInvocations = block.filter(
              (part) => part.type === "tool-invocation"
            ).map((part) => part.toolInvocation);
            if (stepInvocations.length > 0) {
              coreMessages.push({
                role: "tool",
                content: stepInvocations.map(
                  (toolInvocation) => {
                    if (!("result" in toolInvocation)) {
                      throw new MessageConversionError2({
                        originalMessage: message,
                        message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
                      });
                    }
                    const { toolCallId, toolName, result } = toolInvocation;
                    const tool22 = tools[toolName];
                    return (tool22 == null ? void 0 : tool22.experimental_toToolResultContent) != null ? {
                      type: "tool-result",
                      toolCallId,
                      toolName,
                      result: tool22.experimental_toToolResultContent(result),
                      experimental_content: tool22.experimental_toToolResultContent(result)
                    } : {
                      type: "tool-result",
                      toolCallId,
                      toolName,
                      result
                    };
                  }
                )
              });
            }
            block = [];
            blockHasToolInvocations = false;
            currentStep++;
          }, "processBlock2");
          var processBlock = processBlock2;
          let currentStep = 0;
          let blockHasToolInvocations = false;
          let block = [];
          for (const part of message.parts) {
            switch (part.type) {
              case "text": {
                if (blockHasToolInvocations) {
                  processBlock2();
                }
                block.push(part);
                break;
              }
              case "file":
              case "reasoning": {
                block.push(part);
                break;
              }
              case "tool-invocation": {
                if (((_b = part.toolInvocation.step) != null ? _b : 0) !== currentStep) {
                  processBlock2();
                }
                block.push(part);
                blockHasToolInvocations = true;
                break;
              }
            }
          }
          processBlock2();
          break;
        }
        const toolInvocations = message.toolInvocations;
        if (toolInvocations == null || toolInvocations.length === 0) {
          coreMessages.push({ role: "assistant", content });
          break;
        }
        const maxStep = toolInvocations.reduce((max, toolInvocation) => {
          var _a182;
          return Math.max(max, (_a182 = toolInvocation.step) != null ? _a182 : 0);
        }, 0);
        for (let i2 = 0; i2 <= maxStep; i2++) {
          const stepInvocations = toolInvocations.filter(
            (toolInvocation) => {
              var _a182;
              return ((_a182 = toolInvocation.step) != null ? _a182 : 0) === i2;
            }
          );
          if (stepInvocations.length === 0) {
            continue;
          }
          coreMessages.push({
            role: "assistant",
            content: [
              ...isLastMessage && content && i2 === 0 ? [{ type: "text", text: content }] : [],
              ...stepInvocations.map(
                ({ toolCallId, toolName, args }) => ({
                  type: "tool-call",
                  toolCallId,
                  toolName,
                  args
                })
              )
            ]
          });
          coreMessages.push({
            role: "tool",
            content: stepInvocations.map((toolInvocation) => {
              if (!("result" in toolInvocation)) {
                throw new MessageConversionError2({
                  originalMessage: message,
                  message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
                });
              }
              const { toolCallId, toolName, result } = toolInvocation;
              const tool22 = tools[toolName];
              return (tool22 == null ? void 0 : tool22.experimental_toToolResultContent) != null ? {
                type: "tool-result",
                toolCallId,
                toolName,
                result: tool22.experimental_toToolResultContent(result),
                experimental_content: tool22.experimental_toToolResultContent(result)
              } : {
                type: "tool-result",
                toolCallId,
                toolName,
                result
              };
            })
          });
        }
        if (content && !isLastMessage) {
          coreMessages.push({ role: "assistant", content });
        }
        break;
      }
      case "data": {
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new MessageConversionError2({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return coreMessages;
}
__name(convertToCoreMessages, "convertToCoreMessages");
var jsonValueSchema2 = external_exports2.lazy(
  () => external_exports2.union([
    external_exports2.null(),
    external_exports2.string(),
    external_exports2.number(),
    external_exports2.boolean(),
    external_exports2.record(external_exports2.string(), jsonValueSchema2),
    external_exports2.array(jsonValueSchema2)
  ])
);
var providerMetadataSchema2 = external_exports2.record(
  external_exports2.string(),
  external_exports2.record(external_exports2.string(), jsonValueSchema2)
);
var toolResultContentSchema = external_exports2.array(
  external_exports2.union([
    external_exports2.object({ type: external_exports2.literal("text"), text: external_exports2.string() }),
    external_exports2.object({
      type: external_exports2.literal("image"),
      data: external_exports2.string(),
      mimeType: external_exports2.string().optional()
    })
  ])
);
var textPartSchema2 = external_exports2.object({
  type: external_exports2.literal("text"),
  text: external_exports2.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var imagePartSchema2 = external_exports2.object({
  type: external_exports2.literal("image"),
  image: external_exports2.union([dataContentSchema2, external_exports2.instanceof(URL)]),
  mimeType: external_exports2.string().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var filePartSchema2 = external_exports2.object({
  type: external_exports2.literal("file"),
  data: external_exports2.union([dataContentSchema2, external_exports2.instanceof(URL)]),
  filename: external_exports2.string().optional(),
  mimeType: external_exports2.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var reasoningPartSchema2 = external_exports2.object({
  type: external_exports2.literal("reasoning"),
  text: external_exports2.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var redactedReasoningPartSchema = external_exports2.object({
  type: external_exports2.literal("redacted-reasoning"),
  data: external_exports2.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolCallPartSchema2 = external_exports2.object({
  type: external_exports2.literal("tool-call"),
  toolCallId: external_exports2.string(),
  toolName: external_exports2.string(),
  args: external_exports2.unknown(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolResultPartSchema2 = external_exports2.object({
  type: external_exports2.literal("tool-result"),
  toolCallId: external_exports2.string(),
  toolName: external_exports2.string(),
  result: external_exports2.unknown(),
  content: toolResultContentSchema.optional(),
  isError: external_exports2.boolean().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreSystemMessageSchema = external_exports2.object({
  role: external_exports2.literal("system"),
  content: external_exports2.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreUserMessageSchema = external_exports2.object({
  role: external_exports2.literal("user"),
  content: external_exports2.union([
    external_exports2.string(),
    external_exports2.array(external_exports2.union([textPartSchema2, imagePartSchema2, filePartSchema2]))
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreAssistantMessageSchema = external_exports2.object({
  role: external_exports2.literal("assistant"),
  content: external_exports2.union([
    external_exports2.string(),
    external_exports2.array(
      external_exports2.union([
        textPartSchema2,
        filePartSchema2,
        reasoningPartSchema2,
        redactedReasoningPartSchema,
        toolCallPartSchema2
      ])
    )
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreToolMessageSchema = external_exports2.object({
  role: external_exports2.literal("tool"),
  content: external_exports2.array(toolResultPartSchema2),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreMessageSchema = external_exports2.union([
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);
function standardizePrompt({
  prompt,
  tools
}) {
  if (prompt.prompt == null && prompt.messages == null) {
    throw new InvalidPromptError2({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (prompt.prompt != null && prompt.messages != null) {
    throw new InvalidPromptError2({
      prompt,
      message: "prompt and messages cannot be defined at the same time"
    });
  }
  if (prompt.system != null && typeof prompt.system !== "string") {
    throw new InvalidPromptError2({
      prompt,
      message: "system must be a string"
    });
  }
  if (prompt.prompt != null) {
    if (typeof prompt.prompt !== "string") {
      throw new InvalidPromptError2({
        prompt,
        message: "prompt must be a string"
      });
    }
    return {
      type: "prompt",
      system: prompt.system,
      messages: [
        {
          role: "user",
          content: prompt.prompt
        }
      ]
    };
  }
  if (prompt.messages != null) {
    const promptType = detectPromptType(prompt.messages);
    const messages = promptType === "ui-messages" ? convertToCoreMessages(prompt.messages, {
      tools
    }) : prompt.messages;
    if (messages.length === 0) {
      throw new InvalidPromptError2({
        prompt,
        message: "messages must not be empty"
      });
    }
    const validationResult = safeValidateTypes2({
      value: messages,
      schema: external_exports2.array(coreMessageSchema)
    });
    if (!validationResult.success) {
      throw new InvalidPromptError2({
        prompt,
        message: [
          "message must be a CoreMessage or a UI message",
          `Validation error: ${validationResult.error.message}`
        ].join("\n"),
        cause: validationResult.error
      });
    }
    return {
      type: "messages",
      messages,
      system: prompt.system
    };
  }
  throw new Error("unreachable");
}
__name(standardizePrompt, "standardizePrompt");
function detectPromptType(prompt) {
  if (!Array.isArray(prompt)) {
    throw new InvalidPromptError2({
      prompt,
      message: [
        "messages must be an array of CoreMessage or UIMessage",
        `Received non-array value: ${JSON.stringify(prompt)}`
      ].join("\n"),
      cause: prompt
    });
  }
  if (prompt.length === 0) {
    return "messages";
  }
  const characteristics = prompt.map(detectSingleMessageCharacteristics);
  if (characteristics.some((c) => c === "has-ui-specific-parts")) {
    return "ui-messages";
  }
  const nonMessageIndex = characteristics.findIndex(
    (c) => c !== "has-core-specific-parts" && c !== "message"
  );
  if (nonMessageIndex === -1) {
    return "messages";
  }
  throw new InvalidPromptError2({
    prompt,
    message: [
      "messages must be an array of CoreMessage or UIMessage",
      `Received message of type: "${characteristics[nonMessageIndex]}" at index ${nonMessageIndex}`,
      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`
    ].join("\n"),
    cause: prompt
  });
}
__name(detectPromptType, "detectPromptType");
function detectSingleMessageCharacteristics(message) {
  if (typeof message === "object" && message !== null && (message.role === "function" || // UI-only role
  message.role === "data" || // UI-only role
  "toolInvocations" in message || // UI-specific field
  "parts" in message || // UI-specific field
  "experimental_attachments" in message)) {
    return "has-ui-specific-parts";
  } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || // Core messages can have array content
  "experimental_providerMetadata" in message || "providerOptions" in message)) {
    return "has-core-specific-parts";
  } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && ["system", "user", "assistant", "tool"].includes(message.role)) {
    return "message";
  } else {
    return "other";
  }
}
__name(detectSingleMessageCharacteristics, "detectSingleMessageCharacteristics");
function calculateLanguageModelUsage({
  promptTokens,
  completionTokens
}) {
  return {
    promptTokens,
    completionTokens,
    totalTokens: promptTokens + completionTokens
  };
}
__name(calculateLanguageModelUsage, "calculateLanguageModelUsage");
function addLanguageModelUsage(usage1, usage2) {
  return {
    promptTokens: usage1.promptTokens + usage2.promptTokens,
    completionTokens: usage1.completionTokens + usage2.completionTokens,
    totalTokens: usage1.totalTokens + usage2.totalTokens
  };
}
__name(addLanguageModelUsage, "addLanguageModelUsage");
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
__name(injectJsonInstruction, "injectJsonInstruction");
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return stream;
}
__name(createAsyncIterableStream, "createAsyncIterableStream");
var noSchemaOutputStrategy = {
  type: "no-schema",
  jsonSchema: void 0,
  validatePartialResult({ value, textDelta }) {
    return { success: true, value: { partial: value, textDelta } };
  },
  validateFinalResult(value, context3) {
    return value === void 0 ? {
      success: false,
      error: new NoObjectGeneratedError2({
        message: "No object generated: response did not match schema.",
        text: context3.text,
        response: context3.response,
        usage: context3.usage,
        finishReason: context3.finishReason
      })
    } : { success: true, value };
  },
  createElementStream() {
    throw new UnsupportedFunctionalityError2({
      functionality: "element streams in no-schema mode"
    });
  }
};
var objectOutputStrategy = /* @__PURE__ */ __name((schema) => ({
  type: "object",
  jsonSchema: schema.jsonSchema,
  validatePartialResult({ value, textDelta }) {
    return {
      success: true,
      value: {
        // Note: currently no validation of partial results:
        partial: value,
        textDelta
      }
    };
  },
  validateFinalResult(value) {
    return safeValidateTypes2({ value, schema });
  },
  createElementStream() {
    throw new UnsupportedFunctionalityError2({
      functionality: "element streams in object mode"
    });
  }
}), "objectOutputStrategy");
var arrayOutputStrategy = /* @__PURE__ */ __name((schema) => {
  const { $schema, ...itemSchema } = schema.jsonSchema;
  return {
    type: "enum",
    // wrap in object that contains array of elements, since most LLMs will not
    // be able to generate an array directly:
    // possible future optimization: use arrays directly when model supports grammar-guided generation
    jsonSchema: {
      $schema: "http://json-schema.org/draft-07/schema#",
      type: "object",
      properties: {
        elements: { type: "array", items: itemSchema }
      },
      required: ["elements"],
      additionalProperties: false
    },
    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {
      var _a172;
      if (!isJSONObject(value) || !isJSONArray(value.elements)) {
        return {
          success: false,
          error: new TypeValidationError2({
            value,
            cause: "value must be an object that contains an array of elements"
          })
        };
      }
      const inputArray = value.elements;
      const resultArray = [];
      for (let i = 0; i < inputArray.length; i++) {
        const element = inputArray[i];
        const result = safeValidateTypes2({ value: element, schema });
        if (i === inputArray.length - 1 && !isFinalDelta) {
          continue;
        }
        if (!result.success) {
          return result;
        }
        resultArray.push(result.value);
      }
      const publishedElementCount = (_a172 = latestObject == null ? void 0 : latestObject.length) != null ? _a172 : 0;
      let textDelta = "";
      if (isFirstDelta) {
        textDelta += "[";
      }
      if (publishedElementCount > 0) {
        textDelta += ",";
      }
      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(",");
      if (isFinalDelta) {
        textDelta += "]";
      }
      return {
        success: true,
        value: {
          partial: resultArray,
          textDelta
        }
      };
    },
    validateFinalResult(value) {
      if (!isJSONObject(value) || !isJSONArray(value.elements)) {
        return {
          success: false,
          error: new TypeValidationError2({
            value,
            cause: "value must be an object that contains an array of elements"
          })
        };
      }
      const inputArray = value.elements;
      for (const element of inputArray) {
        const result = safeValidateTypes2({ value: element, schema });
        if (!result.success) {
          return result;
        }
      }
      return { success: true, value: inputArray };
    },
    createElementStream(originalStream) {
      let publishedElements = 0;
      return createAsyncIterableStream(
        originalStream.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              switch (chunk.type) {
                case "object": {
                  const array3 = chunk.object;
                  for (; publishedElements < array3.length; publishedElements++) {
                    controller.enqueue(array3[publishedElements]);
                  }
                  break;
                }
                case "text-delta":
                case "finish":
                case "error":
                  break;
                default: {
                  const _exhaustiveCheck = chunk;
                  throw new Error(
                    `Unsupported chunk type: ${_exhaustiveCheck}`
                  );
                }
              }
            }
          })
        )
      );
    }
  };
}, "arrayOutputStrategy");
var enumOutputStrategy = /* @__PURE__ */ __name((enumValues) => {
  return {
    type: "enum",
    // wrap in object that contains result, since most LLMs will not
    // be able to generate an enum value directly:
    // possible future optimization: use enums directly when model supports top-level enums
    jsonSchema: {
      $schema: "http://json-schema.org/draft-07/schema#",
      type: "object",
      properties: {
        result: { type: "string", enum: enumValues }
      },
      required: ["result"],
      additionalProperties: false
    },
    validateFinalResult(value) {
      if (!isJSONObject(value) || typeof value.result !== "string") {
        return {
          success: false,
          error: new TypeValidationError2({
            value,
            cause: 'value must be an object that contains a string in the "result" property.'
          })
        };
      }
      const result = value.result;
      return enumValues.includes(result) ? { success: true, value: result } : {
        success: false,
        error: new TypeValidationError2({
          value,
          cause: "value must be a string in the enum"
        })
      };
    },
    validatePartialResult() {
      throw new UnsupportedFunctionalityError2({
        functionality: "partial results in enum mode"
      });
    },
    createElementStream() {
      throw new UnsupportedFunctionalityError2({
        functionality: "element streams in enum mode"
      });
    }
  };
}, "enumOutputStrategy");
function getOutputStrategy({
  output,
  schema,
  enumValues
}) {
  switch (output) {
    case "object":
      return objectOutputStrategy(asSchema2(schema));
    case "array":
      return arrayOutputStrategy(asSchema2(schema));
    case "enum":
      return enumOutputStrategy(enumValues);
    case "no-schema":
      return noSchemaOutputStrategy;
    default: {
      const _exhaustiveCheck = output;
      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);
    }
  }
}
__name(getOutputStrategy, "getOutputStrategy");
function validateObjectGenerationInput({
  output,
  mode,
  schema,
  schemaName,
  schemaDescription,
  enumValues
}) {
  if (output != null && output !== "object" && output !== "array" && output !== "enum" && output !== "no-schema") {
    throw new InvalidArgumentError3({
      parameter: "output",
      value: output,
      message: "Invalid output type."
    });
  }
  if (output === "no-schema") {
    if (mode === "auto" || mode === "tool") {
      throw new InvalidArgumentError3({
        parameter: "mode",
        value: mode,
        message: 'Mode must be "json" for no-schema output.'
      });
    }
    if (schema != null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for no-schema output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for no-schema output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for no-schema output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for no-schema output."
      });
    }
  }
  if (output === "object") {
    if (schema == null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is required for object output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for object output."
      });
    }
  }
  if (output === "array") {
    if (schema == null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Element schema is required for array output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for array output."
      });
    }
  }
  if (output === "enum") {
    if (schema != null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for enum output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for enum output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for enum output."
      });
    }
    if (enumValues == null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are required for enum output."
      });
    }
    for (const value of enumValues) {
      if (typeof value !== "string") {
        throw new InvalidArgumentError3({
          parameter: "enumValues",
          value,
          message: "Enum values must be strings."
        });
      }
    }
  }
}
__name(validateObjectGenerationInput, "validateObjectGenerationInput");
function stringifyForTelemetry(prompt) {
  const processedPrompt = prompt.map((message) => {
    return {
      ...message,
      content: typeof message.content === "string" ? message.content : message.content.map(processPart)
    };
  });
  return JSON.stringify(processedPrompt);
}
__name(stringifyForTelemetry, "stringifyForTelemetry");
function processPart(part) {
  if (part.type === "image") {
    return {
      ...part,
      image: part.image instanceof Uint8Array ? convertDataContentToBase64String(part.image) : part.image
    };
  }
  return part;
}
__name(processPart, "processPart");
var originalGenerateId5 = createIdGenerator2({ prefix: "aiobj", size: 24 });
async function generateObject({
  model,
  enum: enumValues,
  // rename bc enum is reserved by typescript
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = "object",
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_repairText: repairText,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  _internal: {
    generateId: generateId32 = originalGenerateId5,
    currentDate = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Date(), "currentDate")
  } = {},
  ...settings
}) {
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  validateObjectGenerationInput({
    output,
    mode,
    schema: inputSchema,
    schemaName,
    schemaDescription,
    enumValues
  });
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const outputStrategy = getOutputStrategy({
    output,
    schema: inputSchema,
    enumValues
  });
  if (outputStrategy.type === "no-schema" && mode === void 0) {
    mode = "json";
  }
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { ...settings, maxRetries }
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.generateObject",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.generateObject",
          telemetry
        }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.prompt": {
          input: /* @__PURE__ */ __name(() => JSON.stringify({ system, prompt, messages }), "input")
        },
        "ai.schema": outputStrategy.jsonSchema != null ? { input: /* @__PURE__ */ __name(() => JSON.stringify(outputStrategy.jsonSchema), "input") } : void 0,
        "ai.schema.name": schemaName,
        "ai.schema.description": schemaDescription,
        "ai.settings.output": outputStrategy.type,
        "ai.settings.mode": mode
      }
    }),
    tracer,
    fn: /* @__PURE__ */ __name(async (span) => {
      var _a172, _b, _c, _d;
      if (mode === "auto" || mode == null) {
        mode = model.defaultObjectGenerationMode;
      }
      let result;
      let finishReason;
      let usage;
      let warnings;
      let rawResponse;
      let response;
      let request;
      let logprobs;
      let resultProviderMetadata;
      switch (mode) {
        case "json": {
          const standardizedPrompt = standardizePrompt({
            prompt: {
              system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({
                prompt: system,
                schema: outputStrategy.jsonSchema
              }),
              prompt,
              messages
            },
            tools: void 0
          });
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: standardizedPrompt,
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_a172 = model.supportsUrl) == null ? void 0 : _a172.bind(model)
            // support 'this' context
          });
          const generateResult = await retry(
            () => recordSpan({
              name: "ai.generateObject.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateObject.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: /* @__PURE__ */ __name(() => standardizedPrompt.type, "input")
                  },
                  "ai.prompt.messages": {
                    input: /* @__PURE__ */ __name(() => JSON.stringify(promptMessages), "input")
                  },
                  "ai.settings.mode": mode,
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              fn: /* @__PURE__ */ __name(async (span2) => {
                var _a182, _b2, _c2, _d2, _e, _f;
                const result2 = await model.doGenerate({
                  mode: {
                    type: "object-json",
                    schema: outputStrategy.jsonSchema,
                    name: schemaName,
                    description: schemaDescription
                  },
                  ...prepareCallSettings(settings),
                  inputFormat: standardizedPrompt.type,
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                });
                const responseData = {
                  id: (_b2 = (_a182 = result2.response) == null ? void 0 : _a182.id) != null ? _b2 : generateId32(),
                  timestamp: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId
                };
                if (result2.text === void 0) {
                  throw new NoObjectGeneratedError2({
                    message: "No object generated: the model did not return a response.",
                    response: responseData,
                    usage: calculateLanguageModelUsage(result2.usage),
                    finishReason: result2.finishReason
                  });
                }
                span2.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result2.finishReason,
                      "ai.response.object": { output: /* @__PURE__ */ __name(() => result2.text, "output") },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(
                        result2.providerMetadata
                      ),
                      "ai.usage.promptTokens": result2.usage.promptTokens,
                      "ai.usage.completionTokens": result2.usage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [result2.finishReason],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.prompt_tokens": result2.usage.promptTokens,
                      "gen_ai.usage.completion_tokens": result2.usage.completionTokens
                    }
                  })
                );
                return { ...result2, objectText: result2.text, responseData };
              }, "fn")
            })
          );
          result = generateResult.objectText;
          finishReason = generateResult.finishReason;
          usage = generateResult.usage;
          warnings = generateResult.warnings;
          rawResponse = generateResult.rawResponse;
          logprobs = generateResult.logprobs;
          resultProviderMetadata = generateResult.providerMetadata;
          request = (_b = generateResult.request) != null ? _b : {};
          response = generateResult.responseData;
          break;
        }
        case "tool": {
          const standardizedPrompt = standardizePrompt({
            prompt: { system, prompt, messages },
            tools: void 0
          });
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: standardizedPrompt,
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_c = model.supportsUrl) == null ? void 0 : _c.bind(model)
            // support 'this' context,
          });
          const inputFormat = standardizedPrompt.type;
          const generateResult = await retry(
            () => recordSpan({
              name: "ai.generateObject.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateObject.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: /* @__PURE__ */ __name(() => inputFormat, "input")
                  },
                  "ai.prompt.messages": {
                    input: /* @__PURE__ */ __name(() => stringifyForTelemetry(promptMessages), "input")
                  },
                  "ai.settings.mode": mode,
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              fn: /* @__PURE__ */ __name(async (span2) => {
                var _a182, _b2, _c2, _d2, _e, _f, _g, _h;
                const result2 = await model.doGenerate({
                  mode: {
                    type: "object-tool",
                    tool: {
                      type: "function",
                      name: schemaName != null ? schemaName : "json",
                      description: schemaDescription != null ? schemaDescription : "Respond with a JSON object.",
                      parameters: outputStrategy.jsonSchema
                    }
                  },
                  ...prepareCallSettings(settings),
                  inputFormat,
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                });
                const objectText = (_b2 = (_a182 = result2.toolCalls) == null ? void 0 : _a182[0]) == null ? void 0 : _b2.args;
                const responseData = {
                  id: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.id) != null ? _d2 : generateId32(),
                  timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),
                  modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId
                };
                if (objectText === void 0) {
                  throw new NoObjectGeneratedError2({
                    message: "No object generated: the tool was not called.",
                    response: responseData,
                    usage: calculateLanguageModelUsage(result2.usage),
                    finishReason: result2.finishReason
                  });
                }
                span2.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result2.finishReason,
                      "ai.response.object": { output: /* @__PURE__ */ __name(() => objectText, "output") },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(
                        result2.providerMetadata
                      ),
                      "ai.usage.promptTokens": result2.usage.promptTokens,
                      "ai.usage.completionTokens": result2.usage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [result2.finishReason],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.input_tokens": result2.usage.promptTokens,
                      "gen_ai.usage.output_tokens": result2.usage.completionTokens
                    }
                  })
                );
                return { ...result2, objectText, responseData };
              }, "fn")
            })
          );
          result = generateResult.objectText;
          finishReason = generateResult.finishReason;
          usage = generateResult.usage;
          warnings = generateResult.warnings;
          rawResponse = generateResult.rawResponse;
          logprobs = generateResult.logprobs;
          resultProviderMetadata = generateResult.providerMetadata;
          request = (_d = generateResult.request) != null ? _d : {};
          response = generateResult.responseData;
          break;
        }
        case void 0: {
          throw new Error(
            "Model does not have a default object generation mode."
          );
        }
        default: {
          const _exhaustiveCheck = mode;
          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);
        }
      }
      function processResult(result2) {
        const parseResult = safeParseJSON2({ text: result2 });
        if (!parseResult.success) {
          throw new NoObjectGeneratedError2({
            message: "No object generated: could not parse the response.",
            cause: parseResult.error,
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage),
            finishReason
          });
        }
        const validationResult = outputStrategy.validateFinalResult(
          parseResult.value,
          {
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage)
          }
        );
        if (!validationResult.success) {
          throw new NoObjectGeneratedError2({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage),
            finishReason
          });
        }
        return validationResult.value;
      }
      __name(processResult, "processResult");
      let object22;
      try {
        object22 = processResult(result);
      } catch (error87) {
        if (repairText != null && NoObjectGeneratedError2.isInstance(error87) && (JSONParseError2.isInstance(error87.cause) || TypeValidationError2.isInstance(error87.cause))) {
          const repairedText = await repairText({
            text: result,
            error: error87.cause
          });
          if (repairedText === null) {
            throw error87;
          }
          object22 = processResult(repairedText);
        } else {
          throw error87;
        }
      }
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": finishReason,
            "ai.response.object": {
              output: /* @__PURE__ */ __name(() => JSON.stringify(object22), "output")
            },
            "ai.usage.promptTokens": usage.promptTokens,
            "ai.usage.completionTokens": usage.completionTokens
          }
        })
      );
      return new DefaultGenerateObjectResult({
        object: object22,
        finishReason,
        usage: calculateLanguageModelUsage(usage),
        warnings,
        request,
        response: {
          ...response,
          headers: rawResponse == null ? void 0 : rawResponse.headers,
          body: rawResponse == null ? void 0 : rawResponse.body
        },
        logprobs,
        providerMetadata: resultProviderMetadata
      });
    }, "fn")
  });
}
__name(generateObject, "generateObject");
var DefaultGenerateObjectResult = class {
  static {
    __name(this, "DefaultGenerateObjectResult");
  }
  constructor(options) {
    this.object = options.object;
    this.finishReason = options.finishReason;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.providerMetadata = options.providerMetadata;
    this.experimental_providerMetadata = options.providerMetadata;
    this.response = options.response;
    this.request = options.request;
    this.logprobs = options.logprobs;
  }
  toJsonResponse(init) {
    var _a172;
    return new Response(JSON.stringify(this.object), {
      status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "application/json; charset=utf-8"
      })
    });
  }
};
var DelayedPromise = class {
  static {
    __name(this, "DelayedPromise");
  }
  constructor() {
    this.status = { type: "pending" };
    this._resolve = void 0;
    this._reject = void 0;
  }
  get value() {
    if (this.promise) {
      return this.promise;
    }
    this.promise = new Promise((resolve3, reject) => {
      if (this.status.type === "resolved") {
        resolve3(this.status.value);
      } else if (this.status.type === "rejected") {
        reject(this.status.error);
      }
      this._resolve = resolve3;
      this._reject = reject;
    });
    return this.promise;
  }
  resolve(value) {
    var _a172;
    this.status = { type: "resolved", value };
    if (this.promise) {
      (_a172 = this._resolve) == null ? void 0 : _a172.call(this, value);
    }
  }
  reject(error87) {
    var _a172;
    this.status = { type: "rejected", error: error87 };
    if (this.promise) {
      (_a172 = this._reject) == null ? void 0 : _a172.call(this, error87);
    }
  }
};
function createResolvablePromise() {
  let resolve3;
  let reject;
  const promise3 = new Promise((res, rej) => {
    resolve3 = res;
    reject = rej;
  });
  return {
    promise: promise3,
    resolve: resolve3,
    reject
  };
}
__name(createResolvablePromise, "createResolvablePromise");
function createStitchableStream() {
  let innerStreamReaders = [];
  let controller = null;
  let isClosed = false;
  let waitForNewStream = createResolvablePromise();
  const processPull = /* @__PURE__ */ __name(async () => {
    if (isClosed && innerStreamReaders.length === 0) {
      controller == null ? void 0 : controller.close();
      return;
    }
    if (innerStreamReaders.length === 0) {
      waitForNewStream = createResolvablePromise();
      await waitForNewStream.promise;
      return processPull();
    }
    try {
      const { value, done } = await innerStreamReaders[0].read();
      if (done) {
        innerStreamReaders.shift();
        if (innerStreamReaders.length > 0) {
          await processPull();
        } else if (isClosed) {
          controller == null ? void 0 : controller.close();
        }
      } else {
        controller == null ? void 0 : controller.enqueue(value);
      }
    } catch (error87) {
      controller == null ? void 0 : controller.error(error87);
      innerStreamReaders.shift();
      if (isClosed && innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    }
  }, "processPull");
  return {
    stream: new ReadableStream({
      start(controllerParam) {
        controller = controllerParam;
      },
      pull: processPull,
      async cancel() {
        for (const reader of innerStreamReaders) {
          await reader.cancel();
        }
        innerStreamReaders = [];
        isClosed = true;
      }
    }),
    addStream: /* @__PURE__ */ __name((innerStream) => {
      if (isClosed) {
        throw new Error("Cannot add inner stream: outer stream is closed");
      }
      innerStreamReaders.push(innerStream.getReader());
      waitForNewStream.resolve();
    }, "addStream"),
    /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */
    close: /* @__PURE__ */ __name(() => {
      isClosed = true;
      waitForNewStream.resolve();
      if (innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    }, "close"),
    /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */
    terminate: /* @__PURE__ */ __name(() => {
      isClosed = true;
      waitForNewStream.resolve();
      innerStreamReaders.forEach((reader) => reader.cancel());
      innerStreamReaders = [];
      controller == null ? void 0 : controller.close();
    }, "terminate")
  };
}
__name(createStitchableStream, "createStitchableStream");
function now() {
  var _a172, _b;
  return (_b = (_a172 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a172.now()) != null ? _b : Date.now();
}
__name(now, "now");
var originalGenerateId22 = createIdGenerator2({ prefix: "aiobj", size: 24 });
function streamObject({
  model,
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = "object",
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  onError,
  onFinish,
  _internal: {
    generateId: generateId32 = originalGenerateId22,
    currentDate = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Date(), "currentDate"),
    now: now2 = now
  } = {},
  ...settings
}) {
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  validateObjectGenerationInput({
    output,
    mode,
    schema: inputSchema,
    schemaName,
    schemaDescription
  });
  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });
  if (outputStrategy.type === "no-schema" && mode === void 0) {
    mode = "json";
  }
  return new DefaultStreamObjectResult({
    model,
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    mode,
    onError,
    onFinish,
    generateId: generateId32,
    currentDate,
    now: now2
  });
}
__name(streamObject, "streamObject");
var DefaultStreamObjectResult = class {
  static {
    __name(this, "DefaultStreamObjectResult");
  }
  constructor({
    model,
    headers,
    telemetry,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    mode,
    onError,
    onFinish,
    generateId: generateId32,
    currentDate,
    now: now2
  }) {
    this.objectPromise = new DelayedPromise();
    this.usagePromise = new DelayedPromise();
    this.providerMetadataPromise = new DelayedPromise();
    this.warningsPromise = new DelayedPromise();
    this.requestPromise = new DelayedPromise();
    this.responsePromise = new DelayedPromise();
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg
    });
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...settings, maxRetries }
    });
    const tracer = getTracer(telemetry);
    const self2 = this;
    const stitchableStream = createStitchableStream();
    const eventProcessor = new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
        if (chunk.type === "error") {
          onError == null ? void 0 : onError({ error: chunk.error });
        }
      }
    });
    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);
    recordSpan({
      name: "ai.streamObject",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.streamObject",
            telemetry
          }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: /* @__PURE__ */ __name(() => JSON.stringify({ system, prompt, messages }), "input")
          },
          "ai.schema": outputStrategy.jsonSchema != null ? { input: /* @__PURE__ */ __name(() => JSON.stringify(outputStrategy.jsonSchema), "input") } : void 0,
          "ai.schema.name": schemaName,
          "ai.schema.description": schemaDescription,
          "ai.settings.output": outputStrategy.type,
          "ai.settings.mode": mode
        }
      }),
      tracer,
      endWhenDone: false,
      fn: /* @__PURE__ */ __name(async (rootSpan) => {
        var _a172, _b;
        if (mode === "auto" || mode == null) {
          mode = model.defaultObjectGenerationMode;
        }
        let callOptions;
        let transformer;
        switch (mode) {
          case "json": {
            const standardizedPrompt = standardizePrompt({
              prompt: {
                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({
                  prompt: system,
                  schema: outputStrategy.jsonSchema
                }),
                prompt,
                messages
              },
              tools: void 0
            });
            callOptions = {
              mode: {
                type: "object-json",
                schema: outputStrategy.jsonSchema,
                name: schemaName,
                description: schemaDescription
              },
              ...prepareCallSettings(settings),
              inputFormat: standardizedPrompt.type,
              prompt: await convertToLanguageModelPrompt({
                prompt: standardizedPrompt,
                modelSupportsImageUrls: model.supportsImageUrls,
                modelSupportsUrl: (_a172 = model.supportsUrl) == null ? void 0 : _a172.bind(model)
                // support 'this' context
              }),
              providerMetadata: providerOptions,
              abortSignal,
              headers
            };
            transformer = {
              transform: /* @__PURE__ */ __name((chunk, controller) => {
                switch (chunk.type) {
                  case "text-delta":
                    controller.enqueue(chunk.textDelta);
                    break;
                  case "response-metadata":
                  case "finish":
                  case "error":
                    controller.enqueue(chunk);
                    break;
                }
              }, "transform")
            };
            break;
          }
          case "tool": {
            const standardizedPrompt = standardizePrompt({
              prompt: { system, prompt, messages },
              tools: void 0
            });
            callOptions = {
              mode: {
                type: "object-tool",
                tool: {
                  type: "function",
                  name: schemaName != null ? schemaName : "json",
                  description: schemaDescription != null ? schemaDescription : "Respond with a JSON object.",
                  parameters: outputStrategy.jsonSchema
                }
              },
              ...prepareCallSettings(settings),
              inputFormat: standardizedPrompt.type,
              prompt: await convertToLanguageModelPrompt({
                prompt: standardizedPrompt,
                modelSupportsImageUrls: model.supportsImageUrls,
                modelSupportsUrl: (_b = model.supportsUrl) == null ? void 0 : _b.bind(model)
                // support 'this' context,
              }),
              providerMetadata: providerOptions,
              abortSignal,
              headers
            };
            transformer = {
              transform(chunk, controller) {
                switch (chunk.type) {
                  case "tool-call-delta":
                    controller.enqueue(chunk.argsTextDelta);
                    break;
                  case "response-metadata":
                  case "finish":
                  case "error":
                    controller.enqueue(chunk);
                    break;
                }
              }
            };
            break;
          }
          case void 0: {
            throw new Error(
              "Model does not have a default object generation mode."
            );
          }
          default: {
            const _exhaustiveCheck = mode;
            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);
          }
        }
        const {
          result: { stream, warnings, rawResponse, request },
          doStreamSpan,
          startTimestampMs
        } = await retry(
          () => recordSpan({
            name: "ai.streamObject.doStream",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.streamObject.doStream",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                "ai.prompt.format": {
                  input: /* @__PURE__ */ __name(() => callOptions.inputFormat, "input")
                },
                "ai.prompt.messages": {
                  input: /* @__PURE__ */ __name(() => stringifyForTelemetry(callOptions.prompt), "input")
                },
                "ai.settings.mode": mode,
                // standardized gen-ai llm span attributes:
                "gen_ai.system": model.provider,
                "gen_ai.request.model": model.modelId,
                "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                "gen_ai.request.max_tokens": settings.maxTokens,
                "gen_ai.request.presence_penalty": settings.presencePenalty,
                "gen_ai.request.temperature": settings.temperature,
                "gen_ai.request.top_k": settings.topK,
                "gen_ai.request.top_p": settings.topP
              }
            }),
            tracer,
            endWhenDone: false,
            fn: /* @__PURE__ */ __name(async (doStreamSpan2) => ({
              startTimestampMs: now2(),
              doStreamSpan: doStreamSpan2,
              result: await model.doStream(callOptions)
            }), "fn")
          })
        );
        self2.requestPromise.resolve(request != null ? request : {});
        let usage;
        let finishReason;
        let providerMetadata;
        let object22;
        let error87;
        let accumulatedText = "";
        let textDelta = "";
        let response = {
          id: generateId32(),
          timestamp: currentDate(),
          modelId: model.modelId
        };
        let latestObjectJson = void 0;
        let latestObject = void 0;
        let isFirstChunk = true;
        let isFirstDelta = true;
        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(
          new TransformStream({
            async transform(chunk, controller) {
              var _a182, _b2, _c;
              if (isFirstChunk) {
                const msToFirstChunk = now2() - startTimestampMs;
                isFirstChunk = false;
                doStreamSpan.addEvent("ai.stream.firstChunk", {
                  "ai.stream.msToFirstChunk": msToFirstChunk
                });
                doStreamSpan.setAttributes({
                  "ai.stream.msToFirstChunk": msToFirstChunk
                });
              }
              if (typeof chunk === "string") {
                accumulatedText += chunk;
                textDelta += chunk;
                const { value: currentObjectJson, state: parseState } = parsePartialJson2(accumulatedText);
                if (currentObjectJson !== void 0 && !isDeepEqualData2(latestObjectJson, currentObjectJson)) {
                  const validationResult = outputStrategy.validatePartialResult({
                    value: currentObjectJson,
                    textDelta,
                    latestObject,
                    isFirstDelta,
                    isFinalDelta: parseState === "successful-parse"
                  });
                  if (validationResult.success && !isDeepEqualData2(
                    latestObject,
                    validationResult.value.partial
                  )) {
                    latestObjectJson = currentObjectJson;
                    latestObject = validationResult.value.partial;
                    controller.enqueue({
                      type: "object",
                      object: latestObject
                    });
                    controller.enqueue({
                      type: "text-delta",
                      textDelta: validationResult.value.textDelta
                    });
                    textDelta = "";
                    isFirstDelta = false;
                  }
                }
                return;
              }
              switch (chunk.type) {
                case "response-metadata": {
                  response = {
                    id: (_a182 = chunk.id) != null ? _a182 : response.id,
                    timestamp: (_b2 = chunk.timestamp) != null ? _b2 : response.timestamp,
                    modelId: (_c = chunk.modelId) != null ? _c : response.modelId
                  };
                  break;
                }
                case "finish": {
                  if (textDelta !== "") {
                    controller.enqueue({ type: "text-delta", textDelta });
                  }
                  finishReason = chunk.finishReason;
                  usage = calculateLanguageModelUsage(chunk.usage);
                  providerMetadata = chunk.providerMetadata;
                  controller.enqueue({ ...chunk, usage, response });
                  self2.usagePromise.resolve(usage);
                  self2.providerMetadataPromise.resolve(providerMetadata);
                  self2.responsePromise.resolve({
                    ...response,
                    headers: rawResponse == null ? void 0 : rawResponse.headers
                  });
                  const validationResult = outputStrategy.validateFinalResult(
                    latestObjectJson,
                    {
                      text: accumulatedText,
                      response,
                      usage
                    }
                  );
                  if (validationResult.success) {
                    object22 = validationResult.value;
                    self2.objectPromise.resolve(object22);
                  } else {
                    error87 = new NoObjectGeneratedError2({
                      message: "No object generated: response did not match schema.",
                      cause: validationResult.error,
                      text: accumulatedText,
                      response,
                      usage,
                      finishReason
                    });
                    self2.objectPromise.reject(error87);
                  }
                  break;
                }
                default: {
                  controller.enqueue(chunk);
                  break;
                }
              }
            },
            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
            async flush(controller) {
              try {
                const finalUsage = usage != null ? usage : {
                  promptTokens: NaN,
                  completionTokens: NaN,
                  totalTokens: NaN
                };
                doStreamSpan.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": finishReason,
                      "ai.response.object": {
                        output: /* @__PURE__ */ __name(() => JSON.stringify(object22), "output")
                      },
                      "ai.response.id": response.id,
                      "ai.response.model": response.modelId,
                      "ai.response.timestamp": response.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(providerMetadata),
                      "ai.usage.promptTokens": finalUsage.promptTokens,
                      "ai.usage.completionTokens": finalUsage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [finishReason],
                      "gen_ai.response.id": response.id,
                      "gen_ai.response.model": response.modelId,
                      "gen_ai.usage.input_tokens": finalUsage.promptTokens,
                      "gen_ai.usage.output_tokens": finalUsage.completionTokens
                    }
                  })
                );
                doStreamSpan.end();
                rootSpan.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.usage.promptTokens": finalUsage.promptTokens,
                      "ai.usage.completionTokens": finalUsage.completionTokens,
                      "ai.response.object": {
                        output: /* @__PURE__ */ __name(() => JSON.stringify(object22), "output")
                      },
                      "ai.response.providerMetadata": JSON.stringify(providerMetadata)
                    }
                  })
                );
                await (onFinish == null ? void 0 : onFinish({
                  usage: finalUsage,
                  object: object22,
                  error: error87,
                  response: {
                    ...response,
                    headers: rawResponse == null ? void 0 : rawResponse.headers
                  },
                  warnings,
                  providerMetadata,
                  experimental_providerMetadata: providerMetadata
                }));
              } catch (error210) {
                controller.enqueue({ type: "error", error: error210 });
              } finally {
                rootSpan.end();
              }
            }
          })
        );
        stitchableStream.addStream(transformedStream);
      }, "fn")
    }).catch((error87) => {
      stitchableStream.addStream(
        new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "error", error: error87 });
            controller.close();
          }
        })
      );
    }).finally(() => {
      stitchableStream.close();
    });
    this.outputStrategy = outputStrategy;
  }
  get object() {
    return this.objectPromise.value;
  }
  get usage() {
    return this.usagePromise.value;
  }
  get experimental_providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get warnings() {
    return this.warningsPromise.value;
  }
  get request() {
    return this.requestPromise.value;
  }
  get response() {
    return this.responsePromise.value;
  }
  get partialObjectStream() {
    return createAsyncIterableStream(
      this.baseStream.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            switch (chunk.type) {
              case "object":
                controller.enqueue(chunk.object);
                break;
              case "text-delta":
              case "finish":
              case "error":
                break;
              default: {
                const _exhaustiveCheck = chunk;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      )
    );
  }
  get elementStream() {
    return this.outputStrategy.createElementStream(this.baseStream);
  }
  get textStream() {
    return createAsyncIterableStream(
      this.baseStream.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            switch (chunk.type) {
              case "text-delta":
                controller.enqueue(chunk.textDelta);
                break;
              case "object":
              case "finish":
              case "error":
                break;
              default: {
                const _exhaustiveCheck = chunk;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      )
    );
  }
  get fullStream() {
    return createAsyncIterableStream(this.baseStream);
  }
  pipeTextStreamToResponse(response, init) {
    writeToServerResponse({
      response,
      status: init == null ? void 0 : init.status,
      statusText: init == null ? void 0 : init.statusText,
      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      }),
      stream: this.textStream.pipeThrough(new TextEncoderStream())
    });
  }
  toTextStreamResponse(init) {
    var _a172;
    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {
      status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      })
    });
  }
};
var name94 = "AI_NoOutputSpecifiedError";
var marker94 = `vercel.ai.error.${name94}`;
var symbol94 = Symbol.for(marker94);
var _a94;
var NoOutputSpecifiedError = class extends AISDKError2 {
  static {
    __name(this, "NoOutputSpecifiedError");
  }
  // used in isInstance
  constructor({ message = "No output specified." } = {}) {
    super({ name: name94, message });
    this[_a94] = true;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker94);
  }
};
_a94 = symbol94;
var name104 = "AI_ToolExecutionError";
var marker104 = `vercel.ai.error.${name104}`;
var symbol104 = Symbol.for(marker104);
var _a104;
var ToolExecutionError = class extends AISDKError2 {
  static {
    __name(this, "ToolExecutionError");
  }
  constructor({
    toolArgs,
    toolName,
    toolCallId,
    cause,
    message = `Error executing tool ${toolName}: ${getErrorMessage3(cause)}`
  }) {
    super({ name: name104, message, cause });
    this[_a104] = true;
    this.toolArgs = toolArgs;
    this.toolName = toolName;
    this.toolCallId = toolCallId;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker104);
  }
};
_a104 = symbol104;
function isNonEmptyObject(object22) {
  return object22 != null && Object.keys(object22).length > 0;
}
__name(isNonEmptyObject, "isNonEmptyObject");
function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools)) {
    return {
      tools: void 0,
      toolChoice: void 0
    };
  }
  const filteredTools = activeTools != null ? Object.entries(tools).filter(
    ([name172]) => activeTools.includes(name172)
  ) : Object.entries(tools);
  return {
    tools: filteredTools.map(([name172, tool22]) => {
      const toolType = tool22.type;
      switch (toolType) {
        case void 0:
        case "function":
          return {
            type: "function",
            name: name172,
            description: tool22.description,
            parameters: asSchema2(tool22.parameters).jsonSchema
          };
        case "provider-defined":
          return {
            type: "provider-defined",
            name: name172,
            id: tool22.id,
            args: tool22.args
          };
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    }),
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}
__name(prepareToolsAndToolChoice, "prepareToolsAndToolChoice");
var lastWhitespaceRegexp = /^([\s\S]*?)(\s+)(\S*)$/;
function splitOnLastWhitespace(text22) {
  const match2 = text22.match(lastWhitespaceRegexp);
  return match2 ? { prefix: match2[1], whitespace: match2[2], suffix: match2[3] } : void 0;
}
__name(splitOnLastWhitespace, "splitOnLastWhitespace");
function removeTextAfterLastWhitespace(text22) {
  const match2 = splitOnLastWhitespace(text22);
  return match2 ? match2.prefix + match2.whitespace : text22;
}
__name(removeTextAfterLastWhitespace, "removeTextAfterLastWhitespace");
var name114 = "AI_InvalidToolArgumentsError";
var marker114 = `vercel.ai.error.${name114}`;
var symbol114 = Symbol.for(marker114);
var _a114;
var InvalidToolArgumentsError = class extends AISDKError2 {
  static {
    __name(this, "InvalidToolArgumentsError");
  }
  constructor({
    toolArgs,
    toolName,
    cause,
    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage3(
      cause
    )}`
  }) {
    super({ name: name114, message, cause });
    this[_a114] = true;
    this.toolArgs = toolArgs;
    this.toolName = toolName;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker114);
  }
};
_a114 = symbol114;
var name124 = "AI_NoSuchToolError";
var marker124 = `vercel.ai.error.${name124}`;
var symbol124 = Symbol.for(marker124);
var _a124;
var NoSuchToolError = class extends AISDKError2 {
  static {
    __name(this, "NoSuchToolError");
  }
  constructor({
    toolName,
    availableTools = void 0,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
  }) {
    super({ name: name124, message });
    this[_a124] = true;
    this.toolName = toolName;
    this.availableTools = availableTools;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker124);
  }
};
_a124 = symbol124;
var name134 = "AI_ToolCallRepairError";
var marker134 = `vercel.ai.error.${name134}`;
var symbol134 = Symbol.for(marker134);
var _a134;
var ToolCallRepairError = class extends AISDKError2 {
  static {
    __name(this, "ToolCallRepairError");
  }
  constructor({
    cause,
    originalError,
    message = `Error repairing tool call: ${getErrorMessage3(cause)}`
  }) {
    super({ name: name134, message, cause });
    this[_a134] = true;
    this.originalError = originalError;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker134);
  }
};
_a134 = symbol134;
async function parseToolCall({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages
}) {
  if (tools == null) {
    throw new NoSuchToolError({ toolName: toolCall.toolName });
  }
  try {
    return await doParseToolCall({ toolCall, tools });
  } catch (error87) {
    if (repairToolCall == null || !(NoSuchToolError.isInstance(error87) || InvalidToolArgumentsError.isInstance(error87))) {
      throw error87;
    }
    let repairedToolCall = null;
    try {
      repairedToolCall = await repairToolCall({
        toolCall,
        tools,
        parameterSchema: /* @__PURE__ */ __name(({ toolName }) => asSchema2(tools[toolName].parameters).jsonSchema, "parameterSchema"),
        system,
        messages,
        error: error87
      });
    } catch (repairError) {
      throw new ToolCallRepairError({
        cause: repairError,
        originalError: error87
      });
    }
    if (repairedToolCall == null) {
      throw error87;
    }
    return await doParseToolCall({ toolCall: repairedToolCall, tools });
  }
}
__name(parseToolCall, "parseToolCall");
async function doParseToolCall({
  toolCall,
  tools
}) {
  const toolName = toolCall.toolName;
  const tool22 = tools[toolName];
  if (tool22 == null) {
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  const schema = asSchema2(tool22.parameters);
  const parseResult = toolCall.args.trim() === "" ? safeValidateTypes2({ value: {}, schema }) : safeParseJSON2({ text: toolCall.args, schema });
  if (parseResult.success === false) {
    throw new InvalidToolArgumentsError({
      toolName,
      toolArgs: toolCall.args,
      cause: parseResult.error
    });
  }
  return {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    args: parseResult.value
  };
}
__name(doParseToolCall, "doParseToolCall");
function asReasoningText(reasoning) {
  const reasoningText = reasoning.filter((part) => part.type === "text").map((part) => part.text).join("");
  return reasoningText.length > 0 ? reasoningText : void 0;
}
__name(asReasoningText, "asReasoningText");
function toResponseMessages({
  text: text22 = "",
  files,
  reasoning,
  tools,
  toolCalls,
  toolResults,
  messageId,
  generateMessageId
}) {
  const responseMessages = [];
  const content = [];
  if (reasoning.length > 0) {
    content.push(
      ...reasoning.map(
        (part) => part.type === "text" ? { ...part, type: "reasoning" } : { ...part, type: "redacted-reasoning" }
      )
    );
  }
  if (files.length > 0) {
    content.push(
      ...files.map((file3) => ({
        type: "file",
        data: file3.base64,
        mimeType: file3.mimeType
      }))
    );
  }
  if (text22.length > 0) {
    content.push({ type: "text", text: text22 });
  }
  if (toolCalls.length > 0) {
    content.push(...toolCalls);
  }
  if (content.length > 0) {
    responseMessages.push({
      role: "assistant",
      content,
      id: messageId
    });
  }
  if (toolResults.length > 0) {
    responseMessages.push({
      role: "tool",
      id: generateMessageId(),
      content: toolResults.map((toolResult) => {
        const tool22 = tools[toolResult.toolName];
        return (tool22 == null ? void 0 : tool22.experimental_toToolResultContent) != null ? {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: tool22.experimental_toToolResultContent(toolResult.result),
          experimental_content: tool22.experimental_toToolResultContent(
            toolResult.result
          )
        } : {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: toolResult.result
        };
      })
    });
  }
  return responseMessages;
}
__name(toResponseMessages, "toResponseMessages");
var originalGenerateId32 = createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
var originalGenerateMessageId = createIdGenerator2({
  prefix: "msg",
  size: 24
});
async function generateText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_activeTools: activeTools,
  experimental_prepareStep: prepareStep,
  experimental_repairToolCall: repairToolCall,
  _internal: {
    generateId: generateId32 = originalGenerateId32,
    currentDate = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Date(), "currentDate")
  } = {},
  onStepFinish,
  ...settings
}) {
  var _a172;
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  if (maxSteps < 1) {
    throw new InvalidArgumentError3({
      parameter: "maxSteps",
      value: maxSteps,
      message: "maxSteps must be at least 1"
    });
  }
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { ...settings, maxRetries }
  });
  const initialPrompt = standardizePrompt({
    prompt: {
      system: (_a172 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a172 : system,
      prompt,
      messages
    },
    tools
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.generateText",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.generateText",
          telemetry
        }),
        ...baseTelemetryAttributes,
        // model:
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // specific settings that only make sense on the outer level:
        "ai.prompt": {
          input: /* @__PURE__ */ __name(() => JSON.stringify({ system, prompt, messages }), "input")
        },
        "ai.settings.maxSteps": maxSteps
      }
    }),
    tracer,
    fn: /* @__PURE__ */ __name(async (span) => {
      var _a182, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const callSettings = prepareCallSettings(settings);
      let currentModelResponse;
      let currentToolCalls = [];
      let currentToolResults = [];
      let currentReasoningDetails = [];
      let stepCount = 0;
      const responseMessages = [];
      let text22 = "";
      const sources = [];
      const steps = [];
      let usage = {
        completionTokens: 0,
        promptTokens: 0,
        totalTokens: 0
      };
      let stepType = "initial";
      do {
        const promptFormat = stepCount === 0 ? initialPrompt.type : "messages";
        const stepInputMessages = [
          ...initialPrompt.messages,
          ...responseMessages
        ];
        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
          model,
          steps,
          maxSteps,
          stepNumber: stepCount
        }));
        const stepToolChoice = (_a182 = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _a182 : toolChoice;
        const stepActiveTools = (_b = prepareStepResult == null ? void 0 : prepareStepResult.experimental_activeTools) != null ? _b : activeTools;
        const stepModel = (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model;
        const promptMessages = await convertToLanguageModelPrompt({
          prompt: {
            type: promptFormat,
            system: initialPrompt.system,
            messages: stepInputMessages
          },
          modelSupportsImageUrls: stepModel.supportsImageUrls,
          modelSupportsUrl: (_d = stepModel.supportsUrl) == null ? void 0 : _d.bind(stepModel)
          // support 'this' context
        });
        const mode = {
          type: "regular",
          ...prepareToolsAndToolChoice({
            tools,
            toolChoice: stepToolChoice,
            activeTools: stepActiveTools
          })
        };
        currentModelResponse = await retry(
          () => recordSpan({
            name: "ai.generateText.doGenerate",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.generateText.doGenerate",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // model:
                "ai.model.provider": stepModel.provider,
                "ai.model.id": stepModel.modelId,
                // prompt:
                "ai.prompt.format": { input: /* @__PURE__ */ __name(() => promptFormat, "input") },
                "ai.prompt.messages": {
                  input: /* @__PURE__ */ __name(() => stringifyForTelemetry(promptMessages), "input")
                },
                "ai.prompt.tools": {
                  // convert the language model level tools:
                  input: /* @__PURE__ */ __name(() => {
                    var _a192;
                    return (_a192 = mode.tools) == null ? void 0 : _a192.map((tool22) => JSON.stringify(tool22));
                  }, "input")
                },
                "ai.prompt.toolChoice": {
                  input: /* @__PURE__ */ __name(() => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0, "input")
                },
                // standardized gen-ai llm span attributes:
                "gen_ai.system": stepModel.provider,
                "gen_ai.request.model": stepModel.modelId,
                "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                "gen_ai.request.max_tokens": settings.maxTokens,
                "gen_ai.request.presence_penalty": settings.presencePenalty,
                "gen_ai.request.stop_sequences": settings.stopSequences,
                "gen_ai.request.temperature": settings.temperature,
                "gen_ai.request.top_k": settings.topK,
                "gen_ai.request.top_p": settings.topP
              }
            }),
            tracer,
            fn: /* @__PURE__ */ __name(async (span2) => {
              var _a192, _b2, _c2, _d2, _e2, _f2;
              const result = await stepModel.doGenerate({
                mode,
                ...callSettings,
                inputFormat: promptFormat,
                responseFormat: output == null ? void 0 : output.responseFormat({ model }),
                prompt: promptMessages,
                providerMetadata: providerOptions,
                abortSignal,
                headers
              });
              const responseData = {
                id: (_b2 = (_a192 = result.response) == null ? void 0 : _a192.id) != null ? _b2 : generateId32(),
                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId
              };
              span2.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.response.finishReason": result.finishReason,
                    "ai.response.text": {
                      output: /* @__PURE__ */ __name(() => result.text, "output")
                    },
                    "ai.response.toolCalls": {
                      output: /* @__PURE__ */ __name(() => JSON.stringify(result.toolCalls), "output")
                    },
                    "ai.response.id": responseData.id,
                    "ai.response.model": responseData.modelId,
                    "ai.response.timestamp": responseData.timestamp.toISOString(),
                    "ai.response.providerMetadata": JSON.stringify(
                      result.providerMetadata
                    ),
                    "ai.usage.promptTokens": result.usage.promptTokens,
                    "ai.usage.completionTokens": result.usage.completionTokens,
                    // standardized gen-ai llm span attributes:
                    "gen_ai.response.finish_reasons": [result.finishReason],
                    "gen_ai.response.id": responseData.id,
                    "gen_ai.response.model": responseData.modelId,
                    "gen_ai.usage.input_tokens": result.usage.promptTokens,
                    "gen_ai.usage.output_tokens": result.usage.completionTokens
                  }
                })
              );
              return { ...result, response: responseData };
            }, "fn")
          })
        );
        currentToolCalls = await Promise.all(
          ((_e = currentModelResponse.toolCalls) != null ? _e : []).map(
            (toolCall) => parseToolCall({
              toolCall,
              tools,
              repairToolCall,
              system,
              messages: stepInputMessages
            })
          )
        );
        currentToolResults = tools == null ? [] : await executeTools({
          toolCalls: currentToolCalls,
          tools,
          tracer,
          telemetry,
          messages: stepInputMessages,
          abortSignal
        });
        const currentUsage = calculateLanguageModelUsage(
          currentModelResponse.usage
        );
        usage = addLanguageModelUsage(usage, currentUsage);
        let nextStepType = "done";
        if (++stepCount < maxSteps) {
          if (continueSteps && currentModelResponse.finishReason === "length" && // only use continue when there are no tool calls:
          currentToolCalls.length === 0) {
            nextStepType = "continue";
          } else if (
            // there are tool calls:
            currentToolCalls.length > 0 && // all current tool calls have results:
            currentToolResults.length === currentToolCalls.length
          ) {
            nextStepType = "tool-result";
          }
        }
        const originalText = (_f = currentModelResponse.text) != null ? _f : "";
        const stepTextLeadingWhitespaceTrimmed = stepType === "continue" && // only for continue steps
        text22.trimEnd() !== text22 ? originalText.trimStart() : originalText;
        const stepText = nextStepType === "continue" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;
        text22 = nextStepType === "continue" || stepType === "continue" ? text22 + stepText : stepText;
        currentReasoningDetails = asReasoningDetails(
          currentModelResponse.reasoning
        );
        sources.push(...(_g = currentModelResponse.sources) != null ? _g : []);
        if (stepType === "continue") {
          const lastMessage = responseMessages[responseMessages.length - 1];
          if (typeof lastMessage.content === "string") {
            lastMessage.content += stepText;
          } else {
            lastMessage.content.push({
              text: stepText,
              type: "text"
            });
          }
        } else {
          responseMessages.push(
            ...toResponseMessages({
              text: text22,
              files: asFiles(currentModelResponse.files),
              reasoning: asReasoningDetails(currentModelResponse.reasoning),
              tools: tools != null ? tools : {},
              toolCalls: currentToolCalls,
              toolResults: currentToolResults,
              messageId: generateMessageId(),
              generateMessageId
            })
          );
        }
        const currentStepResult = {
          stepType,
          text: stepText,
          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)
          reasoning: asReasoningText(currentReasoningDetails),
          reasoningDetails: currentReasoningDetails,
          files: asFiles(currentModelResponse.files),
          sources: (_h = currentModelResponse.sources) != null ? _h : [],
          toolCalls: currentToolCalls,
          toolResults: currentToolResults,
          finishReason: currentModelResponse.finishReason,
          usage: currentUsage,
          warnings: currentModelResponse.warnings,
          logprobs: currentModelResponse.logprobs,
          request: (_i = currentModelResponse.request) != null ? _i : {},
          response: {
            ...currentModelResponse.response,
            headers: (_j = currentModelResponse.rawResponse) == null ? void 0 : _j.headers,
            body: (_k = currentModelResponse.rawResponse) == null ? void 0 : _k.body,
            // deep clone msgs to avoid mutating past messages in multi-step:
            messages: structuredClone(responseMessages)
          },
          providerMetadata: currentModelResponse.providerMetadata,
          experimental_providerMetadata: currentModelResponse.providerMetadata,
          isContinued: nextStepType === "continue"
        };
        steps.push(currentStepResult);
        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
        stepType = nextStepType;
      } while (stepType !== "done");
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": currentModelResponse.finishReason,
            "ai.response.text": {
              output: /* @__PURE__ */ __name(() => currentModelResponse.text, "output")
            },
            "ai.response.toolCalls": {
              output: /* @__PURE__ */ __name(() => JSON.stringify(currentModelResponse.toolCalls), "output")
            },
            "ai.usage.promptTokens": currentModelResponse.usage.promptTokens,
            "ai.usage.completionTokens": currentModelResponse.usage.completionTokens,
            "ai.response.providerMetadata": JSON.stringify(
              currentModelResponse.providerMetadata
            )
          }
        })
      );
      return new DefaultGenerateTextResult({
        text: text22,
        files: asFiles(currentModelResponse.files),
        reasoning: asReasoningText(currentReasoningDetails),
        reasoningDetails: currentReasoningDetails,
        sources,
        outputResolver: /* @__PURE__ */ __name(() => {
          if (output == null) {
            throw new NoOutputSpecifiedError();
          }
          return output.parseOutput(
            { text: text22 },
            {
              response: currentModelResponse.response,
              usage,
              finishReason: currentModelResponse.finishReason
            }
          );
        }, "outputResolver"),
        toolCalls: currentToolCalls,
        toolResults: currentToolResults,
        finishReason: currentModelResponse.finishReason,
        usage,
        warnings: currentModelResponse.warnings,
        request: (_l = currentModelResponse.request) != null ? _l : {},
        response: {
          ...currentModelResponse.response,
          headers: (_m = currentModelResponse.rawResponse) == null ? void 0 : _m.headers,
          body: (_n = currentModelResponse.rawResponse) == null ? void 0 : _n.body,
          messages: responseMessages
        },
        logprobs: currentModelResponse.logprobs,
        steps,
        providerMetadata: currentModelResponse.providerMetadata
      });
    }, "fn")
  });
}
__name(generateText, "generateText");
async function executeTools({
  toolCalls,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal
}) {
  const toolResults = await Promise.all(
    toolCalls.map(async ({ toolCallId, toolName, args }) => {
      const tool22 = tools[toolName];
      if ((tool22 == null ? void 0 : tool22.execute) == null) {
        return void 0;
      }
      const result = await recordSpan({
        name: "ai.toolCall",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({
              operationId: "ai.toolCall",
              telemetry
            }),
            "ai.toolCall.name": toolName,
            "ai.toolCall.id": toolCallId,
            "ai.toolCall.args": {
              output: /* @__PURE__ */ __name(() => JSON.stringify(args), "output")
            }
          }
        }),
        tracer,
        fn: /* @__PURE__ */ __name(async (span) => {
          try {
            const result2 = await tool22.execute(args, {
              toolCallId,
              messages,
              abortSignal
            });
            try {
              span.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.toolCall.result": {
                      output: /* @__PURE__ */ __name(() => JSON.stringify(result2), "output")
                    }
                  }
                })
              );
            } catch (ignored) {
            }
            return result2;
          } catch (error87) {
            recordErrorOnSpan(span, error87);
            throw new ToolExecutionError({
              toolCallId,
              toolName,
              toolArgs: args,
              cause: error87
            });
          }
        }, "fn")
      });
      return {
        type: "tool-result",
        toolCallId,
        toolName,
        args,
        result
      };
    })
  );
  return toolResults.filter(
    (result) => result != null
  );
}
__name(executeTools, "executeTools");
var DefaultGenerateTextResult = class {
  static {
    __name(this, "DefaultGenerateTextResult");
  }
  constructor(options) {
    this.text = options.text;
    this.files = options.files;
    this.reasoning = options.reasoning;
    this.reasoningDetails = options.reasoningDetails;
    this.toolCalls = options.toolCalls;
    this.toolResults = options.toolResults;
    this.finishReason = options.finishReason;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.request = options.request;
    this.response = options.response;
    this.steps = options.steps;
    this.experimental_providerMetadata = options.providerMetadata;
    this.providerMetadata = options.providerMetadata;
    this.logprobs = options.logprobs;
    this.outputResolver = options.outputResolver;
    this.sources = options.sources;
  }
  get experimental_output() {
    return this.outputResolver();
  }
};
function asReasoningDetails(reasoning) {
  if (reasoning == null) {
    return [];
  }
  if (typeof reasoning === "string") {
    return [{ type: "text", text: reasoning }];
  }
  return reasoning;
}
__name(asReasoningDetails, "asReasoningDetails");
function asFiles(files) {
  var _a172;
  return (_a172 = files == null ? void 0 : files.map((file3) => new DefaultGeneratedFile(file3))) != null ? _a172 : [];
}
__name(asFiles, "asFiles");
var output_exports2 = {};
__export3(output_exports2, {
  object: /* @__PURE__ */ __name(() => object3, "object"),
  text: /* @__PURE__ */ __name(() => text2, "text")
});
var name143 = "AI_InvalidStreamPartError";
var marker144 = `vercel.ai.error.${name143}`;
var symbol144 = Symbol.for(marker144);
var _a144;
var InvalidStreamPartError = class extends AISDKError2 {
  static {
    __name(this, "InvalidStreamPartError");
  }
  constructor({
    chunk,
    message
  }) {
    super({ name: name143, message });
    this[_a144] = true;
    this.chunk = chunk;
  }
  static isInstance(error87) {
    return AISDKError2.hasMarker(error87, marker144);
  }
};
_a144 = symbol144;
var name152 = "AI_MCPClientError";
var marker153 = `vercel.ai.error.${name152}`;
var symbol153 = Symbol.for(marker153);
var _a153;
_a153 = symbol153;
var text2 = /* @__PURE__ */ __name(() => ({
  type: "text",
  responseFormat: /* @__PURE__ */ __name(() => ({ type: "text" }), "responseFormat"),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text22 }) {
    return { partial: text22 };
  },
  parseOutput({ text: text22 }) {
    return text22;
  }
}), "text");
var object3 = /* @__PURE__ */ __name(({
  schema: inputSchema
}) => {
  const schema = asSchema2(inputSchema);
  return {
    type: "object",
    responseFormat: /* @__PURE__ */ __name(({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }), "responseFormat"),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text22 }) {
      const result = parsePartialJson2(text22);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text22 }, context3) {
      const parseResult = safeParseJSON2({ text: text22 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text22,
          response: context3.response,
          usage: context3.usage,
          finishReason: context3.finishReason
        });
      }
      const validationResult = safeValidateTypes2({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text22,
          response: context3.response,
          usage: context3.usage,
          finishReason: context3.finishReason
        });
      }
      return validationResult.value;
    }
  };
}, "object");
function asArray(value) {
  return value === void 0 ? [] : Array.isArray(value) ? value : [value];
}
__name(asArray, "asArray");
async function consumeStream({
  stream,
  onError
}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done)
        break;
    }
  } catch (error87) {
    onError == null ? void 0 : onError(error87);
  } finally {
    reader.releaseLock();
  }
}
__name(consumeStream, "consumeStream");
function mergeStreams(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error87) {
      controller.error(error87);
    }
  }
  __name(readStream1, "readStream1");
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error87) {
      controller.error(error87);
    }
  }
  __name(readStream2, "readStream2");
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error87) {
        controller.error(error87);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
__name(mergeStreams, "mergeStreams");
function runToolsTransformation({
  tools,
  generatorStream,
  toolCallStreaming,
  tracer,
  telemetry,
  system,
  messages,
  abortSignal,
  repairToolCall
}) {
  let toolResultsStreamController = null;
  const toolResultsStream = new ReadableStream({
    start(controller) {
      toolResultsStreamController = controller;
    }
  });
  const activeToolCalls = {};
  const outstandingToolResults = /* @__PURE__ */ new Set();
  let canClose = false;
  let finishChunk = void 0;
  function attemptClose() {
    if (canClose && outstandingToolResults.size === 0) {
      if (finishChunk != null) {
        toolResultsStreamController.enqueue(finishChunk);
      }
      toolResultsStreamController.close();
    }
  }
  __name(attemptClose, "attemptClose");
  const forwardStream = new TransformStream({
    async transform(chunk, controller) {
      const chunkType = chunk.type;
      switch (chunkType) {
        case "text-delta":
        case "reasoning":
        case "reasoning-signature":
        case "redacted-reasoning":
        case "source":
        case "response-metadata":
        case "error": {
          controller.enqueue(chunk);
          break;
        }
        case "file": {
          controller.enqueue(
            new DefaultGeneratedFileWithType({
              data: chunk.data,
              mimeType: chunk.mimeType
            })
          );
          break;
        }
        case "tool-call-delta": {
          if (toolCallStreaming) {
            if (!activeToolCalls[chunk.toolCallId]) {
              controller.enqueue({
                type: "tool-call-streaming-start",
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName
              });
              activeToolCalls[chunk.toolCallId] = true;
            }
            controller.enqueue({
              type: "tool-call-delta",
              toolCallId: chunk.toolCallId,
              toolName: chunk.toolName,
              argsTextDelta: chunk.argsTextDelta
            });
          }
          break;
        }
        case "tool-call": {
          try {
            const toolCall = await parseToolCall({
              toolCall: chunk,
              tools,
              repairToolCall,
              system,
              messages
            });
            controller.enqueue(toolCall);
            const tool22 = tools[toolCall.toolName];
            if (tool22.execute != null) {
              const toolExecutionId = generateId2();
              outstandingToolResults.add(toolExecutionId);
              recordSpan({
                name: "ai.toolCall",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.toolCall",
                      telemetry
                    }),
                    "ai.toolCall.name": toolCall.toolName,
                    "ai.toolCall.id": toolCall.toolCallId,
                    "ai.toolCall.args": {
                      output: /* @__PURE__ */ __name(() => JSON.stringify(toolCall.args), "output")
                    }
                  }
                }),
                tracer,
                fn: /* @__PURE__ */ __name(async (span) => tool22.execute(toolCall.args, {
                  toolCallId: toolCall.toolCallId,
                  messages,
                  abortSignal
                }).then(
                  (result) => {
                    toolResultsStreamController.enqueue({
                      ...toolCall,
                      type: "tool-result",
                      result
                    });
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                    try {
                      span.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.toolCall.result": {
                              output: /* @__PURE__ */ __name(() => JSON.stringify(result), "output")
                            }
                          }
                        })
                      );
                    } catch (ignored) {
                    }
                  },
                  (error87) => {
                    recordErrorOnSpan(span, error87);
                    toolResultsStreamController.enqueue({
                      type: "error",
                      error: new ToolExecutionError({
                        toolCallId: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        toolArgs: toolCall.args,
                        cause: error87
                      })
                    });
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                  }
                ), "fn")
              });
            }
          } catch (error87) {
            toolResultsStreamController.enqueue({
              type: "error",
              error: error87
            });
          }
          break;
        }
        case "finish": {
          finishChunk = {
            type: "finish",
            finishReason: chunk.finishReason,
            logprobs: chunk.logprobs,
            usage: calculateLanguageModelUsage(chunk.usage),
            experimental_providerMetadata: chunk.providerMetadata
          };
          break;
        }
        default: {
          const _exhaustiveCheck = chunkType;
          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
        }
      }
    },
    flush() {
      canClose = true;
      attemptClose();
    }
  });
  return new ReadableStream({
    async start(controller) {
      return Promise.all([
        generatorStream.pipeThrough(forwardStream).pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
            }
          })
        ),
        toolResultsStream.pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
              controller.close();
            }
          })
        )
      ]);
    }
  });
}
__name(runToolsTransformation, "runToolsTransformation");
var originalGenerateId42 = createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
var originalGenerateMessageId2 = createIdGenerator2({
  prefix: "msg",
  size: 24
});
function streamText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId2,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_toolCallStreaming = false,
  toolCallStreaming = experimental_toolCallStreaming,
  experimental_activeTools: activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform3,
  onChunk,
  onError,
  onFinish,
  onStepFinish,
  _internal: {
    now: now2 = now,
    generateId: generateId32 = originalGenerateId42,
    currentDate = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Date(), "currentDate")
  } = {},
  ...settings
}) {
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  return new DefaultStreamTextResult({
    model,
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    toolCallStreaming,
    transforms: asArray(transform3),
    activeTools,
    repairToolCall,
    maxSteps,
    output,
    continueSteps,
    providerOptions,
    onChunk,
    onError,
    onFinish,
    onStepFinish,
    now: now2,
    currentDate,
    generateId: generateId32,
    generateMessageId
  });
}
__name(streamText, "streamText");
function createOutputTransformStream(output) {
  if (!output) {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
      }
    });
  }
  let text22 = "";
  let textChunk = "";
  let lastPublishedJson = "";
  function publishTextChunk({
    controller,
    partialOutput = void 0
  }) {
    controller.enqueue({
      part: { type: "text-delta", textDelta: textChunk },
      partialOutput
    });
    textChunk = "";
  }
  __name(publishTextChunk, "publishTextChunk");
  return new TransformStream({
    transform(chunk, controller) {
      if (chunk.type === "step-finish") {
        publishTextChunk({ controller });
      }
      if (chunk.type !== "text-delta") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      text22 += chunk.textDelta;
      textChunk += chunk.textDelta;
      const result = output.parsePartial({ text: text22 });
      if (result != null) {
        const currentJson = JSON.stringify(result.partial);
        if (currentJson !== lastPublishedJson) {
          publishTextChunk({ controller, partialOutput: result.partial });
          lastPublishedJson = currentJson;
        }
      }
    },
    flush(controller) {
      if (textChunk.length > 0) {
        publishTextChunk({ controller });
      }
    }
  });
}
__name(createOutputTransformStream, "createOutputTransformStream");
var DefaultStreamTextResult = class {
  static {
    __name(this, "DefaultStreamTextResult");
  }
  constructor({
    model,
    telemetry,
    headers,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    toolCallStreaming,
    transforms,
    activeTools,
    repairToolCall,
    maxSteps,
    output,
    continueSteps,
    providerOptions,
    now: now2,
    currentDate,
    generateId: generateId32,
    generateMessageId,
    onChunk,
    onError,
    onFinish,
    onStepFinish
  }) {
    this.warningsPromise = new DelayedPromise();
    this.usagePromise = new DelayedPromise();
    this.finishReasonPromise = new DelayedPromise();
    this.providerMetadataPromise = new DelayedPromise();
    this.textPromise = new DelayedPromise();
    this.reasoningPromise = new DelayedPromise();
    this.reasoningDetailsPromise = new DelayedPromise();
    this.sourcesPromise = new DelayedPromise();
    this.filesPromise = new DelayedPromise();
    this.toolCallsPromise = new DelayedPromise();
    this.toolResultsPromise = new DelayedPromise();
    this.requestPromise = new DelayedPromise();
    this.responsePromise = new DelayedPromise();
    this.stepsPromise = new DelayedPromise();
    var _a172;
    if (maxSteps < 1) {
      throw new InvalidArgumentError3({
        parameter: "maxSteps",
        value: maxSteps,
        message: "maxSteps must be at least 1"
      });
    }
    this.output = output;
    let recordedStepText = "";
    let recordedContinuationText = "";
    let recordedFullText = "";
    let stepReasoning = [];
    let stepFiles = [];
    let activeReasoningText = void 0;
    let recordedStepSources = [];
    const recordedSources = [];
    const recordedResponse = {
      id: generateId32(),
      timestamp: currentDate(),
      modelId: model.modelId,
      messages: []
    };
    let recordedToolCalls = [];
    let recordedToolResults = [];
    let recordedFinishReason = void 0;
    let recordedUsage = void 0;
    let stepType = "initial";
    const recordedSteps = [];
    let rootSpan;
    const eventProcessor = new TransformStream({
      async transform(chunk, controller) {
        controller.enqueue(chunk);
        const { part } = chunk;
        if (part.type === "text-delta" || part.type === "reasoning" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-call-streaming-start" || part.type === "tool-call-delta") {
          await (onChunk == null ? void 0 : onChunk({ chunk: part }));
        }
        if (part.type === "error") {
          await (onError == null ? void 0 : onError({ error: part.error }));
        }
        if (part.type === "text-delta") {
          recordedStepText += part.textDelta;
          recordedContinuationText += part.textDelta;
          recordedFullText += part.textDelta;
        }
        if (part.type === "reasoning") {
          if (activeReasoningText == null) {
            activeReasoningText = { type: "text", text: part.textDelta };
            stepReasoning.push(activeReasoningText);
          } else {
            activeReasoningText.text += part.textDelta;
          }
        }
        if (part.type === "reasoning-signature") {
          if (activeReasoningText == null) {
            throw new AISDKError2({
              name: "InvalidStreamPart",
              message: "reasoning-signature without reasoning"
            });
          }
          activeReasoningText.signature = part.signature;
          activeReasoningText = void 0;
        }
        if (part.type === "redacted-reasoning") {
          stepReasoning.push({ type: "redacted", data: part.data });
        }
        if (part.type === "file") {
          stepFiles.push(part);
        }
        if (part.type === "source") {
          recordedSources.push(part.source);
          recordedStepSources.push(part.source);
        }
        if (part.type === "tool-call") {
          recordedToolCalls.push(part);
        }
        if (part.type === "tool-result") {
          recordedToolResults.push(part);
        }
        if (part.type === "step-finish") {
          const stepMessages = toResponseMessages({
            text: recordedContinuationText,
            files: stepFiles,
            reasoning: stepReasoning,
            tools: tools != null ? tools : {},
            toolCalls: recordedToolCalls,
            toolResults: recordedToolResults,
            messageId: part.messageId,
            generateMessageId
          });
          const currentStep = recordedSteps.length;
          let nextStepType = "done";
          if (currentStep + 1 < maxSteps) {
            if (continueSteps && part.finishReason === "length" && // only use continue when there are no tool calls:
            recordedToolCalls.length === 0) {
              nextStepType = "continue";
            } else if (
              // there are tool calls:
              recordedToolCalls.length > 0 && // all current tool calls have results:
              recordedToolResults.length === recordedToolCalls.length
            ) {
              nextStepType = "tool-result";
            }
          }
          const currentStepResult = {
            stepType,
            text: recordedStepText,
            reasoning: asReasoningText(stepReasoning),
            reasoningDetails: stepReasoning,
            files: stepFiles,
            sources: recordedStepSources,
            toolCalls: recordedToolCalls,
            toolResults: recordedToolResults,
            finishReason: part.finishReason,
            usage: part.usage,
            warnings: part.warnings,
            logprobs: part.logprobs,
            request: part.request,
            response: {
              ...part.response,
              messages: [...recordedResponse.messages, ...stepMessages]
            },
            providerMetadata: part.experimental_providerMetadata,
            experimental_providerMetadata: part.experimental_providerMetadata,
            isContinued: part.isContinued
          };
          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
          recordedSteps.push(currentStepResult);
          recordedToolCalls = [];
          recordedToolResults = [];
          recordedStepText = "";
          recordedStepSources = [];
          stepReasoning = [];
          stepFiles = [];
          activeReasoningText = void 0;
          if (nextStepType !== "done") {
            stepType = nextStepType;
          }
          if (nextStepType !== "continue") {
            recordedResponse.messages.push(...stepMessages);
            recordedContinuationText = "";
          }
        }
        if (part.type === "finish") {
          recordedResponse.id = part.response.id;
          recordedResponse.timestamp = part.response.timestamp;
          recordedResponse.modelId = part.response.modelId;
          recordedResponse.headers = part.response.headers;
          recordedUsage = part.usage;
          recordedFinishReason = part.finishReason;
        }
      },
      async flush(controller) {
        var _a182;
        try {
          if (recordedSteps.length === 0) {
            return;
          }
          const lastStep = recordedSteps[recordedSteps.length - 1];
          self2.warningsPromise.resolve(lastStep.warnings);
          self2.requestPromise.resolve(lastStep.request);
          self2.responsePromise.resolve(lastStep.response);
          self2.toolCallsPromise.resolve(lastStep.toolCalls);
          self2.toolResultsPromise.resolve(lastStep.toolResults);
          self2.providerMetadataPromise.resolve(
            lastStep.experimental_providerMetadata
          );
          self2.reasoningPromise.resolve(lastStep.reasoning);
          self2.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);
          const finishReason = recordedFinishReason != null ? recordedFinishReason : "unknown";
          const usage = recordedUsage != null ? recordedUsage : {
            completionTokens: NaN,
            promptTokens: NaN,
            totalTokens: NaN
          };
          self2.finishReasonPromise.resolve(finishReason);
          self2.usagePromise.resolve(usage);
          self2.textPromise.resolve(recordedFullText);
          self2.sourcesPromise.resolve(recordedSources);
          self2.filesPromise.resolve(lastStep.files);
          self2.stepsPromise.resolve(recordedSteps);
          await (onFinish == null ? void 0 : onFinish({
            finishReason,
            logprobs: void 0,
            usage,
            text: recordedFullText,
            reasoning: lastStep.reasoning,
            reasoningDetails: lastStep.reasoningDetails,
            files: lastStep.files,
            sources: lastStep.sources,
            toolCalls: lastStep.toolCalls,
            toolResults: lastStep.toolResults,
            request: (_a182 = lastStep.request) != null ? _a182 : {},
            response: lastStep.response,
            warnings: lastStep.warnings,
            providerMetadata: lastStep.providerMetadata,
            experimental_providerMetadata: lastStep.experimental_providerMetadata,
            steps: recordedSteps
          }));
          rootSpan.setAttributes(
            selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": finishReason,
                "ai.response.text": { output: /* @__PURE__ */ __name(() => recordedFullText, "output") },
                "ai.response.toolCalls": {
                  output: /* @__PURE__ */ __name(() => {
                    var _a192;
                    return ((_a192 = lastStep.toolCalls) == null ? void 0 : _a192.length) ? JSON.stringify(lastStep.toolCalls) : void 0;
                  }, "output")
                },
                "ai.usage.promptTokens": usage.promptTokens,
                "ai.usage.completionTokens": usage.completionTokens,
                "ai.response.providerMetadata": JSON.stringify(
                  lastStep.providerMetadata
                )
              }
            })
          );
        } catch (error87) {
          controller.error(error87);
        } finally {
          rootSpan.end();
        }
      }
    });
    const stitchableStream = createStitchableStream();
    this.addStream = stitchableStream.addStream;
    this.closeStream = stitchableStream.close;
    let stream = stitchableStream.stream;
    for (const transform3 of transforms) {
      stream = stream.pipeThrough(
        transform3({
          tools,
          stopStream() {
            stitchableStream.terminate();
          }
        })
      );
    }
    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg
    });
    const tracer = getTracer(telemetry);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...settings, maxRetries }
    });
    const initialPrompt = standardizePrompt({
      prompt: {
        system: (_a172 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a172 : system,
        prompt,
        messages
      },
      tools
    });
    const self2 = this;
    recordSpan({
      name: "ai.streamText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: /* @__PURE__ */ __name(() => JSON.stringify({ system, prompt, messages }), "input")
          },
          "ai.settings.maxSteps": maxSteps
        }
      }),
      tracer,
      endWhenDone: false,
      fn: /* @__PURE__ */ __name(async (rootSpanArg) => {
        rootSpan = rootSpanArg;
        async function streamStep({
          currentStep,
          responseMessages,
          usage,
          stepType: stepType2,
          previousStepText,
          hasLeadingWhitespace,
          messageId
        }) {
          var _a182;
          const promptFormat = responseMessages.length === 0 ? initialPrompt.type : "messages";
          const stepInputMessages = [
            ...initialPrompt.messages,
            ...responseMessages
          ];
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: {
              type: promptFormat,
              system: initialPrompt.system,
              messages: stepInputMessages
            },
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_a182 = model.supportsUrl) == null ? void 0 : _a182.bind(model)
            // support 'this' context
          });
          const mode = {
            type: "regular",
            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools })
          };
          const {
            result: { stream: stream2, warnings, rawResponse, request },
            doStreamSpan,
            startTimestampMs
          } = await retry(
            () => recordSpan({
              name: "ai.streamText.doStream",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.streamText.doStream",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: /* @__PURE__ */ __name(() => promptFormat, "input")
                  },
                  "ai.prompt.messages": {
                    input: /* @__PURE__ */ __name(() => stringifyForTelemetry(promptMessages), "input")
                  },
                  "ai.prompt.tools": {
                    // convert the language model level tools:
                    input: /* @__PURE__ */ __name(() => {
                      var _a192;
                      return (_a192 = mode.tools) == null ? void 0 : _a192.map((tool22) => JSON.stringify(tool22));
                    }, "input")
                  },
                  "ai.prompt.toolChoice": {
                    input: /* @__PURE__ */ __name(() => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0, "input")
                  },
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.stop_sequences": settings.stopSequences,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              endWhenDone: false,
              fn: /* @__PURE__ */ __name(async (doStreamSpan2) => ({
                startTimestampMs: now2(),
                // get before the call
                doStreamSpan: doStreamSpan2,
                result: await model.doStream({
                  mode,
                  ...prepareCallSettings(settings),
                  inputFormat: promptFormat,
                  responseFormat: output == null ? void 0 : output.responseFormat({ model }),
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                })
              }), "fn")
            })
          );
          const transformedStream = runToolsTransformation({
            tools,
            generatorStream: stream2,
            toolCallStreaming,
            tracer,
            telemetry,
            system,
            messages: stepInputMessages,
            repairToolCall,
            abortSignal
          });
          const stepRequest = request != null ? request : {};
          const stepToolCalls = [];
          const stepToolResults = [];
          const stepReasoning2 = [];
          const stepFiles2 = [];
          let activeReasoningText2 = void 0;
          let stepFinishReason = "unknown";
          let stepUsage = {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
          };
          let stepProviderMetadata;
          let stepFirstChunk = true;
          let stepText = "";
          let fullStepText = stepType2 === "continue" ? previousStepText : "";
          let stepLogProbs;
          let stepResponse = {
            id: generateId32(),
            timestamp: currentDate(),
            modelId: model.modelId
          };
          let chunkBuffer = "";
          let chunkTextPublished = false;
          let inWhitespacePrefix = true;
          let hasWhitespaceSuffix = false;
          async function publishTextChunk({
            controller,
            chunk
          }) {
            controller.enqueue(chunk);
            stepText += chunk.textDelta;
            fullStepText += chunk.textDelta;
            chunkTextPublished = true;
            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;
          }
          __name(publishTextChunk, "publishTextChunk");
          self2.addStream(
            transformedStream.pipeThrough(
              new TransformStream({
                async transform(chunk, controller) {
                  var _a192, _b, _c;
                  if (stepFirstChunk) {
                    const msToFirstChunk = now2() - startTimestampMs;
                    stepFirstChunk = false;
                    doStreamSpan.addEvent("ai.stream.firstChunk", {
                      "ai.response.msToFirstChunk": msToFirstChunk
                    });
                    doStreamSpan.setAttributes({
                      "ai.response.msToFirstChunk": msToFirstChunk
                    });
                    controller.enqueue({
                      type: "step-start",
                      messageId,
                      request: stepRequest,
                      warnings: warnings != null ? warnings : []
                    });
                  }
                  if (chunk.type === "text-delta" && chunk.textDelta.length === 0) {
                    return;
                  }
                  const chunkType = chunk.type;
                  switch (chunkType) {
                    case "text-delta": {
                      if (continueSteps) {
                        const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;
                        if (trimmedChunkText.length === 0) {
                          break;
                        }
                        inWhitespacePrefix = false;
                        chunkBuffer += trimmedChunkText;
                        const split = splitOnLastWhitespace(chunkBuffer);
                        if (split != null) {
                          chunkBuffer = split.suffix;
                          await publishTextChunk({
                            controller,
                            chunk: {
                              type: "text-delta",
                              textDelta: split.prefix + split.whitespace
                            }
                          });
                        }
                      } else {
                        await publishTextChunk({ controller, chunk });
                      }
                      break;
                    }
                    case "reasoning": {
                      controller.enqueue(chunk);
                      if (activeReasoningText2 == null) {
                        activeReasoningText2 = {
                          type: "text",
                          text: chunk.textDelta
                        };
                        stepReasoning2.push(activeReasoningText2);
                      } else {
                        activeReasoningText2.text += chunk.textDelta;
                      }
                      break;
                    }
                    case "reasoning-signature": {
                      controller.enqueue(chunk);
                      if (activeReasoningText2 == null) {
                        throw new InvalidStreamPartError({
                          chunk,
                          message: "reasoning-signature without reasoning"
                        });
                      }
                      activeReasoningText2.signature = chunk.signature;
                      activeReasoningText2 = void 0;
                      break;
                    }
                    case "redacted-reasoning": {
                      controller.enqueue(chunk);
                      stepReasoning2.push({
                        type: "redacted",
                        data: chunk.data
                      });
                      break;
                    }
                    case "tool-call": {
                      controller.enqueue(chunk);
                      stepToolCalls.push(chunk);
                      break;
                    }
                    case "tool-result": {
                      controller.enqueue(chunk);
                      stepToolResults.push(chunk);
                      break;
                    }
                    case "response-metadata": {
                      stepResponse = {
                        id: (_a192 = chunk.id) != null ? _a192 : stepResponse.id,
                        timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,
                        modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId
                      };
                      break;
                    }
                    case "finish": {
                      stepUsage = chunk.usage;
                      stepFinishReason = chunk.finishReason;
                      stepProviderMetadata = chunk.experimental_providerMetadata;
                      stepLogProbs = chunk.logprobs;
                      const msToFinish = now2() - startTimestampMs;
                      doStreamSpan.addEvent("ai.stream.finish");
                      doStreamSpan.setAttributes({
                        "ai.response.msToFinish": msToFinish,
                        "ai.response.avgCompletionTokensPerSecond": 1e3 * stepUsage.completionTokens / msToFinish
                      });
                      break;
                    }
                    case "file": {
                      stepFiles2.push(chunk);
                      controller.enqueue(chunk);
                      break;
                    }
                    case "source":
                    case "tool-call-streaming-start":
                    case "tool-call-delta": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "error": {
                      controller.enqueue(chunk);
                      stepFinishReason = "error";
                      break;
                    }
                    default: {
                      const exhaustiveCheck = chunkType;
                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                    }
                  }
                },
                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                async flush(controller) {
                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                  let nextStepType = "done";
                  if (currentStep + 1 < maxSteps) {
                    if (continueSteps && stepFinishReason === "length" && // only use continue when there are no tool calls:
                    stepToolCalls.length === 0) {
                      nextStepType = "continue";
                    } else if (
                      // there are tool calls:
                      stepToolCalls.length > 0 && // all current tool calls have results:
                      stepToolResults.length === stepToolCalls.length
                    ) {
                      nextStepType = "tool-result";
                    }
                  }
                  if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== "continue" || // when the next step is a regular step, publish the buffer
                  stepType2 === "continue" && !chunkTextPublished)) {
                    await publishTextChunk({
                      controller,
                      chunk: {
                        type: "text-delta",
                        textDelta: chunkBuffer
                      }
                    });
                    chunkBuffer = "";
                  }
                  try {
                    doStreamSpan.setAttributes(
                      selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                          "ai.response.finishReason": stepFinishReason,
                          "ai.response.text": { output: /* @__PURE__ */ __name(() => stepText, "output") },
                          "ai.response.toolCalls": {
                            output: /* @__PURE__ */ __name(() => stepToolCallsJson, "output")
                          },
                          "ai.response.id": stepResponse.id,
                          "ai.response.model": stepResponse.modelId,
                          "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                          "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                          "ai.usage.promptTokens": stepUsage.promptTokens,
                          "ai.usage.completionTokens": stepUsage.completionTokens,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [stepFinishReason],
                          "gen_ai.response.id": stepResponse.id,
                          "gen_ai.response.model": stepResponse.modelId,
                          "gen_ai.usage.input_tokens": stepUsage.promptTokens,
                          "gen_ai.usage.output_tokens": stepUsage.completionTokens
                        }
                      })
                    );
                  } catch (error87) {
                  } finally {
                    doStreamSpan.end();
                  }
                  controller.enqueue({
                    type: "step-finish",
                    finishReason: stepFinishReason,
                    usage: stepUsage,
                    providerMetadata: stepProviderMetadata,
                    experimental_providerMetadata: stepProviderMetadata,
                    logprobs: stepLogProbs,
                    request: stepRequest,
                    response: {
                      ...stepResponse,
                      headers: rawResponse == null ? void 0 : rawResponse.headers
                    },
                    warnings,
                    isContinued: nextStepType === "continue",
                    messageId
                  });
                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                  if (nextStepType === "done") {
                    controller.enqueue({
                      type: "finish",
                      finishReason: stepFinishReason,
                      usage: combinedUsage,
                      providerMetadata: stepProviderMetadata,
                      experimental_providerMetadata: stepProviderMetadata,
                      logprobs: stepLogProbs,
                      response: {
                        ...stepResponse,
                        headers: rawResponse == null ? void 0 : rawResponse.headers
                      }
                    });
                    self2.closeStream();
                  } else {
                    if (stepType2 === "continue") {
                      const lastMessage = responseMessages[responseMessages.length - 1];
                      if (typeof lastMessage.content === "string") {
                        lastMessage.content += stepText;
                      } else {
                        lastMessage.content.push({
                          text: stepText,
                          type: "text"
                        });
                      }
                    } else {
                      responseMessages.push(
                        ...toResponseMessages({
                          text: stepText,
                          files: stepFiles2,
                          reasoning: stepReasoning2,
                          tools: tools != null ? tools : {},
                          toolCalls: stepToolCalls,
                          toolResults: stepToolResults,
                          messageId,
                          generateMessageId
                        })
                      );
                    }
                    await streamStep({
                      currentStep: currentStep + 1,
                      responseMessages,
                      usage: combinedUsage,
                      stepType: nextStepType,
                      previousStepText: fullStepText,
                      hasLeadingWhitespace: hasWhitespaceSuffix,
                      messageId: (
                        // keep the same id when continuing a step:
                        nextStepType === "continue" ? messageId : generateMessageId()
                      )
                    });
                  }
                }
              })
            )
          );
        }
        __name(streamStep, "streamStep");
        await streamStep({
          currentStep: 0,
          responseMessages: [],
          usage: {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
          },
          previousStepText: "",
          stepType: "initial",
          hasLeadingWhitespace: false,
          messageId: generateMessageId()
        });
      }, "fn")
    }).catch((error87) => {
      self2.addStream(
        new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "error", error: error87 });
            controller.close();
          }
        })
      );
      self2.closeStream();
    });
  }
  get warnings() {
    return this.warningsPromise.value;
  }
  get usage() {
    return this.usagePromise.value;
  }
  get finishReason() {
    return this.finishReasonPromise.value;
  }
  get experimental_providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get text() {
    return this.textPromise.value;
  }
  get reasoning() {
    return this.reasoningPromise.value;
  }
  get reasoningDetails() {
    return this.reasoningDetailsPromise.value;
  }
  get sources() {
    return this.sourcesPromise.value;
  }
  get files() {
    return this.filesPromise.value;
  }
  get toolCalls() {
    return this.toolCallsPromise.value;
  }
  get toolResults() {
    return this.toolResultsPromise.value;
  }
  get request() {
    return this.requestPromise.value;
  }
  get response() {
    return this.responsePromise.value;
  }
  get steps() {
    return this.stepsPromise.value;
  }
  /**
  Split out a new stream from the original stream.
  The original stream is replaced to allow for further splitting,
  since we do not know how many times the stream will be split.
  
  Note: this leads to buffering the stream content on the server.
  However, the LLM results are expected to be small enough to not cause issues.
     */
  teeStream() {
    const [stream1, stream2] = this.baseStream.tee();
    this.baseStream = stream2;
    return stream1;
  }
  get textStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            if (part.type === "text-delta") {
              controller.enqueue(part.textDelta);
            }
          }
        })
      )
    );
  }
  get fullStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            controller.enqueue(part);
          }
        })
      )
    );
  }
  async consumeStream(options) {
    var _a172;
    try {
      await consumeStream({
        stream: this.fullStream,
        onError: options == null ? void 0 : options.onError
      });
    } catch (error87) {
      (_a172 = options == null ? void 0 : options.onError) == null ? void 0 : _a172.call(options, error87);
    }
  }
  get experimental_partialOutputStream() {
    if (this.output == null) {
      throw new NoOutputSpecifiedError();
    }
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ partialOutput }, controller) {
            if (partialOutput != null) {
              controller.enqueue(partialOutput);
            }
          }
        })
      )
    );
  }
  toDataStreamInternal({
    getErrorMessage: getErrorMessage52 = /* @__PURE__ */ __name(() => "An error occurred.", "getErrorMessage5"),
    // mask error messages for safety by default
    sendUsage = true,
    sendReasoning = false,
    sendSources = false,
    experimental_sendFinish = true
  }) {
    return this.fullStream.pipeThrough(
      new TransformStream({
        transform: /* @__PURE__ */ __name(async (chunk, controller) => {
          const chunkType = chunk.type;
          switch (chunkType) {
            case "text-delta": {
              controller.enqueue(formatDataStreamPart("text", chunk.textDelta));
              break;
            }
            case "reasoning": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("reasoning", chunk.textDelta)
                );
              }
              break;
            }
            case "redacted-reasoning": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("redacted_reasoning", {
                    data: chunk.data
                  })
                );
              }
              break;
            }
            case "reasoning-signature": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("reasoning_signature", {
                    signature: chunk.signature
                  })
                );
              }
              break;
            }
            case "file": {
              controller.enqueue(
                formatDataStreamPart("file", {
                  mimeType: chunk.mimeType,
                  data: chunk.base64
                })
              );
              break;
            }
            case "source": {
              if (sendSources) {
                controller.enqueue(
                  formatDataStreamPart("source", chunk.source)
                );
              }
              break;
            }
            case "tool-call-streaming-start": {
              controller.enqueue(
                formatDataStreamPart("tool_call_streaming_start", {
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName
                })
              );
              break;
            }
            case "tool-call-delta": {
              controller.enqueue(
                formatDataStreamPart("tool_call_delta", {
                  toolCallId: chunk.toolCallId,
                  argsTextDelta: chunk.argsTextDelta
                })
              );
              break;
            }
            case "tool-call": {
              controller.enqueue(
                formatDataStreamPart("tool_call", {
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  args: chunk.args
                })
              );
              break;
            }
            case "tool-result": {
              controller.enqueue(
                formatDataStreamPart("tool_result", {
                  toolCallId: chunk.toolCallId,
                  result: chunk.result
                })
              );
              break;
            }
            case "error": {
              controller.enqueue(
                formatDataStreamPart("error", getErrorMessage52(chunk.error))
              );
              break;
            }
            case "step-start": {
              controller.enqueue(
                formatDataStreamPart("start_step", {
                  messageId: chunk.messageId
                })
              );
              break;
            }
            case "step-finish": {
              controller.enqueue(
                formatDataStreamPart("finish_step", {
                  finishReason: chunk.finishReason,
                  usage: sendUsage ? {
                    promptTokens: chunk.usage.promptTokens,
                    completionTokens: chunk.usage.completionTokens
                  } : void 0,
                  isContinued: chunk.isContinued
                })
              );
              break;
            }
            case "finish": {
              if (experimental_sendFinish) {
                controller.enqueue(
                  formatDataStreamPart("finish_message", {
                    finishReason: chunk.finishReason,
                    usage: sendUsage ? {
                      promptTokens: chunk.usage.promptTokens,
                      completionTokens: chunk.usage.completionTokens
                    } : void 0
                  })
                );
              }
              break;
            }
            default: {
              const exhaustiveCheck = chunkType;
              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
            }
          }
        }, "transform")
      })
    );
  }
  pipeDataStreamToResponse(response, {
    status,
    statusText,
    headers,
    data,
    getErrorMessage: getErrorMessage52,
    sendUsage,
    sendReasoning,
    sendSources,
    experimental_sendFinish
  } = {}) {
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: prepareOutgoingHttpHeaders(headers, {
        contentType: "text/plain; charset=utf-8",
        dataStreamVersion: "v1"
      }),
      stream: this.toDataStream({
        data,
        getErrorMessage: getErrorMessage52,
        sendUsage,
        sendReasoning,
        sendSources,
        experimental_sendFinish
      })
    });
  }
  pipeTextStreamToResponse(response, init) {
    writeToServerResponse({
      response,
      status: init == null ? void 0 : init.status,
      statusText: init == null ? void 0 : init.statusText,
      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      }),
      stream: this.textStream.pipeThrough(new TextEncoderStream())
    });
  }
  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())
  toDataStream(options) {
    const stream = this.toDataStreamInternal({
      getErrorMessage: options == null ? void 0 : options.getErrorMessage,
      sendUsage: options == null ? void 0 : options.sendUsage,
      sendReasoning: options == null ? void 0 : options.sendReasoning,
      sendSources: options == null ? void 0 : options.sendSources,
      experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish
    }).pipeThrough(new TextEncoderStream());
    return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;
  }
  mergeIntoDataStream(writer, options) {
    writer.merge(
      this.toDataStreamInternal({
        getErrorMessage: writer.onError,
        sendUsage: options == null ? void 0 : options.sendUsage,
        sendReasoning: options == null ? void 0 : options.sendReasoning,
        sendSources: options == null ? void 0 : options.sendSources,
        experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish
      })
    );
  }
  toDataStreamResponse({
    headers,
    status,
    statusText,
    data,
    getErrorMessage: getErrorMessage52,
    sendUsage,
    sendReasoning,
    sendSources,
    experimental_sendFinish
  } = {}) {
    return new Response(
      this.toDataStream({
        data,
        getErrorMessage: getErrorMessage52,
        sendUsage,
        sendReasoning,
        sendSources,
        experimental_sendFinish
      }),
      {
        status,
        statusText,
        headers: prepareResponseHeaders(headers, {
          contentType: "text/plain; charset=utf-8",
          dataStreamVersion: "v1"
        })
      }
    );
  }
  toTextStreamResponse(init) {
    var _a172;
    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {
      status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      })
    });
  }
};
var name162 = "AI_NoSuchProviderError";
var marker162 = `vercel.ai.error.${name162}`;
var symbol162 = Symbol.for(marker162);
var _a162;
_a162 = symbol162;
var ClientOrServerImplementationSchema = external_exports2.object({
  name: external_exports2.string(),
  version: external_exports2.string()
}).passthrough();
var BaseParamsSchema = external_exports2.object({
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = external_exports2.object({
  method: external_exports2.string(),
  params: external_exports2.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = external_exports2.object({
  experimental: external_exports2.optional(external_exports2.object({}).passthrough()),
  logging: external_exports2.optional(external_exports2.object({}).passthrough()),
  prompts: external_exports2.optional(
    external_exports2.object({
      listChanged: external_exports2.optional(external_exports2.boolean())
    }).passthrough()
  ),
  resources: external_exports2.optional(
    external_exports2.object({
      subscribe: external_exports2.optional(external_exports2.boolean()),
      listChanged: external_exports2.optional(external_exports2.boolean())
    }).passthrough()
  ),
  tools: external_exports2.optional(
    external_exports2.object({
      listChanged: external_exports2.optional(external_exports2.boolean())
    }).passthrough()
  )
}).passthrough();
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: external_exports2.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: external_exports2.optional(external_exports2.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: external_exports2.optional(external_exports2.string())
});
var ToolSchema = external_exports2.object({
  name: external_exports2.string(),
  description: external_exports2.optional(external_exports2.string()),
  inputSchema: external_exports2.object({
    type: external_exports2.literal("object"),
    properties: external_exports2.optional(external_exports2.object({}).passthrough())
  }).passthrough()
}).passthrough();
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: external_exports2.array(ToolSchema)
});
var TextContentSchema = external_exports2.object({
  type: external_exports2.literal("text"),
  text: external_exports2.string()
}).passthrough();
var ImageContentSchema = external_exports2.object({
  type: external_exports2.literal("image"),
  data: external_exports2.string().base64(),
  mimeType: external_exports2.string()
}).passthrough();
var ResourceContentsSchema = external_exports2.object({
  /**
   * The URI of this resource.
   */
  uri: external_exports2.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: external_exports2.optional(external_exports2.string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: external_exports2.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: external_exports2.string().base64()
});
var EmbeddedResourceSchema = external_exports2.object({
  type: external_exports2.literal("resource"),
  resource: external_exports2.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).passthrough();
var CallToolResultSchema = ResultSchema.extend({
  content: external_exports2.array(
    external_exports2.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
  ),
  isError: external_exports2.boolean().default(false).optional()
}).or(
  ResultSchema.extend({
    toolResult: external_exports2.unknown()
  })
);
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION),
  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION),
  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION),
  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()]),
  error: external_exports2.object({
    code: external_exports2.number().int(),
    message: external_exports2.string(),
    data: external_exports2.optional(external_exports2.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION)
}).merge(
  external_exports2.object({
    method: external_exports2.string(),
    params: external_exports2.optional(BaseParamsSchema)
  })
).strict();
var JSONRPCMessageSchema = external_exports2.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var langchain_adapter_exports = {};
__export3(langchain_adapter_exports, {
  mergeIntoDataStream: /* @__PURE__ */ __name(() => mergeIntoDataStream, "mergeIntoDataStream"),
  toDataStream: /* @__PURE__ */ __name(() => toDataStream, "toDataStream"),
  toDataStreamResponse: /* @__PURE__ */ __name(() => toDataStreamResponse, "toDataStreamResponse")
});
function createCallbacksTransformer(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
__name(createCallbacksTransformer, "createCallbacksTransformer");
function toDataStreamInternal(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: /* @__PURE__ */ __name(async (value, controller) => {
        var _a172;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk(
              (_a172 = value.data) == null ? void 0 : _a172.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk(value, controller);
      }, "transform")
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: /* @__PURE__ */ __name(async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }, "transform")
    })
  );
}
__name(toDataStreamInternal, "toDataStreamInternal");
function toDataStream(stream, callbacks) {
  return toDataStreamInternal(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
__name(toDataStream, "toDataStream");
function toDataStreamResponse(stream, options) {
  var _a172;
  const dataStream = toDataStreamInternal(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
__name(toDataStreamResponse, "toDataStreamResponse");
function mergeIntoDataStream(stream, options) {
  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
__name(mergeIntoDataStream, "mergeIntoDataStream");
function forwardAIMessageChunk(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
__name(forwardAIMessageChunk, "forwardAIMessageChunk");
var llamaindex_adapter_exports = {};
__export3(llamaindex_adapter_exports, {
  mergeIntoDataStream: /* @__PURE__ */ __name(() => mergeIntoDataStream2, "mergeIntoDataStream"),
  toDataStream: /* @__PURE__ */ __name(() => toDataStream2, "toDataStream"),
  toDataStreamResponse: /* @__PURE__ */ __name(() => toDataStreamResponse2, "toDataStreamResponse")
});
function toDataStreamInternal2(stream, callbacks) {
  const trimStart = trimStartOfStream();
  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: /* @__PURE__ */ __name(async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }, "transform")
    })
  );
}
__name(toDataStreamInternal2, "toDataStreamInternal2");
function toDataStream2(stream, callbacks) {
  return toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
__name(toDataStream2, "toDataStream2");
function toDataStreamResponse2(stream, options = {}) {
  var _a172;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
__name(toDataStreamResponse2, "toDataStreamResponse2");
function mergeIntoDataStream2(stream, options) {
  options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
__name(mergeIntoDataStream2, "mergeIntoDataStream2");
function trimStartOfStream() {
  let isStreamStart = true;
  return (text22) => {
    if (isStreamStart) {
      text22 = text22.trimStart();
      if (text22)
        isStreamStart = false;
    }
    return text22;
  };
}
__name(trimStartOfStream, "trimStartOfStream");
var HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;

// node_modules/zod-from-json-schema/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/external.js
var external_exports3 = {};
__export(external_exports3, {
  $brand: () => $brand2,
  $input: () => $input2,
  $output: () => $output2,
  NEVER: () => NEVER3,
  TimePrecision: () => TimePrecision2,
  ZodAny: () => ZodAny3,
  ZodArray: () => ZodArray3,
  ZodBase64: () => ZodBase642,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBigInt: () => ZodBigInt3,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBoolean: () => ZodBoolean3,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCUID: () => ZodCUID3,
  ZodCUID2: () => ZodCUID22,
  ZodCatch: () => ZodCatch3,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodDate: () => ZodDate3,
  ZodDefault: () => ZodDefault3,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion3,
  ZodE164: () => ZodE1642,
  ZodEmail: () => ZodEmail2,
  ZodEmoji: () => ZodEmoji2,
  ZodEnum: () => ZodEnum3,
  ZodError: () => ZodError3,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID2,
  ZodIPv4: () => ZodIPv42,
  ZodIPv6: () => ZodIPv62,
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  ZodIntersection: () => ZodIntersection3,
  ZodIssueCode: () => ZodIssueCode3,
  ZodJWT: () => ZodJWT2,
  ZodKSUID: () => ZodKSUID2,
  ZodLazy: () => ZodLazy3,
  ZodLiteral: () => ZodLiteral3,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap3,
  ZodNaN: () => ZodNaN3,
  ZodNanoID: () => ZodNanoID2,
  ZodNever: () => ZodNever3,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNull: () => ZodNull3,
  ZodNullable: () => ZodNullable3,
  ZodNumber: () => ZodNumber3,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodObject: () => ZodObject3,
  ZodOptional: () => ZodOptional3,
  ZodPipe: () => ZodPipe2,
  ZodPrefault: () => ZodPrefault2,
  ZodPromise: () => ZodPromise3,
  ZodReadonly: () => ZodReadonly3,
  ZodRealError: () => ZodRealError2,
  ZodRecord: () => ZodRecord3,
  ZodSet: () => ZodSet3,
  ZodString: () => ZodString3,
  ZodStringFormat: () => ZodStringFormat2,
  ZodSuccess: () => ZodSuccess2,
  ZodSymbol: () => ZodSymbol3,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodTransform: () => ZodTransform2,
  ZodTuple: () => ZodTuple3,
  ZodType: () => ZodType3,
  ZodULID: () => ZodULID2,
  ZodURL: () => ZodURL2,
  ZodUUID: () => ZodUUID2,
  ZodUndefined: () => ZodUndefined3,
  ZodUnion: () => ZodUnion3,
  ZodUnknown: () => ZodUnknown3,
  ZodVoid: () => ZodVoid3,
  ZodXID: () => ZodXID2,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString2,
  _default: () => _default4,
  _function: () => _function2,
  any: () => any2,
  array: () => array2,
  base64: () => base644,
  base64url: () => base64url4,
  bigint: () => bigint6,
  boolean: () => boolean5,
  catch: () => _catch4,
  check: () => check2,
  cidrv4: () => cidrv44,
  cidrv6: () => cidrv64,
  clone: () => clone2,
  codec: () => codec,
  coerce: () => coerce_exports2,
  config: () => config3,
  core: () => core_exports4,
  cuid: () => cuid5,
  cuid2: () => cuid24,
  custom: () => custom3,
  date: () => date7,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion2,
  e164: () => e1644,
  email: () => email4,
  emoji: () => emoji4,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith2,
  enum: () => _enum4,
  exactOptional: () => exactOptional,
  file: () => file2,
  flattenError: () => flattenError2,
  float32: () => float322,
  float64: () => float642,
  formatError: () => formatError2,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function2,
  getErrorMap: () => getErrorMap3,
  globalRegistry: () => globalRegistry2,
  gt: () => _gt2,
  gte: () => _gte2,
  guid: () => guid4,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname3,
  httpUrl: () => httpUrl,
  includes: () => _includes2,
  instanceof: () => _instanceof2,
  int: () => int2,
  int32: () => int322,
  int64: () => int642,
  intersection: () => intersection2,
  ipv4: () => ipv44,
  ipv6: () => ipv64,
  iso: () => iso_exports2,
  json: () => json2,
  jwt: () => jwt2,
  keyof: () => keyof2,
  ksuid: () => ksuid4,
  lazy: () => lazy2,
  length: () => _length2,
  literal: () => literal2,
  locales: () => locales_exports2,
  looseObject: () => looseObject2,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase2,
  lt: () => _lt2,
  lte: () => _lte2,
  mac: () => mac2,
  map: () => map2,
  maxLength: () => _maxLength2,
  maxSize: () => _maxSize2,
  meta: () => meta2,
  mime: () => _mime2,
  minLength: () => _minLength2,
  minSize: () => _minSize2,
  multipleOf: () => _multipleOf2,
  nan: () => nan2,
  nanoid: () => nanoid4,
  nativeEnum: () => nativeEnum2,
  negative: () => _negative2,
  never: () => never2,
  nonnegative: () => _nonnegative2,
  nonoptional: () => nonoptional2,
  nonpositive: () => _nonpositive2,
  normalize: () => _normalize2,
  null: () => _null6,
  nullable: () => nullable2,
  nullish: () => nullish4,
  number: () => number5,
  object: () => object4,
  optional: () => optional2,
  overwrite: () => _overwrite2,
  parse: () => parse4,
  parseAsync: () => parseAsync4,
  partialRecord: () => partialRecord2,
  pipe: () => pipe2,
  positive: () => _positive2,
  prefault: () => prefault2,
  preprocess: () => preprocess2,
  prettifyError: () => prettifyError2,
  promise: () => promise2,
  property: () => _property2,
  readonly: () => readonly2,
  record: () => record2,
  refine: () => refine2,
  regex: () => _regex2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse4,
  safeParseAsync: () => safeParseAsync4,
  set: () => set2,
  setErrorMap: () => setErrorMap3,
  size: () => _size2,
  slugify: () => _slugify,
  startsWith: () => _startsWith2,
  strictObject: () => strictObject2,
  string: () => string5,
  stringFormat: () => stringFormat2,
  stringbool: () => stringbool2,
  success: () => success2,
  superRefine: () => superRefine2,
  symbol: () => symbol18,
  templateLiteral: () => templateLiteral2,
  toJSONSchema: () => toJSONSchema2,
  toLowerCase: () => _toLowerCase2,
  toUpperCase: () => _toUpperCase2,
  transform: () => transform2,
  treeifyError: () => treeifyError2,
  trim: () => _trim2,
  tuple: () => tuple2,
  uint32: () => uint322,
  uint64: () => uint642,
  ulid: () => ulid4,
  undefined: () => _undefined6,
  union: () => union2,
  unknown: () => unknown2,
  uppercase: () => _uppercase2,
  url: () => url2,
  util: () => util_exports2,
  uuid: () => uuid5,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv62,
  uuidv7: () => uuidv72,
  void: () => _void4,
  xid: () => xid4,
  xor: () => xor
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/index.js
var core_exports4 = {};
__export(core_exports4, {
  $ZodAny: () => $ZodAny2,
  $ZodArray: () => $ZodArray2,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodBase64: () => $ZodBase642,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCUID: () => $ZodCUID3,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCatch: () => $ZodCatch2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodDate: () => $ZodDate2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodE164: () => $ZodE1642,
  $ZodEmail: () => $ZodEmail2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum2,
  $ZodError: () => $ZodError2,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile2,
  $ZodFunction: () => $ZodFunction2,
  $ZodGUID: () => $ZodGUID2,
  $ZodIPv4: () => $ZodIPv42,
  $ZodIPv6: () => $ZodIPv62,
  $ZodISODate: () => $ZodISODate2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodJWT: () => $ZodJWT2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodLazy: () => $ZodLazy2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap2,
  $ZodNaN: () => $ZodNaN2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNever: () => $ZodNever2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNull: () => $ZodNull2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodObject: () => $ZodObject2,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional2,
  $ZodPipe: () => $ZodPipe2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPromise: () => $ZodPromise2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodRealError: () => $ZodRealError2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodSet: () => $ZodSet2,
  $ZodString: () => $ZodString2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTuple: () => $ZodTuple2,
  $ZodType: () => $ZodType2,
  $ZodULID: () => $ZodULID2,
  $ZodURL: () => $ZodURL2,
  $ZodUUID: () => $ZodUUID2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodVoid: () => $ZodVoid2,
  $ZodXID: () => $ZodXID2,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand2,
  $constructor: () => $constructor2,
  $input: () => $input2,
  $output: () => $output2,
  Doc: () => Doc2,
  JSONSchema: () => json_schema_exports2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  NEVER: () => NEVER3,
  TimePrecision: () => TimePrecision2,
  _any: () => _any2,
  _array: () => _array2,
  _base64: () => _base642,
  _base64url: () => _base64url2,
  _bigint: () => _bigint2,
  _boolean: () => _boolean2,
  _catch: () => _catch3,
  _check: () => _check,
  _cidrv4: () => _cidrv42,
  _cidrv6: () => _cidrv62,
  _coercedBigint: () => _coercedBigint2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedDate: () => _coercedDate2,
  _coercedNumber: () => _coercedNumber2,
  _coercedString: () => _coercedString2,
  _cuid: () => _cuid3,
  _cuid2: () => _cuid22,
  _custom: () => _custom2,
  _date: () => _date2,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default3,
  _discriminatedUnion: () => _discriminatedUnion2,
  _e164: () => _e1642,
  _email: () => _email2,
  _emoji: () => _emoji4,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith2,
  _enum: () => _enum3,
  _file: () => _file2,
  _float32: () => _float322,
  _float64: () => _float642,
  _gt: () => _gt2,
  _gte: () => _gte2,
  _guid: () => _guid2,
  _includes: () => _includes2,
  _int: () => _int2,
  _int32: () => _int322,
  _int64: () => _int642,
  _intersection: () => _intersection2,
  _ipv4: () => _ipv42,
  _ipv6: () => _ipv62,
  _isoDate: () => _isoDate2,
  _isoDateTime: () => _isoDateTime2,
  _isoDuration: () => _isoDuration2,
  _isoTime: () => _isoTime2,
  _jwt: () => _jwt2,
  _ksuid: () => _ksuid2,
  _lazy: () => _lazy2,
  _length: () => _length2,
  _literal: () => _literal2,
  _lowercase: () => _lowercase2,
  _lt: () => _lt2,
  _lte: () => _lte2,
  _mac: () => _mac,
  _map: () => _map2,
  _max: () => _lte2,
  _maxLength: () => _maxLength2,
  _maxSize: () => _maxSize2,
  _mime: () => _mime2,
  _min: () => _gte2,
  _minLength: () => _minLength2,
  _minSize: () => _minSize2,
  _multipleOf: () => _multipleOf2,
  _nan: () => _nan2,
  _nanoid: () => _nanoid2,
  _nativeEnum: () => _nativeEnum2,
  _negative: () => _negative2,
  _never: () => _never2,
  _nonnegative: () => _nonnegative2,
  _nonoptional: () => _nonoptional2,
  _nonpositive: () => _nonpositive2,
  _normalize: () => _normalize2,
  _null: () => _null5,
  _nullable: () => _nullable2,
  _number: () => _number2,
  _optional: () => _optional2,
  _overwrite: () => _overwrite2,
  _parse: () => _parse3,
  _parseAsync: () => _parseAsync2,
  _pipe: () => _pipe2,
  _positive: () => _positive2,
  _promise: () => _promise2,
  _property: () => _property2,
  _readonly: () => _readonly2,
  _record: () => _record2,
  _refine: () => _refine2,
  _regex: () => _regex2,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse2,
  _safeParseAsync: () => _safeParseAsync2,
  _set: () => _set2,
  _size: () => _size2,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith2,
  _string: () => _string2,
  _stringFormat: () => _stringFormat2,
  _stringbool: () => _stringbool2,
  _success: () => _success2,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol2,
  _templateLiteral: () => _templateLiteral2,
  _toLowerCase: () => _toLowerCase2,
  _toUpperCase: () => _toUpperCase2,
  _transform: () => _transform2,
  _trim: () => _trim2,
  _tuple: () => _tuple2,
  _uint32: () => _uint322,
  _uint64: () => _uint642,
  _ulid: () => _ulid2,
  _undefined: () => _undefined5,
  _union: () => _union2,
  _unknown: () => _unknown2,
  _uppercase: () => _uppercase2,
  _url: () => _url2,
  _uuid: () => _uuid2,
  _uuidv4: () => _uuidv42,
  _uuidv6: () => _uuidv62,
  _uuidv7: () => _uuidv72,
  _void: () => _void3,
  _xid: () => _xid2,
  _xor: () => _xor,
  clone: () => clone2,
  config: () => config3,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError2,
  formatError: () => formatError2,
  globalConfig: () => globalConfig2,
  globalRegistry: () => globalRegistry2,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase642,
  isValidBase64URL: () => isValidBase64URL2,
  isValidJWT: () => isValidJWT3,
  locales: () => locales_exports2,
  meta: () => meta,
  parse: () => parse3,
  parseAsync: () => parseAsync3,
  prettifyError: () => prettifyError2,
  process: () => process2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse3,
  safeParseAsync: () => safeParseAsync3,
  toDotPath: () => toDotPath2,
  toJSONSchema: () => toJSONSchema2,
  treeifyError: () => treeifyError2,
  util: () => util_exports2,
  version: () => version3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/core.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var NEVER3 = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor2(name51, initializer5, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name51)) {
      return;
    }
    inst._zod.traits.add(name51);
    initializer5(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", { value: name51 });
  function _(def) {
    var _a61;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a61 = inst._zod).deferred ?? (_a61.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  __name(_, "_");
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name51);
    }, "value")
  });
  Object.defineProperty(_, "name", { value: name51 });
  return _;
}
__name($constructor2, "$constructor");
var $brand2 = Symbol("zod_brand");
var $ZodAsyncError2 = class extends Error {
  static {
    __name(this, "$ZodAsyncError");
  }
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  static {
    __name(this, "$ZodEncodeError");
  }
  constructor(name51) {
    super(`Encountered unidirectional transform during encode: ${name51}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig2 = {};
function config3(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
__name(config3, "config");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2,
  Class: () => Class2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  aborted: () => aborted2,
  allowsEval: () => allowsEval2,
  assert: () => assert3,
  assertEqual: () => assertEqual2,
  assertIs: () => assertIs2,
  assertNever: () => assertNever2,
  assertNotEqual: () => assertNotEqual2,
  assignProp: () => assignProp2,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached2,
  captureStackTrace: () => captureStackTrace2,
  cleanEnum: () => cleanEnum2,
  cleanRegex: () => cleanRegex2,
  clone: () => clone2,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy2,
  defineLazy: () => defineLazy2,
  esc: () => esc2,
  escapeRegex: () => escapeRegex2,
  extend: () => extend2,
  finalizeIssue: () => finalizeIssue2,
  floatSafeRemainder: () => floatSafeRemainder3,
  getElementAtPath: () => getElementAtPath2,
  getEnumValues: () => getEnumValues2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getParsedType: () => getParsedType3,
  getSizableOrigin: () => getSizableOrigin2,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject2,
  issue: () => issue2,
  joinValues: () => joinValues2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  merge: () => merge2,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams2,
  nullish: () => nullish3,
  numKeys: () => numKeys2,
  objectClone: () => objectClone,
  omit: () => omit3,
  optionalKeys: () => optionalKeys2,
  parsedType: () => parsedType4,
  partial: () => partial2,
  pick: () => pick2,
  prefixIssues: () => prefixIssues2,
  primitiveTypes: () => primitiveTypes2,
  promiseAllObject: () => promiseAllObject2,
  propertyKeyTypes: () => propertyKeyTypes2,
  randomString: () => randomString2,
  required: () => required2,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive2,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function assertEqual2(val) {
  return val;
}
__name(assertEqual2, "assertEqual");
function assertNotEqual2(val) {
  return val;
}
__name(assertNotEqual2, "assertNotEqual");
function assertIs2(_arg) {
}
__name(assertIs2, "assertIs");
function assertNever2(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
__name(assertNever2, "assertNever");
function assert3(_) {
}
__name(assert3, "assert");
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
__name(getEnumValues2, "getEnumValues");
function joinValues2(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive2(val)).join(separator);
}
__name(joinValues2, "joinValues");
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
__name(jsonStringifyReplacer2, "jsonStringifyReplacer");
function cached2(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
__name(cached2, "cached");
function nullish3(input) {
  return input === null || input === void 0;
}
__name(nullish3, "nullish");
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
__name(cleanRegex2, "cleanRegex");
function floatSafeRemainder3(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match2 = stepString.match(/\d?e-(\d?)/);
    if (match2?.[1]) {
      stepDecCount = Number.parseInt(match2[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder3, "floatSafeRemainder");
var EVALUATING = Symbol("evaluating");
function defineLazy2(object5, key, getter) {
  let value = void 0;
  Object.defineProperty(object5, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object5, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
__name(defineLazy2, "defineLazy");
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
__name(objectClone, "objectClone");
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
__name(assignProp2, "assignProp");
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
__name(mergeDefs, "mergeDefs");
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
__name(cloneDef, "cloneDef");
function getElementAtPath2(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
__name(getElementAtPath2, "getElementAtPath");
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
__name(promiseAllObject2, "promiseAllObject");
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
__name(randomString2, "randomString");
function esc2(str) {
  return JSON.stringify(str);
}
__name(esc2, "esc");
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
__name(slugify, "slugify");
var captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
__name(isObject2, "isObject");
var allowsEval2 = cached2(() => {
  if (typeof navigator !== "undefined" && "Cloudflare-Workers"?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject2, "isPlainObject");
function shallowClone(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
__name(shallowClone, "shallowClone");
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
__name(numKeys2, "numKeys");
var getParsedType3 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, "getParsedType");
var propertyKeyTypes2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes2 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex2, "escapeRegex");
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
__name(clone2, "clone");
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: /* @__PURE__ */ __name(() => params, "error") };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: /* @__PURE__ */ __name(() => params.error, "error") };
  return params;
}
__name(normalizeParams2, "normalizeParams");
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
__name(createTransparentProxy2, "createTransparentProxy");
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
__name(stringifyPrimitive2, "stringifyPrimitive");
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
__name(optionalKeys2, "optionalKeys");
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
__name(pick2, "pick");
function omit3(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
__name(omit3, "omit");
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema, def);
}
__name(extend2, "extend");
function safeExtend(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema, def);
}
__name(safeExtend, "safeExtend");
function merge2(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone2(a, def);
}
__name(merge2, "merge");
function partial2(Class3, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
__name(partial2, "partial");
function required2(Class3, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    }
  });
  return clone2(schema, def);
}
__name(required2, "required");
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
__name(aborted2, "aborted");
function prefixIssues2(path3, issues) {
  return issues.map((iss) => {
    var _a61;
    (_a61 = iss).path ?? (_a61.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
__name(prefixIssues2, "prefixIssues");
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
__name(unwrapMessage2, "unwrapMessage");
function finalizeIssue2(iss, ctx, config4) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config4.customError?.(iss)) ?? unwrapMessage2(config4.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
__name(finalizeIssue2, "finalizeIssue");
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
__name(getSizableOrigin2, "getSizableOrigin");
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
__name(getLengthableOrigin2, "getLengthableOrigin");
function parsedType4(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
__name(parsedType4, "parsedType");
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
__name(issue2, "issue");
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
__name(cleanEnum2, "cleanEnum");
function base64ToUint8Array(base646) {
  const binaryString = atob(base646);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
__name(base64ToUint8Array, "base64ToUint8Array");
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
__name(uint8ArrayToBase64, "uint8ArrayToBase64");
function base64urlToUint8Array(base64url5) {
  const base646 = base64url5.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base646.length % 4) % 4);
  return base64ToUint8Array(base646 + padding);
}
__name(base64urlToUint8Array, "base64urlToUint8Array");
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
__name(uint8ArrayToBase64url, "uint8ArrayToBase64url");
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
__name(hexToUint8Array, "hexToUint8Array");
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(uint8ArrayToHex, "uint8ArrayToHex");
var Class2 = class {
  static {
    __name(this, "Class");
  }
  constructor(..._args) {
  }
};

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/errors.js
var initializer3 = /* @__PURE__ */ __name((inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: /* @__PURE__ */ __name(() => inst.message, "value"),
    enumerable: false
  });
}, "initializer");
var $ZodError2 = $constructor2("$ZodError", initializer3);
var $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
function flattenError2(error87, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error87.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
__name(flattenError2, "flattenError");
function formatError2(error87, mapper = (issue3) => issue3.message) {
  const fieldErrors = { _errors: [] };
  const processError = /* @__PURE__ */ __name((error88) => {
    for (const issue3 of error88.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  }, "processError");
  processError(error87);
  return fieldErrors;
}
__name(formatError2, "formatError");
function treeifyError2(error87, mapper = (issue3) => issue3.message) {
  const result = { errors: [] };
  const processError = /* @__PURE__ */ __name((error88, path3 = []) => {
    var _a61, _b;
    for (const issue3 of error88.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path3, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a61 = curr.properties)[el] ?? (_a61[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  }, "processError");
  processError(error87);
  return result;
}
__name(treeifyError2, "treeifyError");
function toDotPath2(_path) {
  const segs = [];
  const path3 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
__name(toDotPath2, "toDotPath");
function prettifyError2(error87) {
  const lines = [];
  const issues = [...error87.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath2(issue3.path)}`);
  }
  return lines.join("\n");
}
__name(prettifyError2, "prettifyError");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/parse.js
var _parse3 = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
}, "_parse");
var parse3 = /* @__PURE__ */ _parse3($ZodRealError2);
var _parseAsync2 = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
}, "_parseAsync");
var parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
var _safeParse2 = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())))
  } : { success: true, data: result.value };
}, "_safeParse");
var safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())))
  } : { success: true, data: result.value };
}, "_safeParseAsync");
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse3(_Err)(schema, value, ctx);
}, "_encode");
var encode = /* @__PURE__ */ _encode($ZodRealError2);
var _decode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _parse3(_Err)(schema, value, _ctx);
}, "_decode");
var decode = /* @__PURE__ */ _decode($ZodRealError2);
var _encodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
}, "_encodeAsync");
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError2);
var _decodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
}, "_decodeAsync");
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError2);
var _safeEncode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
}, "_safeEncode");
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError2);
var _safeDecode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
}, "_safeDecode");
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError2);
var _safeEncodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
}, "_safeEncodeAsync");
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError2);
var _safeDecodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
}, "_safeDecodeAsync");
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError2);

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/regexes.js
var regexes_exports2 = {};
__export(regexes_exports2, {
  base64: () => base643,
  base64url: () => base64url3,
  bigint: () => bigint5,
  boolean: () => boolean4,
  browserEmail: () => browserEmail2,
  cidrv4: () => cidrv43,
  cidrv6: () => cidrv63,
  cuid: () => cuid4,
  cuid2: () => cuid23,
  date: () => date5,
  datetime: () => datetime3,
  domain: () => domain3,
  duration: () => duration3,
  e164: () => e1643,
  email: () => email3,
  emoji: () => emoji3,
  extendedDuration: () => extendedDuration2,
  guid: () => guid3,
  hex: () => hex,
  hostname: () => hostname2,
  html5Email: () => html5Email2,
  idnEmail: () => idnEmail,
  integer: () => integer2,
  ipv4: () => ipv43,
  ipv6: () => ipv63,
  ksuid: () => ksuid3,
  lowercase: () => lowercase2,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid3,
  null: () => _null4,
  number: () => number4,
  rfc5322Email: () => rfc5322Email2,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string4,
  time: () => time3,
  ulid: () => ulid3,
  undefined: () => _undefined4,
  unicodeEmail: () => unicodeEmail2,
  uppercase: () => uppercase2,
  uuid: () => uuid3,
  uuid4: () => uuid42,
  uuid6: () => uuid62,
  uuid7: () => uuid72,
  xid: () => xid3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var cuid4 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = /* @__PURE__ */ __name((version4) => {
  if (!version4)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version4}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "uuid");
var uuid42 = /* @__PURE__ */ uuid3(4);
var uuid62 = /* @__PURE__ */ uuid3(6);
var uuid72 = /* @__PURE__ */ uuid3(7);
var email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail2;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji3, "u");
}
__name(emoji3, "emoji");
var ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = /* @__PURE__ */ __name((delimiter) => {
  const escapedDelim = escapeRegex2(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, "mac");
var cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname2 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain3 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1643 = /^\+[1-9]\d{6,14}$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
__name(timeSource2, "timeSource");
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
__name(time3, "time");
function datetime3(args) {
  const time5 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex2})$`);
}
__name(datetime3, "datetime");
var string4 = /* @__PURE__ */ __name((params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, "string");
var bigint5 = /^-?\d+n?$/;
var integer2 = /^-?\d+$/;
var number4 = /^-?\d+(?:\.\d+)?$/;
var boolean4 = /^(?:true|false)$/i;
var _null4 = /^null$/i;
var _undefined4 = /^undefined$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
__name(fixedBase64, "fixedBase64");
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
__name(fixedBase64url, "fixedBase64url");
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/checks.js
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a61;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a61 = inst._zod).onattach ?? (_a61.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a61;
    (_a61 = inst2._zod.bag).multipleOf ?? (_a61.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder3(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt2 = def.format?.includes("int");
  const origin = isInt2 ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt2)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt2) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a61;
  $ZodCheck2.init(inst, def);
  (_a61 = inst._zod.def).when ?? (_a61.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a61, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a61 = inst._zod).check ?? (_a61.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
__name(handleCheckPropertyResult2, "handleCheckPropertyResult");
var $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/doc.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var Doc2 = class {
  static {
    __name(this, "Doc");
  }
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/versions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var version3 = {
  major: 4,
  minor: 3,
  patch: 5
};

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/schemas.js
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a61;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version3;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a61 = inst._zod).deferred ?? (_a61.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
      let isAborted2 = aborted2(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError2();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    }, "runChecks");
    const handleCanaryResult = /* @__PURE__ */ __name((canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    }, "handleCanaryResult");
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy2(inst, "~standard", () => ({
    validate: /* @__PURE__ */ __name((value) => {
      try {
        const r = safeParse3(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  }));
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v));
  } else
    def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url3 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url3.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url3.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid4);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor2("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
__name(isValidBase642, "isValidBase64");
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base646 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base646.padEnd(Math.ceil(base646.length / 4) * 4, "=");
  return isValidBase642(padded);
}
__name(isValidBase64URL2, "isValidBase64URL");
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url3);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT3(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT3, "isValidJWT");
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT3(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint5;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined4;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null4;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate3 = input instanceof Date;
    const isValidDate = isDate3 && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate3 ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleArrayResult2, "handleArrayResult");
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
__name(handlePropertyResult, "handlePropertyResult");
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
__name(normalizeDef, "normalizeDef");
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
__name(handleCatchall, "handleCatchall");
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: /* @__PURE__ */ __name(() => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }, "get")
    });
  }
  const _normalized = cached2(() => normalizeDef(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject4 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
  $ZodObject2.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached2(() => normalizeDef(def));
  const generateFastpass = /* @__PURE__ */ __name((shape) => {
    const doc = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = /* @__PURE__ */ __name((key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    }, "parseStr");
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc2(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, "generateFastpass");
  let fastpass;
  const isObject4 = isObject2;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())))
  });
  return final;
}
__name(handleUnionResults2, "handleUnionResults");
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config3())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
__name(handleExclusiveUnionResults, "handleExclusiveUnionResults");
var $ZodXor = /* @__PURE__ */ $constructor2("$ZodXor", (inst, def) => {
  $ZodUnion2.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    const opts = def.options;
    const map3 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map3.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map3.set(v, o);
      }
    }
    return map3;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues3(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues3(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues3(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
__name(mergeValues3, "mergeValues");
function handleIntersectionResults2(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues3(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
__name(handleIntersectionResults2, "handleIntersectionResults");
var $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleTupleResult2, "handleTupleResult");
var $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number4.test(key) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config3())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config3()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config3()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
__name(handleMapResult2, "handleMapResult");
var $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
__name(handleSetResult2, "handleSetResult");
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
__name(handleOptionalResult, "handleOptionalResult");
var $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor2("$ZodExactOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : void 0;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
__name(handleDefaultResult2, "handleDefaultResult");
var $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
__name(handleNonOptionalResult2, "handleNonOptionalResult");
var $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config3()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config3()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
      }
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
    }
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
__name(handlePipeResult2, "handlePipeResult");
var $ZodCodec = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
__name(handleCodecAResult, "handleCodecAResult");
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
__name(handleCodecTxResult, "handleCodecTxResult");
var $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
__name(handleReadonlyResult2, "handleReadonlyResult");
var $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse3(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse3(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync3(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
__name(handleRefineResult2, "handleRefineResult");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/index.js
var locales_exports2 = {};
__export(locales_exports2, {
  ar: () => ar_default2,
  az: () => az_default2,
  be: () => be_default2,
  bg: () => bg_default,
  ca: () => ca_default2,
  cs: () => cs_default2,
  da: () => da_default,
  de: () => de_default2,
  en: () => en_default3,
  eo: () => eo_default2,
  es: () => es_default2,
  fa: () => fa_default2,
  fi: () => fi_default2,
  fr: () => fr_default2,
  frCA: () => fr_CA_default2,
  he: () => he_default2,
  hu: () => hu_default2,
  hy: () => hy_default,
  id: () => id_default2,
  is: () => is_default,
  it: () => it_default2,
  ja: () => ja_default2,
  ka: () => ka_default,
  kh: () => kh_default2,
  km: () => km_default,
  ko: () => ko_default2,
  lt: () => lt_default,
  mk: () => mk_default2,
  ms: () => ms_default2,
  nl: () => nl_default2,
  no: () => no_default2,
  ota: () => ota_default2,
  pl: () => pl_default2,
  ps: () => ps_default2,
  pt: () => pt_default2,
  ru: () => ru_default2,
  sl: () => sl_default2,
  sv: () => sv_default2,
  ta: () => ta_default2,
  th: () => th_default2,
  tr: () => tr_default2,
  ua: () => ua_default2,
  uk: () => uk_default,
  ur: () => ur_default2,
  uz: () => uz_default,
  vi: () => vi_default2,
  yo: () => yo_default,
  zhCN: () => zh_CN_default2,
  zhTW: () => zh_TW_default2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ar.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error40 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
}, "error");
function ar_default2() {
  return {
    localeError: error40()
  };
}
__name(ar_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/az.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error41 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue3.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
}, "error");
function az_default2() {
  return {
    localeError: error41()
  };
}
__name(az_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/be.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getBelarusianPlural2, "getBelarusianPlural");
var error42 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
}, "error");
function be_default2() {
  return {
    localeError: error42()
  };
}
__name(be_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/bg.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error43 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue3.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
}, "error");
function bg_default() {
  return {
    localeError: error43()
  };
}
__name(bg_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ca.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error44 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue3.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
}, "error");
function ca_default2() {
  return {
    localeError: error44()
  };
}
__name(ca_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/cs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error45 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue3.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
}, "error");
function cs_default2() {
  return {
    localeError: error45()
  };
}
__name(cs_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/da.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error46 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue3.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
}, "error");
function da_default() {
  return {
    localeError: error46()
  };
}
__name(da_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/de.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error47 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue3.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
}, "error");
function de_default2() {
  return {
    localeError: error47()
  };
}
__name(de_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error48 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
}, "error");
function en_default3() {
  return {
    localeError: error48()
  };
}
__name(en_default3, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/eo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error49 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue3.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
}, "error");
function eo_default2() {
  return {
    localeError: error49()
  };
}
__name(eo_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/es.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error50 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue3.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
}, "error");
function es_default2() {
  return {
    localeError: error50()
  };
}
__name(es_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/fa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error51 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive2(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues2(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
}, "error");
function fa_default2() {
  return {
    localeError: error51()
  };
}
__name(fa_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/fi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error52 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue3.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
}, "error");
function fi_default2() {
  return {
    localeError: error52()
  };
}
__name(fi_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/fr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error53 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue3.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_default2() {
  return {
    localeError: error53()
  };
}
__name(fr_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/fr-CA.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error54 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue3.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_CA_default2() {
  return {
    localeError: error54()
  };
}
__name(fr_CA_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/he.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error55 = /* @__PURE__ */ __name(() => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = /* @__PURE__ */ __name((t) => t ? TypeNames[t] : void 0, "typeEntry");
  const typeLabel = /* @__PURE__ */ __name((t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  }, "typeLabel");
  const withDefinite = /* @__PURE__ */ __name((t) => `\u05D4${typeLabel(t)}`, "withDefinite");
  const verbFor = /* @__PURE__ */ __name((t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  }, "verbFor");
  const getSizing = /* @__PURE__ */ __name((origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  }, "getSizing");
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expectedKey = issue3.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue3.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive2(issue3.values[0])}`;
        }
        const stringified = issue3.values.map((v) => stringifyPrimitive2(v));
        if (issue3.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.maximum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue3.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue3.inclusive ? `${issue3.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue3.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? "<=" : "<";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.minimum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue3.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue3.minimum === 1 && issue3.inclusive) {
            const singularPhrase = issue3.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue3.inclusive ? `${issue3.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue3.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? ">=" : ">";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue3.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
}, "error");
function he_default2() {
  return {
    localeError: error55()
  };
}
__name(he_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/hu.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error56 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue3.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
}, "error");
function hu_default2() {
  return {
    localeError: error56()
  };
}
__name(hu_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/hy.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
__name(getArmenianPlural, "getArmenianPlural");
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
__name(withDefiniteArticle, "withDefiniteArticle");
var error57 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue3.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive2(issue3.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056C\u056B\u0576\u056B ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue3.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue3.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
}, "error");
function hy_default() {
  return {
    localeError: error57()
  };
}
__name(hy_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/id.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error58 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
}, "error");
function id_default2() {
  return {
    localeError: error58()
  };
}
__name(id_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/is.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error59 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue3.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
}, "error");
function is_default() {
  return {
    localeError: error59()
  };
}
__name(is_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/it.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error60 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input non valido: atteso instanceof ${issue3.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
}, "error");
function it_default2() {
  return {
    localeError: error60()
  };
}
__name(it_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ja.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error61 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive2(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues2(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
}, "error");
function ja_default2() {
  return {
    localeError: error61()
  };
}
__name(ja_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ka.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error62 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues2(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
}, "error");
function ka_default() {
  return {
    localeError: error62()
  };
}
__name(ka_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/kh.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/km.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error63 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
}, "error");
function km_default() {
  return {
    localeError: error63()
  };
}
__name(km_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default();
}
__name(kh_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ko.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error64 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive2(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues2(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
}, "error");
function ko_default2() {
  return {
    localeError: error64()
  };
}
__name(ko_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/lt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var capitalizeFirstCharacter = /* @__PURE__ */ __name((text3) => {
  return text3.charAt(0).toUpperCase() + text3.slice(1);
}, "capitalizeFirstCharacter");
function getUnitTypeFromNumber(number7) {
  const abs = Math.abs(number7);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
__name(getUnitTypeFromNumber, "getUnitTypeFromNumber");
var error65 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue3.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues2(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
}, "error");
function lt_default() {
  return {
    localeError: error65()
  };
}
__name(lt_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/mk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error66 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
}, "error");
function mk_default2() {
  return {
    localeError: error66()
  };
}
__name(mk_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ms.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error67 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
}, "error");
function ms_default2() {
  return {
    localeError: error67()
  };
}
__name(ms_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/nl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error68 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue3.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const longName = issue3.origin === "date" ? "laat" : issue3.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const shortName = issue3.origin === "date" ? "vroeg" : issue3.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
}, "error");
function nl_default2() {
  return {
    localeError: error68()
  };
}
__name(nl_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/no.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error69 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldig input: forventet instanceof ${issue3.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
}, "error");
function no_default2() {
  return {
    localeError: error69()
  };
}
__name(no_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ota.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error70 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue3.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
}, "error");
function ota_default2() {
  return {
    localeError: error70()
  };
}
__name(ota_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ps.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error71 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive2(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues2(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
}, "error");
function ps_default2() {
  return {
    localeError: error71()
  };
}
__name(ps_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/pl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error72 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue3.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
}, "error");
function pl_default2() {
  return {
    localeError: error72()
  };
}
__name(pl_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/pt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error73 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue3.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
}, "error");
function pt_default2() {
  return {
    localeError: error73()
  };
}
__name(pt_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ru.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getRussianPlural2, "getRussianPlural");
var error74 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
}, "error");
function ru_default2() {
  return {
    localeError: error74()
  };
}
__name(ru_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/sl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error75 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue3.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error");
function sl_default2() {
  return {
    localeError: error75()
  };
}
__name(sl_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/sv.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error76 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue3.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
}, "error");
function sv_default2() {
  return {
    localeError: error76()
  };
}
__name(sv_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ta.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error77 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues2(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
}, "error");
function ta_default2() {
  return {
    localeError: error77()
  };
}
__name(ta_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/th.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error78 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
}, "error");
function th_default2() {
  return {
    localeError: error78()
  };
}
__name(th_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/tr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error79 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue3.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
}, "error");
function tr_default2() {
  return {
    localeError: error79()
  };
}
__name(tr_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ua.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/uk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error80 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
}, "error");
function uk_default() {
  return {
    localeError: error80()
  };
}
__name(uk_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default();
}
__name(ua_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/ur.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error81 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive2(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues2(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
}, "error");
function ur_default2() {
  return {
    localeError: error81()
  };
}
__name(ur_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/uz.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error82 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue3.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue3.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue3.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
}, "error");
function uz_default() {
  return {
    localeError: error82()
  };
}
__name(uz_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/vi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error83 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive2(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
}, "error");
function vi_default2() {
  return {
    localeError: error83()
  };
}
__name(vi_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/zh-CN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error84 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
}, "error");
function zh_CN_default2() {
  return {
    localeError: error84()
  };
}
__name(zh_CN_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/zh-TW.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error85 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
}, "error");
function zh_TW_default2() {
  return {
    localeError: error85()
  };
}
__name(zh_TW_default2, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/locales/yo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var error86 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType4(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
}, "error");
function yo_default() {
  return {
    localeError: error86()
  };
}
__name(yo_default, "default");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/registries.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var _a19;
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");
var $ZodRegistry2 = class {
  static {
    __name(this, "$ZodRegistry");
  }
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry2() {
  return new $ZodRegistry2();
}
__name(registry2, "registry");
(_a19 = globalThis).__zod_globalRegistry ?? (_a19.__zod_globalRegistry = registry2());
var globalRegistry2 = globalThis.__zod_globalRegistry;

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
// @__NO_SIDE_EFFECTS__
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
__name(_string2, "_string");
// @__NO_SIDE_EFFECTS__
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
__name(_coercedString2, "_coercedString");
// @__NO_SIDE_EFFECTS__
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_email2, "_email");
// @__NO_SIDE_EFFECTS__
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_guid2, "_guid");
// @__NO_SIDE_EFFECTS__
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_uuid2, "_uuid");
// @__NO_SIDE_EFFECTS__
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
__name(_uuidv42, "_uuidv4");
// @__NO_SIDE_EFFECTS__
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
__name(_uuidv62, "_uuidv6");
// @__NO_SIDE_EFFECTS__
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
__name(_uuidv72, "_uuidv7");
// @__NO_SIDE_EFFECTS__
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_url2, "_url");
// @__NO_SIDE_EFFECTS__
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_emoji4, "_emoji");
// @__NO_SIDE_EFFECTS__
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_nanoid2, "_nanoid");
// @__NO_SIDE_EFFECTS__
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_cuid3, "_cuid");
// @__NO_SIDE_EFFECTS__
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_cuid22, "_cuid2");
// @__NO_SIDE_EFFECTS__
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_ulid2, "_ulid");
// @__NO_SIDE_EFFECTS__
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_xid2, "_xid");
// @__NO_SIDE_EFFECTS__
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_ksuid2, "_ksuid");
// @__NO_SIDE_EFFECTS__
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_ipv42, "_ipv4");
// @__NO_SIDE_EFFECTS__
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_ipv62, "_ipv6");
// @__NO_SIDE_EFFECTS__
function _mac(Class3, params) {
  return new Class3({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_mac, "_mac");
// @__NO_SIDE_EFFECTS__
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_cidrv42, "_cidrv4");
// @__NO_SIDE_EFFECTS__
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_cidrv62, "_cidrv6");
// @__NO_SIDE_EFFECTS__
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_base642, "_base64");
// @__NO_SIDE_EFFECTS__
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_base64url2, "_base64url");
// @__NO_SIDE_EFFECTS__
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_e1642, "_e164");
// @__NO_SIDE_EFFECTS__
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
__name(_jwt2, "_jwt");
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
__name(_isoDateTime2, "_isoDateTime");
// @__NO_SIDE_EFFECTS__
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
__name(_isoDate2, "_isoDate");
// @__NO_SIDE_EFFECTS__
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
__name(_isoTime2, "_isoTime");
// @__NO_SIDE_EFFECTS__
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
__name(_isoDuration2, "_isoDuration");
// @__NO_SIDE_EFFECTS__
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
__name(_number2, "_number");
// @__NO_SIDE_EFFECTS__
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
__name(_coercedNumber2, "_coercedNumber");
// @__NO_SIDE_EFFECTS__
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
__name(_int2, "_int");
// @__NO_SIDE_EFFECTS__
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
__name(_float322, "_float32");
// @__NO_SIDE_EFFECTS__
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
__name(_float642, "_float64");
// @__NO_SIDE_EFFECTS__
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
__name(_int322, "_int32");
// @__NO_SIDE_EFFECTS__
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
__name(_uint322, "_uint32");
// @__NO_SIDE_EFFECTS__
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
__name(_boolean2, "_boolean");
// @__NO_SIDE_EFFECTS__
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
__name(_coercedBoolean2, "_coercedBoolean");
// @__NO_SIDE_EFFECTS__
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
__name(_bigint2, "_bigint");
// @__NO_SIDE_EFFECTS__
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
__name(_coercedBigint2, "_coercedBigint");
// @__NO_SIDE_EFFECTS__
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
__name(_int642, "_int64");
// @__NO_SIDE_EFFECTS__
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
__name(_uint642, "_uint64");
// @__NO_SIDE_EFFECTS__
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
__name(_symbol2, "_symbol");
// @__NO_SIDE_EFFECTS__
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
__name(_undefined5, "_undefined");
// @__NO_SIDE_EFFECTS__
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
__name(_null5, "_null");
// @__NO_SIDE_EFFECTS__
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
__name(_any2, "_any");
// @__NO_SIDE_EFFECTS__
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
__name(_unknown2, "_unknown");
// @__NO_SIDE_EFFECTS__
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
__name(_never2, "_never");
// @__NO_SIDE_EFFECTS__
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
__name(_void3, "_void");
// @__NO_SIDE_EFFECTS__
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
__name(_date2, "_date");
// @__NO_SIDE_EFFECTS__
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
__name(_coercedDate2, "_coercedDate");
// @__NO_SIDE_EFFECTS__
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
__name(_nan2, "_nan");
// @__NO_SIDE_EFFECTS__
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
__name(_lt2, "_lt");
// @__NO_SIDE_EFFECTS__
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
__name(_lte2, "_lte");
// @__NO_SIDE_EFFECTS__
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
__name(_gt2, "_gt");
// @__NO_SIDE_EFFECTS__
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
__name(_gte2, "_gte");
// @__NO_SIDE_EFFECTS__
function _positive2(params) {
  return /* @__PURE__ */ _gt2(0, params);
}
__name(_positive2, "_positive");
// @__NO_SIDE_EFFECTS__
function _negative2(params) {
  return /* @__PURE__ */ _lt2(0, params);
}
__name(_negative2, "_negative");
// @__NO_SIDE_EFFECTS__
function _nonpositive2(params) {
  return /* @__PURE__ */ _lte2(0, params);
}
__name(_nonpositive2, "_nonpositive");
// @__NO_SIDE_EFFECTS__
function _nonnegative2(params) {
  return /* @__PURE__ */ _gte2(0, params);
}
__name(_nonnegative2, "_nonnegative");
// @__NO_SIDE_EFFECTS__
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
__name(_multipleOf2, "_multipleOf");
// @__NO_SIDE_EFFECTS__
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
__name(_maxSize2, "_maxSize");
// @__NO_SIDE_EFFECTS__
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
__name(_minSize2, "_minSize");
// @__NO_SIDE_EFFECTS__
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
__name(_size2, "_size");
// @__NO_SIDE_EFFECTS__
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
__name(_maxLength2, "_maxLength");
// @__NO_SIDE_EFFECTS__
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
__name(_minLength2, "_minLength");
// @__NO_SIDE_EFFECTS__
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
__name(_length2, "_length");
// @__NO_SIDE_EFFECTS__
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
__name(_regex2, "_regex");
// @__NO_SIDE_EFFECTS__
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
__name(_lowercase2, "_lowercase");
// @__NO_SIDE_EFFECTS__
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
__name(_uppercase2, "_uppercase");
// @__NO_SIDE_EFFECTS__
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
__name(_includes2, "_includes");
// @__NO_SIDE_EFFECTS__
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
__name(_startsWith2, "_startsWith");
// @__NO_SIDE_EFFECTS__
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
__name(_endsWith2, "_endsWith");
// @__NO_SIDE_EFFECTS__
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
__name(_property2, "_property");
// @__NO_SIDE_EFFECTS__
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
__name(_mime2, "_mime");
// @__NO_SIDE_EFFECTS__
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
__name(_overwrite2, "_overwrite");
// @__NO_SIDE_EFFECTS__
function _normalize2(form) {
  return /* @__PURE__ */ _overwrite2((input) => input.normalize(form));
}
__name(_normalize2, "_normalize");
// @__NO_SIDE_EFFECTS__
function _trim2() {
  return /* @__PURE__ */ _overwrite2((input) => input.trim());
}
__name(_trim2, "_trim");
// @__NO_SIDE_EFFECTS__
function _toLowerCase2() {
  return /* @__PURE__ */ _overwrite2((input) => input.toLowerCase());
}
__name(_toLowerCase2, "_toLowerCase");
// @__NO_SIDE_EFFECTS__
function _toUpperCase2() {
  return /* @__PURE__ */ _overwrite2((input) => input.toUpperCase());
}
__name(_toUpperCase2, "_toUpperCase");
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite2((input) => slugify(input));
}
__name(_slugify, "_slugify");
// @__NO_SIDE_EFFECTS__
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams2(params)
  });
}
__name(_array2, "_array");
// @__NO_SIDE_EFFECTS__
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
__name(_union2, "_union");
function _xor(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams2(params)
  });
}
__name(_xor, "_xor");
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
__name(_discriminatedUnion2, "_discriminatedUnion");
// @__NO_SIDE_EFFECTS__
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
__name(_intersection2, "_intersection");
// @__NO_SIDE_EFFECTS__
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
__name(_tuple2, "_tuple");
// @__NO_SIDE_EFFECTS__
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
__name(_record2, "_record");
// @__NO_SIDE_EFFECTS__
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
__name(_map2, "_map");
// @__NO_SIDE_EFFECTS__
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
__name(_set2, "_set");
// @__NO_SIDE_EFFECTS__
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
__name(_enum3, "_enum");
// @__NO_SIDE_EFFECTS__
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
__name(_nativeEnum2, "_nativeEnum");
// @__NO_SIDE_EFFECTS__
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
__name(_literal2, "_literal");
// @__NO_SIDE_EFFECTS__
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
__name(_file2, "_file");
// @__NO_SIDE_EFFECTS__
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
__name(_transform2, "_transform");
// @__NO_SIDE_EFFECTS__
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
__name(_optional2, "_optional");
// @__NO_SIDE_EFFECTS__
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
__name(_nullable2, "_nullable");
// @__NO_SIDE_EFFECTS__
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
__name(_default3, "_default");
// @__NO_SIDE_EFFECTS__
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
__name(_nonoptional2, "_nonoptional");
// @__NO_SIDE_EFFECTS__
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
__name(_success2, "_success");
// @__NO_SIDE_EFFECTS__
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch3, "_catch");
// @__NO_SIDE_EFFECTS__
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
__name(_pipe2, "_pipe");
// @__NO_SIDE_EFFECTS__
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
__name(_readonly2, "_readonly");
// @__NO_SIDE_EFFECTS__
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
__name(_templateLiteral2, "_templateLiteral");
// @__NO_SIDE_EFFECTS__
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
__name(_lazy2, "_lazy");
// @__NO_SIDE_EFFECTS__
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
__name(_promise2, "_promise");
// @__NO_SIDE_EFFECTS__
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
__name(_custom2, "_custom");
// @__NO_SIDE_EFFECTS__
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
__name(_refine2, "_refine");
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
__name(_superRefine, "_superRefine");
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
__name(_check, "_check");
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck2({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry2.get(inst) ?? {};
      globalRegistry2.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
__name(describe, "describe");
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck2({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry2.get(inst) ?? {};
      globalRegistry2.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
__name(meta, "meta");
// @__NO_SIDE_EFFECTS__
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: /* @__PURE__ */ __name(((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }), "transform"),
    reverseTransform: /* @__PURE__ */ __name(((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }), "reverseTransform"),
    error: params.error
  });
  return codec2;
}
__name(_stringbool2, "_stringbool");
// @__NO_SIDE_EFFECTS__
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
__name(_stringFormat2, "_stringFormat");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/to-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry2,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
__name(initializeContext, "initializeContext");
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a61;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming2(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a61 = result.schema).default ?? (_a61.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
__name(process2, "process");
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = /* @__PURE__ */ __name((entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, "makeURI");
  const extractToDef = /* @__PURE__ */ __name((entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref: ref2, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref2;
  }, "extractToDef");
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
__name(extractDefs, "extractDefs");
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = /* @__PURE__ */ __name((zodSchema6) => {
    const seen = ctx.seen.get(zodSchema6);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref2 = seen.ref;
    seen.ref = null;
    if (ref2) {
      flattenRef(ref2);
      const refSeen = ctx.seen.get(ref2);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema6._zod.parent === ref2;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema6._zod.parent;
    if (parent && parent !== ref2) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema: zodSchema6,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  }, "flattenRef");
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
__name(finalize, "finalize");
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming2(def.element, ctx);
  if (def.type === "set")
    return isTransforming2(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming2(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming2(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming2(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming2(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming2(item, ctx))
        return true;
    }
    if (def.rest && isTransforming2(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
__name(isTransforming2, "isTransforming");
var createToJSONSchemaMethod = /* @__PURE__ */ __name((schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, "createToJSONSchemaMethod");
var createStandardJSONSchemaMethod = /* @__PURE__ */ __name((schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, "createStandardJSONSchemaMethod");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/json-schema-processors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = /* @__PURE__ */ __name((schema, ctx, _json, _params) => {
  const json3 = _json;
  json3.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minLength = minimum;
  if (typeof maximum === "number")
    json3.maxLength = maximum;
  if (format) {
    json3.format = formatMap[format] ?? format;
    if (json3.format === "")
      delete json3.format;
    if (format === "time") {
      delete json3.format;
    }
  }
  if (contentEncoding)
    json3.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json3.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json3.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
}, "stringProcessor");
var numberProcessor = /* @__PURE__ */ __name((schema, ctx, _json, _params) => {
  const json3 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json3.type = "integer";
  else
    json3.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.minimum = exclusiveMinimum;
      json3.exclusiveMinimum = true;
    } else {
      json3.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json3.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json3.minimum;
      else
        delete json3.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.maximum = exclusiveMaximum;
      json3.exclusiveMaximum = true;
    } else {
      json3.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json3.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json3.maximum;
      else
        delete json3.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json3.multipleOf = multipleOf;
}, "numberProcessor");
var booleanProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
}, "booleanProcessor");
var bigintProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
}, "bigintProcessor");
var symbolProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
}, "symbolProcessor");
var nullProcessor = /* @__PURE__ */ __name((_schema, ctx, json3, _params) => {
  if (ctx.target === "openapi-3.0") {
    json3.type = "string";
    json3.nullable = true;
    json3.enum = [null];
  } else {
    json3.type = "null";
  }
}, "nullProcessor");
var undefinedProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
}, "undefinedProcessor");
var voidProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
}, "voidProcessor");
var neverProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.not = {};
}, "neverProcessor");
var anyProcessor = /* @__PURE__ */ __name((_schema, _ctx, _json, _params) => {
}, "anyProcessor");
var unknownProcessor = /* @__PURE__ */ __name((_schema, _ctx, _json, _params) => {
}, "unknownProcessor");
var dateProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
}, "dateProcessor");
var enumProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues2(def.entries);
  if (values.every((v) => typeof v === "number"))
    json3.type = "number";
  if (values.every((v) => typeof v === "string"))
    json3.type = "string";
  json3.enum = values;
}, "enumProcessor");
var literalProcessor = /* @__PURE__ */ __name((schema, ctx, json3, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json3.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.enum = [val];
    } else {
      json3.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json3.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json3.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json3.type = "boolean";
    if (vals.every((v) => v === null))
      json3.type = "null";
    json3.enum = vals;
  }
}, "literalProcessor");
var nanProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
}, "nanProcessor");
var templateLiteralProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const _json = json3;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
}, "templateLiteralProcessor");
var fileProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const _json = json3;
  const file3 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file3.minLength = minimum;
  if (maximum !== void 0)
    file3.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file3.contentMediaType = mime[0];
      Object.assign(_json, file3);
    } else {
      Object.assign(_json, file3);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file3);
  }
}, "fileProcessor");
var successProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
}, "successProcessor");
var customProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
}, "customProcessor");
var functionProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
}, "functionProcessor");
var transformProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
}, "transformProcessor");
var mapProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
}, "mapProcessor");
var setProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
}, "setProcessor");
var arrayProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
  json3.type = "array";
  json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, "arrayProcessor");
var objectProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  json3.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json3.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json3.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json3.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json3.additionalProperties = false;
  } else if (def.catchall) {
    json3.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
}, "objectProcessor");
var unionProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json3.oneOf = options;
  } else {
    json3.anyOf = options;
  }
}, "unionProcessor");
var intersectionProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json3.allOf = allOf;
}, "intersectionProcessor");
var tupleProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json3.prefixItems = prefixItems;
    if (rest) {
      json3.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json3.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json3.items.anyOf.push(rest);
    }
    json3.minItems = prefixItems.length;
    if (!rest) {
      json3.maxItems = prefixItems.length;
    }
  } else {
    json3.items = prefixItems;
    if (rest) {
      json3.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
}, "tupleProcessor");
var recordProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json3.patternProperties = {};
    for (const pattern of patterns) {
      json3.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json3.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json3.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json3.required = validKeyValues;
    }
  }
}, "recordProcessor");
var nullableProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json3.nullable = true;
  } else {
    json3.anyOf = [inner, { type: "null" }];
  }
}, "nullableProcessor");
var nonoptionalProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "nonoptionalProcessor");
var defaultProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.default = JSON.parse(JSON.stringify(def.defaultValue));
}, "defaultProcessor");
var prefaultProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
}, "prefaultProcessor");
var catchProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json3.default = catchValue;
}, "catchProcessor");
var pipeProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, "pipeProcessor");
var readonlyProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.readOnly = true;
}, "readonlyProcessor");
var promiseProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "promiseProcessor");
var optionalProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "optionalProcessor");
var lazyProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, "lazyProcessor");
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema2(input, params) {
  if ("_idmap" in input) {
    const registry3 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry3._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry3,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry3._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
__name(toJSONSchema2, "toJSONSchema");

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/json-schema-generator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var JSONSchemaGenerator2 = class {
  static {
    __name(this, "JSONSchemaGenerator");
  }
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/zod-from-json-schema/node_modules/zod/v4/core/json-schema.js
var json_schema_exports2 = {};
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/schemas.js
var schemas_exports4 = {};
__export(schemas_exports4, {
  ZodAny: () => ZodAny3,
  ZodArray: () => ZodArray3,
  ZodBase64: () => ZodBase642,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBigInt: () => ZodBigInt3,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBoolean: () => ZodBoolean3,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCUID: () => ZodCUID3,
  ZodCUID2: () => ZodCUID22,
  ZodCatch: () => ZodCatch3,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodDate: () => ZodDate3,
  ZodDefault: () => ZodDefault3,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion3,
  ZodE164: () => ZodE1642,
  ZodEmail: () => ZodEmail2,
  ZodEmoji: () => ZodEmoji2,
  ZodEnum: () => ZodEnum3,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile2,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID2,
  ZodIPv4: () => ZodIPv42,
  ZodIPv6: () => ZodIPv62,
  ZodIntersection: () => ZodIntersection3,
  ZodJWT: () => ZodJWT2,
  ZodKSUID: () => ZodKSUID2,
  ZodLazy: () => ZodLazy3,
  ZodLiteral: () => ZodLiteral3,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap3,
  ZodNaN: () => ZodNaN3,
  ZodNanoID: () => ZodNanoID2,
  ZodNever: () => ZodNever3,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNull: () => ZodNull3,
  ZodNullable: () => ZodNullable3,
  ZodNumber: () => ZodNumber3,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodObject: () => ZodObject3,
  ZodOptional: () => ZodOptional3,
  ZodPipe: () => ZodPipe2,
  ZodPrefault: () => ZodPrefault2,
  ZodPromise: () => ZodPromise3,
  ZodReadonly: () => ZodReadonly3,
  ZodRecord: () => ZodRecord3,
  ZodSet: () => ZodSet3,
  ZodString: () => ZodString3,
  ZodStringFormat: () => ZodStringFormat2,
  ZodSuccess: () => ZodSuccess2,
  ZodSymbol: () => ZodSymbol3,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodTransform: () => ZodTransform2,
  ZodTuple: () => ZodTuple3,
  ZodType: () => ZodType3,
  ZodULID: () => ZodULID2,
  ZodURL: () => ZodURL2,
  ZodUUID: () => ZodUUID2,
  ZodUndefined: () => ZodUndefined3,
  ZodUnion: () => ZodUnion3,
  ZodUnknown: () => ZodUnknown3,
  ZodVoid: () => ZodVoid3,
  ZodXID: () => ZodXID2,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString2,
  _default: () => _default4,
  _function: () => _function2,
  any: () => any2,
  array: () => array2,
  base64: () => base644,
  base64url: () => base64url4,
  bigint: () => bigint6,
  boolean: () => boolean5,
  catch: () => _catch4,
  check: () => check2,
  cidrv4: () => cidrv44,
  cidrv6: () => cidrv64,
  codec: () => codec,
  cuid: () => cuid5,
  cuid2: () => cuid24,
  custom: () => custom3,
  date: () => date7,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion2,
  e164: () => e1644,
  email: () => email4,
  emoji: () => emoji4,
  enum: () => _enum4,
  exactOptional: () => exactOptional,
  file: () => file2,
  float32: () => float322,
  float64: () => float642,
  function: () => _function2,
  guid: () => guid4,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname3,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof2,
  int: () => int2,
  int32: () => int322,
  int64: () => int642,
  intersection: () => intersection2,
  ipv4: () => ipv44,
  ipv6: () => ipv64,
  json: () => json2,
  jwt: () => jwt2,
  keyof: () => keyof2,
  ksuid: () => ksuid4,
  lazy: () => lazy2,
  literal: () => literal2,
  looseObject: () => looseObject2,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map2,
  meta: () => meta2,
  nan: () => nan2,
  nanoid: () => nanoid4,
  nativeEnum: () => nativeEnum2,
  never: () => never2,
  nonoptional: () => nonoptional2,
  null: () => _null6,
  nullable: () => nullable2,
  nullish: () => nullish4,
  number: () => number5,
  object: () => object4,
  optional: () => optional2,
  partialRecord: () => partialRecord2,
  pipe: () => pipe2,
  prefault: () => prefault2,
  preprocess: () => preprocess2,
  promise: () => promise2,
  readonly: () => readonly2,
  record: () => record2,
  refine: () => refine2,
  set: () => set2,
  strictObject: () => strictObject2,
  string: () => string5,
  stringFormat: () => stringFormat2,
  stringbool: () => stringbool2,
  success: () => success2,
  superRefine: () => superRefine2,
  symbol: () => symbol18,
  templateLiteral: () => templateLiteral2,
  transform: () => transform2,
  tuple: () => tuple2,
  uint32: () => uint322,
  uint64: () => uint642,
  ulid: () => ulid4,
  undefined: () => _undefined6,
  union: () => union2,
  unknown: () => unknown2,
  url: () => url2,
  uuid: () => uuid5,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv62,
  uuidv7: () => uuidv72,
  void: () => _void4,
  xid: () => xid4,
  xor: () => xor
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/checks.js
var checks_exports4 = {};
__export(checks_exports4, {
  endsWith: () => _endsWith2,
  gt: () => _gt2,
  gte: () => _gte2,
  includes: () => _includes2,
  length: () => _length2,
  lowercase: () => _lowercase2,
  lt: () => _lt2,
  lte: () => _lte2,
  maxLength: () => _maxLength2,
  maxSize: () => _maxSize2,
  mime: () => _mime2,
  minLength: () => _minLength2,
  minSize: () => _minSize2,
  multipleOf: () => _multipleOf2,
  negative: () => _negative2,
  nonnegative: () => _nonnegative2,
  nonpositive: () => _nonpositive2,
  normalize: () => _normalize2,
  overwrite: () => _overwrite2,
  positive: () => _positive2,
  property: () => _property2,
  regex: () => _regex2,
  size: () => _size2,
  slugify: () => _slugify,
  startsWith: () => _startsWith2,
  toLowerCase: () => _toLowerCase2,
  toUpperCase: () => _toUpperCase2,
  trim: () => _trim2,
  uppercase: () => _uppercase2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  date: () => date6,
  datetime: () => datetime4,
  duration: () => duration4,
  time: () => time4
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
__name(datetime4, "datetime");
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
__name(date6, "date");
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
__name(time4, "time");
var ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}
__name(duration4, "duration");

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var initializer4 = /* @__PURE__ */ __name((inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: /* @__PURE__ */ __name((mapper) => formatError2(inst, mapper), "value")
      // enumerable: false,
    },
    flatten: {
      value: /* @__PURE__ */ __name((mapper) => flattenError2(inst, mapper), "value")
      // enumerable: false,
    },
    addIssue: {
      value: /* @__PURE__ */ __name((issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }, "value")
      // enumerable: false,
    },
    addIssues: {
      value: /* @__PURE__ */ __name((issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }, "value")
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, "initializer");
var ZodError3 = $constructor2("ZodError", initializer4);
var ZodRealError2 = $constructor2("ZodError", initializer4, {
  Parent: Error
});

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/parse.js
var parse4 = /* @__PURE__ */ _parse3(ZodRealError2);
var parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode2 = /* @__PURE__ */ _encode(ZodRealError2);
var decode2 = /* @__PURE__ */ _decode(ZodRealError2);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError2);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError2);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError2);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError2);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError2);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError2);

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/schemas.js
var ZodType3 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports2.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check3, params) => inst.check(refine2(check3, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default4(inst, def2);
  inst.prefault = (def2) => prefault2(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry2.get(inst);
    }
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString3 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime4(params));
  inst.date = (params) => inst.check(date6(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration4(params));
});
function string5(params) {
  return _string2(ZodString3, params);
}
__name(string5, "string");
var ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  _ZodString2.init(inst, def);
});
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function email4(params) {
  return _email2(ZodEmail2, params);
}
__name(email4, "email");
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
__name(guid4, "guid");
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
__name(uuid5, "uuid");
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
__name(uuidv42, "uuidv4");
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
__name(uuidv62, "uuidv6");
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
__name(uuidv72, "uuidv7");
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function url2(params) {
  return _url2(ZodURL2, params);
}
__name(url2, "url");
function httpUrl(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: regexes_exports2.domain,
    ...util_exports2.normalizeParams(params)
  });
}
__name(httpUrl, "httpUrl");
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
__name(emoji4, "emoji");
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
__name(nanoid4, "nanoid");
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid5(params) {
  return _cuid3(ZodCUID3, params);
}
__name(cuid5, "cuid");
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
__name(cuid24, "cuid2");
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
__name(ulid4, "ulid");
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function xid4(params) {
  return _xid2(ZodXID2, params);
}
__name(xid4, "xid");
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
__name(ksuid4, "ksuid");
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
__name(ipv44, "ipv4");
var ZodMAC = /* @__PURE__ */ $constructor2("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
__name(mac2, "mac");
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
__name(ipv64, "ipv6");
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
__name(cidrv44, "cidrv4");
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
__name(cidrv64, "cidrv6");
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base644(params) {
  return _base642(ZodBase642, params);
}
__name(base644, "base64");
var ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
__name(base64url4, "base64url");
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function e1644(params) {
  return _e1642(ZodE1642, params);
}
__name(e1644, "e164");
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
__name(jwt2, "jwt");
var ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
__name(stringFormat2, "stringFormat");
function hostname3(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", regexes_exports2.hostname, _params);
}
__name(hostname3, "hostname");
function hex2(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", regexes_exports2.hex, _params);
}
__name(hex2, "hex");
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
__name(hash, "hash");
var ZodNumber3 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt2(0, params));
  inst.nonnegative = (params) => inst.check(_gte2(0, params));
  inst.negative = (params) => inst.check(_lt2(0, params));
  inst.nonpositive = (params) => inst.check(_lte2(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  inst.step = (value, params) => inst.check(_multipleOf2(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number5(params) {
  return _number2(ZodNumber3, params);
}
__name(number5, "number");
var ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodNumber3.init(inst, def);
});
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
__name(int2, "int");
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
__name(float322, "float32");
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
__name(float642, "float64");
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
__name(int322, "int32");
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
__name(uint322, "uint32");
var ZodBoolean3 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
});
function boolean5(params) {
  return _boolean2(ZodBoolean3, params);
}
__name(boolean5, "boolean");
var ZodBigInt3 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint6(params) {
  return _bigint2(ZodBigInt3, params);
}
__name(bigint6, "bigint");
var ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodBigInt3.init(inst, def);
});
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
__name(int642, "int64");
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
__name(uint642, "uint64");
var ZodSymbol3 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
});
function symbol18(params) {
  return _symbol2(ZodSymbol3, params);
}
__name(symbol18, "symbol");
var ZodUndefined3 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
});
function _undefined6(params) {
  return _undefined5(ZodUndefined3, params);
}
__name(_undefined6, "_undefined");
var ZodNull3 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
});
function _null6(params) {
  return _null5(ZodNull3, params);
}
__name(_null6, "_null");
var ZodAny3 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
});
function any2() {
  return _any2(ZodAny3);
}
__name(any2, "any");
var ZodUnknown3 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
});
function unknown2() {
  return _unknown2(ZodUnknown3);
}
__name(unknown2, "unknown");
var ZodNever3 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
});
function never2(params) {
  return _never2(ZodNever3, params);
}
__name(never2, "never");
var ZodVoid3 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
});
function _void4(params) {
  return _void3(ZodVoid3, params);
}
__name(_void4, "_void");
var ZodDate3 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date7(params) {
  return _date2(ZodDate3, params);
}
__name(date7, "date");
var ZodArray3 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray3, element, params);
}
__name(array2, "array");
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
__name(keyof2, "keyof");
var ZodObject3 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
  util_exports2.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports2.merge(inst, other);
  inst.pick = (mask) => util_exports2.pick(inst, mask);
  inst.omit = (mask) => util_exports2.omit(inst, mask);
  inst.partial = (...args) => util_exports2.partial(ZodOptional3, inst, args[0]);
  inst.required = (...args) => util_exports2.required(ZodNonOptional2, inst, args[0]);
});
function object4(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports2.normalizeParams(params)
  };
  return new ZodObject3(def);
}
__name(object4, "object");
function strictObject2(shape, params) {
  return new ZodObject3({
    type: "object",
    shape,
    catchall: never2(),
    ...util_exports2.normalizeParams(params)
  });
}
__name(strictObject2, "strictObject");
function looseObject2(shape, params) {
  return new ZodObject3({
    type: "object",
    shape,
    catchall: unknown2(),
    ...util_exports2.normalizeParams(params)
  });
}
__name(looseObject2, "looseObject");
var ZodUnion3 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion3({
    type: "union",
    options,
    ...util_exports2.normalizeParams(params)
  });
}
__name(union2, "union");
var ZodXor = /* @__PURE__ */ $constructor2("ZodXor", (inst, def) => {
  ZodUnion3.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports2.normalizeParams(params)
  });
}
__name(xor, "xor");
var ZodDiscriminatedUnion3 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion3.init(inst, def);
  $ZodDiscriminatedUnion2.init(inst, def);
});
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion3({
    type: "union",
    options,
    discriminator,
    ...util_exports2.normalizeParams(params)
  });
}
__name(discriminatedUnion2, "discriminatedUnion");
var ZodIntersection3 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
});
function intersection2(left, right) {
  return new ZodIntersection3({
    type: "intersection",
    left,
    right
  });
}
__name(intersection2, "intersection");
var ZodTuple3 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple3({
    type: "tuple",
    items,
    rest,
    ...util_exports2.normalizeParams(params)
  });
}
__name(tuple2, "tuple");
var ZodRecord3 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord3({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(record2, "record");
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = void 0;
  return new ZodRecord3({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(partialRecord2, "partialRecord");
function looseRecord(keyType, valueType, params) {
  return new ZodRecord3({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports2.normalizeParams(params)
  });
}
__name(looseRecord, "looseRecord");
var ZodMap3 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function map2(keyType, valueType, params) {
  return new ZodMap3({
    type: "map",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(map2, "map");
var ZodSet3 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function set2(valueType, params) {
  return new ZodSet3({
    type: "set",
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(set2, "set");
var ZodEnum3 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum3({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum3({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum3({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
__name(_enum4, "_enum");
function nativeEnum2(entries, params) {
  return new ZodEnum3({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
__name(nativeEnum2, "nativeEnum");
var ZodLiteral3 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports2.normalizeParams(params)
  });
}
__name(literal2, "literal");
var ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
  inst.min = (size, params) => inst.check(_minSize2(size, params));
  inst.max = (size, params) => inst.check(_maxSize2(size, params));
  inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file2(ZodFile2, params);
}
__name(file2, "file");
var ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(util_exports2.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
__name(transform2, "transform");
var ZodOptional3 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional3({
    type: "optional",
    innerType
  });
}
__name(optional2, "optional");
var ZodExactOptional = /* @__PURE__ */ $constructor2("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
__name(exactOptional, "exactOptional");
var ZodNullable3 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable3({
    type: "nullable",
    innerType
  });
}
__name(nullable2, "nullable");
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
__name(nullish4, "nullish");
var ZodDefault3 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default4(innerType, defaultValue) {
  return new ZodDefault3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
__name(_default4, "_default");
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
__name(prefault2, "prefault");
var ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(nonoptional2, "nonoptional");
var ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
__name(success2, "success");
var ZodCatch3 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch4, "_catch");
var ZodNaN3 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
});
function nan2(params) {
  return _nan2(ZodNaN3, params);
}
__name(nan2, "nan");
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
__name(pipe2, "pipe");
var ZodCodec = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
  ZodPipe2.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
__name(codec, "codec");
var ZodReadonly3 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly3({
    type: "readonly",
    innerType
  });
}
__name(readonly2, "readonly");
var ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
});
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...util_exports2.normalizeParams(params)
  });
}
__name(templateLiteral2, "templateLiteral");
var ZodLazy3 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy2(getter) {
  return new ZodLazy3({
    type: "lazy",
    getter
  });
}
__name(lazy2, "lazy");
var ZodPromise3 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise2(innerType) {
  return new ZodPromise3({
    type: "promise",
    innerType
  });
}
__name(promise2, "promise");
var ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
  $ZodFunction2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
});
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
__name(_function2, "_function");
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType3.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
});
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
__name(check2, "check");
function custom3(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
__name(custom3, "custom");
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
__name(refine2, "refine");
function superRefine2(fn) {
  return _superRefine(fn);
}
__name(superRefine2, "superRefine");
var describe2 = describe;
var meta2 = meta;
function _instanceof2(cls, params = {}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
__name(_instanceof2, "_instanceof");
var stringbool2 = /* @__PURE__ */ __name((...args) => _stringbool2({
  Codec: ZodCodec,
  Boolean: ZodBoolean3,
  String: ZodString3
}, ...args), "stringbool");
function json2(params) {
  const jsonSchema6 = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema6), record2(string5(), jsonSchema6)]);
  });
  return jsonSchema6;
}
__name(json2, "json");
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
__name(preprocess2, "preprocess");

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var ZodIssueCode3 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap3(map3) {
  config3({
    customError: map3
  });
}
__name(setErrorMap3, "setErrorMap");
function getErrorMap3() {
  return config3().customError;
}
__name(getErrorMap3, "getErrorMap");
var ZodFirstPartyTypeKind2;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/from-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var z = {
  ...schemas_exports4,
  ...checks_exports4,
  iso: iso_exports2
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
__name(detectVersion, "detectVersion");
function resolveRef(ref2, ctx) {
  if (!ref2.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path3 = ref2.slice(1).split("/").filter(Boolean);
  if (path3.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path3[0] === defsKey) {
    const key = path3[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref2}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref2}`);
}
__name(resolveRef, "resolveRef");
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema7 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema7);
    ctx.processing.delete(refPath);
    return zodSchema7;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema6;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema6 = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema6 = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema6 = z.boolean();
      break;
    }
    case "null": {
      zodSchema6 = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema6 = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema6 = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema6 = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema6 = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema6 = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema6 = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema6 = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema6 = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema6 = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema6 = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema6 = zodSchema6.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema6 = zodSchema6.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema6 = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema6 = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema6 = zodSchema6.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema6 = zodSchema6.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema6 = arraySchema;
      } else {
        zodSchema6 = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema6 = zodSchema6.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema6 = zodSchema6.default(schema.default);
  }
  return zodSchema6;
}
__name(convertBaseSchema, "convertBaseSchema");
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
__name(convertSchema, "convertSchema");
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version4 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version4,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry2
  };
  return convertSchema(schema, ctx);
}
__name(fromJSONSchema, "fromJSONSchema");

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint7,
  boolean: () => boolean6,
  date: () => date8,
  number: () => number6,
  string: () => string6
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function string6(params) {
  return _coercedString2(ZodString3, params);
}
__name(string6, "string");
function number6(params) {
  return _coercedNumber2(ZodNumber3, params);
}
__name(number6, "number");
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean3, params);
}
__name(boolean6, "boolean");
function bigint7(params) {
  return _coercedBigint2(ZodBigInt3, params);
}
__name(bigint7, "bigint");
function date8(params) {
  return _coercedDate2(ZodDate3, params);
}
__name(date8, "date");

// node_modules/zod-from-json-schema/node_modules/zod/v4/classic/external.js
config3(en_default3());

// node_modules/zod-from-json-schema/dist/index.mjs
var TypeHandler = class {
  static {
    __name(this, "TypeHandler");
  }
  apply(types, schema) {
    if (!schema.type) return;
    const allowedTypes = Array.isArray(schema.type) ? schema.type : [schema.type];
    const typeSet = new Set(allowedTypes);
    if (!typeSet.has("string")) {
      types.string = false;
    }
    if (!typeSet.has("number") && !typeSet.has("integer")) {
      types.number = false;
    }
    if (!typeSet.has("boolean")) {
      types.boolean = false;
    }
    if (!typeSet.has("null")) {
      types.null = false;
    }
    if (!typeSet.has("array")) {
      types.array = false;
    }
    if (!typeSet.has("object")) {
      types.object = false;
    }
    if (typeSet.has("integer") && types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        types.number = currentNumber.int();
      }
    }
  }
};
var ConstHandler = class {
  static {
    __name(this, "ConstHandler");
  }
  apply(types, schema) {
    if (schema.const === void 0) return;
    const constValue = schema.const;
    types.string = false;
    types.number = false;
    types.boolean = false;
    types.null = false;
    types.array = false;
    types.object = false;
    if (typeof constValue === "string") {
      types.string = external_exports3.literal(constValue);
    } else if (typeof constValue === "number") {
      types.number = external_exports3.literal(constValue);
    } else if (typeof constValue === "boolean") {
      types.boolean = external_exports3.literal(constValue);
    } else if (constValue === null) {
      types.null = external_exports3.null();
    } else if (Array.isArray(constValue)) {
      types.array = void 0;
    } else if (typeof constValue === "object") {
      types.object = void 0;
    }
  }
};
var EnumHandler = class {
  static {
    __name(this, "EnumHandler");
  }
  apply(types, schema) {
    if (!schema.enum) return;
    if (schema.enum.length === 0) {
      if (!schema.type) {
        types.string = false;
        types.number = false;
        types.boolean = false;
        types.null = false;
        types.array = false;
        types.object = false;
      }
      return;
    }
    const valuesByType = {
      string: schema.enum.filter((v) => typeof v === "string"),
      number: schema.enum.filter((v) => typeof v === "number"),
      boolean: schema.enum.filter((v) => typeof v === "boolean"),
      null: schema.enum.filter((v) => v === null),
      array: schema.enum.filter((v) => Array.isArray(v)),
      object: schema.enum.filter((v) => typeof v === "object" && v !== null && !Array.isArray(v))
    };
    types.string = this.createTypeSchema(valuesByType.string, "string");
    types.number = this.createTypeSchema(valuesByType.number, "number");
    types.boolean = this.createTypeSchema(valuesByType.boolean, "boolean");
    types.null = valuesByType.null.length > 0 ? external_exports3.null() : false;
    types.array = valuesByType.array.length > 0 ? void 0 : false;
    types.object = valuesByType.object.length > 0 ? void 0 : false;
  }
  createTypeSchema(values, type) {
    if (values.length === 0) return false;
    if (values.length === 1) {
      return external_exports3.literal(values[0]);
    }
    if (type === "string") {
      return external_exports3.enum(values);
    }
    if (type === "number") {
      const [first, second, ...rest] = values;
      return external_exports3.union([external_exports3.literal(first), external_exports3.literal(second), ...rest.map((v) => external_exports3.literal(v))]);
    }
    if (type === "boolean") {
      return external_exports3.union([external_exports3.literal(true), external_exports3.literal(false)]);
    }
    return false;
  }
};
var FileHandler = class {
  static {
    __name(this, "FileHandler");
  }
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.type === "string" && stringSchema.format === "binary" && stringSchema.contentEncoding === "binary") {
      let fileSchema = external_exports3.file();
      if (stringSchema.minLength !== void 0) {
        fileSchema = fileSchema.min(stringSchema.minLength);
      }
      if (stringSchema.maxLength !== void 0) {
        fileSchema = fileSchema.max(stringSchema.maxLength);
      }
      if (stringSchema.contentMediaType !== void 0) {
        fileSchema = fileSchema.mime(stringSchema.contentMediaType);
      }
      types.file = fileSchema;
      types.string = false;
    }
  }
};
var ImplicitStringHandler = class {
  static {
    __name(this, "ImplicitStringHandler");
  }
  apply(types, schema) {
    const stringSchema = schema;
    if (schema.type === void 0 && (stringSchema.minLength !== void 0 || stringSchema.maxLength !== void 0 || stringSchema.pattern !== void 0)) {
      if (types.string === void 0) {
        types.string = external_exports3.string();
      }
    }
  }
};
var MinLengthHandler = class {
  static {
    __name(this, "MinLengthHandler");
  }
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.minLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || external_exports3.string();
      if (currentString instanceof external_exports3.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength >= stringSchema.minLength;
          },
          { message: `String must be at least ${stringSchema.minLength} characters long` }
        );
      }
    }
  }
};
var MaxLengthHandler = class {
  static {
    __name(this, "MaxLengthHandler");
  }
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.maxLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || external_exports3.string();
      if (currentString instanceof external_exports3.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength <= stringSchema.maxLength;
          },
          { message: `String must be at most ${stringSchema.maxLength} characters long` }
        );
      }
    }
  }
};
var PatternHandler = class {
  static {
    __name(this, "PatternHandler");
  }
  apply(types, schema) {
    const stringSchema = schema;
    if (!stringSchema.pattern) return;
    if (types.string !== false) {
      const currentString = types.string || external_exports3.string();
      if (currentString instanceof external_exports3.ZodString) {
        const regex = new RegExp(stringSchema.pattern);
        types.string = currentString.regex(regex);
      }
    }
  }
};
var MinimumHandler = class {
  static {
    __name(this, "MinimumHandler");
  }
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.minimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        types.number = currentNumber.min(numberSchema.minimum);
      }
    }
  }
};
var MaximumHandler = class {
  static {
    __name(this, "MaximumHandler");
  }
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.maximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        types.number = currentNumber.max(numberSchema.maximum);
      }
    }
  }
};
var ExclusiveMinimumHandler = class {
  static {
    __name(this, "ExclusiveMinimumHandler");
  }
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMinimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        if (typeof numberSchema.exclusiveMinimum === "number") {
          types.number = currentNumber.gt(numberSchema.exclusiveMinimum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var ExclusiveMaximumHandler = class {
  static {
    __name(this, "ExclusiveMaximumHandler");
  }
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMaximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        if (typeof numberSchema.exclusiveMaximum === "number") {
          types.number = currentNumber.lt(numberSchema.exclusiveMaximum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var MultipleOfHandler = class {
  static {
    __name(this, "MultipleOfHandler");
  }
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.multipleOf === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || external_exports3.number();
      if (currentNumber instanceof external_exports3.ZodNumber) {
        types.number = currentNumber.refine(
          (value) => {
            if (numberSchema.multipleOf === 0) return false;
            const quotient = value / numberSchema.multipleOf;
            const rounded = Math.round(quotient);
            const tolerance = Math.min(
              Math.abs(value) * Number.EPSILON * 10,
              Math.abs(numberSchema.multipleOf) * Number.EPSILON * 10
            );
            return Math.abs(quotient - rounded) <= tolerance / Math.abs(numberSchema.multipleOf);
          },
          { message: `Must be a multiple of ${numberSchema.multipleOf}` }
        );
      }
    }
  }
};
var ImplicitArrayHandler = class {
  static {
    __name(this, "ImplicitArrayHandler");
  }
  apply(types, schema) {
    const arraySchema = schema;
    if (schema.type === void 0 && (arraySchema.minItems !== void 0 || arraySchema.maxItems !== void 0 || arraySchema.items !== void 0 || arraySchema.prefixItems !== void 0)) {
      if (types.array === void 0) {
        types.array = external_exports3.array(external_exports3.any());
      }
    }
  }
};
var MinItemsHandler = class {
  static {
    __name(this, "MinItemsHandler");
  }
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.minItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || external_exports3.array(external_exports3.any())).min(arraySchema.minItems);
    }
  }
};
var MaxItemsHandler = class {
  static {
    __name(this, "MaxItemsHandler");
  }
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.maxItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || external_exports3.array(external_exports3.any())).max(arraySchema.maxItems);
    }
  }
};
var ItemsHandler = class {
  static {
    __name(this, "ItemsHandler");
  }
  apply(types, schema) {
    const arraySchema = schema;
    if (types.array === false) return;
    if (Array.isArray(arraySchema.items)) {
      types.array = types.array || external_exports3.array(external_exports3.any());
    } else if (arraySchema.items && typeof arraySchema.items !== "boolean" && !arraySchema.prefixItems) {
      const itemSchema = convertJsonSchemaToZod(arraySchema.items);
      let newArray = external_exports3.array(itemSchema);
      if (types.array && types.array instanceof external_exports3.ZodArray) {
        const existingDef = types.array._def;
        if (existingDef.checks) {
          existingDef.checks.forEach((check3) => {
            if (check3._zod && check3._zod.def) {
              const def = check3._zod.def;
              if (def.check === "min_length" && def.minimum !== void 0) {
                newArray = newArray.min(def.minimum);
              } else if (def.check === "max_length" && def.maximum !== void 0) {
                newArray = newArray.max(def.maximum);
              }
            }
          });
        }
      }
      types.array = newArray;
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
      if (!arraySchema.prefixItems) {
        types.array = external_exports3.array(external_exports3.any()).max(0);
      } else {
        types.array = types.array || external_exports3.array(external_exports3.any());
      }
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === true) {
      types.array = types.array || external_exports3.array(external_exports3.any());
    } else if (arraySchema.prefixItems) {
      types.array = types.array || external_exports3.array(external_exports3.any());
    }
  }
};
var TupleHandler = class {
  static {
    __name(this, "TupleHandler");
  }
  apply(types, schema) {
    if (schema.type !== "array") return;
    const arraySchema = schema;
    if (!Array.isArray(arraySchema.items)) return;
    if (types.array === false) return;
    const itemSchemas = arraySchema.items.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
    let tuple3;
    if (itemSchemas.length === 0) {
      tuple3 = external_exports3.tuple([]);
    } else {
      tuple3 = external_exports3.tuple(itemSchemas);
    }
    if (arraySchema.minItems !== void 0 && arraySchema.minItems > itemSchemas.length) {
      tuple3 = false;
    }
    if (arraySchema.maxItems !== void 0 && arraySchema.maxItems < itemSchemas.length) {
      tuple3 = false;
    }
    types.tuple = tuple3;
    types.array = false;
  }
};
var PropertiesHandler = class {
  static {
    __name(this, "PropertiesHandler");
  }
  apply(types, schema) {
    const objectSchema = schema;
    if (types.object === false) return;
    if (objectSchema.properties || objectSchema.required || objectSchema.additionalProperties !== void 0) {
      types.object = types.object || external_exports3.object({}).passthrough();
    }
  }
};
var ImplicitObjectHandler = class {
  static {
    __name(this, "ImplicitObjectHandler");
  }
  apply(types, schema) {
    const objectSchema = schema;
    if (schema.type === void 0 && (objectSchema.maxProperties !== void 0 || objectSchema.minProperties !== void 0)) {
      if (types.object === void 0) {
        types.object = external_exports3.object({}).passthrough();
      }
    }
  }
};
var MaxPropertiesHandler = class {
  static {
    __name(this, "MaxPropertiesHandler");
  }
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.maxProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || external_exports3.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length <= objectSchema.maxProperties,
        { message: `Object must have at most ${objectSchema.maxProperties} properties` }
      );
    }
  }
};
var MinPropertiesHandler = class {
  static {
    __name(this, "MinPropertiesHandler");
  }
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.minProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || external_exports3.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length >= objectSchema.minProperties,
        { message: `Object must have at least ${objectSchema.minProperties} properties` }
      );
    }
  }
};
function deepEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return a === b;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => deepEqual(item, b[index]));
  }
  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));
  }
  return false;
}
__name(deepEqual, "deepEqual");
function createUniqueItemsValidator() {
  return (value) => {
    if (!Array.isArray(value)) {
      return true;
    }
    const seen = [];
    return value.every((item) => {
      const isDuplicate = seen.some((seenItem) => deepEqual(item, seenItem));
      if (isDuplicate) {
        return false;
      }
      seen.push(item);
      return true;
    });
  };
}
__name(createUniqueItemsValidator, "createUniqueItemsValidator");
function isValidWithSchema(schema, value) {
  return schema.safeParse(value).success;
}
__name(isValidWithSchema, "isValidWithSchema");
var NotHandler = class {
  static {
    __name(this, "NotHandler");
  }
  apply(zodSchema6, schema) {
    if (!schema.not) return zodSchema6;
    const notSchema = convertJsonSchemaToZod(schema.not);
    return zodSchema6.refine(
      (value) => !isValidWithSchema(notSchema, value),
      { message: "Value must not match the 'not' schema" }
    );
  }
};
var UniqueItemsHandler = class {
  static {
    __name(this, "UniqueItemsHandler");
  }
  apply(zodSchema6, schema) {
    const arraySchema = schema;
    if (arraySchema.uniqueItems !== true) return zodSchema6;
    return zodSchema6.refine(createUniqueItemsValidator(), {
      message: "Array items must be unique"
    });
  }
};
var AllOfHandler = class {
  static {
    __name(this, "AllOfHandler");
  }
  apply(zodSchema6, schema) {
    if (!schema.allOf || schema.allOf.length === 0) return zodSchema6;
    const allOfSchemas = schema.allOf.map((s) => convertJsonSchemaToZod(s));
    return allOfSchemas.reduce(
      (acc, s) => external_exports3.intersection(acc, s),
      zodSchema6
    );
  }
};
var AnyOfHandler = class {
  static {
    __name(this, "AnyOfHandler");
  }
  apply(zodSchema6, schema) {
    if (!schema.anyOf || schema.anyOf.length === 0) return zodSchema6;
    const anyOfSchema = schema.anyOf.length === 1 ? convertJsonSchemaToZod(schema.anyOf[0]) : external_exports3.union([
      convertJsonSchemaToZod(schema.anyOf[0]),
      convertJsonSchemaToZod(schema.anyOf[1]),
      ...schema.anyOf.slice(2).map((s) => convertJsonSchemaToZod(s))
    ]);
    return external_exports3.intersection(zodSchema6, anyOfSchema);
  }
};
var OneOfHandler = class {
  static {
    __name(this, "OneOfHandler");
  }
  apply(zodSchema6, schema) {
    if (!schema.oneOf || schema.oneOf.length === 0) return zodSchema6;
    const oneOfSchemas = schema.oneOf.map((s) => convertJsonSchemaToZod(s));
    return zodSchema6.refine(
      (value) => {
        let validCount = 0;
        for (const oneOfSchema of oneOfSchemas) {
          const result = oneOfSchema.safeParse(value);
          if (result.success) {
            validCount++;
            if (validCount > 1) return false;
          }
        }
        return validCount === 1;
      },
      { message: "Value must match exactly one of the oneOf schemas" }
    );
  }
};
var PrefixItemsHandler = class {
  static {
    __name(this, "PrefixItemsHandler");
  }
  apply(zodSchema6, schema) {
    const arraySchema = schema;
    if (arraySchema.prefixItems && Array.isArray(arraySchema.prefixItems)) {
      const prefixItems = arraySchema.prefixItems;
      const prefixSchemas = prefixItems.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
      return zodSchema6.refine(
        (value) => {
          if (!Array.isArray(value)) return true;
          for (let i = 0; i < Math.min(value.length, prefixSchemas.length); i++) {
            if (!isValidWithSchema(prefixSchemas[i], value[i])) {
              return false;
            }
          }
          if (value.length > prefixSchemas.length) {
            if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
              return false;
            } else if (arraySchema.items && typeof arraySchema.items === "object" && !Array.isArray(arraySchema.items)) {
              const additionalItemSchema = convertJsonSchemaToZod(arraySchema.items);
              for (let i = prefixSchemas.length; i < value.length; i++) {
                if (!isValidWithSchema(additionalItemSchema, value[i])) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        { message: "Array does not match prefixItems schema" }
      );
    }
    return zodSchema6;
  }
};
var ObjectPropertiesHandler = class {
  static {
    __name(this, "ObjectPropertiesHandler");
  }
  apply(zodSchema6, schema) {
    const objectSchema = schema;
    if (!objectSchema.properties && !objectSchema.required && objectSchema.additionalProperties !== false) {
      return zodSchema6;
    }
    if (zodSchema6 instanceof external_exports3.ZodObject || zodSchema6 instanceof external_exports3.ZodRecord) {
      const shape = {};
      if (objectSchema.properties) {
        for (const [key, propSchema] of Object.entries(objectSchema.properties)) {
          if (propSchema !== void 0) {
            shape[key] = convertJsonSchemaToZod(propSchema);
          }
        }
      }
      if (objectSchema.required && Array.isArray(objectSchema.required)) {
        const required3 = new Set(objectSchema.required);
        for (const key of Object.keys(shape)) {
          if (!required3.has(key)) {
            shape[key] = shape[key].optional();
          }
        }
      } else {
        for (const key of Object.keys(shape)) {
          shape[key] = shape[key].optional();
        }
      }
      if (objectSchema.additionalProperties === false) {
        return external_exports3.object(shape);
      } else {
        return external_exports3.object(shape).passthrough();
      }
    }
    return zodSchema6.refine(
      (value) => {
        if (typeof value !== "object" || value === null || Array.isArray(value)) {
          return true;
        }
        if (objectSchema.properties) {
          for (const [propName, propSchema] of Object.entries(objectSchema.properties)) {
            if (propSchema !== void 0) {
              const propExists = Object.getOwnPropertyDescriptor(value, propName) !== void 0;
              if (propExists) {
                const zodPropSchema = convertJsonSchemaToZod(propSchema);
                const propResult = zodPropSchema.safeParse(value[propName]);
                if (!propResult.success) {
                  return false;
                }
              }
            }
          }
        }
        if (objectSchema.required && Array.isArray(objectSchema.required)) {
          for (const requiredProp of objectSchema.required) {
            const propExists = Object.getOwnPropertyDescriptor(value, requiredProp) !== void 0;
            if (!propExists) {
              return false;
            }
          }
        }
        if (objectSchema.additionalProperties === false && objectSchema.properties) {
          const allowedProps = new Set(Object.keys(objectSchema.properties));
          for (const prop in value) {
            if (!allowedProps.has(prop)) {
              return false;
            }
          }
        }
        return true;
      },
      { message: "Object constraints validation failed" }
    );
  }
};
var EnumComplexHandler = class {
  static {
    __name(this, "EnumComplexHandler");
  }
  apply(zodSchema6, schema) {
    if (!schema.enum || schema.enum.length === 0) return zodSchema6;
    const complexValues = schema.enum.filter(
      (v) => Array.isArray(v) || typeof v === "object" && v !== null
    );
    if (complexValues.length === 0) return zodSchema6;
    return zodSchema6.refine(
      (value) => {
        if (typeof value !== "object" || value === null) return true;
        return complexValues.some(
          (enumValue) => deepEqual(value, enumValue)
        );
      },
      { message: "Value must match one of the enum values" }
    );
  }
};
var ConstComplexHandler = class {
  static {
    __name(this, "ConstComplexHandler");
  }
  apply(zodSchema6, schema) {
    if (schema.const === void 0) return zodSchema6;
    const constValue = schema.const;
    if (typeof constValue !== "object" || constValue === null) {
      return zodSchema6;
    }
    return zodSchema6.refine(
      (value) => deepEqual(value, constValue),
      { message: "Value must equal the const value" }
    );
  }
};
var MetadataHandler = class {
  static {
    __name(this, "MetadataHandler");
  }
  apply(zodSchema6, schema) {
    if (schema.description) {
      zodSchema6 = zodSchema6.describe(schema.description);
    }
    return zodSchema6;
  }
};
var ProtoRequiredHandler = class {
  static {
    __name(this, "ProtoRequiredHandler");
  }
  apply(zodSchema6, schema) {
    var _a61;
    const objectSchema = schema;
    if (!((_a61 = objectSchema.required) == null ? void 0 : _a61.includes("__proto__")) || schema.type !== void 0) {
      return zodSchema6;
    }
    return external_exports3.any().refine(
      (value) => this.validateRequired(value, objectSchema.required),
      { message: "Missing required properties" }
    );
  }
  validateRequired(value, required3) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      return true;
    }
    return required3.every(
      (prop) => Object.prototype.hasOwnProperty.call(value, prop)
    );
  }
};
var ContainsHandler = class {
  static {
    __name(this, "ContainsHandler");
  }
  apply(zodSchema6, schema) {
    var _a61;
    const arraySchema = schema;
    if (arraySchema.contains === void 0) return zodSchema6;
    const containsSchema = convertJsonSchemaToZod(arraySchema.contains);
    const minContains = (_a61 = arraySchema.minContains) != null ? _a61 : 1;
    const maxContains = arraySchema.maxContains;
    return zodSchema6.refine(
      (value) => {
        if (!Array.isArray(value)) {
          return true;
        }
        let matchCount = 0;
        for (const item of value) {
          if (isValidWithSchema(containsSchema, item)) {
            matchCount++;
          }
        }
        if (matchCount < minContains) {
          return false;
        }
        if (maxContains !== void 0 && matchCount > maxContains) {
          return false;
        }
        return true;
      },
      { message: "Array must contain required items matching the schema" }
    );
  }
};
var DefaultHandler = class {
  static {
    __name(this, "DefaultHandler");
  }
  apply(zodSchema6, schema) {
    const { default: v } = schema;
    if (v === void 0) return zodSchema6;
    if (!zodSchema6.safeParse(v).success) {
      return zodSchema6;
    }
    return zodSchema6.default(v);
  }
};
var primitiveHandlers = [
  // Type constraints - should run first
  new ConstHandler(),
  new EnumHandler(),
  new TypeHandler(),
  // File schema detection - must run before string constraints
  new FileHandler(),
  // Implicit type detection - must run before other constraints
  new ImplicitStringHandler(),
  new ImplicitArrayHandler(),
  new ImplicitObjectHandler(),
  // String constraints
  new MinLengthHandler(),
  new MaxLengthHandler(),
  new PatternHandler(),
  // Number constraints
  new MinimumHandler(),
  new MaximumHandler(),
  new ExclusiveMinimumHandler(),
  new ExclusiveMaximumHandler(),
  new MultipleOfHandler(),
  // Array constraints - TupleHandler must run before ItemsHandler
  new TupleHandler(),
  new MinItemsHandler(),
  new MaxItemsHandler(),
  new ItemsHandler(),
  // Object constraints
  new MaxPropertiesHandler(),
  new MinPropertiesHandler(),
  new PropertiesHandler()
];
var refinementHandlers = [
  // Handle special cases first
  new ProtoRequiredHandler(),
  new EnumComplexHandler(),
  new ConstComplexHandler(),
  // Logical combinations
  new AllOfHandler(),
  new AnyOfHandler(),
  new OneOfHandler(),
  // Type-specific refinements
  new PrefixItemsHandler(),
  new ObjectPropertiesHandler(),
  // Array refinements
  new ContainsHandler(),
  // Other refinements
  new NotHandler(),
  new UniqueItemsHandler(),
  new DefaultHandler(),
  // Metadata last
  new MetadataHandler()
];
function convertJsonSchemaToZod(schema) {
  if (typeof schema === "boolean") {
    return schema ? external_exports3.any() : external_exports3.never();
  }
  const types = {};
  for (const handler of primitiveHandlers) {
    handler.apply(types, schema);
  }
  const allowedSchemas = [];
  if (types.string !== false) {
    allowedSchemas.push(types.string || external_exports3.string());
  }
  if (types.number !== false) {
    allowedSchemas.push(types.number || external_exports3.number());
  }
  if (types.boolean !== false) {
    allowedSchemas.push(types.boolean || external_exports3.boolean());
  }
  if (types.null !== false) {
    allowedSchemas.push(types.null || external_exports3.null());
  }
  if (types.array !== false) {
    allowedSchemas.push(types.array || external_exports3.array(external_exports3.any()));
  }
  if (types.tuple !== false && types.tuple !== void 0) {
    allowedSchemas.push(types.tuple);
  }
  if (types.object !== false) {
    if (types.object) {
      allowedSchemas.push(types.object);
    } else {
      const objectSchema = external_exports3.custom((val) => {
        return typeof val === "object" && val !== null && !Array.isArray(val);
      }, "Must be an object, not an array");
      allowedSchemas.push(objectSchema);
    }
  }
  if (types.file !== false && types.file !== void 0) {
    allowedSchemas.push(types.file);
  }
  let zodSchema6;
  if (allowedSchemas.length === 0) {
    zodSchema6 = external_exports3.never();
  } else if (allowedSchemas.length === 1) {
    zodSchema6 = allowedSchemas[0];
  } else {
    const hasConstraints = Object.keys(schema).some(
      (key) => key !== "$schema" && key !== "title" && key !== "description"
    );
    if (!hasConstraints) {
      zodSchema6 = external_exports3.any();
    } else {
      zodSchema6 = external_exports3.union(allowedSchemas);
    }
  }
  for (const handler of refinementHandlers) {
    zodSchema6 = handler.apply(zodSchema6, schema);
  }
  return zodSchema6;
}
__name(convertJsonSchemaToZod, "convertJsonSchemaToZod");

// node_modules/zod-from-json-schema-v3/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_zod();
function convertJsonSchemaToZod2(schema) {
  function addMetadata(zodSchema6, jsonSchema6) {
    if (jsonSchema6.description) {
      zodSchema6 = zodSchema6.describe(jsonSchema6.description);
    }
    return zodSchema6;
  }
  __name(addMetadata, "addMetadata");
  if (schema.const !== void 0) {
    if (typeof schema.const === "string") {
      return addMetadata(external_exports2.literal(schema.const), schema);
    } else if (typeof schema.const === "number") {
      return addMetadata(external_exports2.literal(schema.const), schema);
    } else if (typeof schema.const === "boolean") {
      return addMetadata(external_exports2.literal(schema.const), schema);
    } else if (schema.const === null) {
      return addMetadata(external_exports2.null(), schema);
    }
    return addMetadata(external_exports2.literal(schema.const), schema);
  }
  if (schema.type) {
    switch (schema.type) {
      case "string": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(external_exports2.string(), schema);
          }
          return addMetadata(external_exports2.enum(schema.enum), schema);
        }
        let stringSchema = external_exports2.string();
        if (schema.minLength !== void 0) {
          stringSchema = stringSchema.min(schema.minLength);
        }
        if (schema.maxLength !== void 0) {
          stringSchema = stringSchema.max(schema.maxLength);
        }
        if (schema.pattern !== void 0) {
          const regex = new RegExp(schema.pattern);
          stringSchema = stringSchema.regex(regex);
        }
        return addMetadata(stringSchema, schema);
      }
      case "number":
      case "integer": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(external_exports2.number(), schema);
          }
          const options = schema.enum.map((val) => external_exports2.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = external_exports2.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        let numberSchema = schema.type === "integer" ? external_exports2.number().int() : external_exports2.number();
        if (schema.minimum !== void 0) {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (schema.maximum !== void 0) {
          numberSchema = numberSchema.max(schema.maximum);
        }
        if (schema.exclusiveMinimum !== void 0) {
          numberSchema = numberSchema.gt(schema.exclusiveMinimum);
        }
        if (schema.exclusiveMaximum !== void 0) {
          numberSchema = numberSchema.lt(schema.exclusiveMaximum);
        }
        if (schema.multipleOf !== void 0) {
          numberSchema = numberSchema.multipleOf(schema.multipleOf);
        }
        return addMetadata(numberSchema, schema);
      }
      case "boolean":
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(external_exports2.boolean(), schema);
          }
          const options = schema.enum.map((val) => external_exports2.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = external_exports2.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        return addMetadata(external_exports2.boolean(), schema);
      case "null":
        return addMetadata(external_exports2.null(), schema);
      case "object":
        if (schema.properties) {
          const shape = {};
          for (const [key, propSchema] of Object.entries(
            schema.properties
          )) {
            shape[key] = convertJsonSchemaToZod2(propSchema);
          }
          if (schema.required && Array.isArray(schema.required)) {
            const required3 = new Set(schema.required);
            for (const key of Object.keys(shape)) {
              if (!required3.has(key)) {
                shape[key] = shape[key].optional();
              }
            }
          } else {
            for (const key of Object.keys(shape)) {
              shape[key] = shape[key].optional();
            }
          }
          let zodSchema6;
          if (schema.additionalProperties !== false) {
            zodSchema6 = external_exports2.object(shape).passthrough();
          } else {
            zodSchema6 = external_exports2.object(shape);
          }
          return addMetadata(zodSchema6, schema);
        }
        return addMetadata(external_exports2.object({}), schema);
      case "array": {
        let arraySchema;
        if (schema.items) {
          arraySchema = external_exports2.array(convertJsonSchemaToZod2(schema.items));
        } else {
          arraySchema = external_exports2.array(external_exports2.any());
        }
        if (schema.minItems !== void 0) {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (schema.maxItems !== void 0) {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        if (schema.uniqueItems === true) {
          arraySchema = arraySchema.refine(
            (items) => {
              const seen = /* @__PURE__ */ new Set();
              return items.every((item) => {
                if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
                  if (seen.has(item)) return false;
                  seen.add(item);
                  return true;
                }
                const serialized = JSON.stringify(item);
                if (seen.has(serialized)) return false;
                seen.add(serialized);
                return true;
              });
            },
            { message: "Array items must be unique" }
          );
        }
        return addMetadata(arraySchema, schema);
      }
    }
  }
  if (schema.enum) {
    if (schema.enum.length === 0) {
      return addMetadata(external_exports2.never(), schema);
    }
    const allStrings = schema.enum.every((val) => typeof val === "string");
    if (allStrings) {
      return addMetadata(external_exports2.enum(schema.enum), schema);
    } else {
      const options = schema.enum.map((val) => external_exports2.literal(val));
      if (options.length === 1) {
        return addMetadata(options[0], schema);
      }
      if (options.length >= 2) {
        const unionSchema = external_exports2.union([options[0], options[1], ...options.slice(2)]);
        return addMetadata(unionSchema, schema);
      }
    }
  }
  if (schema.anyOf && schema.anyOf.length >= 2) {
    const schemas = schema.anyOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      external_exports2.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  if (schema.allOf) {
    return addMetadata(
      schema.allOf.reduce(
        (acc, s) => external_exports2.intersection(acc, convertJsonSchemaToZod2(s)),
        external_exports2.object({})
      ),
      schema
    );
  }
  if (schema.oneOf && schema.oneOf.length >= 2) {
    const schemas = schema.oneOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      external_exports2.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  return addMetadata(external_exports2.any(), schema);
}
__name(convertJsonSchemaToZod2, "convertJsonSchemaToZod");

// node_modules/@mastra/schema-compat/dist/index.js
init_v4();
function convertZodSchemaToAISDKSchema(zodSchema6, target = "jsonSchema7") {
  const jsonSchemaToUse = zodToJsonSchema3(zodSchema6, target);
  return jsonSchema2(jsonSchemaToUse, {
    validate: /* @__PURE__ */ __name((value) => {
      const result = zodSchema6.safeParse(value);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    }, "validate")
  });
}
__name(convertZodSchemaToAISDKSchema, "convertZodSchemaToAISDKSchema");
function isZodType(value) {
  return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
__name(isZodType, "isZodType");
function convertSchemaToZod(schema) {
  if (isZodType(schema)) {
    return schema;
  } else {
    const jsonSchemaToConvert = "jsonSchema" in schema ? schema.jsonSchema : schema;
    try {
      if ("toJSONSchema" in external_exports2) {
        return convertJsonSchemaToZod(jsonSchemaToConvert);
      } else {
        return convertJsonSchemaToZod2(jsonSchemaToConvert);
      }
    } catch (e) {
      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;
      console.error(errorMessage, e);
      throw new Error(errorMessage + (e instanceof Error ? `
${e.stack}` : "\nUnknown error object"));
    }
  }
}
__name(convertSchemaToZod, "convertSchemaToZod");
function applyCompatLayer({
  schema,
  compatLayers,
  mode
}) {
  let zodSchema6;
  if (!isZodType(schema)) {
    zodSchema6 = convertSchemaToZod(schema);
  } else {
    zodSchema6 = schema;
  }
  for (const compat of compatLayers) {
    if (compat.shouldApply()) {
      return mode === "jsonSchema" ? compat.processToJSONSchema(zodSchema6) : compat.processToAISDKSchema(zodSchema6);
    }
  }
  if (mode === "jsonSchema") {
    return zodToJsonSchema3(zodSchema6, "jsonSchema7");
  } else {
    return convertZodSchemaToAISDKSchema(zodSchema6);
  }
}
__name(applyCompatLayer, "applyCompatLayer");
var ALL_STRING_CHECKS = ["regex", "emoji", "email", "url", "uuid", "cuid", "min", "max"];
var ALL_NUMBER_CHECKS = [
  "min",
  // gte internally
  "max",
  // lte internally
  "multipleOf"
];
var ALL_ARRAY_CHECKS = ["min", "max", "length"];
var UNSUPPORTED_ZOD_TYPES = ["ZodIntersection", "ZodNever", "ZodNull", "ZodTuple", "ZodUndefined"];
var SUPPORTED_ZOD_TYPES = [
  "ZodObject",
  "ZodArray",
  "ZodUnion",
  "ZodString",
  "ZodNumber",
  "ZodDate",
  "ZodAny",
  "ZodDefault",
  "ZodNullable"
];
var ALL_ZOD_TYPES = [...SUPPORTED_ZOD_TYPES, ...UNSUPPORTED_ZOD_TYPES];
var SchemaCompatLayer = class {
  static {
    __name(this, "SchemaCompatLayer");
  }
  model;
  parent;
  /**
   * Creates a new schema compatibility instance.
   *
   * @param model - The language model this compatibility layer applies to
   */
  constructor(model, parent) {
    this.model = model;
    this.parent = parent;
  }
  /**
   * Gets the language model associated with this compatibility layer.
   *
   * @returns The language model instance
   */
  getModel() {
    return this.model;
  }
  getUnsupportedZodTypes() {
    return UNSUPPORTED_ZOD_TYPES;
  }
  /**
   * Type guard for optional Zod types
   */
  isOptional(v) {
    return v instanceof ZodOptional2;
  }
  /**
   * Type guard for object Zod types
   */
  isObj(v) {
    return v instanceof ZodObject2;
  }
  /**
   * Type guard for null Zod types
   */
  isNull(v) {
    return v instanceof ZodNull2;
  }
  /**
   * Type guard for array Zod types
   */
  isArr(v) {
    return v instanceof ZodArray2;
  }
  /**
   * Type guard for union Zod types
   */
  isUnion(v) {
    return v instanceof ZodUnion2;
  }
  /**
   * Type guard for string Zod types
   */
  isString(v) {
    return v instanceof ZodString2;
  }
  /**
   * Type guard for number Zod types
   */
  isNumber(v) {
    return v instanceof ZodNumber2;
  }
  /**
   * Type guard for date Zod types
   */
  isDate(v) {
    return v instanceof ZodDate2;
  }
  /**
   * Type guard for default Zod types
   */
  isDefault(v) {
    return v instanceof ZodDefault2;
  }
  /**
   * Determines whether this compatibility layer should be applied for the current model.
   *
   * @returns True if this compatibility layer should be used, false otherwise
   * @abstract
   */
  shouldApply() {
    return this.parent.shouldApply();
  }
  /**
   * Returns the JSON Schema target format for this provider.
   *
   * @returns The schema target format, or undefined to use the default 'jsonSchema7'
   * @abstract
   */
  getSchemaTarget() {
    return this.parent.getSchemaTarget();
  }
  /**
   * Processes a specific Zod type according to the provider's requirements.
   *
   * @param value - The Zod type to process
   * @returns The processed Zod type
   * @abstract
   */
  processZodType(value) {
    return this.parent.processZodType(value);
  }
  /**
   * Default handler for Zod object types. Recursively processes all properties in the object.
   *
   * @param value - The Zod object to process
   * @returns The processed Zod object
   */
  defaultZodObjectHandler(value, options = { passthrough: true }) {
    const processedShape = Object.entries(value.shape).reduce((acc, [key, propValue]) => {
      acc[key] = this.processZodType(propValue);
      return acc;
    }, {});
    let result = external_exports2.object(processedShape);
    if (value._def.unknownKeys === "strict") {
      result = result.strict();
    }
    if (value._def.catchall && !(value._def.catchall instanceof external_exports2.ZodNever)) {
      result = result.catchall(value._def.catchall);
    }
    if (value.description) {
      result = result.describe(value.description);
    }
    if (options.passthrough && value._def.unknownKeys === "passthrough") {
      result = result.passthrough();
    }
    return result;
  }
  /**
   * Merges validation constraints into a parameter description.
   *
   * This helper method converts validation constraints that may not be supported
   * by a provider into human-readable descriptions.
   *
   * @param description - The existing parameter description
   * @param constraints - The validation constraints to merge
   * @returns The updated description with constraints, or undefined if no constraints
   */
  mergeParameterDescription(description, constraints) {
    if (constraints.length > 0) {
      return (description ? description + "\n" : "") + `constraints: ${constraints.join(`, `)}`;
    } else {
      return description;
    }
  }
  /**
   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.
   *
   * @param value - The Zod type to check
   * @param throwOnTypes - Array of type names to throw errors for
   * @returns The original value if not in the throw list
   * @throws Error if the type is in the unsupported list
   */
  defaultUnsupportedZodTypeHandler(value, throwOnTypes = UNSUPPORTED_ZOD_TYPES) {
    if (throwOnTypes.includes(value._def?.typeName)) {
      throw new Error(`${this.model.modelId} does not support zod type: ${value._def?.typeName}`);
    }
    return value;
  }
  /**
   * Default handler for Zod array types. Processes array constraints according to provider support.
   *
   * @param value - The Zod array to process
   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod array
   */
  defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS) {
    const zodArrayDef = value._def;
    const processedType = this.processZodType(zodArrayDef.type);
    let result = external_exports2.array(processedType);
    const constraints = [];
    if (zodArrayDef.minLength?.value !== void 0) {
      if (handleChecks.includes("min")) {
        constraints.push(`minimum length ${zodArrayDef.minLength.value}`);
      } else {
        result = result.min(zodArrayDef.minLength.value);
      }
    }
    if (zodArrayDef.maxLength?.value !== void 0) {
      if (handleChecks.includes("max")) {
        constraints.push(`maximum length ${zodArrayDef.maxLength.value}`);
      } else {
        result = result.max(zodArrayDef.maxLength.value);
      }
    }
    if (zodArrayDef.exactLength?.value !== void 0) {
      if (handleChecks.includes("length")) {
        constraints.push(`exact length ${zodArrayDef.exactLength.value}`);
      } else {
        result = result.length(zodArrayDef.exactLength.value);
      }
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod union types. Processes all union options.
   *
   * @param value - The Zod union to process
   * @returns The processed Zod union
   * @throws Error if union has fewer than 2 options
   */
  defaultZodUnionHandler(value) {
    const processedOptions = value._def.options.map((option) => this.processZodType(option));
    if (processedOptions.length < 2) throw new Error("Union must have at least 2 options");
    let result = external_exports2.union(processedOptions);
    if (value.description) {
      result = result.describe(value.description);
    }
    return result;
  }
  /**
   * Default handler for Zod string types. Processes string validation constraints.
   *
   * @param value - The Zod string to process
   * @param handleChecks - String constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod string
   */
  defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS) {
    const constraints = [];
    const checks = value._def.checks || [];
    const newChecks = [];
    for (const check3 of checks) {
      if ("kind" in check3) {
        if (handleChecks.includes(check3.kind)) {
          switch (check3.kind) {
            case "regex": {
              constraints.push(`input must match this regex ${check3.regex.source}`);
              break;
            }
            case "emoji":
            case "email":
            case "url":
            case "uuid":
            case "cuid": {
              constraints.push(`a valid ${check3.kind}`);
              break;
            }
            case "min":
            case "max": {
              constraints.push(`${check3.kind}imum length ${check3.value}`);
              break;
            }
          }
        } else {
          newChecks.push(check3);
        }
      }
    }
    let result = external_exports2.string();
    for (const check3 of newChecks) {
      result = result._addCheck(check3);
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod number types. Processes number validation constraints.
   *
   * @param value - The Zod number to process
   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod number
   */
  defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS) {
    const constraints = [];
    const checks = value._def.checks || [];
    const newChecks = [];
    for (const check3 of checks) {
      if ("kind" in check3) {
        if (handleChecks.includes(check3.kind)) {
          switch (check3.kind) {
            case "min":
              if (check3.inclusive) {
                constraints.push(`greater than or equal to ${check3.value}`);
              } else {
                constraints.push(`greater than ${check3.value}`);
              }
              break;
            case "max":
              if (check3.inclusive) {
                constraints.push(`lower than or equal to ${check3.value}`);
              } else {
                constraints.push(`lower than ${check3.value}`);
              }
              break;
            case "multipleOf": {
              constraints.push(`multiple of ${check3.value}`);
              break;
            }
          }
        } else {
          newChecks.push(check3);
        }
      }
    }
    let result = external_exports2.number();
    for (const check3 of newChecks) {
      switch (check3.kind) {
        case "int":
          result = result.int();
          break;
        case "finite":
          result = result.finite();
          break;
        default:
          result = result._addCheck(check3);
      }
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.
   *
   * @param value - The Zod date to process
   * @returns A Zod string schema representing the date in ISO format
   */
  defaultZodDateHandler(value) {
    const constraints = [];
    const checks = value._def.checks || [];
    for (const check3 of checks) {
      if ("kind" in check3) {
        switch (check3.kind) {
          case "min":
            const minDate = new Date(check3.value);
            if (!isNaN(minDate.getTime())) {
              constraints.push(`Date must be newer than ${minDate.toISOString()} (ISO)`);
            }
            break;
          case "max":
            const maxDate = new Date(check3.value);
            if (!isNaN(maxDate.getTime())) {
              constraints.push(`Date must be older than ${maxDate.toISOString()} (ISO)`);
            }
            break;
        }
      }
    }
    constraints.push(`Date format is date-time`);
    let result = external_exports2.string().describe("date-time");
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod optional types. Processes the inner type and maintains optionality.
   *
   * @param value - The Zod optional to process
   * @param handleTypes - Types that should be processed vs passed through
   * @returns The processed Zod optional
   */
  defaultZodOptionalHandler(value, handleTypes = SUPPORTED_ZOD_TYPES) {
    if (handleTypes.includes(value._def.innerType._def.typeName)) {
      return this.processZodType(value._def.innerType).optional();
    } else {
      return value;
    }
  }
  /**
   * Processes a Zod object schema and converts it to an AI SDK Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns An AI SDK Schema with provider-specific compatibility applied
   */
  processToAISDKSchema(zodSchema6) {
    const processedSchema = this.processZodType(zodSchema6);
    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());
  }
  /**
   * Processes a Zod object schema and converts it to a JSON Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns A JSONSchema7 object with provider-specific compatibility applied
   */
  processToJSONSchema(zodSchema6) {
    return this.processToAISDKSchema(zodSchema6).jsonSchema;
  }
};
var ALL_STRING_CHECKS2 = [
  "regex",
  "emoji",
  "email",
  "url",
  "uuid",
  "cuid",
  "min_length",
  "max_length",
  "string_format"
];
var ALL_NUMBER_CHECKS2 = ["greater_than", "less_than", "multiple_of"];
var ALL_ARRAY_CHECKS2 = ["min", "max", "length"];
var UNSUPPORTED_ZOD_TYPES2 = ["ZodIntersection", "ZodNever", "ZodNull", "ZodTuple", "ZodUndefined"];
var SUPPORTED_ZOD_TYPES2 = [
  "ZodObject",
  "ZodArray",
  "ZodUnion",
  "ZodString",
  "ZodNumber",
  "ZodDate",
  "ZodAny",
  "ZodDefault",
  "ZodNullable"
];
var SchemaCompatLayer2 = class {
  static {
    __name(this, "SchemaCompatLayer2");
  }
  model;
  parent;
  /**
   * Creates a new schema compatibility instance.
   *
   * @param model - The language model this compatibility layer applies to
   */
  constructor(model, parent) {
    this.model = model;
    this.parent = parent;
  }
  /**
   * Gets the language model associated with this compatibility layer.
   *
   * @returns The language model instance
   */
  getModel() {
    return this.model;
  }
  getUnsupportedZodTypes() {
    return UNSUPPORTED_ZOD_TYPES2;
  }
  /**
   * Type guard for optional Zod types
   */
  isOptional(v) {
    return v instanceof ZodOptional;
  }
  /**
   * Type guard for object Zod types
   */
  isObj(v) {
    return v instanceof ZodObject;
  }
  /**
   * Type guard for null Zod types
   */
  isNull(v) {
    return v instanceof ZodNull;
  }
  /**
   * Type guard for nullable Zod types
   */
  isNullable(v) {
    return v instanceof ZodNullable;
  }
  /**
   * Type guard for array Zod types
   */
  isArr(v) {
    return v instanceof ZodArray;
  }
  /**
   * Type guard for union Zod types
   */
  isUnion(v) {
    return v instanceof ZodUnion;
  }
  /**
   * Type guard for string Zod types
   */
  isString(v) {
    return v instanceof ZodString;
  }
  /**
   * Type guard for number Zod types
   */
  isNumber(v) {
    return v instanceof ZodNumber;
  }
  /**
   * Type guard for date Zod types
   */
  isDate(v) {
    return v instanceof ZodDate;
  }
  /**
   * Type guard for default Zod types
   */
  isDefault(v) {
    return v instanceof ZodDefault;
  }
  /**
   * Determines whether this compatibility layer should be applied for the current model.
   *
   * @returns True if this compatibility layer should be used, false otherwise
   * @abstract
   */
  shouldApply() {
    return this.parent.shouldApply();
  }
  /**
   * Returns the JSON Schema target format for this provider.
   *
   * @returns The schema target format, or undefined to use the default 'jsonSchema7'
   * @abstract
   */
  getSchemaTarget() {
    return this.parent.getSchemaTarget();
  }
  /**
   * Processes a specific Zod type according to the provider's requirements.
   *
   * @param value - The Zod type to process
   * @returns The processed Zod type
   * @abstract
   */
  processZodType(value) {
    return this.parent.processZodType(value);
  }
  /**
   * Default handler for Zod object types. Recursively processes all properties in the object.
   *
   * @param value - The Zod object to process
   * @returns The processed Zod object
   */
  defaultZodObjectHandler(value, options = { passthrough: true }) {
    const processedShape = Object.entries(value.shape).reduce((acc, [key, propValue]) => {
      acc[key] = this.processZodType(propValue);
      return acc;
    }, {});
    let result = external_exports.object(processedShape);
    if (value._zod.def.catchall instanceof external_exports.ZodNever) {
      result = external_exports.strictObject(processedShape);
    }
    if (value._zod.def.catchall && !(value._zod.def.catchall instanceof external_exports.ZodNever)) {
      result = result.catchall(value._zod.def.catchall);
    }
    if (value.description) {
      result = result.describe(value.description);
    }
    if (options.passthrough && value._zod.def.catchall instanceof external_exports.ZodUnknown) {
      result = external_exports.looseObject(processedShape);
    }
    return result;
  }
  /**
   * Merges validation constraints into a parameter description.
   *
   * This helper method converts validation constraints that may not be supported
   * by a provider into human-readable descriptions.
   *
   * @param description - The existing parameter description
   * @param constraints - The validation constraints to merge
   * @returns The updated description with constraints, or undefined if no constraints
   */
  mergeParameterDescription(description, constraints) {
    if (constraints.length > 0) {
      return (description ? description + "\n" : "") + `constraints: ${constraints.join(`, `)}`;
    } else {
      return description;
    }
  }
  /**
   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.
   *
   * @param value - The Zod type to check
   * @param throwOnTypes - Array of type names to throw errors for
   * @returns The original value if not in the throw list
   * @throws Error if the type is in the unsupported list
   */
  defaultUnsupportedZodTypeHandler(value, throwOnTypes = UNSUPPORTED_ZOD_TYPES2) {
    if (throwOnTypes.includes(value.constructor.name)) {
      throw new Error(`${this.model.modelId} does not support zod type: ${value.constructor.name}`);
    }
    return value;
  }
  /**
   * Default handler for Zod array types. Processes array constraints according to provider support.
   *
   * @param value - The Zod array to process
   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod array
   */
  defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS2) {
    const zodArrayDef = value._zod.def;
    const processedType = this.processZodType(zodArrayDef.element);
    let result = external_exports.array(processedType);
    const constraints = [];
    if (zodArrayDef.checks) {
      for (const check3 of zodArrayDef.checks) {
        if (check3._zod.def.check === "min_length") {
          if (handleChecks.includes("min")) {
            constraints.push(`minimum length ${check3._zod.def.minimum}`);
          } else {
            result = result.min(check3._zod.def.minimum);
          }
        }
        if (check3._zod.def.check === "max_length") {
          if (handleChecks.includes("max")) {
            constraints.push(`maximum length ${check3._zod.def.maximum}`);
          } else {
            result = result.max(check3._zod.def.maximum);
          }
        }
        if (check3._zod.def.check === "length_equals") {
          if (handleChecks.includes("length")) {
            constraints.push(`exact length ${check3._zod.def.length}`);
          } else {
            result = result.length(check3._zod.def.length);
          }
        }
      }
    }
    const metaDescription = value.meta()?.description;
    const legacyDescription = value.description;
    const description = this.mergeParameterDescription(metaDescription || legacyDescription, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod union types. Processes all union options.
   *
   * @param value - The Zod union to process
   * @returns The processed Zod union
   * @throws Error if union has fewer than 2 options
   */
  defaultZodUnionHandler(value) {
    const processedOptions = value._zod.def.options.map((option) => this.processZodType(option));
    if (processedOptions.length < 2) throw new Error("Union must have at least 2 options");
    let result = external_exports.union(processedOptions);
    if (value.description) {
      result = result.describe(value.description);
    }
    return result;
  }
  /**
   * Default handler for Zod string types. Processes string validation constraints.
   *
   * @param value - The Zod string to process
   * @param handleChecks - String constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod string
   */
  defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS2) {
    const constraints = [];
    const checks = value._zod.def.checks || [];
    const newChecks = [];
    if (checks) {
      for (const check3 of checks) {
        if (handleChecks.includes(check3._zod.def.check)) {
          switch (check3._zod.def.check) {
            case "min_length":
              constraints.push(`minimum length ${check3._zod.def.minimum}`);
              break;
            case "max_length":
              constraints.push(`maximum length ${check3._zod.def.maximum}`);
              break;
            case "string_format":
              {
                switch (check3._zod.def.format) {
                  case "email":
                  case "url":
                  case "emoji":
                  case "uuid":
                  case "cuid":
                    constraints.push(`a valid ${check3._zod.def.format}`);
                    break;
                  case "regex":
                    constraints.push(`input must match this regex ${check3._zod.def.pattern}`);
                    break;
                }
              }
              break;
          }
        } else {
          newChecks.push(check3);
        }
      }
    }
    let result = external_exports.string();
    for (const check3 of newChecks) {
      result = result.check(check3);
    }
    const metaDescription = value.meta()?.description;
    const legacyDescription = value.description;
    const description = this.mergeParameterDescription(metaDescription || legacyDescription, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod number types. Processes number validation constraints.
   *
   * @param value - The Zod number to process
   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod number
   */
  defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS2) {
    const constraints = [];
    const checks = value._zod.def.checks || [];
    const newChecks = [];
    if (checks) {
      for (const check3 of checks) {
        if (handleChecks.includes(check3._zod.def.check)) {
          switch (check3._zod.def.check) {
            case "greater_than":
              if (check3._zod.def.inclusive) {
                constraints.push(`greater than or equal to ${check3._zod.def.value}`);
              } else {
                constraints.push(`greater than ${check3._zod.def.value}`);
              }
              break;
            case "less_than":
              if (check3._zod.def.inclusive) {
                constraints.push(`lower than or equal to ${check3._zod.def.value}`);
              } else {
                constraints.push(`lower than ${check3._zod.def.value}`);
              }
              break;
            case "multiple_of": {
              constraints.push(`multiple of ${check3._zod.def.value}`);
              break;
            }
          }
        } else {
          newChecks.push(check3);
        }
      }
    }
    let result = external_exports.number();
    for (const check3 of newChecks) {
      switch (check3._zod.def.check) {
        case "number_format": {
          switch (check3._zod.def.format) {
            case "safeint":
              result = result.int();
              break;
          }
          break;
        }
        default:
          result = result.check(check3);
      }
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.
   *
   * @param value - The Zod date to process
   * @returns A Zod string schema representing the date in ISO format
   */
  defaultZodDateHandler(value) {
    const constraints = [];
    const checks = value._zod.def.checks || [];
    if (checks) {
      for (const check3 of checks) {
        switch (check3._zod.def.check) {
          case "less_than":
            const minDate = new Date(check3._zod.def.value);
            if (!isNaN(minDate.getTime())) {
              constraints.push(`Date must be newer than ${minDate.toISOString()} (ISO)`);
            }
            break;
          case "greater_than":
            const maxDate = new Date(check3._zod.def.value);
            if (!isNaN(maxDate.getTime())) {
              constraints.push(`Date must be older than ${maxDate.toISOString()} (ISO)`);
            }
            break;
        }
      }
    }
    constraints.push(`Date format is date-time`);
    let result = external_exports.string().describe("date-time");
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  /**
   * Default handler for Zod optional types. Processes the inner type and maintains optionality.
   *
   * @param value - The Zod optional to process
   * @param handleTypes - Types that should be processed vs passed through
   * @returns The processed Zod optional
   */
  defaultZodOptionalHandler(value, handleTypes = SUPPORTED_ZOD_TYPES2) {
    if (handleTypes.includes(value.constructor.name)) {
      return this.processZodType(value._zod.def.innerType).optional();
    } else {
      return value;
    }
  }
  /**
   * Processes a Zod object schema and converts it to an AI SDK Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns An AI SDK Schema with provider-specific compatibility applied
   */
  processToAISDKSchema(zodSchema6) {
    const processedSchema = this.processZodType(zodSchema6);
    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());
  }
  /**
   * Processes a Zod object schema and converts it to a JSON Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns A JSONSchema7 object with provider-specific compatibility applied
   */
  processToJSONSchema(zodSchema6) {
    return this.processToAISDKSchema(zodSchema6).jsonSchema;
  }
};
var SchemaCompatLayer3 = class {
  static {
    __name(this, "SchemaCompatLayer3");
  }
  model;
  v3Layer;
  v4Layer;
  /**
   * Creates a new schema compatibility instance.
   *
   * @param model - The language model this compatibility layer applies to
   */
  constructor(model) {
    this.model = model;
    this.v3Layer = new SchemaCompatLayer(model, this);
    this.v4Layer = new SchemaCompatLayer2(model, this);
  }
  /**
   * Gets the language model associated with this compatibility layer.
   *
   * @returns The language model instance
   */
  getModel() {
    return this.model;
  }
  getUnsupportedZodTypes(v) {
    if ("_zod" in v) {
      return this.v4Layer.getUnsupportedZodTypes();
    } else {
      return this.v3Layer.getUnsupportedZodTypes();
    }
  }
  isOptional(v) {
    if ("_zod" in v) {
      return this.v4Layer.isOptional(v);
    } else {
      return this.v3Layer.isOptional(v);
    }
  }
  isObj(v) {
    if ("_zod" in v) {
      return this.v4Layer.isObj(v);
    } else {
      return this.v3Layer.isObj(v);
    }
  }
  isNull(v) {
    if ("_zod" in v) {
      return this.v4Layer.isNull(v);
    } else {
      return this.v3Layer.isNull(v);
    }
  }
  isArr(v) {
    if ("_zod" in v) {
      return this.v4Layer.isArr(v);
    } else {
      return this.v3Layer.isArr(v);
    }
  }
  isUnion(v) {
    if ("_zod" in v) {
      return this.v4Layer.isUnion(v);
    } else {
      return this.v3Layer.isUnion(v);
    }
  }
  isString(v) {
    if ("_zod" in v) {
      return this.v4Layer.isString(v);
    } else {
      return this.v3Layer.isString(v);
    }
  }
  isNumber(v) {
    if ("_zod" in v) {
      return this.v4Layer.isNumber(v);
    } else {
      return this.v3Layer.isNumber(v);
    }
  }
  isDate(v) {
    if ("_zod" in v) {
      return this.v4Layer.isDate(v);
    } else {
      return this.v3Layer.isDate(v);
    }
  }
  isDefault(v) {
    if ("_zod" in v) {
      return this.v4Layer.isDefault(v);
    } else {
      return this.v3Layer.isDefault(v);
    }
  }
  defaultZodObjectHandler(value, options = { passthrough: true }) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodObjectHandler(value, options);
    } else {
      return this.v3Layer.defaultZodObjectHandler(value, options);
    }
  }
  /**
   * Merges validation constraints into a parameter description.
   *
   * This helper method converts validation constraints that may not be supported
   * by a provider into human-readable descriptions.
   *
   * @param description - The existing parameter description
   * @param constraints - The validation constraints to merge
   * @returns The updated description with constraints, or undefined if no constraints
   */
  mergeParameterDescription(description, constraints) {
    return this.v3Layer.mergeParameterDescription(description, constraints);
  }
  /**
   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.
   *
   * @param value - The Zod type to check
   * @param throwOnTypes - Array of type names to throw errors for
   * @returns The original value if not in the throw list
   * @throws Error if the type is in the unsupported list
   */
  defaultUnsupportedZodTypeHandler(value, throwOnTypes) {
    if ("_zod" in value) {
      return this.v4Layer.defaultUnsupportedZodTypeHandler(
        // @ts-expect-error - fix later
        value,
        throwOnTypes ?? UNSUPPORTED_ZOD_TYPES2
      );
    } else {
      return this.v3Layer.defaultUnsupportedZodTypeHandler(
        value,
        throwOnTypes ?? UNSUPPORTED_ZOD_TYPES
      );
    }
  }
  defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodArrayHandler(value, handleChecks);
    } else {
      return this.v3Layer.defaultZodArrayHandler(value, handleChecks);
    }
  }
  defaultZodUnionHandler(value) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodUnionHandler(value);
    } else {
      return this.v3Layer.defaultZodUnionHandler(value);
    }
  }
  defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodStringHandler(value);
    } else {
      return this.v3Layer.defaultZodStringHandler(value, handleChecks);
    }
  }
  defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodNumberHandler(value);
    } else {
      return this.v3Layer.defaultZodNumberHandler(value, handleChecks);
    }
  }
  defaultZodDateHandler(value) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodDateHandler(value);
    } else {
      return this.v3Layer.defaultZodDateHandler(value);
    }
  }
  defaultZodOptionalHandler(value, handleTypes) {
    if ("_zod" in value) {
      return this.v4Layer.defaultZodOptionalHandler(value, handleTypes ?? SUPPORTED_ZOD_TYPES2);
    } else {
      return this.v3Layer.defaultZodOptionalHandler(value, handleTypes ?? SUPPORTED_ZOD_TYPES);
    }
  }
  /**
   * Processes a Zod object schema and converts it to an AI SDK Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns An AI SDK Schema with provider-specific compatibility applied
   */
  processToAISDKSchema(zodSchema6) {
    const processedSchema = this.processZodType(zodSchema6);
    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());
  }
  /**
   * Processes a Zod object schema and converts it to a JSON Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns A JSONSchema7 object with provider-specific compatibility applied
   */
  processToJSONSchema(zodSchema6) {
    return this.processToAISDKSchema(zodSchema6).jsonSchema;
  }
};
function isOptional2(z10) {
  return (v) => v instanceof z10["ZodOptional"];
}
__name(isOptional2, "isOptional2");
function isObj2(z10) {
  return (v) => v instanceof z10["ZodObject"];
}
__name(isObj2, "isObj2");
function isNull(z10) {
  return (v) => v instanceof z10["ZodNull"];
}
__name(isNull, "isNull");
function isArr2(z10) {
  return (v) => v instanceof z10["ZodArray"];
}
__name(isArr2, "isArr2");
function isUnion2(z10) {
  return (v) => v instanceof z10["ZodUnion"];
}
__name(isUnion2, "isUnion2");
function isString2(z10) {
  return (v) => v instanceof z10["ZodString"];
}
__name(isString2, "isString2");
function isNumber2(z10) {
  return (v) => v instanceof z10["ZodNumber"];
}
__name(isNumber2, "isNumber2");
function isDate(z10) {
  return (v) => v instanceof z10["ZodDate"];
}
__name(isDate, "isDate");
function isDefault(z10) {
  return (v) => v instanceof z10["ZodDefault"];
}
__name(isDefault, "isDefault");
function isNullable(z10) {
  return (v) => v instanceof z10["ZodNullable"];
}
__name(isNullable, "isNullable");
var AnthropicSchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "AnthropicSchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("claude");
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      const handleTypes = [
        "ZodObject",
        "ZodArray",
        "ZodUnion",
        "ZodNever",
        "ZodUndefined",
        "ZodTuple"
      ];
      if (this.getModel().modelId.includes("claude-3.5-haiku")) handleTypes.push("ZodString");
      return this.defaultZodOptionalHandler(value, handleTypes);
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value);
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value, []);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isString2(external_exports2)(value)) {
      if (this.getModel().modelId.includes("claude-3.5-haiku")) {
        return this.defaultZodStringHandler(value, ["max", "min"]);
      } else {
        return value;
      }
    }
    return this.defaultUnsupportedZodTypeHandler(value, [
      "ZodNever",
      "ZodTuple",
      "ZodUndefined"
    ]);
  }
};
var DeepSeekSchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "DeepSeekSchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("deepseek") && !this.getModel().modelId.includes("r1");
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      return this.defaultZodOptionalHandler(value, ["ZodObject", "ZodArray", "ZodUnion", "ZodString", "ZodNumber"]);
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value);
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value, ["min", "max"]);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isString2(external_exports2)(value)) {
      return this.defaultZodStringHandler(value);
    }
    return value;
  }
};
var GoogleSchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "GoogleSchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().provider.includes("google") || this.getModel().modelId.includes("google");
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      return this.defaultZodOptionalHandler(value, ["ZodObject", "ZodArray", "ZodUnion", "ZodString", "ZodNumber"]);
    } else if (isNull(external_exports2)(value)) {
      return external_exports2.any().refine((v) => v === null, { message: "must be null" }).describe(value.description || "must be null");
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value);
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value, []);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isString2(external_exports2)(value)) {
      return this.defaultZodStringHandler(value);
    } else if (isNumber2(external_exports2)(value)) {
      return this.defaultZodNumberHandler(value);
    }
    return this.defaultUnsupportedZodTypeHandler(value);
  }
};
var MetaSchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "MetaSchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("meta");
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      return this.defaultZodOptionalHandler(value, ["ZodObject", "ZodArray", "ZodUnion", "ZodString", "ZodNumber"]);
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value);
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value, ["min", "max"]);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isNumber2(external_exports2)(value)) {
      return this.defaultZodNumberHandler(value);
    } else if (isString2(external_exports2)(value)) {
      return this.defaultZodStringHandler(value);
    }
    return value;
  }
};
var OpenAISchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "OpenAISchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return `jsonSchema7`;
  }
  shouldApply() {
    if (!this.getModel().supportsStructuredOutputs && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
      return true;
    }
    return false;
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      const innerType = "_def" in value ? value._def.innerType : value._zod?.def?.innerType;
      if (innerType) {
        if (isNullable(external_exports2)(innerType)) {
          const processed = this.processZodType(innerType);
          return processed.transform((val) => val === null ? void 0 : val);
        }
        const processedInner = this.processZodType(innerType);
        return processedInner.nullable().transform((val) => val === null ? void 0 : val);
      }
      return value;
    } else if (isNullable(external_exports2)(value)) {
      const innerType = "_def" in value ? value._def.innerType : value._zod?.def?.innerType;
      if (innerType) {
        if (isOptional2(external_exports2)(innerType)) {
          const innerInnerType = "_def" in innerType ? innerType._def.innerType : innerType._zod?.def?.innerType;
          if (innerInnerType) {
            const processedInnerInner = this.processZodType(innerInnerType);
            return processedInnerInner.nullable().transform((val) => val === null ? void 0 : val);
          }
        }
        const processedInner = this.processZodType(innerType);
        return processedInner.nullable();
      }
      return value;
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value);
    } else if (isString2(external_exports2)(value)) {
      const model = this.getModel();
      const checks = ["emoji"];
      if (model.modelId.includes("gpt-4o-mini")) {
        return this.defaultZodStringHandler(value, ["emoji", "regex"]);
      }
      return this.defaultZodStringHandler(value, checks);
    }
    return this.defaultUnsupportedZodTypeHandler(value, [
      "ZodNever",
      "ZodUndefined",
      "ZodTuple"
    ]);
  }
};
var OpenAIReasoningSchemaCompatLayer = class extends SchemaCompatLayer3 {
  static {
    __name(this, "OpenAIReasoningSchemaCompatLayer");
  }
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return `openApi3`;
  }
  isReasoningModel() {
    return this.getModel().modelId.includes(`o3`) || this.getModel().modelId.includes(`o4`) || this.getModel().modelId.includes(`o1`);
  }
  shouldApply() {
    if ((this.getModel().supportsStructuredOutputs || this.isReasoningModel()) && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
      return true;
    }
    return false;
  }
  processZodType(value) {
    if (isOptional2(external_exports2)(value)) {
      const innerType = "_def" in value ? value._def.innerType : value._zod?.def?.innerType;
      if (innerType) {
        if (isNullable(external_exports2)(innerType)) {
          const processed = this.processZodType(innerType);
          return processed.transform((val) => val === null ? void 0 : val);
        }
        const processedInner = this.processZodType(innerType);
        return processedInner.nullable().transform((val) => val === null ? void 0 : val);
      }
      return value;
    } else if (isNullable(external_exports2)(value)) {
      const innerType = "_def" in value ? value._def.innerType : value._zod?.def?.innerType;
      if (innerType && isOptional2(external_exports2)(innerType)) {
        const innerInnerType = "_def" in innerType ? innerType._def.innerType : innerType._zod?.def?.innerType;
        if (innerInnerType) {
          const processedInnerInner = this.processZodType(innerInnerType);
          return processedInnerInner.nullable().transform((val) => val === null ? void 0 : val);
        }
      }
      if (innerType) {
        const processedInner = this.processZodType(innerType);
        return processedInner.nullable();
      }
      return value;
    } else if (isObj2(external_exports2)(value)) {
      return this.defaultZodObjectHandler(value, { passthrough: false });
    } else if (isArr2(external_exports2)(value)) {
      return this.defaultZodArrayHandler(value);
    } else if (isUnion2(external_exports2)(value)) {
      return this.defaultZodUnionHandler(value);
    } else if (isDefault(external_exports2)(value)) {
      const defaultDef = value._def;
      const innerType = defaultDef.innerType;
      const defaultValue = typeof defaultDef.defaultValue === "function" ? defaultDef.defaultValue() : defaultDef.defaultValue;
      const constraints = [];
      if (defaultValue !== void 0) {
        constraints.push(`the default value is ${defaultValue}`);
      }
      const description = this.mergeParameterDescription(value.description, constraints);
      let result = this.processZodType(innerType);
      if (description) {
        result = result.describe(description);
      }
      return result;
    } else if (isNumber2(external_exports2)(value)) {
      return this.defaultZodNumberHandler(value);
    } else if (isString2(external_exports2)(value)) {
      return this.defaultZodStringHandler(value);
    } else if (isDate(external_exports2)(value)) {
      return this.defaultZodDateHandler(value);
    } else if (value.constructor.name === "ZodAny") {
      return external_exports2.string().describe(
        (value.description ?? "") + `
Argument was an "any" type, but you (the LLM) do not support "any", so it was cast to a "string" type`
      );
    }
    return this.defaultUnsupportedZodTypeHandler(value);
  }
};

// node_modules/@mastra/core/dist/chunk-BBE22VBK.js
import { TransformStream as TransformStream2 } from "stream/web";
var CoreToolBuilder = class extends MastraBase {
  static {
    __name(this, "CoreToolBuilder");
  }
  originalTool;
  options;
  logType;
  constructor(input) {
    super({ name: "CoreToolBuilder" });
    this.originalTool = input.originalTool;
    this.options = input.options;
    this.logType = input.logType;
  }
  // Helper to get parameters based on tool type
  getParameters = /* @__PURE__ */ __name(() => {
    if (isVercelTool(this.originalTool)) {
      let schema2 = this.originalTool.parameters ?? ("inputSchema" in this.originalTool ? this.originalTool.inputSchema : void 0) ?? external_exports2.object({});
      if (typeof schema2 === "function") {
        schema2 = schema2();
      }
      return schema2;
    }
    let schema = this.originalTool.inputSchema ?? external_exports2.object({});
    if (typeof schema === "function") {
      schema = schema();
    }
    return schema;
  }, "getParameters");
  getOutputSchema = /* @__PURE__ */ __name(() => {
    if ("outputSchema" in this.originalTool) {
      let schema = this.originalTool.outputSchema;
      if (typeof schema === "function") {
        schema = schema();
      }
      return schema;
    }
    return null;
  }, "getOutputSchema");
  // For provider-defined tools, we need to include all required properties
  buildProviderTool(tool5) {
    if ("type" in tool5 && tool5.type === "provider-defined" && "id" in tool5 && typeof tool5.id === "string" && tool5.id.includes(".")) {
      const parameters = this.getParameters();
      const outputSchema2 = this.getOutputSchema();
      return {
        type: "provider-defined",
        id: tool5.id,
        args: "args" in this.originalTool ? this.originalTool.args : {},
        description: tool5.description,
        parameters: parameters.jsonSchema ? parameters : convertZodSchemaToAISDKSchema(parameters),
        ...outputSchema2 ? { outputSchema: outputSchema2.jsonSchema ? outputSchema2 : convertZodSchemaToAISDKSchema(outputSchema2) } : {},
        execute: this.originalTool.execute ? this.createExecute(
          this.originalTool,
          { ...this.options, description: this.originalTool.description },
          this.logType
        ) : void 0
      };
    }
    return void 0;
  }
  createLogMessageOptions({ agentName, toolName, type }) {
    if (!agentName) {
      return {
        start: `Executing tool ${toolName}`,
        error: `Failed tool execution`
      };
    }
    const prefix = `[Agent:${agentName}]`;
    const toolType = type === "toolset" ? "toolset" : "tool";
    return {
      start: `${prefix} - Executing ${toolType} ${toolName}`,
      error: `${prefix} - Failed ${toolType} execution`
    };
  }
  createExecute(tool5, options, logType, processedSchema) {
    const { logger, mastra: _mastra, memory: _memory, runtimeContext, model, ...rest } = options;
    const logModelObject = {
      modelId: model?.modelId,
      provider: model?.provider,
      specificationVersion: model?.specificationVersion
    };
    const { start, error: error87 } = this.createLogMessageOptions({
      agentName: options.agentName,
      toolName: options.name,
      type: logType
    });
    const execFunction = /* @__PURE__ */ __name(async (args, execOptions) => {
      const tracingContext = execOptions.tracingContext || options.tracingContext;
      const toolSpan = tracingContext?.currentSpan?.createChildSpan({
        type: "tool_call",
        name: `tool: '${options.name}'`,
        input: args,
        attributes: {
          toolId: options.name,
          toolDescription: options.description,
          toolType: logType || "tool"
        },
        tracingPolicy: options.tracingPolicy
      });
      try {
        let result;
        if (isVercelTool(tool5)) {
          result = await tool5?.execute?.(args, execOptions);
        } else {
          const wrappedMastra = options.mastra ? wrapMastra(options.mastra, { currentSpan: toolSpan }) : options.mastra;
          result = await tool5?.execute?.(
            {
              context: args,
              threadId: options.threadId,
              resourceId: options.resourceId,
              mastra: wrappedMastra,
              memory: options.memory,
              runId: options.runId,
              runtimeContext: options.runtimeContext ?? new RuntimeContext(),
              writer: new ToolStream(
                {
                  prefix: "tool",
                  callId: execOptions.toolCallId,
                  name: options.name,
                  runId: options.runId
                },
                options.writableStream || execOptions.writableStream
              ),
              tracingContext: { currentSpan: toolSpan }
            },
            execOptions
          );
        }
        toolSpan?.end({ output: result });
        return result ?? void 0;
      } catch (error210) {
        toolSpan?.error({ error: error210 });
        throw error210;
      }
    }, "execFunction");
    return async (args, execOptions) => {
      let logger2 = options.logger || this.logger;
      try {
        logger2.debug(start, { ...rest, model: logModelObject, args });
        const parameters = processedSchema || this.getParameters();
        const { data, error: error210 } = validateToolInput(parameters, args, options.name);
        if (error210) {
          logger2.warn(`Tool input validation failed for '${options.name}'`, {
            toolName: options.name,
            errors: error210.validationErrors,
            args
          });
          return error210;
        }
        args = data;
        return await new Promise((resolve3, reject) => {
          setImmediate(async () => {
            try {
              const result = await execFunction(args, execOptions);
              resolve3(result);
            } catch (err) {
              reject(err);
            }
          });
        });
      } catch (err) {
        const mastraError = new MastraError(
          {
            id: "TOOL_EXECUTION_FAILED",
            domain: "TOOL",
            category: "USER",
            details: {
              errorMessage: String(error87),
              argsJson: JSON.stringify(args),
              model: model?.modelId ?? ""
            }
          },
          err
        );
        logger2.trackException(mastraError);
        logger2.error(error87, { ...rest, model: logModelObject, error: mastraError, args });
        return mastraError;
      }
    };
  }
  buildV5() {
    const builtTool = this.build();
    if (!builtTool.parameters) {
      throw new Error("Tool parameters are required");
    }
    const base = {
      ...builtTool,
      inputSchema: builtTool.parameters,
      onInputStart: "onInputStart" in this.originalTool ? this.originalTool.onInputStart : void 0,
      onInputDelta: "onInputDelta" in this.originalTool ? this.originalTool.onInputDelta : void 0,
      onInputAvailable: "onInputAvailable" in this.originalTool ? this.originalTool.onInputAvailable : void 0
    };
    if (builtTool.type === "provider-defined") {
      const { execute: execute2, parameters, ...rest } = base;
      const name51 = builtTool.id.split(".")[1] || builtTool.id;
      return {
        ...rest,
        type: builtTool.type,
        id: builtTool.id,
        name: name51,
        args: builtTool.args
      };
    }
    return base;
  }
  build() {
    const providerTool = this.buildProviderTool(this.originalTool);
    if (providerTool) {
      return providerTool;
    }
    const model = this.options.model;
    const schemaCompatLayers = [];
    if (model) {
      const supportsStructuredOutputs = model.specificationVersion !== "v2" ? model.supportsStructuredOutputs ?? false : false;
      const modelInfo = {
        modelId: model.modelId,
        supportsStructuredOutputs,
        provider: model.provider
      };
      schemaCompatLayers.push(
        new OpenAIReasoningSchemaCompatLayer(modelInfo),
        new OpenAISchemaCompatLayer(modelInfo),
        new GoogleSchemaCompatLayer(modelInfo),
        new AnthropicSchemaCompatLayer(modelInfo),
        new DeepSeekSchemaCompatLayer(modelInfo),
        new MetaSchemaCompatLayer(modelInfo)
      );
    }
    let processedZodSchema;
    let processedSchema;
    const originalSchema = this.getParameters();
    const applicableLayer = schemaCompatLayers.find((layer) => layer.shouldApply());
    if (applicableLayer && originalSchema) {
      processedZodSchema = applicableLayer.processZodType(originalSchema);
      processedSchema = applyCompatLayer({
        schema: originalSchema,
        compatLayers: schemaCompatLayers,
        mode: "aiSdkSchema"
      });
    } else {
      processedZodSchema = originalSchema;
      processedSchema = applyCompatLayer({
        schema: originalSchema,
        compatLayers: schemaCompatLayers,
        mode: "aiSdkSchema"
      });
    }
    let processedOutputSchema;
    if (this.getOutputSchema()) {
      processedOutputSchema = applyCompatLayer({
        schema: this.getOutputSchema(),
        compatLayers: [],
        mode: "aiSdkSchema"
      });
    }
    const definition = {
      type: "function",
      description: this.originalTool.description,
      parameters: this.getParameters(),
      outputSchema: this.getOutputSchema(),
      requireApproval: this.options.requireApproval,
      execute: this.originalTool.execute ? this.createExecute(
        this.originalTool,
        { ...this.options, description: this.originalTool.description },
        this.logType,
        processedZodSchema
        // Pass the processed Zod schema for validation
      ) : void 0
    };
    return {
      ...definition,
      id: "id" in this.originalTool ? this.originalTool.id : void 0,
      parameters: processedSchema,
      outputSchema: processedOutputSchema
    };
  }
};
var delay2 = /* @__PURE__ */ __name((ms) => new Promise((resolve3) => setTimeout(resolve3, ms)), "delay");
function resolveSerializedZodOutput(schema) {
  return Function("z", `"use strict";return (${schema});`)(external_exports2);
}
__name(resolveSerializedZodOutput, "resolveSerializedZodOutput");
function isZodType2(value) {
  return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
__name(isZodType2, "isZodType");
function createDeterministicId(input) {
  return createHash("sha256").update(input).digest("hex").slice(0, 8);
}
__name(createDeterministicId, "createDeterministicId");
function setVercelToolProperties(tool5) {
  const inputSchema = "inputSchema" in tool5 ? tool5.inputSchema : convertVercelToolParameters(tool5);
  const toolId = !("id" in tool5) ? tool5.description ? `tool-${createDeterministicId(tool5.description)}` : `tool-${Math.random().toString(36).substring(2, 9)}` : tool5.id;
  return {
    ...tool5,
    id: toolId,
    inputSchema
  };
}
__name(setVercelToolProperties, "setVercelToolProperties");
function ensureToolProperties(tools) {
  const toolsWithProperties = Object.keys(tools).reduce((acc, key) => {
    const tool5 = tools?.[key];
    if (tool5) {
      if (isVercelTool(tool5)) {
        acc[key] = setVercelToolProperties(tool5);
      } else {
        acc[key] = tool5;
      }
    }
    return acc;
  }, {});
  return toolsWithProperties;
}
__name(ensureToolProperties, "ensureToolProperties");
function convertVercelToolParameters(tool5) {
  let schema = tool5.parameters ?? external_exports2.object({});
  if (typeof schema === "function") {
    schema = schema();
  }
  return isZodType2(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod2(schema));
}
__name(convertVercelToolParameters, "convertVercelToolParameters");
function makeCoreTool(originalTool, options, logType) {
  return new CoreToolBuilder({ originalTool, options, logType }).build();
}
__name(makeCoreTool, "makeCoreTool");
function createMastraProxy({ mastra, logger }) {
  return new Proxy(mastra, {
    get(target, prop) {
      const hasProp = Reflect.has(target, prop);
      if (hasProp) {
        const value = Reflect.get(target, prop);
        const isFunction2 = typeof value === "function";
        if (isFunction2) {
          return value.bind(target);
        }
        return value;
      }
      if (prop === "logger") {
        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);
        return Reflect.apply(target.getLogger, target, []);
      }
      if (prop === "telemetry") {
        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);
        return Reflect.apply(target.getTelemetry, target, []);
      }
      if (prop === "storage") {
        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);
        return Reflect.get(target, "storage");
      }
      if (prop === "agents") {
        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);
        return Reflect.apply(target.getAgents, target, []);
      }
      if (prop === "tts") {
        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);
        return Reflect.apply(target.getTTS, target, []);
      }
      if (prop === "vectors") {
        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);
        return Reflect.apply(target.getVectors, target, []);
      }
      if (prop === "memory") {
        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);
        return Reflect.get(target, "memory");
      }
      return Reflect.get(target, prop);
    }
  });
}
__name(createMastraProxy, "createMastraProxy");
async function fetchWithRetry(url3, options = {}, maxRetries = 3) {
  let retryCount = 0;
  let lastError = null;
  while (retryCount < maxRetries) {
    try {
      const response = await fetch(url3, options);
      if (!response.ok) {
        throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);
      }
      return response;
    } catch (error87) {
      lastError = error87 instanceof Error ? error87 : new Error(String(error87));
      retryCount++;
      if (retryCount >= maxRetries) {
        break;
      }
      const delay22 = Math.min(1e3 * Math.pow(2, retryCount) * 1e3, 1e4);
      await new Promise((resolve3) => setTimeout(resolve3, delay22));
    }
  }
  throw lastError || new Error("Request failed after multiple retry attempts");
}
__name(fetchWithRetry, "fetchWithRetry");
var removeUndefinedValues = /* @__PURE__ */ __name((obj) => {
  return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== void 0));
}, "removeUndefinedValues");
var AITracingRegistry = class {
  static {
    __name(this, "AITracingRegistry");
  }
  instances = /* @__PURE__ */ new Map();
  defaultInstance;
  configSelector;
  /**
   * Register a tracing instance
   */
  register(name51, instance, isDefault2 = false) {
    if (this.instances.has(name51)) {
      throw new Error(`AI Tracing instance '${name51}' already registered`);
    }
    this.instances.set(name51, instance);
    if (isDefault2 || !this.defaultInstance) {
      this.defaultInstance = instance;
    }
  }
  /**
   * Get a tracing instance by name
   */
  get(name51) {
    return this.instances.get(name51);
  }
  /**
   * Get the default tracing instance
   */
  getDefault() {
    return this.defaultInstance;
  }
  /**
   * Set the tracing selector function
   */
  setSelector(selector) {
    this.configSelector = selector;
  }
  /**
   * Get the selected tracing instance based on context
   */
  getSelected(options) {
    if (this.configSelector) {
      const selected = this.configSelector(options, this.instances);
      if (selected && this.instances.has(selected)) {
        return this.instances.get(selected);
      }
    }
    return this.defaultInstance;
  }
  /**
   * Unregister a tracing instance
   */
  unregister(name51) {
    return this.instances.delete(name51);
  }
  /**
   * Shutdown all instances and clear the registry
   */
  async shutdown() {
    const shutdownPromises = Array.from(this.instances.values()).map((instance) => instance.shutdown());
    await Promise.allSettled(shutdownPromises);
    this.instances.clear();
  }
  /**
   * Clear all instances without shutdown
   */
  clear() {
    this.instances.clear();
    this.defaultInstance = void 0;
    this.configSelector = void 0;
  }
  /**
   * Get all registered instances
   */
  getAll() {
    return new Map(this.instances);
  }
};
var aiTracingRegistry = new AITracingRegistry();
function getSelectedAITracing(options) {
  return aiTracingRegistry.getSelected(options);
}
__name(getSelectedAITracing, "getSelectedAITracing");
function selectFields2(obj, fields) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const result = {};
  for (const field of fields) {
    const value = getNestedValue2(obj, field);
    if (value !== void 0) {
      setNestedValue2(result, field, value);
    }
  }
  return result;
}
__name(selectFields2, "selectFields2");
function getNestedValue2(obj, path3) {
  return path3.split(".").reduce((current, key) => {
    return current && typeof current === "object" ? current[key] : void 0;
  }, obj);
}
__name(getNestedValue2, "getNestedValue2");
function setNestedValue2(obj, path3, value) {
  const keys = path3.split(".");
  const lastKey = keys.pop();
  if (!lastKey) {
    return;
  }
  const target = keys.reduce((current, key) => {
    if (!current[key] || typeof current[key] !== "object") {
      current[key] = {};
    }
    return current[key];
  }, obj);
  target[lastKey] = value;
}
__name(setNestedValue2, "setNestedValue2");
function getValidTraceId(span) {
  return span?.isValid ? span.traceId : void 0;
}
__name(getValidTraceId, "getValidTraceId");
function getOrCreateSpan(options) {
  const { type, attributes, tracingContext, runtimeContext, tracingOptions, ...rest } = options;
  const metadata = {
    ...rest.metadata ?? {},
    ...tracingOptions?.metadata ?? {}
  };
  if (tracingContext?.currentSpan) {
    return tracingContext.currentSpan.createChildSpan({
      type,
      attributes,
      ...rest,
      metadata
    });
  }
  const aiTracing = getSelectedAITracing({
    runtimeContext
  });
  return aiTracing?.startSpan({
    type,
    attributes,
    ...rest,
    metadata,
    runtimeContext,
    tracingOptions,
    traceId: tracingOptions?.traceId,
    parentSpanId: tracingOptions?.parentSpanId,
    customSamplerOptions: {
      runtimeContext,
      metadata
    }
  });
}
__name(getOrCreateSpan, "getOrCreateSpan");
var AGENT_GETTERS = ["getAgent", "getAgentById"];
var AGENT_METHODS_TO_WRAP = ["generate", "stream", "generateLegacy", "streamLegacy"];
var WORKFLOW_GETTERS = ["getWorkflow", "getWorkflowById"];
var WORKFLOW_METHODS_TO_WRAP = ["execute", "createRun", "createRunAsync"];
function isNoOpSpan(span) {
  return span.constructor.name === "NoOpAISpan" || span.__isNoOp === true;
}
__name(isNoOpSpan, "isNoOpSpan");
function isMastra(mastra) {
  const hasAgentGetters = AGENT_GETTERS.every((method) => typeof mastra?.[method] === "function");
  const hasWorkflowGetters = WORKFLOW_GETTERS.every((method) => typeof mastra?.[method] === "function");
  return hasAgentGetters && hasWorkflowGetters;
}
__name(isMastra, "isMastra");
function wrapMastra(mastra, tracingContext) {
  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
    return mastra;
  }
  if (!isMastra(mastra)) {
    return mastra;
  }
  try {
    return new Proxy(mastra, {
      get(target, prop) {
        try {
          if (AGENT_GETTERS.includes(prop)) {
            return (...args) => {
              const agent = target[prop](...args);
              return wrapAgent(agent, tracingContext);
            };
          }
          if (WORKFLOW_GETTERS.includes(prop)) {
            return (...args) => {
              const workflow = target[prop](...args);
              return wrapWorkflow(workflow, tracingContext);
            };
          }
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        } catch (error87) {
          console.warn("AI Tracing: Failed to wrap method, falling back to original", error87);
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        }
      }
    });
  } catch (error87) {
    console.warn("AI Tracing: Failed to create proxy, using original Mastra instance", error87);
    return mastra;
  }
}
__name(wrapMastra, "wrapMastra");
function wrapAgent(agent, tracingContext) {
  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
    return agent;
  }
  try {
    return new Proxy(agent, {
      get(target, prop) {
        try {
          if (AGENT_METHODS_TO_WRAP.includes(prop)) {
            return (input, options = {}) => {
              return target[prop](input, {
                ...options,
                tracingContext
              });
            };
          }
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        } catch (error87) {
          console.warn("AI Tracing: Failed to wrap agent method, falling back to original", error87);
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        }
      }
    });
  } catch (error87) {
    console.warn("AI Tracing: Failed to create agent proxy, using original instance", error87);
    return agent;
  }
}
__name(wrapAgent, "wrapAgent");
function wrapWorkflow(workflow, tracingContext) {
  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
    return workflow;
  }
  try {
    return new Proxy(workflow, {
      get(target, prop) {
        try {
          if (WORKFLOW_METHODS_TO_WRAP.includes(prop)) {
            if (prop === "createRun" || prop === "createRunAsync") {
              return async (options = {}) => {
                const run = await target[prop](options);
                return run ? wrapRun(run, tracingContext) : run;
              };
            }
            return (input, options = {}) => {
              return target[prop](input, {
                ...options,
                tracingContext
              });
            };
          }
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        } catch (error87) {
          console.warn("AI Tracing: Failed to wrap workflow method, falling back to original", error87);
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        }
      }
    });
  } catch (error87) {
    console.warn("AI Tracing: Failed to create workflow proxy, using original instance", error87);
    return workflow;
  }
}
__name(wrapWorkflow, "wrapWorkflow");
function wrapRun(run, tracingContext) {
  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
    return run;
  }
  try {
    return new Proxy(run, {
      get(target, prop) {
        try {
          if (prop === "start") {
            return (startOptions = {}) => {
              return target.start({
                ...startOptions,
                tracingContext: startOptions.tracingContext ?? tracingContext
              });
            };
          }
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        } catch (error87) {
          console.warn("AI Tracing: Failed to wrap run method, falling back to original", error87);
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        }
      }
    });
  } catch (error87) {
    console.warn("AI Tracing: Failed to create run proxy, using original instance", error87);
    return run;
  }
}
__name(wrapRun, "wrapRun");
var ModelSpanTracker = class {
  static {
    __name(this, "ModelSpanTracker");
  }
  #modelSpan;
  #currentStepSpan;
  #currentChunkSpan;
  #accumulator = {};
  #stepIndex = 0;
  #chunkSequence = 0;
  constructor(modelSpan) {
    this.#modelSpan = modelSpan;
  }
  /**
   * Get the tracing context for creating child spans.
   * Returns the current step span if active, otherwise the model span.
   */
  getTracingContext() {
    return {
      currentSpan: this.#currentStepSpan ?? this.#modelSpan
    };
  }
  /**
   * Report an error on the generation span
   */
  reportGenerationError(options) {
    this.#modelSpan?.error(options);
  }
  /**
   * End the generation span
   */
  endGeneration(options) {
    this.#modelSpan?.end(options);
  }
  /**
   * Update the generation span
   */
  updateGeneration(options) {
    this.#modelSpan?.update(options);
  }
  /**
   * Start a new Model execution step
   */
  #startStepSpan(payload) {
    this.#currentStepSpan = this.#modelSpan?.createChildSpan({
      name: `step: ${this.#stepIndex}`,
      type: "model_step",
      attributes: {
        stepIndex: this.#stepIndex,
        ...payload?.messageId ? { messageId: payload.messageId } : {},
        ...payload?.warnings?.length ? { warnings: payload.warnings } : {}
      },
      input: payload?.request
    });
    this.#chunkSequence = 0;
  }
  /**
   * End the current Model execution step with token usage, finish reason, output, and metadata
   */
  #endStepSpan(payload) {
    if (!this.#currentStepSpan) return;
    const output = payload.output;
    const { usage, ...otherOutput } = output;
    const stepResult = payload.stepResult;
    const metadata = payload.metadata;
    const cleanMetadata = metadata ? { ...metadata } : void 0;
    if (cleanMetadata?.request) {
      delete cleanMetadata.request;
    }
    this.#currentStepSpan.end({
      output: otherOutput,
      attributes: {
        usage,
        isContinued: stepResult.isContinued,
        finishReason: stepResult.reason,
        warnings: stepResult.warnings
      },
      metadata: {
        ...cleanMetadata
      }
    });
    this.#currentStepSpan = void 0;
    this.#stepIndex++;
  }
  /**
   * Create a new chunk span (for multi-part chunks like text-start/delta/end)
   */
  #startChunkSpan(chunkType, initialData) {
    if (!this.#currentStepSpan) {
      this.#startStepSpan();
    }
    this.#currentChunkSpan = this.#currentStepSpan?.createChildSpan({
      name: `chunk: '${chunkType}'`,
      type: "model_chunk",
      attributes: {
        chunkType,
        sequenceNumber: this.#chunkSequence
      }
    });
    this.#accumulator = initialData || {};
  }
  /**
   * Append string content to a specific field in the accumulator
   */
  #appendToAccumulator(field, text3) {
    if (this.#accumulator[field] === void 0) {
      this.#accumulator[field] = text3;
    } else {
      this.#accumulator[field] += text3;
    }
  }
  /**
   * End the current chunk span.
   * Safe to call multiple times - will no-op if span already ended.
   */
  #endChunkSpan(output) {
    if (!this.#currentChunkSpan) return;
    this.#currentChunkSpan.end({
      output: output !== void 0 ? output : this.#accumulator
    });
    this.#currentChunkSpan = void 0;
    this.#accumulator = {};
    this.#chunkSequence++;
  }
  /**
   * Create an event span (for single chunks like tool-call)
   */
  #createEventSpan(chunkType, output) {
    if (!this.#currentStepSpan) {
      this.#startStepSpan();
    }
    const span = this.#currentStepSpan?.createEventSpan({
      name: `chunk: '${chunkType}'`,
      type: "model_chunk",
      attributes: {
        chunkType,
        sequenceNumber: this.#chunkSequence
      },
      output
    });
    if (span) {
      this.#chunkSequence++;
    }
  }
  /**
   * Check if there is currently an active chunk span
   */
  #hasActiveChunkSpan() {
    return !!this.#currentChunkSpan;
  }
  /**
   * Get the current accumulator value
   */
  #getAccumulator() {
    return this.#accumulator;
  }
  /**
   * Handle text chunk spans (text-start/delta/end)
   */
  #handleTextChunk(chunk) {
    switch (chunk.type) {
      case "text-start":
        this.#startChunkSpan("text");
        break;
      case "text-delta":
        this.#appendToAccumulator("text", chunk.payload.text);
        break;
      case "text-end": {
        this.#endChunkSpan();
        break;
      }
    }
  }
  /**
   * Handle reasoning chunk spans (reasoning-start/delta/end)
   */
  #handleReasoningChunk(chunk) {
    switch (chunk.type) {
      case "reasoning-start":
        this.#startChunkSpan("reasoning");
        break;
      case "reasoning-delta":
        this.#appendToAccumulator("text", chunk.payload.text);
        break;
      case "reasoning-end": {
        this.#endChunkSpan();
        break;
      }
    }
  }
  /**
   * Handle tool call chunk spans (tool-call-input-streaming-start/delta/end, tool-call)
   */
  #handleToolCallChunk(chunk) {
    switch (chunk.type) {
      case "tool-call-input-streaming-start":
        this.#startChunkSpan("tool-call", {
          toolName: chunk.payload.toolName,
          toolCallId: chunk.payload.toolCallId
        });
        break;
      case "tool-call-delta":
        this.#appendToAccumulator("toolInput", chunk.payload.argsTextDelta);
        break;
      case "tool-call-input-streaming-end":
      case "tool-call": {
        const acc = this.#getAccumulator();
        let toolInput;
        try {
          toolInput = acc.toolInput ? JSON.parse(acc.toolInput) : {};
        } catch {
          toolInput = acc.toolInput;
        }
        this.#endChunkSpan({
          toolName: acc.toolName,
          toolCallId: acc.toolCallId,
          toolInput
        });
        break;
      }
    }
  }
  /**
   * Handle object chunk spans (object, object-result)
   */
  #handleObjectChunk(chunk) {
    switch (chunk.type) {
      case "object":
        if (!this.#hasActiveChunkSpan()) {
          this.#startChunkSpan("object");
        }
        break;
      case "object-result":
        this.#endChunkSpan(chunk.object);
        break;
    }
  }
  /**
   * Wraps a stream with model tracing transform to track MODEL_STEP and MODEL_CHUNK spans.
   *
   * This should be added to the stream pipeline to automatically
   * create MODEL_STEP and MODEL_CHUNK spans for each semantic unit in the stream.
   */
  wrapStream(stream) {
    return stream.pipeThrough(
      new TransformStream2({
        transform: /* @__PURE__ */ __name((chunk, controller) => {
          controller.enqueue(chunk);
          switch (chunk.type) {
            case "text-start":
            case "text-delta":
            case "text-end":
              this.#handleTextChunk(chunk);
              break;
            case "tool-call-input-streaming-start":
            case "tool-call-delta":
            case "tool-call-input-streaming-end":
            case "tool-call":
              this.#handleToolCallChunk(chunk);
              break;
            case "reasoning-start":
            case "reasoning-delta":
            case "reasoning-end":
              this.#handleReasoningChunk(chunk);
              break;
            case "object":
            case "object-result":
              this.#handleObjectChunk(chunk);
              break;
            case "step-start":
              this.#startStepSpan(chunk.payload);
              break;
            case "step-finish":
              this.#endStepSpan(chunk.payload);
              break;
            case "raw":
            // Skip raw chunks as they're redundant
            case "start":
            case "finish":
              break;
            // Default: auto-create event span for all other chunk types
            default: {
              let outputPayload = chunk.payload;
              if (outputPayload && typeof outputPayload === "object" && "data" in outputPayload) {
                const typedPayload = outputPayload;
                outputPayload = { ...typedPayload };
                if (typedPayload.data) {
                  outputPayload.size = typeof typedPayload.data === "string" ? typedPayload.data.length : typedPayload.data instanceof Uint8Array ? typedPayload.data.length : void 0;
                  delete outputPayload.data;
                }
              }
              this.#createEventSpan(chunk.type, outputPayload);
              break;
            }
          }
        }, "transform")
      })
    );
  }
};

// node_modules/@mastra/core/dist/chunk-NFJJ6B6P.js
init_chunk_PZUZNPFM();

// node_modules/@ai-sdk/provider-utils-v5/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@ai-sdk/provider-utils-v5/node_modules/@ai-sdk/provider/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var marker18 = "vercel.ai.error";
var symbol19 = Symbol.for(marker18);
var _a20;
var _AISDKError5 = class _AISDKError6 extends Error {
  static {
    __name(this, "_AISDKError");
  }
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a20] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error87) {
    return _AISDKError6.hasMarker(error87, marker18);
  }
  static hasMarker(error87, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
  }
};
_a20 = symbol19;
var AISDKError3 = _AISDKError5;
var name18 = "AI_APICallError";
var marker25 = `vercel.ai.error.${name18}`;
var symbol26 = Symbol.for(marker25);
var _a25;
_a25 = symbol26;
var name25 = "AI_EmptyResponseBodyError";
var marker35 = `vercel.ai.error.${name25}`;
var symbol35 = Symbol.for(marker35);
var _a35;
_a35 = symbol35;
var name35 = "AI_InvalidArgumentError";
var marker45 = `vercel.ai.error.${name35}`;
var symbol45 = Symbol.for(marker45);
var _a45;
var InvalidArgumentError4 = class extends AISDKError3 {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name35, message, cause });
    this[_a45] = true;
    this.argument = argument;
  }
  static isInstance(error87) {
    return AISDKError3.hasMarker(error87, marker45);
  }
};
_a45 = symbol45;
var name45 = "AI_InvalidPromptError";
var marker55 = `vercel.ai.error.${name45}`;
var symbol55 = Symbol.for(marker55);
var _a55;
_a55 = symbol55;
var name55 = "AI_InvalidResponseDataError";
var marker65 = `vercel.ai.error.${name55}`;
var symbol65 = Symbol.for(marker65);
var _a65;
_a65 = symbol65;
var name65 = "AI_JSONParseError";
var marker75 = `vercel.ai.error.${name65}`;
var symbol75 = Symbol.for(marker75);
var _a75;
_a75 = symbol75;
var name75 = "AI_LoadAPIKeyError";
var marker85 = `vercel.ai.error.${name75}`;
var symbol85 = Symbol.for(marker85);
var _a85;
_a85 = symbol85;
var name85 = "AI_LoadSettingError";
var marker95 = `vercel.ai.error.${name85}`;
var symbol95 = Symbol.for(marker95);
var _a95;
_a95 = symbol95;
var name95 = "AI_NoContentGeneratedError";
var marker105 = `vercel.ai.error.${name95}`;
var symbol105 = Symbol.for(marker105);
var _a105;
_a105 = symbol105;
var name105 = "AI_NoSuchModelError";
var marker115 = `vercel.ai.error.${name105}`;
var symbol115 = Symbol.for(marker115);
var _a115;
_a115 = symbol115;
var name115 = "AI_TooManyEmbeddingValuesForCallError";
var marker125 = `vercel.ai.error.${name115}`;
var symbol125 = Symbol.for(marker125);
var _a125;
_a125 = symbol125;
var name125 = "AI_TypeValidationError";
var marker135 = `vercel.ai.error.${name125}`;
var symbol135 = Symbol.for(marker135);
var _a135;
_a135 = symbol135;
var name135 = "AI_UnsupportedFunctionalityError";
var marker145 = `vercel.ai.error.${name135}`;
var symbol145 = Symbol.for(marker145);
var _a145;
_a145 = symbol145;

// node_modules/@ai-sdk/provider-utils-v5/dist/index.mjs
init_dist2();
var createIdGenerator3 = /* @__PURE__ */ __name(({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = /* @__PURE__ */ __name(() => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  }, "generator");
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError4({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
}, "createIdGenerator");
var generateId3 = createIdGenerator3();
function isAbortError3(error87) {
  return (error87 instanceof Error || error87 instanceof DOMException) && (error87.name === "AbortError" || error87.name === "ResponseAborted" || // Next.js
  error87.name === "TimeoutError");
}
__name(isAbortError3, "isAbortError");
var DEFAULT_SCHEMA_PREFIX2 = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX2 = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX2 = "You MUST answer with JSON.";
function injectJsonInstruction2({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX2 : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX2 : DEFAULT_GENERIC_SUFFIX2
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
__name(injectJsonInstruction2, "injectJsonInstruction");
function injectJsonInstructionIntoMessages({
  messages,
  schema,
  schemaPrefix,
  schemaSuffix
}) {
  var _a61, _b;
  const systemMessage = ((_a61 = messages[0]) == null ? void 0 : _a61.role) === "system" ? { ...messages[0] } : { role: "system", content: "" };
  systemMessage.content = injectJsonInstruction2({
    prompt: systemMessage.content,
    schema,
    schemaPrefix,
    schemaSuffix
  });
  return [
    systemMessage,
    ...((_b = messages[0]) == null ? void 0 : _b.role) === "system" ? messages.slice(1) : messages
  ];
}
__name(injectJsonInstructionIntoMessages, "injectJsonInstructionIntoMessages");
function isUrlSupported({
  mediaType,
  url: url3,
  supportedUrls
}) {
  url3 = url3.toLowerCase();
  mediaType = mediaType.toLowerCase();
  return Object.entries(supportedUrls).map(([key, value]) => {
    const mediaType2 = key.toLowerCase();
    return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url3));
}
__name(isUrlSupported, "isUrlSupported");
var validatorSymbol3 = Symbol.for("vercel.ai.validator");
var ignoreOverride3 = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var ALPHA_NUMERIC3 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
var schemaSymbol3 = Symbol.for("vercel.ai.schema");
var { btoa: btoa4, atob: atob4 } = globalThis;
function convertBase64ToUint8Array2(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob4(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
__name(convertBase64ToUint8Array2, "convertBase64ToUint8Array");
function convertUint8ArrayToBase642(array3) {
  let latin1string = "";
  for (let i = 0; i < array3.length; i++) {
    latin1string += String.fromCodePoint(array3[i]);
  }
  return btoa4(latin1string);
}
__name(convertUint8ArrayToBase642, "convertUint8ArrayToBase64");

// node_modules/@mastra/core/dist/chunk-NFJJ6B6P.js
import { randomUUID } from "crypto";
init_zod();
var DefaultGeneratedFile2 = class {
  static {
    __name(this, "DefaultGeneratedFile");
  }
  base64Data;
  uint8ArrayData;
  mediaType;
  constructor({ data, mediaType }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data;
    this.uint8ArrayData = isUint8Array ? data : void 0;
    this.mediaType = mediaType;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = convertUint8ArrayToBase642(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = convertBase64ToUint8Array2(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
var DefaultGeneratedFileWithType2 = class extends DefaultGeneratedFile2 {
  static {
    __name(this, "DefaultGeneratedFileWithType");
  }
  type = "file";
  constructor(options) {
    super(options);
  }
};
function splitDataUrl2(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header?.split(";")[0]?.split(":")[1],
      base64Content
    };
  } catch {
    return {
      mediaType: void 0,
      base64Content: void 0
    };
  }
}
__name(splitDataUrl2, "splitDataUrl");
function convertToDataContent(content) {
  if (content instanceof Uint8Array) {
    return { data: content, mediaType: void 0 };
  }
  if (content instanceof ArrayBuffer) {
    return { data: new Uint8Array(content), mediaType: void 0 };
  }
  if (typeof content === "string") {
    try {
      content = new URL(content);
    } catch {
    }
  }
  if (content instanceof URL && content.protocol === "data:") {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl2(content.toString());
    if (dataUrlMediaType == null || base64Content == null) {
      throw new MastraError({
        id: "INVALID_DATA_URL_FORMAT",
        text: `Invalid data URL format in content ${content.toString()}`,
        domain: "LLM",
        category: "USER"
        /* USER */
      });
    }
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: void 0 };
}
__name(convertToDataContent, "convertToDataContent");
var imageMediaTypeSignatures = [
  {
    mediaType: "image/gif",
    bytesPrefix: [71, 73, 70],
    base64Prefix: "R0lG"
  },
  {
    mediaType: "image/png",
    bytesPrefix: [137, 80, 78, 71],
    base64Prefix: "iVBORw"
  },
  {
    mediaType: "image/jpeg",
    bytesPrefix: [255, 216],
    base64Prefix: "/9j/"
  },
  {
    mediaType: "image/webp",
    bytesPrefix: [82, 73, 70, 70],
    base64Prefix: "UklGRg"
  },
  {
    mediaType: "image/bmp",
    bytesPrefix: [66, 77],
    base64Prefix: "Qk"
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0],
    base64Prefix: "SUkqAA"
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42],
    base64Prefix: "TU0AKg"
  },
  {
    mediaType: "image/avif",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 97, 118, 105, 102],
    base64Prefix: "AAAAIGZ0eXBhdmlm"
  },
  {
    mediaType: "image/heic",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 104, 101, 105, 99],
    base64Prefix: "AAAAIGZ0eXBoZWlj"
  }
];
var stripID32 = /* @__PURE__ */ __name((data) => {
  const bytes = typeof data === "string" ? convertBase64ToUint8Array2(data) : data;
  const id3Size = (
    // @ts-ignore
    (bytes[6] & 127) << 21 | // @ts-ignore
    (bytes[7] & 127) << 14 | // @ts-ignore
    (bytes[8] & 127) << 7 | // @ts-ignore
    bytes[9] & 127
  );
  return bytes.slice(id3Size + 10);
}, "stripID3");
function stripID3TagsIfPresent2(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
  data[1] === 68 && // 'D'
  data[2] === 51;
  return hasId3 ? stripID32(data) : data;
}
__name(stripID3TagsIfPresent2, "stripID3TagsIfPresent");
function detectMediaType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent2(data);
  for (const signature of signatures) {
    if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index) => processedData[index] === byte)) {
      return signature.mediaType;
    }
  }
  return void 0;
}
__name(detectMediaType, "detectMediaType");
function convertImageFilePart(part, downloadedAssets) {
  let originalData;
  const type = part.type;
  switch (type) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  const { data: convertedData, mediaType: convertedMediaType } = convertToDataContent(originalData);
  let mediaType = convertedMediaType ?? part.mediaType;
  let data = convertedData;
  if (data instanceof URL && downloadedAssets) {
    const downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile) {
      data = downloadedFile.data;
      mediaType ??= downloadedFile.mediaType;
    }
  }
  switch (type) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string") {
        mediaType = detectMediaType({ data, signatures: imageMediaTypeSignatures }) ?? mediaType;
      }
      return {
        type: "file",
        mediaType: mediaType ?? "image/*",
        // any image
        filename: void 0,
        data,
        providerOptions: part.providerOptions
      };
    }
    case "file": {
      if (mediaType == null) {
        throw new Error(`Media type is missing for file part`);
      }
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions
      };
    }
  }
}
__name(convertImageFilePart, "convertImageFilePart");
external_exports2.union([
  external_exports2.string(),
  external_exports2.instanceof(Uint8Array),
  external_exports2.instanceof(ArrayBuffer),
  external_exports2.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => globalThis.Buffer?.isBuffer(value) ?? false,
    { message: "Must be a Buffer" }
  )
]);
function convertDataContentToBase64String2(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
__name(convertDataContentToBase64String2, "convertDataContentToBase64String");
function parseDataUri(dataUri) {
  if (!dataUri.startsWith("data:")) {
    return {
      isDataUri: false,
      base64Content: dataUri
    };
  }
  const base64Index = dataUri.indexOf(",");
  if (base64Index === -1) {
    return {
      isDataUri: true,
      base64Content: dataUri
    };
  }
  const header = dataUri.substring(5, base64Index);
  const base64Content = dataUri.substring(base64Index + 1);
  const semicolonIndex = header.indexOf(";");
  const mimeType = semicolonIndex !== -1 ? header.substring(0, semicolonIndex) : header;
  return {
    isDataUri: true,
    mimeType: mimeType || void 0,
    base64Content
  };
}
__name(parseDataUri, "parseDataUri");
function createDataUri(base64Content, mimeType = "application/octet-stream") {
  if (base64Content.startsWith("data:")) {
    return base64Content;
  }
  return `data:${mimeType};base64,${base64Content}`;
}
__name(createDataUri, "createDataUri");
function imageContentToString(image, fallbackMimeType) {
  if (typeof image === "string") {
    return image;
  }
  if (image instanceof URL) {
    return image.toString();
  }
  if (image instanceof Uint8Array || image instanceof ArrayBuffer || globalThis.Buffer && Buffer.isBuffer(image)) {
    const base646 = convertDataContentToBase64String2(image);
    if (fallbackMimeType && !base646.startsWith("data:")) {
      return `data:${fallbackMimeType};base64,${base646}`;
    }
    return base646;
  }
  return String(image);
}
__name(imageContentToString, "imageContentToString");
function imageContentToDataUri(image, mimeType = "image/png") {
  const imageStr = imageContentToString(image, mimeType);
  if (imageStr.startsWith("data:")) {
    return imageStr;
  }
  if (imageStr.startsWith("http://") || imageStr.startsWith("https://")) {
    return imageStr;
  }
  return `data:${mimeType};base64,${imageStr}`;
}
__name(imageContentToDataUri, "imageContentToDataUri");
function getImageCacheKey(image) {
  if (image instanceof URL) {
    return image.toString();
  }
  if (typeof image === "string") {
    return image.length;
  }
  if (image instanceof Uint8Array) {
    return image.byteLength;
  }
  if (image instanceof ArrayBuffer) {
    return image.byteLength;
  }
  return image;
}
__name(getImageCacheKey, "getImageCacheKey");
function isValidUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    if (str.startsWith("//")) {
      try {
        new URL(`https:${str}`);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
}
__name(isValidUrl, "isValidUrl");
function categorizeFileData(data, fallbackMimeType) {
  const parsed = parseDataUri(data);
  const mimeType = parsed.isDataUri && parsed.mimeType ? parsed.mimeType : fallbackMimeType;
  if (parsed.isDataUri) {
    return {
      type: "dataUri",
      mimeType,
      data
    };
  }
  if (isValidUrl(data)) {
    return {
      type: "url",
      mimeType,
      data
    };
  }
  return {
    type: "raw",
    mimeType,
    data
  };
}
__name(categorizeFileData, "categorizeFileData");
function attachmentsToParts2(attachments) {
  const parts = [];
  for (const attachment of attachments) {
    const categorized = categorizeFileData(attachment.url, attachment.contentType);
    let urlString = attachment.url;
    if (categorized.type === "raw") {
      urlString = createDataUri(attachment.url, attachment.contentType || "application/octet-stream");
    }
    let url3;
    try {
      url3 = new URL(urlString);
    } catch {
      throw new Error(`Invalid URL: ${attachment.url}`);
    }
    switch (url3.protocol) {
      case "http:":
      case "https:": {
        if (attachment.contentType?.startsWith("image/")) {
          parts.push({ type: "image", image: url3.toString(), mimeType: attachment.contentType });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image, it must specify a content type");
          }
          parts.push({
            type: "file",
            data: url3.toString(),
            mimeType: attachment.contentType
          });
        }
        break;
      }
      case "data:": {
        if (attachment.contentType?.startsWith("image/")) {
          parts.push({
            type: "image",
            image: urlString,
            mimeType: attachment.contentType
          });
        } else if (attachment.contentType?.startsWith("text/")) {
          parts.push({
            type: "file",
            data: urlString,
            mimeType: attachment.contentType
          });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image or text, it must specify a content type");
          }
          parts.push({
            type: "file",
            data: urlString,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      default: {
        throw new Error(`Unsupported URL protocol: ${url3.protocol}`);
      }
    }
  }
  return parts;
}
__name(attachmentsToParts2, "attachmentsToParts");
var makePushOrCombine = /* @__PURE__ */ __name((v1Messages) => {
  const idUsageCount = /* @__PURE__ */ new Map();
  const SPLIT_SUFFIX_PATTERN = /__split-\d+$/;
  return (msg) => {
    const previousMessage = v1Messages.at(-1);
    if (msg.role === previousMessage?.role && Array.isArray(previousMessage.content) && Array.isArray(msg.content) && // we were creating new messages for tool calls before and not appending to the assistant message
    // so don't append here so everything works as before
    (msg.role !== `assistant` || msg.role === `assistant` && msg.content.at(-1)?.type !== `tool-call`)) {
      for (const part of msg.content) {
        previousMessage.content.push(part);
      }
    } else {
      let baseId = msg.id;
      const hasSplitSuffix = SPLIT_SUFFIX_PATTERN.test(baseId);
      if (hasSplitSuffix) {
        v1Messages.push(msg);
        return;
      }
      const currentCount = idUsageCount.get(baseId) || 0;
      if (currentCount > 0) {
        msg.id = `${baseId}__split-${currentCount}`;
      }
      idUsageCount.set(baseId, currentCount + 1);
      v1Messages.push(msg);
    }
  };
}, "makePushOrCombine");
function convertToV1Messages(messages) {
  const v1Messages = [];
  const pushOrCombine = makePushOrCombine(v1Messages);
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const isLastMessage = i === messages.length - 1;
    if (!message?.content) continue;
    const { content, experimental_attachments: inputAttachments = [], parts: inputParts } = message.content;
    const { role } = message;
    const fields = {
      id: message.id,
      createdAt: message.createdAt,
      resourceId: message.resourceId,
      threadId: message.threadId
    };
    const experimental_attachments = [...inputAttachments];
    const parts = [];
    for (const part of inputParts) {
      if (part.type === "file") {
        experimental_attachments.push({
          url: part.data,
          contentType: part.mimeType
        });
      } else {
        parts.push(part);
      }
    }
    switch (role) {
      case "user": {
        if (parts == null) {
          const userContent = experimental_attachments ? [{ type: "text", text: content || "" }, ...attachmentsToParts2(experimental_attachments)] : { type: "text", text: content || "" };
          pushOrCombine({
            role: "user",
            ...fields,
            type: "text",
            // @ts-ignore
            content: userContent
          });
        } else {
          const textParts = message.content.parts.filter((part) => part.type === "text").map((part) => ({
            type: "text",
            text: part.text
          }));
          const userContent = experimental_attachments ? [...textParts, ...attachmentsToParts2(experimental_attachments)] : textParts;
          pushOrCombine({
            role: "user",
            ...fields,
            type: "text",
            content: Array.isArray(userContent) && userContent.length === 1 && userContent[0]?.type === `text` && typeof content !== `undefined` ? content : userContent
          });
        }
        break;
      }
      case "assistant": {
        if (message.content.parts != null) {
          let processBlock2 = /* @__PURE__ */ __name(function() {
            const content2 = [];
            for (const part of block) {
              switch (part.type) {
                case "file":
                case "text": {
                  content2.push(part);
                  break;
                }
                case "reasoning": {
                  for (const detail of part.details) {
                    switch (detail.type) {
                      case "text":
                        content2.push({
                          type: "reasoning",
                          text: detail.text,
                          signature: detail.signature
                        });
                        break;
                      case "redacted":
                        content2.push({
                          type: "redacted-reasoning",
                          data: detail.data
                        });
                        break;
                    }
                  }
                  break;
                }
                case "tool-invocation":
                  if (part.toolInvocation.toolName !== "updateWorkingMemory") {
                    content2.push({
                      type: "tool-call",
                      toolCallId: part.toolInvocation.toolCallId,
                      toolName: part.toolInvocation.toolName,
                      args: part.toolInvocation.args
                    });
                  }
                  break;
              }
            }
            pushOrCombine({
              role: "assistant",
              ...fields,
              type: content2.some((c) => c.type === `tool-call`) ? "tool-call" : "text",
              content: typeof content2 !== `string` && Array.isArray(content2) && content2.length === 1 && content2[0]?.type === `text` ? content2[0].text : content2
            });
            const stepInvocations = block.filter((part) => `type` in part && part.type === "tool-invocation").map((part) => part.toolInvocation).filter((ti) => ti.toolName !== "updateWorkingMemory");
            const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
            if (invocationsWithResults.length > 0) {
              pushOrCombine({
                role: "tool",
                ...fields,
                type: "tool-result",
                content: invocationsWithResults.map((toolInvocation) => {
                  const { toolCallId, toolName, result } = toolInvocation;
                  return {
                    type: "tool-result",
                    toolCallId,
                    toolName,
                    result
                  };
                })
              });
            }
            block = [];
            blockHasToolInvocations = false;
            currentStep++;
          }, "processBlock2");
          let currentStep = 0;
          let blockHasToolInvocations = false;
          let block = [];
          for (const part of message.content.parts) {
            switch (part.type) {
              case "text": {
                if (blockHasToolInvocations) {
                  processBlock2();
                }
                block.push(part);
                break;
              }
              case "file":
              case "reasoning": {
                block.push(part);
                break;
              }
              case "tool-invocation": {
                const hasNonToolContent = block.some(
                  (p) => p.type === "text" || p.type === "file" || p.type === "reasoning"
                );
                if (hasNonToolContent || (part.toolInvocation.step ?? 0) !== currentStep) {
                  processBlock2();
                }
                block.push(part);
                blockHasToolInvocations = true;
                break;
              }
            }
          }
          processBlock2();
          const toolInvocations2 = message.content.toolInvocations;
          if (toolInvocations2 && toolInvocations2.length > 0) {
            const processedToolCallIds = /* @__PURE__ */ new Set();
            for (const part of message.content.parts) {
              if (part.type === "tool-invocation" && part.toolInvocation.toolCallId) {
                processedToolCallIds.add(part.toolInvocation.toolCallId);
              }
            }
            const unprocessedToolInvocations = toolInvocations2.filter(
              (ti) => !processedToolCallIds.has(ti.toolCallId) && ti.toolName !== "updateWorkingMemory"
            );
            if (unprocessedToolInvocations.length > 0) {
              const invocationsByStep = /* @__PURE__ */ new Map();
              for (const inv of unprocessedToolInvocations) {
                const step = inv.step ?? 0;
                if (!invocationsByStep.has(step)) {
                  invocationsByStep.set(step, []);
                }
                invocationsByStep.get(step).push(inv);
              }
              const sortedSteps = Array.from(invocationsByStep.keys()).sort((a, b) => a - b);
              for (const step of sortedSteps) {
                const stepInvocations = invocationsByStep.get(step);
                pushOrCombine({
                  role: "assistant",
                  ...fields,
                  type: "tool-call",
                  content: [
                    ...stepInvocations.map(({ toolCallId, toolName, args }) => ({
                      type: "tool-call",
                      toolCallId,
                      toolName,
                      args
                    }))
                  ]
                });
                const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
                if (invocationsWithResults.length > 0) {
                  pushOrCombine({
                    role: "tool",
                    ...fields,
                    type: "tool-result",
                    content: invocationsWithResults.map((toolInvocation) => {
                      const { toolCallId, toolName, result } = toolInvocation;
                      return {
                        type: "tool-result",
                        toolCallId,
                        toolName,
                        result
                      };
                    })
                  });
                }
              }
            }
          }
          break;
        }
        const toolInvocations = message.content.toolInvocations;
        if (toolInvocations == null || toolInvocations.length === 0) {
          pushOrCombine({ role: "assistant", ...fields, content: content || "", type: "text" });
          break;
        }
        const maxStep = toolInvocations.reduce((max, toolInvocation) => {
          return Math.max(max, toolInvocation.step ?? 0);
        }, 0);
        for (let i2 = 0; i2 <= maxStep; i2++) {
          const stepInvocations = toolInvocations.filter(
            (toolInvocation) => (toolInvocation.step ?? 0) === i2 && toolInvocation.toolName !== "updateWorkingMemory"
          );
          if (stepInvocations.length === 0) {
            continue;
          }
          pushOrCombine({
            role: "assistant",
            ...fields,
            type: "tool-call",
            content: [
              ...isLastMessage && content && i2 === 0 ? [{ type: "text", text: content }] : [],
              ...stepInvocations.map(({ toolCallId, toolName, args }) => ({
                type: "tool-call",
                toolCallId,
                toolName,
                args
              }))
            ]
          });
          const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
          if (invocationsWithResults.length > 0) {
            pushOrCombine({
              role: "tool",
              ...fields,
              type: "tool-result",
              content: invocationsWithResults.map((toolInvocation) => {
                const { toolCallId, toolName, result } = toolInvocation;
                return {
                  type: "tool-result",
                  toolCallId,
                  toolName,
                  result
                };
              })
            });
          }
        }
        if (content && !isLastMessage) {
          pushOrCombine({ role: "assistant", ...fields, type: "text", content: content || "" });
        }
        break;
      }
    }
  }
  return v1Messages;
}
__name(convertToV1Messages, "convertToV1Messages");
var downloadFromUrl = /* @__PURE__ */ __name(async ({ url: url3, downloadRetries }) => {
  const urlText = url3.toString();
  try {
    const response = await fetchWithRetry(
      urlText,
      {
        method: "GET"
      },
      downloadRetries
    );
    if (!response.ok) {
      throw new MastraError({
        id: "DOWNLOAD_ASSETS_FAILED",
        text: "Failed to download asset",
        domain: "LLM",
        category: "USER"
        /* USER */
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mediaType: response.headers.get("content-type") ?? void 0
    };
  } catch (error87) {
    throw new MastraError(
      {
        id: "DOWNLOAD_ASSETS_FAILED",
        text: "Failed to download asset",
        domain: "LLM",
        category: "USER"
        /* USER */
      },
      error87
    );
  }
}, "downloadFromUrl");
async function downloadAssetsFromMessages({
  messages,
  downloadConcurrency = 10,
  downloadRetries = 3,
  supportedUrls
}) {
  const pMap2 = (await Promise.resolve().then(() => (init_p_map(), p_map_exports))).default;
  const filesToDownload = messages.filter((message) => message.role === "user").map((message) => message.content).filter((content) => Array.isArray(content)).flat().filter((part) => part.type === "image" || part.type === "file").map((part) => {
    const mediaType = part.mediaType ?? (part.type === "image" ? "image/*" : void 0);
    let data = part.type === "image" ? part.image : part.data;
    if (typeof data === "string") {
      try {
        data = new URL(data);
      } catch {
      }
    }
    return { mediaType, data };
  }).filter((part) => part.data instanceof URL).map((part) => {
    return {
      url: part.data,
      isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
        url: part.data.toString(),
        mediaType: part.mediaType,
        supportedUrls: supportedUrls ?? {}
      })
    };
  });
  const downloadedFiles = await pMap2(
    filesToDownload,
    async (fileItem) => {
      if (fileItem.isUrlSupportedByModel) {
        return null;
      }
      return {
        url: fileItem.url.toString(),
        ...await downloadFromUrl({ url: fileItem.url, downloadRetries })
      };
    },
    {
      concurrency: downloadConcurrency
    }
  );
  const downloadFileList = downloadedFiles.filter(
    (downloadedFile) => downloadedFile?.data != null
  ).map(({ url: url3, data, mediaType }) => [url3, { data, mediaType }]);
  return Object.fromEntries(downloadFileList);
}
__name(downloadAssetsFromMessages, "downloadAssetsFromMessages");
function ensureGeminiCompatibleMessages(messages) {
  const result = [...messages];
  const firstNonSystemIndex = result.findIndex((m) => m.role !== "system");
  if (firstNonSystemIndex === -1) {
    throw new MastraError({
      id: "NO_USER_OR_ASSISTANT_MESSAGES",
      domain: "AGENT",
      category: "USER",
      text: "This request does not contain any user or assistant messages. At least one user or assistant message is required to generate a response."
    });
  } else if (result[firstNonSystemIndex]?.role === "assistant") {
    result.splice(firstNonSystemIndex, 0, {
      role: "user",
      content: "."
    });
  }
  return result;
}
__name(ensureGeminiCompatibleMessages, "ensureGeminiCompatibleMessages");
function getToolName2(type) {
  if (typeof type === "object" && type && "type" in type) {
    type = type.type;
  }
  if (typeof type !== "string") {
    return "unknown";
  }
  if (type === "dynamic-tool") {
    return "dynamic-tool";
  }
  if (type.startsWith("tool-")) {
    return type.slice("tool-".length);
  }
  return type;
}
__name(getToolName2, "getToolName");
var MessageList = class _MessageList {
  static {
    __name(this, "_MessageList");
  }
  messages = [];
  // passed in by dev in input or context
  systemMessages = [];
  // passed in by us for a specific purpose, eg memory system message
  taggedSystemMessages = {};
  memoryInfo = null;
  // used to filter this.messages by how it was added: input/response/memory
  memoryMessages = /* @__PURE__ */ new Set();
  newUserMessages = /* @__PURE__ */ new Set();
  newResponseMessages = /* @__PURE__ */ new Set();
  userContextMessages = /* @__PURE__ */ new Set();
  memoryMessagesPersisted = /* @__PURE__ */ new Set();
  newUserMessagesPersisted = /* @__PURE__ */ new Set();
  newResponseMessagesPersisted = /* @__PURE__ */ new Set();
  userContextMessagesPersisted = /* @__PURE__ */ new Set();
  generateMessageId;
  _agentNetworkAppend = false;
  constructor({
    threadId,
    resourceId,
    generateMessageId,
    // @ts-ignore Flag for agent network messages
    _agentNetworkAppend
  } = {}) {
    if (threadId) {
      this.memoryInfo = { threadId, resourceId };
    }
    this.generateMessageId = generateMessageId;
    this._agentNetworkAppend = _agentNetworkAppend || false;
  }
  add(messages, messageSource) {
    if (messageSource === `user`) messageSource = `input`;
    if (!messages) return this;
    for (const message of Array.isArray(messages) ? messages : [messages]) {
      this.addOne(
        typeof message === `string` ? {
          role: "user",
          content: message
        } : message,
        messageSource
      );
    }
    return this;
  }
  serializeSet(set3) {
    return Array.from(set3).map((value) => value.id);
  }
  deserializeSet(ids) {
    return new Set(ids.map((id) => this.messages.find((m) => m.id === id)).filter(Boolean));
  }
  serializeMessage(message) {
    return {
      ...message,
      createdAt: message.createdAt.toUTCString()
    };
  }
  deserializeMessage(state) {
    return {
      ...state,
      createdAt: new Date(state.createdAt)
    };
  }
  serialize() {
    return {
      messages: this.messages.map(this.serializeMessage),
      systemMessages: this.systemMessages,
      taggedSystemMessages: this.taggedSystemMessages,
      memoryInfo: this.memoryInfo,
      _agentNetworkAppend: this._agentNetworkAppend,
      memoryMessages: this.serializeSet(this.memoryMessages),
      newUserMessages: this.serializeSet(this.newUserMessages),
      newResponseMessages: this.serializeSet(this.newResponseMessages),
      userContextMessages: this.serializeSet(this.userContextMessages),
      memoryMessagesPersisted: this.serializeSet(this.memoryMessagesPersisted),
      newUserMessagesPersisted: this.serializeSet(this.newUserMessagesPersisted),
      newResponseMessagesPersisted: this.serializeSet(this.newResponseMessagesPersisted),
      userContextMessagesPersisted: this.serializeSet(this.userContextMessagesPersisted)
    };
  }
  deserialize(state) {
    this.messages = state.messages.map(this.deserializeMessage);
    this.systemMessages = state.systemMessages;
    this.taggedSystemMessages = state.taggedSystemMessages;
    this.memoryInfo = state.memoryInfo;
    this._agentNetworkAppend = state._agentNetworkAppend;
    this.memoryMessages = this.deserializeSet(state.memoryMessages);
    this.newUserMessages = this.deserializeSet(state.newUserMessages);
    this.newResponseMessages = this.deserializeSet(state.newResponseMessages);
    this.userContextMessages = this.deserializeSet(state.userContextMessages);
    this.memoryMessagesPersisted = this.deserializeSet(state.memoryMessagesPersisted);
    this.newUserMessagesPersisted = this.deserializeSet(state.newUserMessagesPersisted);
    this.newResponseMessagesPersisted = this.deserializeSet(state.newResponseMessagesPersisted);
    this.userContextMessagesPersisted = this.deserializeSet(state.userContextMessagesPersisted);
    return this;
  }
  getLatestUserContent() {
    const currentUserMessages = this.all.core().filter((m) => m.role === "user");
    const content = currentUserMessages.at(-1)?.content;
    if (!content) return null;
    return _MessageList.coreContentToString(content);
  }
  get get() {
    return {
      all: this.all,
      remembered: this.remembered,
      input: this.input,
      response: this.response
    };
  }
  get getPersisted() {
    return {
      remembered: this.rememberedPersisted,
      input: this.inputPersisted,
      taggedSystemMessages: this.taggedSystemMessages,
      response: this.responsePersisted
    };
  }
  get clear() {
    return {
      input: {
        v2: /* @__PURE__ */ __name(() => {
          const userMessages = Array.from(this.newUserMessages);
          this.messages = this.messages.filter((m) => !this.newUserMessages.has(m));
          this.newUserMessages.clear();
          return userMessages;
        }, "v2")
      },
      response: {
        v2: /* @__PURE__ */ __name(() => {
          const responseMessages = Array.from(this.newResponseMessages);
          this.messages = this.messages.filter((m) => !this.newResponseMessages.has(m));
          this.newResponseMessages.clear();
          return responseMessages;
        }, "v2")
      }
    };
  }
  all = {
    v3: /* @__PURE__ */ __name(() => this.cleanV3Metadata(this.messages.map(this.mastraMessageV2ToMastraMessageV3)), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages, "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.all.v2()), "v1"),
    aiV5: {
      model: /* @__PURE__ */ __name(() => this.aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui()), "model"),
      ui: /* @__PURE__ */ __name(() => this.all.v3().map(_MessageList.mastraMessageV3ToAIV5UIMessage), "ui"),
      // Used when calling AI SDK streamText/generateText
      prompt: /* @__PURE__ */ __name(() => {
        const systemMessages = this.aiV4CoreMessagesToAIV5ModelMessages(
          [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()],
          `system`
        );
        const modelMessages = this.all.aiV5.model();
        const messages = [...systemMessages, ...modelMessages];
        return ensureGeminiCompatibleMessages(messages);
      }, "prompt"),
      // Used for creating LLM prompt messages without AI SDK streamText/generateText
      llmPrompt: /* @__PURE__ */ __name(async (options = {
        downloadConcurrency: 10,
        downloadRetries: 3
      }) => {
        const modelMessages = this.all.aiV5.model();
        const systemMessages = this.aiV4CoreMessagesToAIV5ModelMessages(
          [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()],
          `system`
        );
        const downloadedAssets = await downloadAssetsFromMessages({
          messages: modelMessages,
          downloadConcurrency: options?.downloadConcurrency,
          downloadRetries: options?.downloadRetries,
          supportedUrls: options?.supportedUrls
        });
        let messages = [...systemMessages, ...modelMessages];
        const hasImageOrFileContent = modelMessages.some(
          (message) => message.role === "user" && typeof message.content !== "string" && message.content.some((part) => part.type === "image" || part.type === "file")
        );
        if (hasImageOrFileContent) {
          messages = messages.map((message) => {
            if (message.role === "user") {
              if (typeof message.content === "string") {
                return {
                  role: "user",
                  content: [{ type: "text", text: message.content }],
                  providerOptions: message.providerOptions
                };
              }
              const convertedContent = message.content.map((part) => {
                if (part.type === "image" || part.type === "file") {
                  return convertImageFilePart(part, downloadedAssets);
                }
                return part;
              }).filter((part) => part.type !== "text" || part.text !== "");
              return {
                role: "user",
                content: convertedContent,
                providerOptions: message.providerOptions
              };
            }
            return message;
          });
        }
        messages = ensureGeminiCompatibleMessages(messages);
        return messages.map(_MessageList.aiV5ModelMessageToV2PromptMessage);
      }, "llmPrompt")
    },
    /* @deprecated use list.get.all.aiV4.prompt() instead */
    prompt: /* @__PURE__ */ __name(() => this.all.aiV4.prompt(), "prompt"),
    /* @deprecated use list.get.all.aiV4.ui() */
    ui: /* @__PURE__ */ __name(() => this.all.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
    /* @deprecated use list.get.all.aiV4.core() */
    core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()), "core"),
    aiV4: {
      ui: /* @__PURE__ */ __name(() => this.all.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
      core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()), "core"),
      // Used when calling AI SDK streamText/generateText
      prompt: /* @__PURE__ */ __name(() => {
        const coreMessages = this.all.aiV4.core();
        const messages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat(), ...coreMessages];
        return ensureGeminiCompatibleMessages(messages);
      }, "prompt"),
      // Used for creating LLM prompt messages without AI SDK streamText/generateText
      llmPrompt: /* @__PURE__ */ __name(() => {
        const coreMessages = this.all.aiV4.core();
        const systemMessages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()];
        let messages = [...systemMessages, ...coreMessages];
        messages = ensureGeminiCompatibleMessages(messages);
        return messages.map(_MessageList.aiV4CoreMessageToV1PromptMessage);
      }, "llmPrompt")
    }
  };
  remembered = {
    v3: /* @__PURE__ */ __name(() => this.remembered.v2().map(this.mastraMessageV2ToMastraMessageV3), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages.filter((m) => this.memoryMessages.has(m)), "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.remembered.v2()), "v1"),
    aiV5: {
      model: /* @__PURE__ */ __name(() => this.aiV5UIMessagesToAIV5ModelMessages(this.remembered.aiV5.ui()), "model"),
      ui: /* @__PURE__ */ __name(() => this.remembered.v3().map(_MessageList.mastraMessageV3ToAIV5UIMessage), "ui")
    },
    /* @deprecated use list.get.remembered.aiV4.ui() */
    ui: /* @__PURE__ */ __name(() => this.remembered.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
    /* @deprecated use list.get.remembered.aiV4.core() */
    core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()), "core"),
    aiV4: {
      ui: /* @__PURE__ */ __name(() => this.remembered.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
      core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()), "core")
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  rememberedPersisted = {
    v2: /* @__PURE__ */ __name(() => this.all.v2().filter((m) => this.memoryMessagesPersisted.has(m)), "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.rememberedPersisted.v2()), "v1"),
    ui: /* @__PURE__ */ __name(() => this.rememberedPersisted.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
    core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.rememberedPersisted.ui()), "core")
  };
  input = {
    v3: /* @__PURE__ */ __name(() => this.cleanV3Metadata(
      this.messages.filter((m) => this.newUserMessages.has(m)).map(this.mastraMessageV2ToMastraMessageV3)
    ), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages.filter((m) => this.newUserMessages.has(m)), "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.input.v2()), "v1"),
    aiV5: {
      model: /* @__PURE__ */ __name(() => this.aiV5UIMessagesToAIV5ModelMessages(this.input.aiV5.ui()), "model"),
      ui: /* @__PURE__ */ __name(() => this.input.v3().map(_MessageList.mastraMessageV3ToAIV5UIMessage), "ui")
    },
    /* @deprecated use list.get.input.aiV4.ui() instead */
    ui: /* @__PURE__ */ __name(() => this.input.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
    /* @deprecated use list.get.core.aiV4.ui() instead */
    core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.input.ui()), "core"),
    aiV4: {
      ui: /* @__PURE__ */ __name(() => this.input.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
      core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.input.aiV4.ui()), "core")
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  inputPersisted = {
    v3: /* @__PURE__ */ __name(() => this.cleanV3Metadata(
      this.messages.filter((m) => this.newUserMessagesPersisted.has(m)).map(this.mastraMessageV2ToMastraMessageV3)
    ), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages.filter((m) => this.newUserMessagesPersisted.has(m)), "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.inputPersisted.v2()), "v1"),
    ui: /* @__PURE__ */ __name(() => this.inputPersisted.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
    core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.inputPersisted.ui()), "core")
  };
  response = {
    v3: /* @__PURE__ */ __name(() => this.response.v2().map(this.mastraMessageV2ToMastraMessageV3), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages.filter((m) => this.newResponseMessages.has(m)), "v2"),
    v1: /* @__PURE__ */ __name(() => convertToV1Messages(this.response.v3().map(_MessageList.mastraMessageV3ToV2)), "v1"),
    aiV5: {
      ui: /* @__PURE__ */ __name(() => this.response.v3().map(_MessageList.mastraMessageV3ToAIV5UIMessage), "ui"),
      model: /* @__PURE__ */ __name(() => this.aiV5UIMessagesToAIV5ModelMessages(this.response.aiV5.ui()).filter(
        (m) => m.role === `tool` || m.role === `assistant`
      ), "model"),
      modelContent: /* @__PURE__ */ __name((stepNumber) => {
        if (typeof stepNumber === "number") {
          const uiMessages = this.response.aiV5.ui();
          const uiMessagesParts = uiMessages.flatMap((item) => item.parts);
          const stepBoundaries = [];
          uiMessagesParts.forEach((part, index) => {
            if (part.type === "step-start") {
              stepBoundaries.push(index);
            }
          });
          if (stepNumber === -1) {
            const toolParts = uiMessagesParts.filter((p) => p.type?.startsWith("tool-"));
            const hasStepStart = stepBoundaries.length > 0;
            if (!hasStepStart && toolParts.length > 0) {
              const lastToolPart = toolParts[toolParts.length - 1];
              if (!lastToolPart) {
                return [];
              }
              const lastToolIndex = uiMessagesParts.indexOf(lastToolPart);
              const previousToolPart = toolParts[toolParts.length - 2];
              const previousToolIndex = previousToolPart ? uiMessagesParts.indexOf(previousToolPart) : -1;
              const startIndex2 = previousToolIndex + 1;
              const stepParts3 = uiMessagesParts.slice(startIndex2, lastToolIndex + 1);
              const stepUiMessages3 = [
                {
                  id: "last-step",
                  role: "assistant",
                  parts: stepParts3
                }
              ];
              const modelMessages3 = convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages3));
              return modelMessages3.flatMap(this.response.aiV5.stepContent);
            }
            const totalSteps = stepBoundaries.length + 1;
            if (totalSteps === 1 && !hasStepStart) {
              const stepUiMessages3 = [
                {
                  id: "last-step",
                  role: "assistant",
                  parts: uiMessagesParts
                }
              ];
              const modelMessages3 = convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages3));
              return modelMessages3.flatMap(this.response.aiV5.stepContent);
            }
            const lastStepStart = stepBoundaries[stepBoundaries.length - 1];
            if (lastStepStart === void 0) {
              return [];
            }
            const stepParts2 = uiMessagesParts.slice(lastStepStart + 1);
            if (stepParts2.length === 0) {
              return [];
            }
            const stepUiMessages2 = [
              {
                id: "last-step",
                role: "assistant",
                parts: stepParts2
              }
            ];
            const modelMessages2 = convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages2));
            return modelMessages2.flatMap(this.response.aiV5.stepContent);
          }
          if (stepNumber === 1) {
            const firstStepStart = stepBoundaries[0] ?? uiMessagesParts.length;
            if (firstStepStart === 0) {
              return [];
            }
            const stepParts2 = uiMessagesParts.slice(0, firstStepStart);
            const stepUiMessages2 = [
              {
                id: "step-1",
                role: "assistant",
                parts: stepParts2
              }
            ];
            const modelMessages2 = convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages2));
            return modelMessages2.flatMap(this.response.aiV5.stepContent);
          }
          const stepIndex = stepNumber - 2;
          if (stepIndex < 0 || stepIndex >= stepBoundaries.length) {
            return [];
          }
          const startIndex = (stepBoundaries[stepIndex] ?? 0) + 1;
          const endIndex = stepBoundaries[stepIndex + 1] ?? uiMessagesParts.length;
          if (startIndex >= endIndex) {
            return [];
          }
          const stepParts = uiMessagesParts.slice(startIndex, endIndex);
          const stepUiMessages = [
            {
              id: `step-${stepNumber}`,
              role: "assistant",
              parts: stepParts
            }
          ];
          const modelMessages = convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages));
          return modelMessages.flatMap(this.response.aiV5.stepContent);
        }
        return this.response.aiV5.model().map(this.response.aiV5.stepContent).flat();
      }, "modelContent"),
      stepContent: /* @__PURE__ */ __name((message) => {
        const latest = message ? message : this.response.aiV5.model().at(-1);
        if (!latest) return [];
        if (typeof latest.content === `string`) {
          return [{ type: "text", text: latest.content }];
        }
        return latest.content.map((c) => {
          if (c.type === `tool-result`)
            return {
              type: "tool-result",
              input: {},
              // TODO: we need to find the tool call here and add the input from it
              output: c.output,
              toolCallId: c.toolCallId,
              toolName: c.toolName
            };
          if (c.type === `file`)
            return {
              type: "file",
              file: new DefaultGeneratedFileWithType2({
                data: typeof c.data === `string` ? parseDataUri(c.data).base64Content : c.data instanceof URL ? c.data.toString() : convertDataContentToBase64String2(c.data),
                mediaType: c.mediaType
              })
            };
          if (c.type === `image`) {
            return {
              type: "file",
              file: new DefaultGeneratedFileWithType2({
                data: typeof c.image === `string` ? parseDataUri(c.image).base64Content : c.image instanceof URL ? c.image.toString() : convertDataContentToBase64String2(c.image),
                mediaType: c.mediaType || "unknown"
              })
            };
          }
          return { ...c };
        });
      }, "stepContent")
    },
    aiV4: {
      ui: /* @__PURE__ */ __name(() => this.response.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui"),
      core: /* @__PURE__ */ __name(() => this.aiV4UIMessagesToAIV4CoreMessages(this.response.aiV4.ui()), "core")
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  responsePersisted = {
    v3: /* @__PURE__ */ __name(() => this.cleanV3Metadata(
      this.messages.filter((m) => this.newResponseMessagesPersisted.has(m)).map(this.mastraMessageV2ToMastraMessageV3)
    ), "v3"),
    v2: /* @__PURE__ */ __name(() => this.messages.filter((m) => this.newResponseMessagesPersisted.has(m)), "v2"),
    ui: /* @__PURE__ */ __name(() => this.responsePersisted.v2().map(_MessageList.mastraMessageV2ToAIV4UIMessage), "ui")
  };
  drainUnsavedMessages() {
    const messages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));
    this.newUserMessages.clear();
    this.newResponseMessages.clear();
    return messages;
  }
  getEarliestUnsavedMessageTimestamp() {
    const unsavedMessages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));
    if (unsavedMessages.length === 0) return void 0;
    return Math.min(...unsavedMessages.map((m) => new Date(m.createdAt).getTime()));
  }
  getSystemMessages(tag) {
    if (tag) {
      return this.taggedSystemMessages[tag] || [];
    }
    return this.systemMessages;
  }
  addSystem(messages, tag) {
    if (!messages) return this;
    for (const message of Array.isArray(messages) ? messages : [messages]) {
      this.addOneSystem(message, tag);
    }
    return this;
  }
  aiV4UIMessagesToAIV4CoreMessages(messages) {
    return convertToCoreMessages(this.sanitizeAIV4UIMessages(messages));
  }
  sanitizeAIV4UIMessages(messages) {
    const msgs = messages.map((m) => {
      if (m.parts.length === 0) return false;
      const safeParts = m.parts.filter(
        (p) => p.type !== `tool-invocation` || // calls and partial-calls should be updated to be results at this point
        // if they haven't we can't send them back to the llm and need to remove them.
        p.toolInvocation.state !== `call` && p.toolInvocation.state !== `partial-call`
      );
      if (!safeParts.length) return false;
      const sanitized = {
        ...m,
        parts: safeParts
      };
      if (`toolInvocations` in m && m.toolInvocations) {
        sanitized.toolInvocations = m.toolInvocations.filter((t) => t.state === `result`);
      }
      return sanitized;
    }).filter((m) => Boolean(m));
    return msgs;
  }
  /**
   * Converts various message formats to AIV4 CoreMessage format for system messages
   * @param message - The message to convert (can be string, MastraMessageV2, or AI SDK message types)
   * @returns AIV4 CoreMessage in the proper format
   */
  systemMessageToAICore(message) {
    if (typeof message === `string`) {
      return { role: "system", content: message };
    }
    if (_MessageList.isAIV5CoreMessage(message)) {
      return this.aiV5ModelMessagesToAIV4CoreMessages([message], `system`)[0];
    }
    if (_MessageList.isMastraMessageV2(message)) {
      return _MessageList.mastraMessageV2SystemToV4Core(message);
    }
    return message;
  }
  addOneSystem(message, tag) {
    const coreMessage = this.systemMessageToAICore(message);
    if (coreMessage.role !== `system`) {
      throw new Error(
        `Expected role "system" but saw ${coreMessage.role} for message ${JSON.stringify(coreMessage, null, 2)}`
      );
    }
    if (tag && !this.isDuplicateSystem(coreMessage, tag)) {
      this.taggedSystemMessages[tag] ||= [];
      this.taggedSystemMessages[tag].push(coreMessage);
    } else if (!tag && !this.isDuplicateSystem(coreMessage)) {
      this.systemMessages.push(coreMessage);
    }
  }
  isDuplicateSystem(message, tag) {
    if (tag) {
      if (!this.taggedSystemMessages[tag]) return false;
      return this.taggedSystemMessages[tag].some(
        (m) => _MessageList.cacheKeyFromAIV4CoreMessageContent(m.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(message.content)
      );
    }
    return this.systemMessages.some(
      (m) => _MessageList.cacheKeyFromAIV4CoreMessageContent(m.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(message.content)
    );
  }
  static mastraMessageV2ToAIV4UIMessage(m) {
    const experimentalAttachments = m.content.experimental_attachments ? [...m.content.experimental_attachments] : [];
    const contentString = typeof m.content.content === `string` && m.content.content !== "" ? m.content.content : m.content.parts.reduce((prev, part) => {
      if (part.type === `text`) {
        return part.text;
      }
      return prev;
    }, "");
    const parts = [];
    if (m.content.parts.length) {
      for (const part of m.content.parts) {
        if (part.type === `file`) {
          let normalizedUrl;
          if (typeof part.data === "string") {
            const categorized = categorizeFileData(part.data, part.mimeType);
            if (categorized.type === "raw") {
              normalizedUrl = createDataUri(part.data, part.mimeType || "application/octet-stream");
            } else {
              normalizedUrl = part.data;
            }
          } else {
            normalizedUrl = part.data;
          }
          experimentalAttachments.push({
            contentType: part.mimeType,
            url: normalizedUrl
          });
        } else if (part.type === "tool-invocation" && (part.toolInvocation.state === "call" || part.toolInvocation.state === "partial-call")) {
          continue;
        } else if (part.type === "tool-invocation") {
          const toolInvocation = { ...part.toolInvocation };
          let currentStep = -1;
          let toolStep = -1;
          for (const innerPart of m.content.parts) {
            if (innerPart.type === `step-start`) currentStep++;
            if (innerPart.type === `tool-invocation` && innerPart.toolInvocation.toolCallId === part.toolInvocation.toolCallId) {
              toolStep = currentStep;
              break;
            }
          }
          if (toolStep >= 0) {
            const preparedInvocation = {
              step: toolStep,
              ...toolInvocation
            };
            parts.push({
              type: "tool-invocation",
              toolInvocation: preparedInvocation
            });
          } else {
            parts.push({
              type: "tool-invocation",
              toolInvocation
            });
          }
        } else {
          parts.push(part);
        }
      }
    }
    if (parts.length === 0 && experimentalAttachments.length > 0) {
      parts.push({ type: "text", text: "" });
    }
    if (m.role === `user`) {
      const uiMessage2 = {
        id: m.id,
        role: m.role,
        content: m.content.content || contentString,
        createdAt: m.createdAt,
        parts,
        experimental_attachments: experimentalAttachments
      };
      if (m.content.metadata) {
        uiMessage2.metadata = m.content.metadata;
      }
      return uiMessage2;
    } else if (m.role === `assistant`) {
      const isSingleTextContentArray = Array.isArray(m.content.content) && m.content.content.length === 1 && m.content.content[0].type === `text`;
      const uiMessage2 = {
        id: m.id,
        role: m.role,
        content: isSingleTextContentArray ? contentString : m.content.content || contentString,
        createdAt: m.createdAt,
        parts,
        reasoning: void 0,
        toolInvocations: `toolInvocations` in m.content ? m.content.toolInvocations?.filter((t) => t.state === "result") : void 0
      };
      if (m.content.metadata) {
        uiMessage2.metadata = m.content.metadata;
      }
      return uiMessage2;
    }
    const uiMessage = {
      id: m.id,
      role: m.role,
      content: m.content.content || contentString,
      createdAt: m.createdAt,
      parts,
      experimental_attachments: experimentalAttachments
    };
    if (m.content.metadata) {
      uiMessage.metadata = m.content.metadata;
    }
    return uiMessage;
  }
  /**
   * Converts a MastraMessageV2 system message directly to AIV4 CoreMessage format
   * This is more efficient than converting to UI message first and then to core
   * @param message - The MastraMessageV2 message to convert
   * @returns AIV4 CoreMessage with system role
   */
  static mastraMessageV2SystemToV4Core(message) {
    if (message.role !== `system` || !message.content.content)
      throw new MastraError({
        id: "INVALID_SYSTEM_MESSAGE_FORMAT",
        domain: "AGENT",
        category: "USER",
        text: `Invalid system message format. System messages must include 'role' and 'content' properties. The content should be a string.`,
        details: {
          receivedMessage: JSON.stringify(message, null, 2)
        }
      });
    return { role: "system", content: message.content.content };
  }
  getMessageById(id) {
    return this.messages.find((m) => m.id === id);
  }
  shouldReplaceMessage(message) {
    if (!this.messages.length) return { exists: false };
    if (!(`id` in message) || !message?.id) {
      return { exists: false };
    }
    const existingMessage = this.getMessageById(message.id);
    if (!existingMessage) return { exists: false };
    return {
      exists: true,
      shouldReplace: !_MessageList.messagesAreEqual(existingMessage, message),
      id: existingMessage.id
    };
  }
  addOne(message, messageSource) {
    if ((!(`content` in message) || !message.content && // allow empty strings
    typeof message.content !== "string") && (!(`parts` in message) || !message.parts)) {
      throw new MastraError({
        id: "INVALID_MESSAGE_CONTENT",
        domain: "AGENT",
        category: "USER",
        text: `Message with role "${message.role}" must have either a 'content' property (string or array) or a 'parts' property (array) that is not empty, null, or undefined. Received message: ${JSON.stringify(message, null, 2)}`,
        details: {
          role: message.role,
          messageSource,
          hasContent: "content" in message,
          hasParts: "parts" in message
        }
      });
    }
    if (message.role === `system`) {
      if (messageSource === `memory`) return null;
      const isSupportedSystemFormat = _MessageList.isAIV4CoreMessage(message) || _MessageList.isAIV5CoreMessage(message) || _MessageList.isMastraMessageV2(message);
      if (isSupportedSystemFormat) {
        return this.addSystem(message);
      }
      throw new MastraError({
        id: "INVALID_SYSTEM_MESSAGE_FORMAT",
        domain: "AGENT",
        category: "USER",
        text: `Invalid system message format. System messages must be CoreMessage format with 'role' and 'content' properties. The content should be a string or valid content array.`,
        details: {
          messageSource,
          receivedMessage: JSON.stringify(message, null, 2)
        }
      });
    }
    const messageV2 = this.inputToMastraMessageV2(message, messageSource);
    const { exists, shouldReplace, id } = this.shouldReplaceMessage(messageV2);
    const latestMessage = this.messages.at(-1);
    if (messageSource === `memory`) {
      for (const existingMessage of this.messages) {
        if (_MessageList.messagesAreEqual(existingMessage, messageV2)) {
          return;
        }
      }
    }
    const shouldAppendToLastAssistantMessage = latestMessage?.role === "assistant" && messageV2.role === "assistant" && latestMessage.threadId === messageV2.threadId && // If the message is from memory, don't append to the last assistant message
    messageSource !== "memory";
    const appendNetworkMessage = this._agentNetworkAppend && latestMessage && !this.memoryMessages.has(latestMessage) || !this._agentNetworkAppend;
    if (shouldAppendToLastAssistantMessage && appendNetworkMessage) {
      latestMessage.createdAt = messageV2.createdAt || latestMessage.createdAt;
      const toolResultAnchorMap = /* @__PURE__ */ new Map();
      const partsToAdd = /* @__PURE__ */ new Map();
      for (const [index, part] of messageV2.content.parts.entries()) {
        if (part.type === "tool-invocation") {
          const existingCallPart = [...latestMessage.content.parts].reverse().find((p) => p.type === "tool-invocation" && p.toolInvocation.toolCallId === part.toolInvocation.toolCallId);
          const existingCallToolInvocation = !!existingCallPart && existingCallPart.type === "tool-invocation";
          if (existingCallToolInvocation) {
            if (part.toolInvocation.state === "result") {
              existingCallPart.toolInvocation = {
                ...existingCallPart.toolInvocation,
                step: part.toolInvocation.step,
                state: "result",
                result: part.toolInvocation.result,
                args: {
                  ...existingCallPart.toolInvocation.args,
                  ...part.toolInvocation.args
                }
              };
              if (!latestMessage.content.toolInvocations) {
                latestMessage.content.toolInvocations = [];
              }
              const toolInvocationIndex = latestMessage.content.toolInvocations.findIndex(
                (t) => t.toolCallId === existingCallPart.toolInvocation.toolCallId
              );
              if (toolInvocationIndex === -1) {
                latestMessage.content.toolInvocations.push(existingCallPart.toolInvocation);
              } else {
                latestMessage.content.toolInvocations[toolInvocationIndex] = existingCallPart.toolInvocation;
              }
            }
            const existingIndex = latestMessage.content.parts.findIndex((p) => p === existingCallPart);
            toolResultAnchorMap.set(index, existingIndex);
          } else {
            partsToAdd.set(index, part);
          }
        } else {
          partsToAdd.set(index, part);
        }
      }
      this.addPartsToLatestMessage({
        latestMessage,
        messageV2,
        anchorMap: toolResultAnchorMap,
        partsToAdd
      });
      if (latestMessage.createdAt.getTime() < messageV2.createdAt.getTime()) {
        latestMessage.createdAt = messageV2.createdAt;
      }
      if (!latestMessage.content.content && messageV2.content.content) {
        latestMessage.content.content = messageV2.content.content;
      }
      if (latestMessage.content.content && messageV2.content.content && latestMessage.content.content !== messageV2.content.content) {
        latestMessage.content.content = messageV2.content.content;
      }
      this.pushMessageToSource(latestMessage, messageSource);
    } else {
      let existingIndex = -1;
      if (shouldReplace) {
        existingIndex = this.messages.findIndex((m) => m.id === id);
      }
      const existingMessage = existingIndex !== -1 && this.messages[existingIndex];
      if (shouldReplace && existingMessage) {
        this.messages[existingIndex] = messageV2;
      } else if (!exists) {
        this.messages.push(messageV2);
      }
      this.pushMessageToSource(messageV2, messageSource);
    }
    this.messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
    return this;
  }
  pushMessageToSource(messageV2, messageSource) {
    if (messageSource === `memory`) {
      this.memoryMessages.add(messageV2);
      this.memoryMessagesPersisted.add(messageV2);
    } else if (messageSource === `response`) {
      this.newResponseMessages.add(messageV2);
      this.newResponseMessagesPersisted.add(messageV2);
    } else if (messageSource === `input`) {
      this.newUserMessages.add(messageV2);
      this.newUserMessagesPersisted.add(messageV2);
    } else if (messageSource === `context`) {
      this.userContextMessages.add(messageV2);
      this.userContextMessagesPersisted.add(messageV2);
    } else {
      throw new Error(`Missing message source for message ${messageV2}`);
    }
  }
  /**
   * Pushes a new message part to the latest message.
   * @param latestMessage - The latest message to push the part to.
   * @param newMessage - The new message to push the part from.
   * @param part - The part to push.
   * @param insertAt - The index at which to insert the part. Optional.
   */
  pushNewMessagePart({
    latestMessage,
    newMessage,
    part,
    insertAt
    // optional
  }) {
    const partKey = _MessageList.cacheKeyFromAIV4Parts([part]);
    const latestPartCount = latestMessage.content.parts.filter(
      (p) => _MessageList.cacheKeyFromAIV4Parts([p]) === partKey
    ).length;
    const newPartCount = newMessage.content.parts.filter(
      (p) => _MessageList.cacheKeyFromAIV4Parts([p]) === partKey
    ).length;
    if (latestPartCount < newPartCount) {
      const partIndex = newMessage.content.parts.indexOf(part);
      const hasStepStartBefore = partIndex > 0 && newMessage.content.parts[partIndex - 1]?.type === "step-start";
      const needsStepStart = latestMessage.role === "assistant" && part.type === "text" && !hasStepStartBefore && latestMessage.content.parts.length > 0 && latestMessage.content.parts.at(-1)?.type === "tool-invocation";
      if (typeof insertAt === "number") {
        if (needsStepStart) {
          latestMessage.content.parts.splice(insertAt, 0, { type: "step-start" });
          latestMessage.content.parts.splice(insertAt + 1, 0, part);
        } else {
          latestMessage.content.parts.splice(insertAt, 0, part);
        }
      } else {
        if (needsStepStart) {
          latestMessage.content.parts.push({ type: "step-start" });
        }
        latestMessage.content.parts.push(part);
      }
    }
  }
  /**
   * Upserts parts of messageV2 into latestMessage based on the anchorMap.
   * This is used when appending a message to the last assistant message to ensure that parts are inserted in the correct order.
   * @param latestMessage - The latest message to upsert parts into.
   * @param messageV2 - The message to upsert parts from.
   * @param anchorMap - The anchor map to use for upserting parts.
   */
  addPartsToLatestMessage({
    latestMessage,
    messageV2,
    anchorMap,
    partsToAdd
  }) {
    for (let i = 0; i < messageV2.content.parts.length; ++i) {
      const part = messageV2.content.parts[i];
      if (!part) continue;
      const key = _MessageList.cacheKeyFromAIV4Parts([part]);
      const partToAdd = partsToAdd.get(i);
      if (!key || !partToAdd) continue;
      if (anchorMap.size > 0) {
        if (anchorMap.has(i)) continue;
        const leftAnchorV2 = [...anchorMap.keys()].filter((idx) => idx < i).pop() ?? -1;
        const rightAnchorV2 = [...anchorMap.keys()].find((idx) => idx > i) ?? -1;
        const leftAnchorLatest = leftAnchorV2 !== -1 ? anchorMap.get(leftAnchorV2) : 0;
        const offset = leftAnchorV2 === -1 ? i : i - leftAnchorV2;
        const insertAt = leftAnchorLatest + offset;
        const rightAnchorLatest = rightAnchorV2 !== -1 ? anchorMap.get(rightAnchorV2) : latestMessage.content.parts.length;
        if (insertAt >= 0 && insertAt <= rightAnchorLatest && !latestMessage.content.parts.slice(insertAt, rightAnchorLatest).some((p) => _MessageList.cacheKeyFromAIV4Parts([p]) === _MessageList.cacheKeyFromAIV4Parts([part]))) {
          this.pushNewMessagePart({
            latestMessage,
            newMessage: messageV2,
            part,
            insertAt
          });
          for (const [v2Idx, latestIdx] of anchorMap.entries()) {
            if (latestIdx >= insertAt) {
              anchorMap.set(v2Idx, latestIdx + 1);
            }
          }
        }
      } else {
        this.pushNewMessagePart({
          latestMessage,
          newMessage: messageV2,
          part
        });
      }
    }
  }
  inputToMastraMessageV2(message, messageSource) {
    if (
      // we can't throw if the threadId doesn't match and this message came from memory
      // this is because per-user semantic recall can retrieve messages from other threads
      messageSource !== `memory` && `threadId` in message && message.threadId && this.memoryInfo && message.threadId !== this.memoryInfo.threadId
    ) {
      throw new Error(
        `Received input message with wrong threadId. Input ${message.threadId}, expected ${this.memoryInfo.threadId}`
      );
    }
    if (`resourceId` in message && message.resourceId && this.memoryInfo?.resourceId && message.resourceId !== this.memoryInfo.resourceId) {
      throw new Error(
        `Received input message with wrong resourceId. Input ${message.resourceId}, expected ${this.memoryInfo.resourceId}`
      );
    }
    if (_MessageList.isMastraMessageV1(message)) {
      return this.mastraMessageV1ToMastraMessageV2(message, messageSource);
    }
    if (_MessageList.isMastraMessageV2(message)) {
      return this.hydrateMastraMessageV2Fields(message);
    }
    if (_MessageList.isAIV4CoreMessage(message)) {
      return this.aiV4CoreMessageToMastraMessageV2(message, messageSource);
    }
    if (_MessageList.isAIV4UIMessage(message)) {
      return this.aiV4UIMessageToMastraMessageV2(message, messageSource);
    }
    if (_MessageList.isAIV5CoreMessage(message)) {
      return _MessageList.mastraMessageV3ToV2(this.aiV5ModelMessageToMastraMessageV3(message, messageSource));
    }
    if (_MessageList.isAIV5UIMessage(message)) {
      return _MessageList.mastraMessageV3ToV2(this.aiV5UIMessageToMastraMessageV3(message, messageSource));
    }
    if (_MessageList.isMastraMessageV3(message)) {
      return _MessageList.mastraMessageV3ToV2(this.hydrateMastraMessageV3Fields(message));
    }
    throw new Error(`Found unhandled message ${JSON.stringify(message)}`);
  }
  lastCreatedAt;
  // this makes sure messages added in order will always have a date atleast 1ms apart.
  generateCreatedAt(messageSource, start) {
    start = start instanceof Date ? start : start ? new Date(start) : void 0;
    if (start && !this.lastCreatedAt) {
      this.lastCreatedAt = start.getTime();
      return start;
    }
    if (start && messageSource === `memory`) {
      return start;
    }
    const now2 = /* @__PURE__ */ new Date();
    const nowTime = start?.getTime() || now2.getTime();
    const lastTime = this.messages.reduce((p, m) => {
      if (m.createdAt.getTime() > p) return m.createdAt.getTime();
      return p;
    }, this.lastCreatedAt || 0);
    if (nowTime <= lastTime) {
      const newDate = new Date(lastTime + 1);
      this.lastCreatedAt = newDate.getTime();
      return newDate;
    }
    this.lastCreatedAt = nowTime;
    return now2;
  }
  newMessageId() {
    if (this.generateMessageId) {
      return this.generateMessageId();
    }
    return randomUUID();
  }
  mastraMessageV1ToMastraMessageV2(message, messageSource) {
    const coreV2 = this.aiV4CoreMessageToMastraMessageV2(
      {
        content: message.content,
        role: message.role
      },
      messageSource
    );
    return {
      id: message.id,
      role: coreV2.role,
      createdAt: this.generateCreatedAt(messageSource, message.createdAt),
      threadId: message.threadId,
      resourceId: message.resourceId,
      content: coreV2.content
    };
  }
  hydrateMastraMessageV3Fields(message) {
    if (!(message.createdAt instanceof Date)) message.createdAt = new Date(message.createdAt);
    return message;
  }
  hydrateMastraMessageV2Fields(message) {
    if (!(message.createdAt instanceof Date)) message.createdAt = new Date(message.createdAt);
    if (!message.threadId && this.memoryInfo?.threadId) {
      message.threadId = this.memoryInfo.threadId;
    }
    if (!message.resourceId && this.memoryInfo?.resourceId) {
      message.resourceId = this.memoryInfo.resourceId;
    }
    if (message.content.toolInvocations && message.content.parts) {
      message.content.toolInvocations = message.content.toolInvocations.map((ti) => {
        if (!ti.args || Object.keys(ti.args).length === 0) {
          const partWithArgs = message.content.parts.find(
            (part) => part.type === "tool-invocation" && part.toolInvocation && part.toolInvocation.toolCallId === ti.toolCallId && part.toolInvocation.args && Object.keys(part.toolInvocation.args).length > 0
          );
          if (partWithArgs && partWithArgs.type === "tool-invocation") {
            return { ...ti, args: partWithArgs.toolInvocation.args };
          }
        }
        return ti;
      });
    }
    return message;
  }
  aiV4UIMessageToMastraMessageV2(message, messageSource) {
    const content = {
      format: 2,
      parts: message.parts
    };
    if (message.toolInvocations) content.toolInvocations = message.toolInvocations;
    if (message.reasoning) content.reasoning = message.reasoning;
    if (message.annotations) content.annotations = message.annotations;
    if (message.experimental_attachments) {
      content.experimental_attachments = message.experimental_attachments;
    }
    if ("metadata" in message && message.metadata !== null && message.metadata !== void 0) {
      content.metadata = message.metadata;
    }
    if ("providerMetadata" in message && message.providerMetadata !== null && message.providerMetadata !== void 0) {
      content.providerMetadata = message.providerMetadata;
    }
    return {
      id: message.id || this.newMessageId(),
      role: _MessageList.getRole(message),
      createdAt: this.generateCreatedAt(messageSource, message.createdAt),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  aiV4CoreMessageToMastraMessageV2(coreMessage, messageSource) {
    const id = `id` in coreMessage ? coreMessage.id : this.newMessageId();
    const parts = [];
    const experimentalAttachments = [];
    const toolInvocations = [];
    const isSingleTextContent = messageSource === `response` && Array.isArray(coreMessage.content) && coreMessage.content.length === 1 && coreMessage.content[0] && coreMessage.content[0].type === `text` && `text` in coreMessage.content[0] && coreMessage.content[0].text;
    if (isSingleTextContent && messageSource === `response`) {
      coreMessage.content = isSingleTextContent;
    }
    if (typeof coreMessage.content === "string") {
      parts.push({
        type: "text",
        text: coreMessage.content,
        // Preserve providerOptions from CoreMessage (e.g., for system messages with cacheControl)
        ..."providerOptions" in coreMessage && coreMessage.providerOptions ? { providerMetadata: coreMessage.providerOptions } : {}
      });
    } else if (Array.isArray(coreMessage.content)) {
      for (const part of coreMessage.content) {
        switch (part.type) {
          case "text":
            const prevPart = parts.at(-1);
            if (coreMessage.role === "assistant" && prevPart && prevPart.type === "tool-invocation") {
              parts.push({ type: "step-start" });
            }
            const mergedProviderMetadata = {
              ..."providerOptions" in coreMessage && coreMessage.providerOptions ? coreMessage.providerOptions : {},
              ..."providerOptions" in part && part.providerOptions ? part.providerOptions : {}
            };
            parts.push({
              type: "text",
              text: part.text,
              ...Object.keys(mergedProviderMetadata).length > 0 ? { providerMetadata: mergedProviderMetadata } : {}
            });
            break;
          case "tool-call": {
            const toolCallPart = {
              type: "tool-invocation",
              toolInvocation: {
                state: "call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                args: part.args
              }
            };
            if ("providerOptions" in part && part.providerOptions) {
              toolCallPart.providerMetadata = part.providerOptions;
            }
            parts.push(toolCallPart);
            break;
          }
          case "tool-result":
            let toolArgs = {};
            const toolCallInSameMsg = coreMessage.content.find(
              (p) => p.type === "tool-call" && p.toolCallId === part.toolCallId
            );
            if (toolCallInSameMsg && toolCallInSameMsg.type === "tool-call") {
              toolArgs = toolCallInSameMsg.args;
            }
            if (Object.keys(toolArgs).length === 0) {
              for (let i = this.messages.length - 1; i >= 0; i--) {
                const msg = this.messages[i];
                if (msg && msg.role === "assistant" && msg.content.parts) {
                  const toolCallPart = msg.content.parts.find(
                    (p) => p.type === "tool-invocation" && p.toolInvocation.toolCallId === part.toolCallId && p.toolInvocation.state === "call"
                  );
                  if (toolCallPart && toolCallPart.type === "tool-invocation" && toolCallPart.toolInvocation.args) {
                    toolArgs = toolCallPart.toolInvocation.args;
                    break;
                  }
                }
              }
            }
            const invocation = {
              state: "result",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              result: part.result ?? "",
              // undefined will cause AI SDK to throw an error, but for client side tool calls this really could be undefined
              args: toolArgs
              // Use the args from the corresponding tool-call
            };
            const toolResultPart = {
              type: "tool-invocation",
              toolInvocation: invocation
            };
            if ("providerOptions" in part && part.providerOptions) {
              toolResultPart.providerMetadata = part.providerOptions;
            }
            parts.push(toolResultPart);
            toolInvocations.push(invocation);
            break;
          case "reasoning": {
            const reasoningPart = {
              type: "reasoning",
              reasoning: "",
              // leave this blank so we aren't double storing it in the db along with details
              details: [{ type: "text", text: part.text, signature: part.signature }]
            };
            if ("providerOptions" in part && part.providerOptions) {
              reasoningPart.providerMetadata = part.providerOptions;
            }
            parts.push(reasoningPart);
            break;
          }
          case "redacted-reasoning":
            parts.push({
              type: "reasoning",
              reasoning: "",
              // No text reasoning for redacted parts
              details: [{ type: "redacted", data: part.data }]
            });
            break;
          case "image":
            parts.push({
              type: "file",
              data: imageContentToString(part.image),
              mimeType: part.mimeType
            });
            break;
          case "file":
            if (part.data instanceof URL) {
              parts.push({
                type: "file",
                data: part.data.toString(),
                mimeType: part.mimeType
              });
            } else if (typeof part.data === "string") {
              const categorized = categorizeFileData(part.data, part.mimeType);
              if (categorized.type === "url" || categorized.type === "dataUri") {
                parts.push({
                  type: "file",
                  data: part.data,
                  mimeType: categorized.mimeType || "image/png"
                });
              } else {
                try {
                  parts.push({
                    type: "file",
                    mimeType: categorized.mimeType || "image/png",
                    data: convertDataContentToBase64String2(part.data)
                  });
                } catch (error87) {
                  console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error87}`, error87);
                }
              }
            } else {
              try {
                parts.push({
                  type: "file",
                  mimeType: part.mimeType,
                  data: convertDataContentToBase64String2(part.data)
                });
              } catch (error87) {
                console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error87}`, error87);
              }
            }
            break;
        }
      }
    }
    const content = {
      format: 2,
      parts
    };
    if (toolInvocations.length) content.toolInvocations = toolInvocations;
    if (typeof coreMessage.content === `string`) content.content = coreMessage.content;
    if (experimentalAttachments.length) content.experimental_attachments = experimentalAttachments;
    if (coreMessage.providerOptions) {
      content.providerMetadata = coreMessage.providerOptions;
    }
    if ("metadata" in coreMessage && coreMessage.metadata !== null && coreMessage.metadata !== void 0) {
      content.metadata = coreMessage.metadata;
    }
    return {
      id,
      role: _MessageList.getRole(coreMessage),
      createdAt: this.generateCreatedAt(messageSource),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  static isAIV4UIMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !_MessageList.isAIV4CoreMessage(msg) && `parts` in msg && !_MessageList.hasAIV5UIMessageCharacteristics(msg);
  }
  static isAIV5CoreMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !(`parts` in msg) && `content` in msg && _MessageList.hasAIV5CoreMessageCharacteristics(msg);
  }
  static isAIV4CoreMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !(`parts` in msg) && `content` in msg && !_MessageList.hasAIV5CoreMessageCharacteristics(msg);
  }
  static isMastraMessage(msg) {
    return _MessageList.isMastraMessageV3(msg) || _MessageList.isMastraMessageV2(msg) || _MessageList.isMastraMessageV1(msg);
  }
  static isMastraMessageV1(msg) {
    return !_MessageList.isMastraMessageV2(msg) && !_MessageList.isMastraMessageV3(msg) && (`threadId` in msg || `resourceId` in msg);
  }
  static isMastraMessageV2(msg) {
    return Boolean(
      `content` in msg && msg.content && !Array.isArray(msg.content) && typeof msg.content !== `string` && `format` in msg.content && msg.content.format === 2
    );
  }
  static isMastraMessageV3(msg) {
    return Boolean(
      `content` in msg && msg.content && !Array.isArray(msg.content) && typeof msg.content !== `string` && `format` in msg.content && msg.content.format === 3
    );
  }
  static getRole(message) {
    if (message.role === `assistant` || message.role === `tool`) return `assistant`;
    if (message.role === `user`) return `user`;
    if (message.role === `system`) return `system`;
    throw new Error(
      `BUG: add handling for message role ${message.role} in message ${JSON.stringify(message, null, 2)}`
    );
  }
  static cacheKeyFromAIV4Parts(parts) {
    let key = ``;
    for (const part of parts) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text;
      }
      if (part.type === `tool-invocation`) {
        key += part.toolInvocation.toolCallId;
        key += part.toolInvocation.state;
      }
      if (part.type === `reasoning`) {
        key += part.reasoning;
        key += part.details.reduce((prev, current) => {
          if (current.type === `text`) {
            return prev + current.text.length + (current.signature?.length || 0);
          }
          return prev;
        }, 0);
        const partAny = part;
        if (partAny && Object.hasOwn(partAny, "providerMetadata") && partAny.providerMetadata && Object.hasOwn(partAny.providerMetadata, "openai") && partAny.providerMetadata.openai && Object.hasOwn(partAny.providerMetadata.openai, "itemId")) {
          const itemId = partAny.providerMetadata.openai.itemId;
          key += `|${itemId}`;
        }
      }
      if (part.type === `file`) {
        key += part.data;
        key += part.mimeType;
      }
    }
    return key;
  }
  static coreContentToString(content) {
    if (typeof content === `string`) return content;
    return content.reduce((p, c) => {
      if (c.type === `text`) {
        p += c.text;
      }
      return p;
    }, "");
  }
  static cacheKeyFromAIV4CoreMessageContent(content) {
    if (typeof content === `string`) return content;
    let key = ``;
    for (const part of content) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text.length;
      }
      if (part.type === `reasoning`) {
        key += part.text.length;
      }
      if (part.type === `tool-call`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `tool-result`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `file`) {
        key += part.filename;
        key += part.mimeType;
      }
      if (part.type === `image`) {
        key += getImageCacheKey(part.image);
        key += part.mimeType;
      }
      if (part.type === `redacted-reasoning`) {
        key += part.data.length;
      }
    }
    return key;
  }
  static messagesAreEqual(one, two) {
    const oneUIV4 = _MessageList.isAIV4UIMessage(one) && one;
    const twoUIV4 = _MessageList.isAIV4UIMessage(two) && two;
    if (oneUIV4 && !twoUIV4) return false;
    if (oneUIV4 && twoUIV4) {
      return _MessageList.cacheKeyFromAIV4Parts(one.parts) === _MessageList.cacheKeyFromAIV4Parts(two.parts);
    }
    const oneCMV4 = _MessageList.isAIV4CoreMessage(one) && one;
    const twoCMV4 = _MessageList.isAIV4CoreMessage(two) && two;
    if (oneCMV4 && !twoCMV4) return false;
    if (oneCMV4 && twoCMV4) {
      return _MessageList.cacheKeyFromAIV4CoreMessageContent(oneCMV4.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(twoCMV4.content);
    }
    const oneMM1 = _MessageList.isMastraMessageV1(one) && one;
    const twoMM1 = _MessageList.isMastraMessageV1(two) && two;
    if (oneMM1 && !twoMM1) return false;
    if (oneMM1 && twoMM1) {
      return oneMM1.id === twoMM1.id && _MessageList.cacheKeyFromAIV4CoreMessageContent(oneMM1.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(twoMM1.content);
    }
    const oneMM2 = _MessageList.isMastraMessageV2(one) && one;
    const twoMM2 = _MessageList.isMastraMessageV2(two) && two;
    if (oneMM2 && !twoMM2) return false;
    if (oneMM2 && twoMM2) {
      return oneMM2.id === twoMM2.id && _MessageList.cacheKeyFromAIV4Parts(oneMM2.content.parts) === _MessageList.cacheKeyFromAIV4Parts(twoMM2.content.parts);
    }
    const oneMM3 = _MessageList.isMastraMessageV3(one) && one;
    const twoMM3 = _MessageList.isMastraMessageV3(two) && two;
    if (oneMM3 && !twoMM3) return false;
    if (oneMM3 && twoMM3) {
      return oneMM3.id === twoMM3.id && _MessageList.cacheKeyFromAIV5Parts(oneMM3.content.parts) === _MessageList.cacheKeyFromAIV5Parts(twoMM3.content.parts);
    }
    const oneUIV5 = _MessageList.isAIV5UIMessage(one) && one;
    const twoUIV5 = _MessageList.isAIV5UIMessage(two) && two;
    if (oneUIV5 && !twoUIV5) return false;
    if (oneUIV5 && twoUIV5) {
      return _MessageList.cacheKeyFromAIV5Parts(one.parts) === _MessageList.cacheKeyFromAIV5Parts(two.parts);
    }
    const oneCMV5 = _MessageList.isAIV5CoreMessage(one) && one;
    const twoCMV5 = _MessageList.isAIV5CoreMessage(two) && two;
    if (oneCMV5 && !twoCMV5) return false;
    if (oneCMV5 && twoCMV5) {
      return _MessageList.cacheKeyFromAIV5ModelMessageContent(oneCMV5.content) === _MessageList.cacheKeyFromAIV5ModelMessageContent(twoCMV5.content);
    }
    return true;
  }
  cleanV3Metadata(messages) {
    return messages.map((msg) => {
      if (!msg.content.metadata || typeof msg.content.metadata !== "object") {
        return msg;
      }
      const metadata = { ...msg.content.metadata };
      const hasOriginalContent = "__originalContent" in metadata;
      const hasOriginalAttachments = "__originalExperimentalAttachments" in metadata;
      if (!hasOriginalContent && !hasOriginalAttachments) {
        return msg;
      }
      const { __originalContent, __originalExperimentalAttachments, ...cleanMetadata } = metadata;
      if (Object.keys(cleanMetadata).length === 0) {
        const { metadata: metadata2, ...contentWithoutMetadata } = msg.content;
        return { ...msg, content: contentWithoutMetadata };
      }
      return { ...msg, content: { ...msg.content, metadata: cleanMetadata } };
    });
  }
  static aiV4CoreMessageToV1PromptMessage(coreMessage) {
    if (coreMessage.role === `system`) {
      return coreMessage;
    }
    if (typeof coreMessage.content === `string` && (coreMessage.role === `assistant` || coreMessage.role === `user`)) {
      return {
        ...coreMessage,
        content: [{ type: "text", text: coreMessage.content }]
      };
    }
    if (typeof coreMessage.content === `string`) {
      throw new Error(
        `Saw text content for input CoreMessage, but the role is ${coreMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`
      );
    }
    const roleContent = {
      user: [],
      assistant: [],
      tool: []
    };
    const role = coreMessage.role;
    for (const part of coreMessage.content) {
      const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
      switch (part.type) {
        case "text": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "redacted-reasoning":
        case "reasoning": {
          if (role !== `assistant`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-call": {
          if (role === `tool` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-result": {
          if (role === `assistant` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "image": {
          if (role === `tool` || role === `assistant`) {
            throw new Error(incompatibleMessage);
          }
          let processedImage;
          if (part.image instanceof URL || part.image instanceof Uint8Array) {
            processedImage = part.image;
          } else if (Buffer.isBuffer(part.image) || part.image instanceof ArrayBuffer) {
            processedImage = new Uint8Array(part.image);
          } else {
            const categorized = categorizeFileData(part.image, part.mimeType);
            if (categorized.type === "raw") {
              const dataUri = createDataUri(part.image, part.mimeType || "image/png");
              processedImage = new URL(dataUri);
            } else {
              processedImage = new URL(part.image);
            }
          }
          roleContent[role].push({
            ...part,
            image: processedImage
          });
          break;
        }
        case "file": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            data: part.data instanceof URL ? part.data : typeof part.data === "string" ? part.data : convertDataContentToBase64String2(part.data)
          });
          break;
        }
      }
    }
    if (role === `tool`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    if (role === `user`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    if (role === `assistant`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    throw new Error(
      `Encountered unknown role ${role} when converting V4 CoreMessage -> V4 LanguageModelV1Prompt, input message: ${JSON.stringify(coreMessage, null, 2)}`
    );
  }
  static aiV5ModelMessageToV2PromptMessage(modelMessage) {
    if (modelMessage.role === `system`) {
      return modelMessage;
    }
    if (typeof modelMessage.content === `string` && (modelMessage.role === `assistant` || modelMessage.role === `user`)) {
      return {
        role: modelMessage.role,
        content: [{ type: "text", text: modelMessage.content }],
        providerOptions: modelMessage.providerOptions
      };
    }
    if (typeof modelMessage.content === `string`) {
      throw new Error(
        `Saw text content for input ModelMessage, but the role is ${modelMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`
      );
    }
    const roleContent = {
      user: [],
      assistant: [],
      tool: []
    };
    const role = modelMessage.role;
    for (const part of modelMessage.content) {
      const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
      switch (part.type) {
        case "text": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "reasoning": {
          if (role === `tool` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-call": {
          if (role !== `assistant`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-result": {
          if (role === `assistant` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "file": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            data: part.data instanceof ArrayBuffer ? new Uint8Array(part.data) : part.data
          });
          break;
        }
        case "image": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            mediaType: part.mediaType || "image/unknown",
            type: "file",
            data: part.image instanceof ArrayBuffer ? new Uint8Array(part.image) : part.image
          });
          break;
        }
      }
    }
    if (role === `tool`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    if (role === `user`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    if (role === `assistant`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    throw new Error(
      `Encountered unknown role ${role} when converting V5 ModelMessage -> V5 LanguageModelV2Message, input message: ${JSON.stringify(modelMessage, null, 2)}`
    );
  }
  static mastraMessageV3ToV2(v3Msg) {
    const toolInvocationParts = v3Msg.content.parts.filter((p) => isToolUIPart(p));
    const hadToolInvocations = v3Msg.content.metadata?.__hadToolInvocations === true;
    let toolInvocations = void 0;
    if (toolInvocationParts.length > 0) {
      const invocations = toolInvocationParts.map((p) => {
        const toolName = getToolName2(p);
        if (p.state === `output-available`) {
          return {
            args: p.input,
            result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output,
            toolCallId: p.toolCallId,
            toolName,
            state: "result"
          };
        }
        return {
          args: p.input,
          state: "call",
          toolName,
          toolCallId: p.toolCallId
        };
      });
      toolInvocations = invocations;
    } else if (hadToolInvocations && v3Msg.role === "assistant") {
      toolInvocations = [];
    }
    const attachmentUrls = new Set(v3Msg.content.metadata?.__attachmentUrls || []);
    const v2Msg = {
      id: v3Msg.id,
      resourceId: v3Msg.resourceId,
      threadId: v3Msg.threadId,
      createdAt: v3Msg.createdAt,
      role: v3Msg.role,
      content: {
        format: 2,
        parts: v3Msg.content.parts.map((p) => {
          if (isToolUIPart(p) || p.type === "dynamic-tool") {
            const toolName = getToolName2(p);
            const shared = {
              state: p.state,
              args: p.input,
              toolCallId: p.toolCallId,
              toolName
            };
            if (p.state === `output-available`) {
              return {
                type: "tool-invocation",
                toolInvocation: {
                  ...shared,
                  state: "result",
                  result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output
                },
                providerMetadata: p.callProviderMetadata
              };
            }
            return {
              type: "tool-invocation",
              toolInvocation: {
                ...shared,
                state: p.state === `input-available` ? `call` : `partial-call`
              }
            };
          }
          switch (p.type) {
            case "text":
              return p;
            case "file": {
              const fileDataSource = "url" in p && typeof p.url === "string" ? p.url : "data" in p && typeof p.data === "string" ? p.data : void 0;
              if (!fileDataSource) {
                return null;
              }
              if (attachmentUrls.has(fileDataSource)) {
                return null;
              }
              return {
                type: "file",
                mimeType: p.mediaType,
                data: fileDataSource,
                ...p.providerMetadata ? { providerMetadata: p.providerMetadata } : {}
              };
            }
            case "reasoning":
              if (p.text === "" && !p.providerMetadata) return null;
              return {
                type: "reasoning",
                // Keep reasoning field empty to match the format used in llm-execution-step
                // This ensures cache keys match for deduplication when merging assistant messages
                reasoning: "",
                details: p.text ? [{ type: "text", text: p.text }] : [],
                providerMetadata: p.providerMetadata
              };
            case "source-url":
              return {
                type: "source",
                source: {
                  url: p.url,
                  id: p.sourceId,
                  sourceType: "url"
                },
                providerMetadata: p.providerMetadata
              };
            case "step-start":
              return p;
          }
          return null;
        }).filter((p) => Boolean(p))
      }
    };
    if (toolInvocations !== void 0) {
      v2Msg.content.toolInvocations = toolInvocations;
    }
    if (v3Msg.content.metadata) {
      const { __originalContent, __originalExperimentalAttachments, __attachmentUrls, ...userMetadata } = v3Msg.content.metadata;
      v2Msg.content.metadata = userMetadata;
    }
    const originalContent = v3Msg.content.metadata?.__originalContent;
    if (originalContent !== void 0) {
      const hasOnlyTextOrStepStart = v2Msg.content.parts.every((p) => p.type === `step-start` || p.type === `text`);
      if (typeof originalContent === `string` || hasOnlyTextOrStepStart) {
        v2Msg.content.content = originalContent;
      }
    }
    const originalAttachments = v3Msg.content.metadata?.__originalExperimentalAttachments;
    if (originalAttachments && Array.isArray(originalAttachments)) {
      v2Msg.content.experimental_attachments = originalAttachments || [];
    }
    const originalContentIsV5 = Array.isArray(v3Msg.content.metadata?.__originalContent) && v3Msg.content.metadata?.__originalContent.some((part) => part.type === "file");
    const urlFileParts = originalContentIsV5 ? [] : v2Msg.content.parts.filter(
      (p) => p.type === "file" && typeof p.data === "string" && (p.data.startsWith("http://") || p.data.startsWith("https://")) && !p.providerMetadata
      // Don't move if it has providerMetadata (needed for roundtrip)
    );
    if (urlFileParts.length > 0) {
      if (!v2Msg.content.experimental_attachments) {
        v2Msg.content.experimental_attachments = [];
      }
      for (const urlPart of urlFileParts) {
        if (urlPart.type === "file") {
          v2Msg.content.experimental_attachments.push({
            url: urlPart.data,
            contentType: urlPart.mimeType
          });
        }
      }
      v2Msg.content.parts = v2Msg.content.parts.filter(
        (p) => !(p.type === "file" && typeof p.data === "string" && (p.data.startsWith("http://") || p.data.startsWith("https://")) && !p.providerMetadata)
      );
    }
    if (toolInvocations && toolInvocations.length > 0) {
      const resultToolInvocations = toolInvocations.filter((t) => t.state === "result");
      if (resultToolInvocations.length > 0) {
        v2Msg.content.toolInvocations = resultToolInvocations;
      }
    }
    if (v3Msg.type) v2Msg.type = v3Msg.type;
    return v2Msg;
  }
  mastraMessageV2ToMastraMessageV3(v2Msg) {
    const parts = [];
    const v3Msg = {
      id: v2Msg.id,
      content: {
        format: 3,
        parts
      },
      role: v2Msg.role,
      createdAt: v2Msg.createdAt instanceof Date ? v2Msg.createdAt : new Date(v2Msg.createdAt),
      resourceId: v2Msg.resourceId,
      threadId: v2Msg.threadId,
      type: v2Msg.type
    };
    if (v2Msg.content.metadata) {
      v3Msg.content.metadata = { ...v2Msg.content.metadata };
    }
    if (v2Msg.content.providerMetadata) {
      v3Msg.content.providerMetadata = v2Msg.content.providerMetadata;
    }
    if (v2Msg.content.content !== void 0) {
      v3Msg.content.metadata = {
        ...v3Msg.content.metadata || {},
        __originalContent: v2Msg.content.content
      };
    }
    if (v2Msg.content.experimental_attachments !== void 0) {
      v3Msg.content.metadata = {
        ...v3Msg.content.metadata || {},
        __originalExperimentalAttachments: v2Msg.content.experimental_attachments
      };
    }
    const fileUrls = /* @__PURE__ */ new Set();
    for (const part of v2Msg.content.parts) {
      switch (part.type) {
        case "step-start":
        case "text":
          parts.push(part);
          break;
        case "tool-invocation":
          if (part.toolInvocation.state === `result`) {
            parts.push({
              type: `tool-${part.toolInvocation.toolName}`,
              toolCallId: part.toolInvocation.toolCallId,
              state: "output-available",
              input: part.toolInvocation.args,
              output: part.toolInvocation.result,
              callProviderMetadata: part.providerMetadata
            });
          } else {
            const toolPart = {
              type: `tool-${part.toolInvocation.toolName}`,
              toolCallId: part.toolInvocation.toolCallId,
              state: part.toolInvocation.state === `call` ? `input-available` : `input-streaming`,
              input: part.toolInvocation.args
            };
            if (part.providerMetadata) {
              toolPart.callProviderMetadata = part.providerMetadata;
            }
            parts.push(toolPart);
          }
          break;
        case "source":
          parts.push({
            type: "source-url",
            sourceId: part.source.id,
            url: part.source.url,
            title: part.source.title,
            providerMetadata: part.source.providerMetadata || part.providerMetadata
          });
          break;
        case "reasoning":
          const text3 = part.reasoning || (part.details?.reduce((p, c) => {
            if (c.type === `text`) return p + c.text;
            return p;
          }, "") ?? "");
          if (text3 || part.details?.length || part.providerMetadata) {
            parts.push({
              type: "reasoning",
              text: text3 || "",
              state: "done",
              providerMetadata: part.providerMetadata
            });
          }
          break;
        case "file": {
          const categorized = typeof part.data === "string" ? categorizeFileData(part.data, part.mimeType) : { type: "raw", mimeType: part.mimeType };
          if (categorized.type === "url" && typeof part.data === "string") {
            parts.push({
              type: "file",
              url: part.data,
              mediaType: categorized.mimeType || "image/png",
              ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
            });
            fileUrls.add(part.data);
          } else {
            let filePartData;
            let extractedMimeType = part.mimeType;
            if (typeof part.data === "string") {
              const parsed = parseDataUri(part.data);
              if (parsed.isDataUri) {
                filePartData = parsed.base64Content;
                if (parsed.mimeType) {
                  extractedMimeType = extractedMimeType || parsed.mimeType;
                }
              } else {
                filePartData = part.data;
              }
            } else {
              filePartData = part.data;
            }
            const finalMimeType = extractedMimeType || "image/png";
            let dataUri;
            if (typeof filePartData === "string" && filePartData.startsWith("data:")) {
              dataUri = filePartData;
            } else {
              dataUri = createDataUri(filePartData, finalMimeType);
            }
            parts.push({
              type: "file",
              url: dataUri,
              // Use url field with data URI
              mediaType: finalMimeType,
              ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
            });
          }
          fileUrls.add(part.data);
          break;
        }
      }
    }
    if (v2Msg.content.content && !v3Msg.content.parts?.some((p) => p.type === `text`)) {
      v3Msg.content.parts.push({ type: "text", text: v2Msg.content.content });
    }
    const attachmentUrls = [];
    if (v2Msg.content.experimental_attachments?.length) {
      for (const attachment of v2Msg.content.experimental_attachments) {
        if (fileUrls.has(attachment.url)) continue;
        attachmentUrls.push(attachment.url);
        parts.push({
          url: attachment.url,
          mediaType: attachment.contentType || "unknown",
          type: "file"
        });
      }
    }
    if (attachmentUrls.length > 0) {
      v3Msg.content.metadata = {
        ...v3Msg.content.metadata || {},
        __attachmentUrls: attachmentUrls
      };
    }
    return v3Msg;
  }
  aiV5UIMessagesToAIV5ModelMessages(messages) {
    const sanitized = this.sanitizeV5UIMessages(messages);
    const preprocessed = this.addStartStepPartsForAIV5(sanitized);
    const result = convertToModelMessages(preprocessed);
    const finalResult = result.map((modelMsg, index) => {
      const uiMsg = preprocessed[index];
      let updatedMsg = modelMsg;
      if (uiMsg?.metadata && typeof uiMsg.metadata === "object" && "providerMetadata" in uiMsg.metadata && uiMsg.metadata.providerMetadata) {
        updatedMsg = {
          ...updatedMsg,
          providerOptions: uiMsg.metadata.providerMetadata
        };
      }
      if (updatedMsg.role === "assistant" && Array.isArray(updatedMsg.content)) {
        const updatedContent = updatedMsg.content.map((part, partIndex) => {
          if (part.type === "tool-call") {
            const uiPart = uiMsg?.parts[partIndex];
            if (uiPart && "callProviderMetadata" in uiPart && uiPart.callProviderMetadata) {
              return {
                ...part,
                providerOptions: uiPart.callProviderMetadata
              };
            }
          }
          if (part.type === "reasoning") {
            const uiPart = uiMsg?.parts[partIndex];
            if (uiPart && "providerMetadata" in uiPart && uiPart.providerMetadata) {
              return {
                ...part,
                providerOptions: uiPart.providerMetadata
              };
            }
          }
          return part;
        });
        return {
          ...updatedMsg,
          content: updatedContent
        };
      }
      return updatedMsg;
    });
    return finalResult;
  }
  addStartStepPartsForAIV5(messages) {
    for (const message of messages) {
      if (message.role !== `assistant`) continue;
      for (const [index, part] of message.parts.entries()) {
        if (!isToolUIPart(part)) continue;
        const nextPart = message.parts.at(index + 1);
        if (nextPart && nextPart.type !== `step-start` && !isToolUIPart(nextPart)) {
          message.parts.splice(index + 1, 0, { type: "step-start" });
        }
      }
    }
    return messages;
  }
  sanitizeV5UIMessages(messages) {
    const msgs = messages.map((m) => {
      if (m.parts.length === 0) return false;
      const safeParts = m.parts.filter((p) => {
        if (!isToolUIPart(p)) return true;
        return p.state === "output-available" || p.state === "output-error";
      });
      if (!safeParts.length) return false;
      const sanitized = {
        ...m,
        parts: safeParts.map((part) => {
          if (isToolUIPart(part) && part.state === "output-available") {
            return {
              ...part,
              output: typeof part.output === "object" && part.output && "value" in part.output ? part.output.value : part.output
            };
          }
          return part;
        })
      };
      return sanitized;
    }).filter((m) => Boolean(m));
    return msgs;
  }
  static mastraMessageV3ToAIV5UIMessage(m) {
    const { __originalContent, ...cleanMetadata } = m.content.metadata || {};
    const metadata = {
      ...cleanMetadata
    };
    if (m.createdAt) metadata.createdAt = m.createdAt;
    if (m.threadId) metadata.threadId = m.threadId;
    if (m.resourceId) metadata.resourceId = m.resourceId;
    if (m.content.providerMetadata) metadata.providerMetadata = m.content.providerMetadata;
    const filteredParts = m.content.parts;
    return {
      id: m.id,
      role: m.role,
      metadata,
      parts: filteredParts
    };
  }
  aiV5ModelMessagesToAIV4CoreMessages(messages, messageSource) {
    const v3 = messages.map((msg) => this.aiV5ModelMessageToMastraMessageV3(msg, messageSource));
    const v2 = v3.map(_MessageList.mastraMessageV3ToV2);
    const ui = v2.map(_MessageList.mastraMessageV2ToAIV4UIMessage);
    const core = this.aiV4UIMessagesToAIV4CoreMessages(ui);
    return core;
  }
  aiV4CoreMessagesToAIV5ModelMessages(messages, source) {
    return this.aiV5UIMessagesToAIV5ModelMessages(
      messages.map((m) => this.aiV4CoreMessageToMastraMessageV2(m, source)).map((m) => this.mastraMessageV2ToMastraMessageV3(m)).map((m) => _MessageList.mastraMessageV3ToAIV5UIMessage(m))
    );
  }
  aiV5UIMessageToMastraMessageV3(message, messageSource) {
    const content = {
      format: 3,
      parts: message.parts,
      metadata: message.metadata
    };
    const metadata = message.metadata;
    const createdAt = (() => {
      if ("createdAt" in message && message.createdAt instanceof Date) {
        return message.createdAt;
      }
      if (metadata && "createdAt" in metadata && metadata.createdAt instanceof Date) {
        return metadata.createdAt;
      }
      return void 0;
    })();
    if ("metadata" in message && message.metadata) {
      content.metadata = { ...message.metadata };
    }
    return {
      id: message.id || this.newMessageId(),
      role: _MessageList.getRole(message),
      createdAt: this.generateCreatedAt(messageSource, createdAt),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  aiV5ModelMessageToMastraMessageV3(coreMessage, messageSource) {
    const id = `id` in coreMessage && typeof coreMessage.id === `string` ? coreMessage.id : this.newMessageId();
    const parts = [];
    if (typeof coreMessage.content === "string") {
      parts.push({
        type: "text",
        text: coreMessage.content,
        // Preserve providerOptions from ModelMessage level (e.g., system messages with cacheControl)
        ..."providerOptions" in coreMessage && coreMessage.providerOptions ? { providerMetadata: coreMessage.providerOptions } : {}
      });
    } else if (Array.isArray(coreMessage.content)) {
      for (const part of coreMessage.content) {
        switch (part.type) {
          case "text":
            const prevPart = parts.at(-1);
            if (coreMessage.role === "assistant" && prevPart && isToolUIPart(prevPart) && prevPart.state === "output-available") {
              parts.push({
                type: "step-start"
              });
            }
            const mergedProviderMetadataV3 = {
              ..."providerOptions" in coreMessage && coreMessage.providerOptions ? coreMessage.providerOptions : {},
              ...part.providerOptions || {}
            };
            parts.push({
              type: "text",
              text: part.text,
              ...Object.keys(mergedProviderMetadataV3).length > 0 ? { providerMetadata: mergedProviderMetadataV3 } : {}
            });
            break;
          case "tool-call":
            parts.push({
              type: `tool-${part.toolName}`,
              state: "input-available",
              toolCallId: part.toolCallId,
              input: part.input
            });
            break;
          case "tool-result":
            parts.push({
              type: `tool-${part.toolName}`,
              state: "output-available",
              toolCallId: part.toolCallId,
              output: typeof part.output === "string" ? { type: "text", value: part.output } : part.output ?? { type: "text", value: "" },
              input: {},
              callProviderMetadata: part.providerOptions
            });
            break;
          case "reasoning":
            parts.push({
              type: "reasoning",
              text: part.text,
              providerMetadata: part.providerOptions
            });
            break;
          case "image": {
            let imageData;
            let extractedMimeType = part.mediaType;
            const imageStr = imageContentToDataUri(part.image, extractedMimeType || "image/png");
            const parsed = parseDataUri(imageStr);
            if (parsed.isDataUri) {
              imageData = parsed.base64Content;
              if (!extractedMimeType && parsed.mimeType) {
                extractedMimeType = parsed.mimeType;
              }
            } else if (imageStr.startsWith("http://") || imageStr.startsWith("https://")) {
              parts.push({
                type: "file",
                url: imageStr,
                mediaType: part.mediaType || "image/jpeg",
                // Default to image/jpeg for URLs
                providerMetadata: part.providerOptions
              });
              break;
            } else {
              imageData = imageStr;
            }
            const finalMimeType = extractedMimeType || "image/jpeg";
            const dataUri = imageData.startsWith("data:") ? imageData : createDataUri(imageData, finalMimeType);
            parts.push({
              type: "file",
              url: dataUri,
              mediaType: finalMimeType,
              providerMetadata: part.providerOptions
            });
            break;
          }
          case "file": {
            if (part.data instanceof URL) {
              const urlStr = part.data.toString();
              let extractedMimeType = part.mediaType;
              const parsed = parseDataUri(urlStr);
              if (parsed.isDataUri) {
                if (!extractedMimeType && parsed.mimeType) {
                  extractedMimeType = parsed.mimeType;
                }
                if (parsed.base64Content !== urlStr) {
                  const dataUri = createDataUri(parsed.base64Content, extractedMimeType || "image/png");
                  parts.push({
                    type: "file",
                    url: dataUri,
                    mediaType: extractedMimeType || "image/png",
                    providerMetadata: part.providerOptions
                  });
                } else {
                  parts.push({
                    type: "file",
                    url: urlStr,
                    mediaType: part.mediaType || "image/png",
                    providerMetadata: part.providerOptions
                  });
                }
              } else {
                parts.push({
                  type: "file",
                  url: urlStr,
                  mediaType: part.mediaType || "application/octet-stream",
                  providerMetadata: part.providerOptions
                });
              }
            } else if (typeof part.data === "string") {
              const categorized = categorizeFileData(part.data, part.mediaType);
              if (categorized.type === "url" || categorized.type === "dataUri") {
                parts.push({
                  type: "file",
                  url: part.data,
                  mediaType: categorized.mimeType || "application/octet-stream",
                  providerMetadata: part.providerOptions
                });
              } else {
                try {
                  const base64Data = convertDataContentToBase64String2(part.data);
                  const dataUri = createDataUri(base64Data, categorized.mimeType || "image/png");
                  parts.push({
                    type: "file",
                    url: dataUri,
                    mediaType: categorized.mimeType || "image/png",
                    providerMetadata: part.providerOptions
                  });
                } catch (error87) {
                  console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error87}`, error87);
                }
              }
            } else {
              try {
                const base64Data = convertDataContentToBase64String2(part.data);
                const dataUri = createDataUri(base64Data, part.mediaType || "image/png");
                parts.push({
                  type: "file",
                  url: dataUri,
                  mediaType: part.mediaType || "image/png",
                  providerMetadata: part.providerOptions
                });
              } catch (error87) {
                console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error87}`, error87);
              }
            }
            break;
          }
        }
      }
    }
    const content = {
      format: 3,
      parts
    };
    if ("metadata" in coreMessage && coreMessage.metadata !== null && coreMessage.metadata !== void 0) {
      content.metadata = {
        ...content.metadata || {},
        ...coreMessage.metadata
      };
    }
    if (coreMessage.content) {
      content.metadata = {
        ...content.metadata || {},
        __originalContent: coreMessage.content
      };
    }
    return {
      id,
      role: _MessageList.getRole(coreMessage),
      createdAt: this.generateCreatedAt(messageSource),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  static hasAIV5UIMessageCharacteristics(msg) {
    if (`toolInvocations` in msg || `reasoning` in msg || `experimental_attachments` in msg || `data` in msg || `annotations` in msg)
      return false;
    if (!msg.parts) return false;
    for (const part of msg.parts) {
      if (`metadata` in part) return true;
      if (`toolInvocation` in part) return false;
      if (`toolCallId` in part) return true;
      if (part.type === `source`) return false;
      if (part.type === `source-url`) return true;
      if (part.type === `reasoning`) {
        if (`state` in part || `text` in part) return true;
        if (`reasoning` in part || `details` in part) return false;
      }
      if (part.type === `file` && `mediaType` in part) return true;
    }
    return false;
  }
  static isAIV5UIMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !_MessageList.isAIV5CoreMessage(msg) && `parts` in msg && _MessageList.hasAIV5UIMessageCharacteristics(msg);
  }
  static hasAIV5CoreMessageCharacteristics(msg) {
    if (`experimental_providerMetadata` in msg) return false;
    if (typeof msg.content === `string`) return false;
    for (const part of msg.content) {
      if (part.type === `tool-result` && `output` in part) return true;
      if (part.type === `tool-call` && `input` in part) return true;
      if (part.type === `tool-result` && `result` in part) return false;
      if (part.type === `tool-call` && `args` in part) return false;
      if (`mediaType` in part) return true;
      if (`mimeType` in part) return false;
      if (`experimental_providerMetadata` in part) return false;
      if (part.type === `reasoning` && `signature` in part) return false;
      if (part.type === `redacted-reasoning`) return false;
    }
    return false;
  }
  static cacheKeyFromAIV5Parts(parts) {
    let key = ``;
    for (const part of parts) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text;
      }
      if (isToolUIPart(part) || part.type === "dynamic-tool") {
        key += part.toolCallId;
        key += part.state;
      }
      if (part.type === `reasoning`) {
        key += part.text;
      }
      if (part.type === `file`) {
        key += part.url.length;
        key += part.mediaType;
        key += part.filename || "";
      }
    }
    return key;
  }
  static cacheKeyFromAIV5ModelMessageContent(content) {
    if (typeof content === `string`) return content;
    let key = ``;
    for (const part of content) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text.length;
      }
      if (part.type === `reasoning`) {
        key += part.text.length;
      }
      if (part.type === `tool-call`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `tool-result`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `file`) {
        key += part.filename;
        key += part.mediaType;
      }
      if (part.type === `image`) {
        key += getImageCacheKey(part.image);
        key += part.mediaType;
      }
    }
    return key;
  }
};

// node_modules/@mastra/core/dist/chunk-72F4RGK7.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-PHSTPDWR.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
import fs2 from "fs";
import { createRequire } from "module";
import os from "os";
import path2 from "path";
var provider_registry_default = {
  providers: {
    "moonshotai-cn": {
      url: "https://api.moonshot.cn/v1",
      apiKeyEnvVar: "MOONSHOT_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Moonshot AI (China)",
      models: [
        "kimi-k2-0711-preview",
        "kimi-k2-0905-preview",
        "kimi-k2-thinking",
        "kimi-k2-thinking-turbo",
        "kimi-k2-turbo-preview"
      ],
      docUrl: "https://platform.moonshot.cn/docs/api/chat",
      gateway: "models.dev"
    },
    lucidquery: {
      url: "https://lucidquery.com/api/v1",
      apiKeyEnvVar: "LUCIDQUERY_API_KEY",
      apiKeyHeader: "Authorization",
      name: "LucidQuery AI",
      models: ["lucidnova-rf1-100b", "lucidquery-nexus-coder"],
      docUrl: "https://lucidquery.com/api/docs",
      gateway: "models.dev"
    },
    moonshotai: {
      url: "https://api.moonshot.ai/v1",
      apiKeyEnvVar: "MOONSHOT_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Moonshot AI",
      models: [
        "kimi-k2-0711-preview",
        "kimi-k2-0905-preview",
        "kimi-k2-thinking",
        "kimi-k2-thinking-turbo",
        "kimi-k2-turbo-preview"
      ],
      docUrl: "https://platform.moonshot.ai/docs/api/chat",
      gateway: "models.dev"
    },
    "zai-coding-plan": {
      url: "https://api.z.ai/api/coding/paas/v4",
      apiKeyEnvVar: "ZHIPU_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Z.AI Coding Plan",
      models: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
      docUrl: "https://docs.z.ai/devpack/overview",
      gateway: "models.dev"
    },
    alibaba: {
      url: "https://dashscope-intl.aliyuncs.com/compatible-mode/v1",
      apiKeyEnvVar: "DASHSCOPE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Alibaba",
      models: [
        "qvq-max",
        "qwen-flash",
        "qwen-max",
        "qwen-mt-plus",
        "qwen-mt-turbo",
        "qwen-omni-turbo",
        "qwen-omni-turbo-realtime",
        "qwen-plus",
        "qwen-plus-character-ja",
        "qwen-turbo",
        "qwen-vl-max",
        "qwen-vl-ocr",
        "qwen-vl-plus",
        "qwen2-5-14b-instruct",
        "qwen2-5-32b-instruct",
        "qwen2-5-72b-instruct",
        "qwen2-5-7b-instruct",
        "qwen2-5-omni-7b",
        "qwen2-5-vl-72b-instruct",
        "qwen2-5-vl-7b-instruct",
        "qwen3-14b",
        "qwen3-235b-a22b",
        "qwen3-32b",
        "qwen3-8b",
        "qwen3-asr-flash",
        "qwen3-coder-30b-a3b-instruct",
        "qwen3-coder-480b-a35b-instruct",
        "qwen3-coder-flash",
        "qwen3-coder-plus",
        "qwen3-livetranslate-flash-realtime",
        "qwen3-max",
        "qwen3-next-80b-a3b-instruct",
        "qwen3-next-80b-a3b-thinking",
        "qwen3-omni-flash",
        "qwen3-omni-flash-realtime",
        "qwen3-vl-235b-a22b",
        "qwen3-vl-30b-a3b",
        "qwen3-vl-plus",
        "qwq-plus"
      ],
      docUrl: "https://www.alibabacloud.com/help/en/model-studio/models",
      gateway: "models.dev"
    },
    xai: {
      apiKeyEnvVar: "XAI_API_KEY",
      name: "xAI",
      models: [
        "grok-2",
        "grok-2-1212",
        "grok-2-latest",
        "grok-2-vision",
        "grok-2-vision-1212",
        "grok-2-vision-latest",
        "grok-3",
        "grok-3-fast",
        "grok-3-fast-latest",
        "grok-3-latest",
        "grok-3-mini",
        "grok-3-mini-fast",
        "grok-3-mini-fast-latest",
        "grok-3-mini-latest",
        "grok-4",
        "grok-4-1-fast",
        "grok-4-1-fast-non-reasoning",
        "grok-4-fast",
        "grok-4-fast-non-reasoning",
        "grok-beta",
        "grok-code-fast-1",
        "grok-vision-beta"
      ],
      docUrl: "https://docs.x.ai/docs/models",
      gateway: "models.dev"
    },
    vultr: {
      url: "https://api.vultrinference.com/v1",
      apiKeyEnvVar: "VULTR_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Vultr",
      models: [
        "deepseek-r1-distill-llama-70b",
        "deepseek-r1-distill-qwen-32b",
        "gpt-oss-120b",
        "kimi-k2-instruct",
        "qwen2.5-coder-32b-instruct"
      ],
      docUrl: "https://api.vultrinference.com/",
      gateway: "models.dev"
    },
    nvidia: {
      url: "https://integrate.api.nvidia.com/v1",
      apiKeyEnvVar: "NVIDIA_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Nvidia",
      models: [
        "black-forest-labs/flux.1-dev",
        "deepseek-ai/deepseek-v3.1",
        "deepseek-ai/deepseek-v3.1-terminus",
        "google/gemma-3-27b-it",
        "microsoft/phi-4-mini-instruct",
        "minimaxai/minimax-m2",
        "moonshotai/kimi-k2-instruct",
        "moonshotai/kimi-k2-instruct-0905",
        "nvidia/cosmos-nemotron-34b",
        "nvidia/llama-3.1-nemotron-ultra-253b-v1",
        "nvidia/llama-embed-nemotron-8b",
        "nvidia/nemoretriever-ocr-v1",
        "nvidia/nvidia-nemotron-nano-9b-v2",
        "nvidia/parakeet-tdt-0.6b-v2",
        "openai/gpt-oss-120b",
        "openai/whisper-large-v3",
        "qwen/qwen3-235b-a22b",
        "qwen/qwen3-coder-480b-a35b-instruct",
        "qwen/qwen3-next-80b-a3b-instruct",
        "qwen/qwen3-next-80b-a3b-thinking"
      ],
      docUrl: "https://docs.api.nvidia.com/nim/",
      gateway: "models.dev"
    },
    upstage: {
      url: "https://api.upstage.ai",
      apiKeyEnvVar: "UPSTAGE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Upstage",
      models: ["solar-mini", "solar-pro2"],
      docUrl: "https://developers.upstage.ai/docs/apis/chat",
      gateway: "models.dev"
    },
    groq: {
      url: "https://api.groq.com/openai/v1",
      apiKeyEnvVar: "GROQ_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Groq",
      models: [
        "deepseek-r1-distill-llama-70b",
        "gemma2-9b-it",
        "llama-3.1-8b-instant",
        "llama-3.3-70b-versatile",
        "llama-guard-3-8b",
        "llama3-70b-8192",
        "llama3-8b-8192",
        "meta-llama/llama-4-maverick-17b-128e-instruct",
        "meta-llama/llama-4-scout-17b-16e-instruct",
        "meta-llama/llama-guard-4-12b",
        "mistral-saba-24b",
        "moonshotai/kimi-k2-instruct",
        "moonshotai/kimi-k2-instruct-0905",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "qwen-qwq-32b",
        "qwen/qwen3-32b"
      ],
      docUrl: "https://console.groq.com/docs/models",
      gateway: "models.dev"
    },
    mistral: {
      url: "https://api.mistral.ai/v1",
      apiKeyEnvVar: "MISTRAL_API_KEY",
      name: "Mistral",
      models: [
        "codestral-latest",
        "devstral-medium-2507",
        "devstral-small-2505",
        "devstral-small-2507",
        "magistral-medium-latest",
        "magistral-small",
        "ministral-3b-latest",
        "ministral-8b-latest",
        "mistral-large-latest",
        "mistral-medium-2505",
        "mistral-medium-2508",
        "mistral-medium-latest",
        "mistral-nemo",
        "mistral-small-latest",
        "open-mistral-7b",
        "open-mixtral-8x22b",
        "open-mixtral-8x7b",
        "pixtral-12b",
        "pixtral-large-latest"
      ],
      docUrl: "https://docs.mistral.ai/getting-started/models/",
      gateway: "models.dev"
    },
    vercel: {
      url: "https://ai-gateway.vercel.sh/v1",
      apiKeyEnvVar: "AI_GATEWAY_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Vercel AI Gateway",
      models: [
        "alibaba/qwen3-coder-plus",
        "alibaba/qwen3-max",
        "alibaba/qwen3-next-80b-a3b-instruct",
        "alibaba/qwen3-next-80b-a3b-thinking",
        "alibaba/qwen3-vl-instruct",
        "alibaba/qwen3-vl-thinking",
        "amazon/nova-lite",
        "amazon/nova-micro",
        "amazon/nova-pro",
        "anthropic/claude-3-haiku",
        "anthropic/claude-3-opus",
        "anthropic/claude-3.5-haiku",
        "anthropic/claude-3.5-sonnet",
        "anthropic/claude-3.7-sonnet",
        "anthropic/claude-4-1-opus",
        "anthropic/claude-4-opus",
        "anthropic/claude-4-sonnet",
        "anthropic/claude-4.5-sonnet",
        "anthropic/claude-haiku-4.5",
        "anthropic/claude-opus-4.5",
        "deepseek/deepseek-r1",
        "deepseek/deepseek-r1-distill-llama-70b",
        "deepseek/deepseek-v3.1-terminus",
        "deepseek/deepseek-v3.2-exp",
        "deepseek/deepseek-v3.2-exp-thinking",
        "google/gemini-2.0-flash",
        "google/gemini-2.0-flash-lite",
        "google/gemini-2.5-flash",
        "google/gemini-2.5-flash-lite",
        "google/gemini-2.5-flash-lite-preview-09-2025",
        "google/gemini-2.5-flash-preview-09-2025",
        "google/gemini-2.5-pro",
        "google/gemini-3-pro-preview",
        "meta/llama-3.3-70b",
        "meta/llama-4-maverick",
        "meta/llama-4-scout",
        "minimax/minimax-m2",
        "mistral/codestral",
        "mistral/magistral-medium",
        "mistral/magistral-small",
        "mistral/ministral-3b",
        "mistral/ministral-8b",
        "mistral/mistral-large",
        "mistral/mistral-small",
        "mistral/mixtral-8x22b-instruct",
        "mistral/pixtral-12b",
        "mistral/pixtral-large",
        "moonshotai/kimi-k2",
        "morph/morph-v3-fast",
        "morph/morph-v3-large",
        "openai/gpt-4-turbo",
        "openai/gpt-4.1",
        "openai/gpt-4.1-mini",
        "openai/gpt-4.1-nano",
        "openai/gpt-4o",
        "openai/gpt-4o-mini",
        "openai/gpt-5",
        "openai/gpt-5-codex",
        "openai/gpt-5-mini",
        "openai/gpt-5-nano",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "openai/o1",
        "openai/o3",
        "openai/o3-mini",
        "openai/o4-mini",
        "perplexity/sonar",
        "perplexity/sonar-pro",
        "perplexity/sonar-reasoning",
        "perplexity/sonar-reasoning-pro",
        "vercel/v0-1.0-md",
        "vercel/v0-1.5-md",
        "xai/grok-2",
        "xai/grok-2-vision",
        "xai/grok-3",
        "xai/grok-3-fast",
        "xai/grok-3-mini",
        "xai/grok-3-mini-fast",
        "xai/grok-4",
        "xai/grok-4-fast",
        "xai/grok-4-fast-non-reasoning",
        "xai/grok-code-fast-1",
        "zai/glm-4.5",
        "zai/glm-4.5-air",
        "zai/glm-4.5v",
        "zai/glm-4.6"
      ],
      docUrl: "https://github.com/vercel/ai/tree/5eb85cc45a259553501f535b8ac79a77d0e79223/packages/gateway",
      gateway: "models.dev"
    },
    nebius: {
      url: "https://api.tokenfactory.nebius.com/v1",
      apiKeyEnvVar: "NEBIUS_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Nebius Token Factory",
      models: [
        "NousResearch/hermes-4-405b",
        "NousResearch/hermes-4-70b",
        "deepseek-ai/deepseek-v3",
        "meta-llama/llama-3.3-70b-instruct-base",
        "meta-llama/llama-3.3-70b-instruct-fast",
        "meta-llama/llama-3_1-405b-instruct",
        "moonshotai/kimi-k2-instruct",
        "nvidia/llama-3_1-nemotron-ultra-253b-v1",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "qwen/qwen3-235b-a22b-instruct-2507",
        "qwen/qwen3-235b-a22b-thinking-2507",
        "qwen/qwen3-coder-480b-a35b-instruct",
        "zai-org/glm-4.5",
        "zai-org/glm-4.5-air"
      ],
      docUrl: "https://docs.tokenfactory.nebius.com/",
      gateway: "models.dev"
    },
    deepseek: {
      url: "https://api.deepseek.com",
      apiKeyEnvVar: "DEEPSEEK_API_KEY",
      apiKeyHeader: "Authorization",
      name: "DeepSeek",
      models: ["deepseek-chat", "deepseek-reasoner"],
      docUrl: "https://platform.deepseek.com/api-docs/pricing",
      gateway: "models.dev"
    },
    "alibaba-cn": {
      url: "https://dashscope.aliyuncs.com/compatible-mode/v1",
      apiKeyEnvVar: "DASHSCOPE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Alibaba (China)",
      models: [
        "deepseek-r1",
        "deepseek-r1-0528",
        "deepseek-r1-distill-llama-70b",
        "deepseek-r1-distill-llama-8b",
        "deepseek-r1-distill-qwen-1-5b",
        "deepseek-r1-distill-qwen-14b",
        "deepseek-r1-distill-qwen-32b",
        "deepseek-r1-distill-qwen-7b",
        "deepseek-v3",
        "deepseek-v3-1",
        "deepseek-v3-2-exp",
        "moonshot-kimi-k2-instruct",
        "qvq-max",
        "qwen-deep-research",
        "qwen-doc-turbo",
        "qwen-flash",
        "qwen-long",
        "qwen-math-plus",
        "qwen-math-turbo",
        "qwen-max",
        "qwen-mt-plus",
        "qwen-mt-turbo",
        "qwen-omni-turbo",
        "qwen-omni-turbo-realtime",
        "qwen-plus",
        "qwen-plus-character",
        "qwen-turbo",
        "qwen-vl-max",
        "qwen-vl-ocr",
        "qwen-vl-plus",
        "qwen2-5-14b-instruct",
        "qwen2-5-32b-instruct",
        "qwen2-5-72b-instruct",
        "qwen2-5-7b-instruct",
        "qwen2-5-coder-32b-instruct",
        "qwen2-5-coder-7b-instruct",
        "qwen2-5-math-72b-instruct",
        "qwen2-5-math-7b-instruct",
        "qwen2-5-omni-7b",
        "qwen2-5-vl-72b-instruct",
        "qwen2-5-vl-7b-instruct",
        "qwen3-14b",
        "qwen3-235b-a22b",
        "qwen3-32b",
        "qwen3-8b",
        "qwen3-asr-flash",
        "qwen3-coder-30b-a3b-instruct",
        "qwen3-coder-480b-a35b-instruct",
        "qwen3-coder-flash",
        "qwen3-coder-plus",
        "qwen3-max",
        "qwen3-next-80b-a3b-instruct",
        "qwen3-next-80b-a3b-thinking",
        "qwen3-omni-flash",
        "qwen3-omni-flash-realtime",
        "qwen3-vl-235b-a22b",
        "qwen3-vl-30b-a3b",
        "qwen3-vl-plus",
        "qwq-32b",
        "qwq-plus",
        "tongyi-intent-detect-v3"
      ],
      docUrl: "https://www.alibabacloud.com/help/en/model-studio/models",
      gateway: "models.dev"
    },
    venice: {
      url: "https://api.venice.ai/api/v1",
      apiKeyEnvVar: "VENICE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Venice AI",
      models: [
        "deepseek-coder-v2-lite",
        "deepseek-r1-671b",
        "dolphin-2.9.2-qwen2-72b",
        "llama-3.1-405b",
        "llama-3.2-3b",
        "llama-3.3-70b",
        "mistral-31-24b",
        "qwen-2.5-coder-32b",
        "qwen-2.5-qwq-32b",
        "qwen-2.5-vl",
        "qwen3-235b",
        "qwen3-4b",
        "venice-uncensored",
        "zai-org-glm-4.6"
      ],
      docUrl: "https://docs.venice.ai",
      gateway: "models.dev"
    },
    chutes: {
      url: "https://llm.chutes.ai/v1",
      apiKeyEnvVar: "CHUTES_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Chutes",
      models: [
        "Alibaba-NLP/Tongyi-DeepResearch-30B-A3B",
        "ArliAI/QwQ-32B-ArliAI-RpR-v1",
        "MiniMaxAI/MiniMax-M2",
        "NousResearch/DeepHermes-3-Mistral-24B-Preview",
        "NousResearch/Hermes-4-14B",
        "NousResearch/Hermes-4-405B-FP8",
        "NousResearch/Hermes-4-70B",
        "OpenGVLab/InternVL3-78B",
        "Qwen/Qwen2.5-72B-Instruct",
        "Qwen/Qwen2.5-Coder-32B-Instruct",
        "Qwen/Qwen2.5-VL-32B-Instruct",
        "Qwen/Qwen2.5-VL-72B-Instruct",
        "Qwen/Qwen3-14B",
        "Qwen/Qwen3-235B-A22B",
        "Qwen/Qwen3-235B-A22B-Instruct-2507",
        "Qwen/Qwen3-235B-A22B-Thinking-2507",
        "Qwen/Qwen3-30B-A3B",
        "Qwen/Qwen3-30B-A3B-Instruct-2507",
        "Qwen/Qwen3-32B",
        "Qwen/Qwen3-Coder-30B-A3B-Instruct",
        "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
        "Qwen/Qwen3-Next-80B-A3B-Instruct",
        "Qwen/Qwen3-VL-235B-A22B-Instruct",
        "Qwen/Qwen3-VL-235B-A22B-Thinking",
        "chutesai/Mistral-Small-3.1-24B-Instruct-2503",
        "chutesai/Mistral-Small-3.2-24B-Instruct-2506",
        "deepseek-ai/DeepSeek-R1",
        "deepseek-ai/DeepSeek-R1-0528",
        "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B",
        "deepseek-ai/DeepSeek-R1-Distill-Llama-70B",
        "deepseek-ai/DeepSeek-V3",
        "deepseek-ai/DeepSeek-V3-0324",
        "deepseek-ai/DeepSeek-V3.1",
        "deepseek-ai/DeepSeek-V3.1-Terminus",
        "deepseek-ai/DeepSeek-V3.2-Exp",
        "meituan-longcat/LongCat-Flash-Chat-FP8",
        "microsoft/MAI-DS-R1-FP8",
        "moonshotai/Kimi-K2-Instruct-0905",
        "moonshotai/Kimi-K2-Thinking",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "rednote-hilab/dots.ocr",
        "tngtech/DeepSeek-R1T-Chimera",
        "tngtech/DeepSeek-TNG-R1T2-Chimera",
        "unsloth/Mistral-Nemo-Instruct-2407",
        "unsloth/Mistral-Small-24B-Instruct-2501",
        "unsloth/gemma-3-12b-it",
        "unsloth/gemma-3-27b-it",
        "unsloth/gemma-3-4b-it",
        "zai-org/GLM-4.5",
        "zai-org/GLM-4.5-Air",
        "zai-org/GLM-4.6"
      ],
      docUrl: "https://llm.chutes.ai/v1/models",
      gateway: "models.dev"
    },
    cortecs: {
      url: "https://api.cortecs.ai/v1",
      apiKeyEnvVar: "CORTECS_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Cortecs",
      models: [
        "claude-4-5-sonnet",
        "claude-sonnet-4",
        "deepseek-v3-0324",
        "gemini-2.5-pro",
        "gpt-4.1",
        "gpt-oss-120b",
        "kimi-k2-instruct",
        "llama-3.1-405b-instruct",
        "nova-pro-v1",
        "qwen3-32b",
        "qwen3-coder-480b-a35b-instruct"
      ],
      docUrl: "https://api.cortecs.ai/v1/models",
      gateway: "models.dev"
    },
    "github-models": {
      url: "https://models.github.ai/inference",
      apiKeyEnvVar: "GITHUB_TOKEN",
      apiKeyHeader: "Authorization",
      name: "GitHub Models",
      models: [
        "ai21-labs/ai21-jamba-1.5-large",
        "ai21-labs/ai21-jamba-1.5-mini",
        "cohere/cohere-command-a",
        "cohere/cohere-command-r",
        "cohere/cohere-command-r-08-2024",
        "cohere/cohere-command-r-plus",
        "cohere/cohere-command-r-plus-08-2024",
        "core42/jais-30b-chat",
        "deepseek/deepseek-r1",
        "deepseek/deepseek-r1-0528",
        "deepseek/deepseek-v3-0324",
        "meta/llama-3.2-11b-vision-instruct",
        "meta/llama-3.2-90b-vision-instruct",
        "meta/llama-3.3-70b-instruct",
        "meta/llama-4-maverick-17b-128e-instruct-fp8",
        "meta/llama-4-scout-17b-16e-instruct",
        "meta/meta-llama-3-70b-instruct",
        "meta/meta-llama-3-8b-instruct",
        "meta/meta-llama-3.1-405b-instruct",
        "meta/meta-llama-3.1-70b-instruct",
        "meta/meta-llama-3.1-8b-instruct",
        "microsoft/mai-ds-r1",
        "microsoft/phi-3-medium-128k-instruct",
        "microsoft/phi-3-medium-4k-instruct",
        "microsoft/phi-3-mini-128k-instruct",
        "microsoft/phi-3-mini-4k-instruct",
        "microsoft/phi-3-small-128k-instruct",
        "microsoft/phi-3-small-8k-instruct",
        "microsoft/phi-3.5-mini-instruct",
        "microsoft/phi-3.5-moe-instruct",
        "microsoft/phi-3.5-vision-instruct",
        "microsoft/phi-4",
        "microsoft/phi-4-mini-instruct",
        "microsoft/phi-4-mini-reasoning",
        "microsoft/phi-4-multimodal-instruct",
        "microsoft/phi-4-reasoning",
        "mistral-ai/codestral-2501",
        "mistral-ai/ministral-3b",
        "mistral-ai/mistral-large-2411",
        "mistral-ai/mistral-medium-2505",
        "mistral-ai/mistral-nemo",
        "mistral-ai/mistral-small-2503",
        "openai/gpt-4.1",
        "openai/gpt-4.1-mini",
        "openai/gpt-4.1-nano",
        "openai/gpt-4o",
        "openai/gpt-4o-mini",
        "openai/o1",
        "openai/o1-mini",
        "openai/o1-preview",
        "openai/o3",
        "openai/o3-mini",
        "openai/o4-mini",
        "xai/grok-3",
        "xai/grok-3-mini"
      ],
      docUrl: "https://docs.github.com/en/github-models",
      gateway: "models.dev"
    },
    togetherai: {
      url: "https://api.together.xyz/v1",
      apiKeyEnvVar: "TOGETHER_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Together AI",
      models: [
        "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
        "deepseek-ai/DeepSeek-R1",
        "deepseek-ai/DeepSeek-V3",
        "meta-llama/Llama-3.3-70B-Instruct-Turbo",
        "moonshotai/Kimi-K2-Instruct",
        "openai/gpt-oss-120b"
      ],
      docUrl: "https://docs.together.ai/docs/serverless-models",
      gateway: "models.dev"
    },
    baseten: {
      url: "https://inference.baseten.co/v1",
      apiKeyEnvVar: "BASETEN_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Baseten",
      models: [
        "Qwen/Qwen3-Coder-480B-A35B-Instruct",
        "moonshotai/Kimi-K2-Instruct-0905",
        "moonshotai/Kimi-K2-Thinking",
        "zai-org/GLM-4.6"
      ],
      docUrl: "https://docs.baseten.co/development/model-apis/overview",
      gateway: "models.dev"
    },
    siliconflow: {
      url: "https://api.siliconflow.com/v1",
      apiKeyEnvVar: "SILICONFLOW_API_KEY",
      apiKeyHeader: "Authorization",
      name: "SiliconFlow",
      models: [
        "baidu-ernie-4.5-300b-a47b",
        "bytedance-seed-seed-oss-36b-instruct",
        "deepseek-ai-deepseek-r1",
        "deepseek-ai-deepseek-r1-distill-qwen-14b",
        "deepseek-ai-deepseek-r1-distill-qwen-32b",
        "deepseek-ai-deepseek-r1-distill-qwen-7b",
        "deepseek-ai-deepseek-v3",
        "deepseek-ai-deepseek-v3.1",
        "deepseek-ai-deepseek-v3.1-terminus",
        "deepseek-ai-deepseek-v3.2-exp",
        "deepseek-ai-deepseek-vl2",
        "inclusionai-ling-flash-2.0",
        "inclusionai-ling-mini-2.0",
        "inclusionai-ring-flash-2.0",
        "meta-llama-meta-llama-3.1-8b-instruct",
        "minimaxai-minimax-m1-80k",
        "minimaxai-minimax-m2",
        "moonshotai-kimi-dev-72b",
        "moonshotai-kimi-k2-instruct",
        "moonshotai-kimi-k2-instruct-0905",
        "moonshotai-kimi-k2-thinking",
        "nex-agi-deepseek-v3.1-nex-n1",
        "openai-gpt-oss-120b",
        "openai-gpt-oss-20b",
        "qwen-qwen2.5-14b-instruct",
        "qwen-qwen2.5-32b-instruct",
        "qwen-qwen2.5-72b-instruct",
        "qwen-qwen2.5-72b-instruct-128k",
        "qwen-qwen2.5-7b-instruct",
        "qwen-qwen2.5-coder-32b-instruct",
        "qwen-qwen2.5-vl-32b-instruct",
        "qwen-qwen2.5-vl-72b-instruct",
        "qwen-qwen2.5-vl-7b-instruct",
        "qwen-qwen3-14b",
        "qwen-qwen3-235b-a22b",
        "qwen-qwen3-235b-a22b-instruct-2507",
        "qwen-qwen3-235b-a22b-thinking-2507",
        "qwen-qwen3-30b-a3b",
        "qwen-qwen3-30b-a3b-instruct-2507",
        "qwen-qwen3-30b-a3b-thinking-2507",
        "qwen-qwen3-32b",
        "qwen-qwen3-8b",
        "qwen-qwen3-coder-30b-a3b-instruct",
        "qwen-qwen3-coder-480b-a35b-instruct",
        "qwen-qwen3-next-80b-a3b-instruct",
        "qwen-qwen3-next-80b-a3b-thinking",
        "qwen-qwen3-omni-30b-a3b-captioner",
        "qwen-qwen3-omni-30b-a3b-instruct",
        "qwen-qwen3-omni-30b-a3b-thinking",
        "qwen-qwen3-vl-235b-a22b-instruct",
        "qwen-qwen3-vl-235b-a22b-thinking",
        "qwen-qwen3-vl-30b-a3b-instruct",
        "qwen-qwen3-vl-30b-a3b-thinking",
        "qwen-qwen3-vl-32b-instruct",
        "qwen-qwen3-vl-32b-thinking",
        "qwen-qwen3-vl-8b-instruct",
        "qwen-qwen3-vl-8b-thinking",
        "qwen-qwq-32b",
        "stepfun-ai-step3",
        "tencent-hunyuan-a13b-instruct",
        "tencent-hunyuan-mt-7b",
        "thudm-glm-4-32b-0414",
        "thudm-glm-4-9b-0414",
        "thudm-glm-4.1v-9b-thinking",
        "thudm-glm-z1-32b-0414",
        "thudm-glm-z1-9b-0414",
        "z-ai-glm-4.5",
        "z-ai-glm-4.5-air",
        "zai-org-glm-4.5",
        "zai-org-glm-4.5-air",
        "zai-org-glm-4.5v",
        "zai-org-glm-4.6"
      ],
      docUrl: "https://cloud.siliconflow.com/models",
      gateway: "models.dev"
    },
    huggingface: {
      url: "https://router.huggingface.co/v1",
      apiKeyEnvVar: "HF_TOKEN",
      apiKeyHeader: "Authorization",
      name: "Hugging Face",
      models: [
        "MiniMaxAI/MiniMax-M2",
        "Qwen/Qwen3-235B-A22B-Thinking-2507",
        "Qwen/Qwen3-Coder-480B-A35B-Instruct",
        "Qwen/Qwen3-Embedding-4B",
        "Qwen/Qwen3-Embedding-8B",
        "Qwen/Qwen3-Next-80B-A3B-Instruct",
        "Qwen/Qwen3-Next-80B-A3B-Thinking",
        "deepseek-ai/DeepSeek-R1-0528",
        "deepseek-ai/Deepseek-V3-0324",
        "moonshotai/Kimi-K2-Instruct",
        "moonshotai/Kimi-K2-Instruct-0905",
        "zai-org/GLM-4.5",
        "zai-org/GLM-4.5-Air",
        "zai-org/GLM-4.6"
      ],
      docUrl: "https://huggingface.co/docs/inference-providers",
      gateway: "models.dev"
    },
    opencode: {
      url: "https://opencode.ai/zen/v1",
      apiKeyEnvVar: "OPENCODE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "OpenCode Zen",
      models: [
        "alpha-doubao-seed-code",
        "alpha-gd4",
        "alpha-minimax-m2",
        "big-pickle",
        "claude-3-5-haiku",
        "claude-haiku-4-5",
        "claude-opus-4-1",
        "claude-opus-4-5",
        "claude-sonnet-4",
        "claude-sonnet-4-5",
        "gemini-3-pro",
        "glm-4.6",
        "gpt-5",
        "gpt-5-codex",
        "gpt-5-nano",
        "gpt-5.1",
        "gpt-5.1-codex",
        "grok-code",
        "kimi-k2",
        "kimi-k2-thinking",
        "qwen3-coder"
      ],
      docUrl: "https://opencode.ai/docs/zen",
      gateway: "models.dev"
    },
    fastrouter: {
      url: "https://go.fastrouter.ai/api/v1",
      apiKeyEnvVar: "FASTROUTER_API_KEY",
      apiKeyHeader: "Authorization",
      name: "FastRouter",
      models: [
        "anthropic/claude-opus-4.1",
        "anthropic/claude-sonnet-4",
        "deepseek-ai/deepseek-r1-distill-llama-70b",
        "google/gemini-2.5-flash",
        "google/gemini-2.5-pro",
        "moonshotai/kimi-k2",
        "openai/gpt-4.1",
        "openai/gpt-5",
        "openai/gpt-5-mini",
        "openai/gpt-5-nano",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "qwen/qwen3-coder",
        "x-ai/grok-4"
      ],
      docUrl: "https://fastrouter.ai/models",
      gateway: "models.dev"
    },
    minimax: {
      url: "https://api.minimax.io/anthropic/v1",
      apiKeyEnvVar: "MINIMAX_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Minimax",
      models: ["MiniMax-M2"],
      docUrl: "https://platform.minimax.io/docs/guides/quickstart",
      gateway: "models.dev"
    },
    google: {
      apiKeyEnvVar: "GOOGLE_GENERATIVE_AI_API_KEY",
      name: "Google",
      models: [
        "gemini-1.5-flash",
        "gemini-1.5-flash-8b",
        "gemini-1.5-pro",
        "gemini-2.0-flash",
        "gemini-2.0-flash-lite",
        "gemini-2.5-flash",
        "gemini-2.5-flash-image",
        "gemini-2.5-flash-image-preview",
        "gemini-2.5-flash-lite",
        "gemini-2.5-flash-lite-preview-06-17",
        "gemini-2.5-flash-lite-preview-09-2025",
        "gemini-2.5-flash-preview-04-17",
        "gemini-2.5-flash-preview-05-20",
        "gemini-2.5-flash-preview-09-2025",
        "gemini-2.5-flash-preview-tts",
        "gemini-2.5-pro",
        "gemini-2.5-pro-preview-05-06",
        "gemini-2.5-pro-preview-06-05",
        "gemini-2.5-pro-preview-tts",
        "gemini-3-pro-preview",
        "gemini-embedding-001",
        "gemini-flash-latest",
        "gemini-flash-lite-latest",
        "gemini-live-2.5-flash",
        "gemini-live-2.5-flash-preview-native-audio"
      ],
      docUrl: "https://ai.google.dev/gemini-api/docs/pricing",
      gateway: "models.dev"
    },
    inception: {
      url: "https://api.inceptionlabs.ai/v1/",
      apiKeyEnvVar: "INCEPTION_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Inception",
      models: ["mercury", "mercury-coder"],
      docUrl: "https://platform.inceptionlabs.ai/docs",
      gateway: "models.dev"
    },
    wandb: {
      url: "https://api.inference.wandb.ai/v1",
      apiKeyEnvVar: "WANDB_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Weights & Biases",
      models: [
        "Qwen/Qwen3-235B-A22B-Instruct-2507",
        "Qwen/Qwen3-235B-A22B-Thinking-2507",
        "Qwen/Qwen3-Coder-480B-A35B-Instruct",
        "deepseek-ai/DeepSeek-R1-0528",
        "deepseek-ai/DeepSeek-V3-0324",
        "meta-llama/Llama-3.1-8B-Instruct",
        "meta-llama/Llama-3.3-70B-Instruct",
        "meta-llama/Llama-4-Scout-17B-16E-Instruct",
        "microsoft/Phi-4-mini-instruct",
        "moonshotai/Kimi-K2-Instruct"
      ],
      docUrl: "https://weave-docs.wandb.ai/guides/integrations/inference/",
      gateway: "models.dev"
    },
    openai: {
      apiKeyEnvVar: "OPENAI_API_KEY",
      name: "OpenAI",
      models: [
        "codex-mini-latest",
        "gpt-3.5-turbo",
        "gpt-4",
        "gpt-4-turbo",
        "gpt-4.1",
        "gpt-4.1-mini",
        "gpt-4.1-nano",
        "gpt-4o",
        "gpt-4o-2024-05-13",
        "gpt-4o-2024-08-06",
        "gpt-4o-2024-11-20",
        "gpt-4o-mini",
        "gpt-5",
        "gpt-5-chat-latest",
        "gpt-5-codex",
        "gpt-5-mini",
        "gpt-5-nano",
        "gpt-5-pro",
        "gpt-5.1",
        "gpt-5.1-chat-latest",
        "gpt-5.1-codex",
        "gpt-5.1-codex-mini",
        "o1",
        "o1-mini",
        "o1-preview",
        "o1-pro",
        "o3",
        "o3-deep-research",
        "o3-mini",
        "o3-pro",
        "o4-mini",
        "o4-mini-deep-research",
        "text-embedding-3-large",
        "text-embedding-3-small",
        "text-embedding-ada-002"
      ],
      docUrl: "https://platform.openai.com/docs/models",
      gateway: "models.dev"
    },
    "zhipuai-coding-plan": {
      url: "https://open.bigmodel.cn/api/coding/paas/v4",
      apiKeyEnvVar: "ZHIPU_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Zhipu AI Coding Plan",
      models: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
      docUrl: "https://docs.bigmodel.cn/cn/coding-plan/overview",
      gateway: "models.dev"
    },
    perplexity: {
      url: "https://api.perplexity.ai",
      apiKeyEnvVar: "PERPLEXITY_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Perplexity",
      models: ["sonar", "sonar-pro", "sonar-reasoning", "sonar-reasoning-pro"],
      docUrl: "https://docs.perplexity.ai",
      gateway: "models.dev"
    },
    openrouter: {
      url: "https://openrouter.ai/api/v1",
      apiKeyEnvVar: "OPENROUTER_API_KEY",
      name: "OpenRouter",
      models: [
        "anthropic/claude-3.5-haiku",
        "anthropic/claude-3.7-sonnet",
        "anthropic/claude-haiku-4.5",
        "anthropic/claude-opus-4",
        "anthropic/claude-opus-4.1",
        "anthropic/claude-opus-4.5",
        "anthropic/claude-sonnet-4",
        "anthropic/claude-sonnet-4.5",
        "cognitivecomputations/dolphin3.0-mistral-24b",
        "cognitivecomputations/dolphin3.0-r1-mistral-24b",
        "deepseek/deepseek-chat-v3-0324",
        "deepseek/deepseek-chat-v3.1",
        "deepseek/deepseek-r1-0528-qwen3-8b:free",
        "deepseek/deepseek-r1-0528:free",
        "deepseek/deepseek-r1-distill-llama-70b",
        "deepseek/deepseek-r1-distill-qwen-14b",
        "deepseek/deepseek-r1:free",
        "deepseek/deepseek-v3-base:free",
        "deepseek/deepseek-v3.1-terminus",
        "deepseek/deepseek-v3.1-terminus:exacto",
        "featherless/qwerky-72b",
        "google/gemini-2.0-flash-001",
        "google/gemini-2.0-flash-exp:free",
        "google/gemini-2.5-flash",
        "google/gemini-2.5-flash-lite",
        "google/gemini-2.5-flash-lite-preview-09-2025",
        "google/gemini-2.5-flash-preview-09-2025",
        "google/gemini-2.5-pro",
        "google/gemini-2.5-pro-preview-05-06",
        "google/gemini-2.5-pro-preview-06-05",
        "google/gemini-3-pro-preview",
        "google/gemma-2-9b-it:free",
        "google/gemma-3-12b-it",
        "google/gemma-3-27b-it",
        "google/gemma-3n-e4b-it",
        "google/gemma-3n-e4b-it:free",
        "kwaipilot/kat-coder-pro:free",
        "meta-llama/llama-3.2-11b-vision-instruct",
        "meta-llama/llama-3.3-70b-instruct:free",
        "meta-llama/llama-4-scout:free",
        "microsoft/mai-ds-r1:free",
        "minimax/minimax-01",
        "minimax/minimax-m1",
        "minimax/minimax-m2",
        "mistralai/codestral-2508",
        "mistralai/devstral-medium-2507",
        "mistralai/devstral-small-2505",
        "mistralai/devstral-small-2505:free",
        "mistralai/devstral-small-2507",
        "mistralai/mistral-7b-instruct:free",
        "mistralai/mistral-medium-3",
        "mistralai/mistral-medium-3.1",
        "mistralai/mistral-nemo:free",
        "mistralai/mistral-small-3.1-24b-instruct",
        "mistralai/mistral-small-3.2-24b-instruct",
        "mistralai/mistral-small-3.2-24b-instruct:free",
        "moonshotai/kimi-dev-72b:free",
        "moonshotai/kimi-k2",
        "moonshotai/kimi-k2-0905",
        "moonshotai/kimi-k2-0905:exacto",
        "moonshotai/kimi-k2-thinking",
        "moonshotai/kimi-k2:free",
        "nousresearch/deephermes-3-llama-3-8b-preview",
        "nousresearch/hermes-4-405b",
        "nousresearch/hermes-4-70b",
        "nvidia/nemotron-nano-9b-v2",
        "openai/gpt-4.1",
        "openai/gpt-4.1-mini",
        "openai/gpt-4o-mini",
        "openai/gpt-5",
        "openai/gpt-5-chat",
        "openai/gpt-5-codex",
        "openai/gpt-5-image",
        "openai/gpt-5-mini",
        "openai/gpt-5-nano",
        "openai/gpt-5-pro",
        "openai/gpt-5.1",
        "openai/gpt-5.1-chat",
        "openai/gpt-5.1-codex",
        "openai/gpt-5.1-codex-mini",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-120b:exacto",
        "openai/gpt-oss-20b",
        "openai/gpt-oss-safeguard-20b",
        "openai/o4-mini",
        "qwen/qwen-2.5-coder-32b-instruct",
        "qwen/qwen2.5-vl-32b-instruct:free",
        "qwen/qwen2.5-vl-72b-instruct",
        "qwen/qwen2.5-vl-72b-instruct:free",
        "qwen/qwen3-14b:free",
        "qwen/qwen3-235b-a22b-07-25",
        "qwen/qwen3-235b-a22b-07-25:free",
        "qwen/qwen3-235b-a22b-thinking-2507",
        "qwen/qwen3-235b-a22b:free",
        "qwen/qwen3-30b-a3b-instruct-2507",
        "qwen/qwen3-30b-a3b-thinking-2507",
        "qwen/qwen3-30b-a3b:free",
        "qwen/qwen3-32b:free",
        "qwen/qwen3-8b:free",
        "qwen/qwen3-coder",
        "qwen/qwen3-coder-flash",
        "qwen/qwen3-coder:exacto",
        "qwen/qwen3-coder:free",
        "qwen/qwen3-max",
        "qwen/qwen3-next-80b-a3b-instruct",
        "qwen/qwen3-next-80b-a3b-thinking",
        "qwen/qwq-32b:free",
        "rekaai/reka-flash-3",
        "sarvamai/sarvam-m:free",
        "thudm/glm-z1-32b:free",
        "tngtech/deepseek-r1t2-chimera:free",
        "x-ai/grok-3",
        "x-ai/grok-3-beta",
        "x-ai/grok-3-mini",
        "x-ai/grok-3-mini-beta",
        "x-ai/grok-4",
        "x-ai/grok-4-fast",
        "x-ai/grok-4.1-fast",
        "x-ai/grok-code-fast-1",
        "z-ai/glm-4.5",
        "z-ai/glm-4.5-air",
        "z-ai/glm-4.5-air:free",
        "z-ai/glm-4.5v",
        "z-ai/glm-4.6",
        "z-ai/glm-4.6:exacto"
      ],
      docUrl: "https://openrouter.ai/models",
      gateway: "models.dev"
    },
    zenmux: {
      url: "https://zenmux.ai/api/v1",
      apiKeyEnvVar: "ZENMUX_API_KEY",
      apiKeyHeader: "Authorization",
      name: "ZenMux",
      models: [
        "anthropic/claude-haiku-4.5",
        "anthropic/claude-opus-4.1",
        "anthropic/claude-sonnet-4.5",
        "deepseek/deepseek-chat",
        "google/gemini-2.5-pro",
        "inclusionai/lint-1t",
        "inclusionai/ring-1t",
        "kuaishou/kat-coder-pro-v1",
        "minimax/minimax-m2",
        "moonshotai/kimi-k2-0905",
        "moonshotai/kimi-k2-thinking",
        "moonshotai/kimi-k2-thinking-turbo",
        "openai/gpt-5",
        "openai/gpt-5-codex",
        "qwen/qwen3-coder-plus",
        "x-ai/grok-4",
        "x-ai/grok-4-fast",
        "x-ai/grok-4-fast-non-reasoning",
        "x-ai/grok-code-fast-1",
        "z-ai/glm-4.5-air",
        "z-ai/glm-4.6"
      ],
      docUrl: "https://docs.zenmux.ai",
      gateway: "models.dev"
    },
    ovhcloud: {
      url: "https://oai.endpoints.kepler.ai.cloud.ovh.net/v1",
      apiKeyEnvVar: "OVHCLOUD_API_KEY",
      apiKeyHeader: "Authorization",
      name: "OVHcloud AI Endpoints",
      models: [
        "deepseek-r1-distill-llama-70b",
        "gpt-oss-120b",
        "gpt-oss-20b",
        "llama-3.1-8b-instruct",
        "llava-next-mistral-7b",
        "meta-llama-3_1-70b-instruct",
        "meta-llama-3_3-70b-instruct",
        "mistral-7b-instruct-v0.3",
        "mistral-nemo-instruct-2407",
        "mistral-small-3.2-24b-instruct-2506",
        "mixtral-8x7b-instruct-v0.1",
        "qwen2.5-coder-32b-instruct",
        "qwen2.5-vl-72b-instruct",
        "qwen3-32b",
        "qwen3-coder-30b-a3b-instruct"
      ],
      docUrl: "https://www.ovhcloud.com/en/public-cloud/ai-endpoints/catalog//",
      gateway: "models.dev"
    },
    iflowcn: {
      url: "https://apis.iflow.cn/v1",
      apiKeyEnvVar: "IFLOW_API_KEY",
      apiKeyHeader: "Authorization",
      name: "iFlow",
      models: [
        "deepseek-r1",
        "deepseek-v3",
        "deepseek-v3.1",
        "deepseek-v3.2",
        "glm-4.6",
        "kimi-k2",
        "kimi-k2-0905",
        "minimax-m2",
        "qwen3-235b",
        "qwen3-235b-a22b-instruct",
        "qwen3-235b-a22b-thinking-2507",
        "qwen3-32b",
        "qwen3-coder",
        "qwen3-coder-plus",
        "qwen3-max",
        "qwen3-max-preview",
        "qwen3-vl-plus",
        "tstars2.0"
      ],
      docUrl: "https://platform.iflow.cn/en/docs",
      gateway: "models.dev"
    },
    synthetic: {
      url: "https://api.synthetic.new/v1",
      apiKeyEnvVar: "SYNTHETIC_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Synthetic",
      models: [
        "hf:MiniMaxAI/MiniMax-M2",
        "hf:Qwen/Qwen2.5-Coder-32B-Instruct",
        "hf:Qwen/Qwen3-235B-A22B-Instruct-2507",
        "hf:Qwen/Qwen3-235B-A22B-Thinking-2507",
        "hf:Qwen/Qwen3-Coder-480B-A35B-Instruct",
        "hf:deepseek-ai/DeepSeek-R1",
        "hf:deepseek-ai/DeepSeek-R1-0528",
        "hf:deepseek-ai/DeepSeek-V3",
        "hf:deepseek-ai/DeepSeek-V3-0324",
        "hf:deepseek-ai/DeepSeek-V3.1",
        "hf:deepseek-ai/DeepSeek-V3.1-Terminus",
        "hf:meta-llama/Llama-3.1-405B-Instruct",
        "hf:meta-llama/Llama-3.1-70B-Instruct",
        "hf:meta-llama/Llama-3.1-8B-Instruct",
        "hf:meta-llama/Llama-3.3-70B-Instruct",
        "hf:meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
        "hf:meta-llama/Llama-4-Scout-17B-16E-Instruct",
        "hf:moonshotai/Kimi-K2-Instruct",
        "hf:moonshotai/Kimi-K2-Instruct-0905",
        "hf:moonshotai/Kimi-K2-Thinking",
        "hf:openai/gpt-oss-120b",
        "hf:zai-org/GLM-4.5",
        "hf:zai-org/GLM-4.6"
      ],
      docUrl: "https://synthetic.new/pricing",
      gateway: "models.dev"
    },
    deepinfra: {
      url: "https://api.deepinfra.com/v1/openai",
      apiKeyEnvVar: "DEEPINFRA_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Deep Infra",
      models: [
        "Qwen/Qwen3-Coder-480B-A35B-Instruct",
        "Qwen/Qwen3-Coder-480B-A35B-Instruct-Turbo",
        "moonshotai/Kimi-K2-Instruct",
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b",
        "zai-org/GLM-4.5"
      ],
      docUrl: "https://deepinfra.com/models",
      gateway: "models.dev"
    },
    zhipuai: {
      url: "https://open.bigmodel.cn/api/paas/v4",
      apiKeyEnvVar: "ZHIPU_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Zhipu AI",
      models: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
      docUrl: "https://docs.z.ai/guides/overview/pricing",
      gateway: "models.dev"
    },
    submodel: {
      url: "https://llm.submodel.ai/v1",
      apiKeyEnvVar: "SUBMODEL_INSTAGEN_ACCESS_KEY",
      apiKeyHeader: "Authorization",
      name: "submodel",
      models: [
        "Qwen/Qwen3-235B-A22B-Instruct-2507",
        "Qwen/Qwen3-235B-A22B-Thinking-2507",
        "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
        "deepseek-ai/DeepSeek-R1-0528",
        "deepseek-ai/DeepSeek-V3-0324",
        "deepseek-ai/DeepSeek-V3.1",
        "openai/gpt-oss-120b",
        "zai-org/GLM-4.5-Air",
        "zai-org/GLM-4.5-FP8"
      ],
      docUrl: "https://submodel.gitbook.io",
      gateway: "models.dev"
    },
    zai: {
      url: "https://api.z.ai/api/paas/v4",
      apiKeyEnvVar: "ZHIPU_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Z.AI",
      models: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
      docUrl: "https://docs.z.ai/guides/overview/pricing",
      gateway: "models.dev"
    },
    inference: {
      url: "https://inference.net/v1",
      apiKeyEnvVar: "INFERENCE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Inference",
      models: [
        "google/gemma-3",
        "meta/llama-3.1-8b-instruct",
        "meta/llama-3.2-11b-vision-instruct",
        "meta/llama-3.2-1b-instruct",
        "meta/llama-3.2-3b-instruct",
        "mistral/mistral-nemo-12b-instruct",
        "osmosis/osmosis-structure-0.6b",
        "qwen/qwen-2.5-7b-vision-instruct",
        "qwen/qwen3-embedding-4b"
      ],
      docUrl: "https://inference.net/models",
      gateway: "models.dev"
    },
    requesty: {
      url: "https://router.requesty.ai/v1",
      apiKeyEnvVar: "REQUESTY_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Requesty",
      models: [
        "anthropic/claude-3-7-sonnet",
        "anthropic/claude-haiku-4-5",
        "anthropic/claude-opus-4",
        "anthropic/claude-opus-4-1",
        "anthropic/claude-sonnet-4",
        "anthropic/claude-sonnet-4-5",
        "google/gemini-2.5-flash",
        "google/gemini-2.5-pro",
        "openai/gpt-4.1",
        "openai/gpt-4.1-mini",
        "openai/gpt-4o-mini",
        "openai/gpt-5",
        "openai/gpt-5-mini",
        "openai/gpt-5-nano",
        "openai/o4-mini",
        "xai/grok-4",
        "xai/grok-4-fast"
      ],
      docUrl: "https://requesty.ai/solution/llm-routing/models",
      gateway: "models.dev"
    },
    morph: {
      url: "https://api.morphllm.com/v1",
      apiKeyEnvVar: "MORPH_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Morph",
      models: ["auto", "morph-v3-fast", "morph-v3-large"],
      docUrl: "https://docs.morphllm.com/api-reference/introduction",
      gateway: "models.dev"
    },
    lmstudio: {
      url: "http://127.0.0.1:1234/v1",
      apiKeyEnvVar: "LMSTUDIO_API_KEY",
      apiKeyHeader: "Authorization",
      name: "LMStudio",
      models: ["openai/gpt-oss-20b", "qwen/qwen3-30b-a3b-2507", "qwen/qwen3-coder-30b"],
      docUrl: "https://lmstudio.ai/models",
      gateway: "models.dev"
    },
    anthropic: {
      apiKeyEnvVar: "ANTHROPIC_API_KEY",
      name: "Anthropic",
      models: [
        "claude-3-5-haiku-20241022",
        "claude-3-5-haiku-latest",
        "claude-3-5-sonnet-20240620",
        "claude-3-5-sonnet-20241022",
        "claude-3-7-sonnet-20250219",
        "claude-3-7-sonnet-latest",
        "claude-3-haiku-20240307",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "claude-haiku-4-5",
        "claude-haiku-4-5-20251001",
        "claude-opus-4-0",
        "claude-opus-4-1",
        "claude-opus-4-1-20250805",
        "claude-opus-4-20250514",
        "claude-opus-4-5",
        "claude-sonnet-4-0",
        "claude-sonnet-4-20250514",
        "claude-sonnet-4-5",
        "claude-sonnet-4-5-20250929"
      ],
      docUrl: "https://docs.anthropic.com/en/docs/about-claude/models",
      gateway: "models.dev"
    },
    "fireworks-ai": {
      url: "https://api.fireworks.ai/inference/v1/",
      apiKeyEnvVar: "FIREWORKS_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Fireworks AI",
      models: [
        "accounts/fireworks/models/deepseek-r1-0528",
        "accounts/fireworks/models/deepseek-v3-0324",
        "accounts/fireworks/models/deepseek-v3p1",
        "accounts/fireworks/models/glm-4p5",
        "accounts/fireworks/models/glm-4p5-air",
        "accounts/fireworks/models/gpt-oss-120b",
        "accounts/fireworks/models/gpt-oss-20b",
        "accounts/fireworks/models/kimi-k2-instruct",
        "accounts/fireworks/models/kimi-k2-thinking",
        "accounts/fireworks/models/minimax-m2",
        "accounts/fireworks/models/qwen3-235b-a22b",
        "accounts/fireworks/models/qwen3-coder-480b-a35b-instruct"
      ],
      docUrl: "https://fireworks.ai/docs/",
      gateway: "models.dev"
    },
    modelscope: {
      url: "https://api-inference.modelscope.cn/v1",
      apiKeyEnvVar: "MODELSCOPE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "ModelScope",
      models: [
        "Qwen/Qwen3-235B-A22B-Instruct-2507",
        "Qwen/Qwen3-235B-A22B-Thinking-2507",
        "Qwen/Qwen3-30B-A3B-Instruct-2507",
        "Qwen/Qwen3-30B-A3B-Thinking-2507",
        "Qwen/Qwen3-Coder-30B-A3B-Instruct",
        "ZhipuAI/GLM-4.5",
        "ZhipuAI/GLM-4.6"
      ],
      docUrl: "https://modelscope.cn/docs/model-service/API-Inference/intro",
      gateway: "models.dev"
    },
    llama: {
      url: "https://api.llama.com/compat/v1/",
      apiKeyEnvVar: "LLAMA_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Llama",
      models: [
        "cerebras-llama-4-maverick-17b-128e-instruct",
        "cerebras-llama-4-scout-17b-16e-instruct",
        "groq-llama-4-maverick-17b-128e-instruct",
        "llama-3.3-70b-instruct",
        "llama-3.3-8b-instruct",
        "llama-4-maverick-17b-128e-instruct-fp8",
        "llama-4-scout-17b-16e-instruct-fp8"
      ],
      docUrl: "https://llama.developer.meta.com/docs/models",
      gateway: "models.dev"
    },
    scaleway: {
      url: "https://api.scaleway.ai/v1",
      apiKeyEnvVar: "SCALEWAY_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Scaleway",
      models: [
        "bge-multilingual-gemma2",
        "deepseek-r1-distill-llama-70b",
        "gemma-3-27b-it",
        "gpt-oss-120b",
        "llama-3.1-8b-instruct",
        "llama-3.3-70b-instruct",
        "mistral-nemo-instruct-2407",
        "mistral-small-3.2-24b-instruct-2506",
        "pixtral-12b-2409",
        "qwen3-235b-a22b-instruct-2507",
        "qwen3-coder-30b-a3b-instruct",
        "voxtral-small-24b-2507",
        "whisper-large-v3"
      ],
      docUrl: "https://www.scaleway.com/en/docs/generative-apis/",
      gateway: "models.dev"
    },
    poe: {
      url: "https://api.poe.com/v1",
      apiKeyEnvVar: "POE_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Poe",
      models: [
        "anthropic/claude-haiku-3",
        "anthropic/claude-haiku-3.5",
        "anthropic/claude-haiku-3.5-search",
        "anthropic/claude-haiku-4.5",
        "anthropic/claude-opus-3",
        "anthropic/claude-opus-4",
        "anthropic/claude-opus-4-reasoning",
        "anthropic/claude-opus-4-search",
        "anthropic/claude-opus-4.1",
        "anthropic/claude-sonnet-3.5",
        "anthropic/claude-sonnet-3.5-june",
        "anthropic/claude-sonnet-3.7",
        "anthropic/claude-sonnet-3.7-reasoning",
        "anthropic/claude-sonnet-3.7-search",
        "anthropic/claude-sonnet-4",
        "anthropic/claude-sonnet-4-reasoning",
        "anthropic/claude-sonnet-4-search",
        "anthropic/claude-sonnet-4.5",
        "elevenlabs/elevenlabs-music",
        "elevenlabs/elevenlabs-v2.5-turbo",
        "elevenlabs/elevenlabs-v3",
        "facebook/llama-3.1-405b",
        "facebook/llama-3.1-70b",
        "facebook/llama-3.1-8b",
        "google/gemini-2.0-flash",
        "google/gemini-2.0-flash-lite",
        "google/gemini-2.5-flash",
        "google/gemini-2.5-flash-lite",
        "google/gemini-2.5-pro",
        "google/gemini-3.0-pro",
        "google/imagen-3",
        "google/imagen-3-fast",
        "google/imagen-4",
        "google/imagen-4-fast",
        "google/imagen-4-ultra",
        "google/lyria",
        "google/nano-banana",
        "google/veo-2",
        "google/veo-3",
        "google/veo-3-fast",
        "google/veo-3.1",
        "google/veo-3.1-fast",
        "ideogramai/ideogram",
        "ideogramai/ideogram-v2",
        "ideogramai/ideogram-v2a",
        "ideogramai/ideogram-v2a-turbo",
        "lumalabs/dream-machine",
        "lumalabs/ray2",
        "novita/glm-4.6",
        "openAi/chatgpt-4o-latest",
        "openAi/dall-e-3",
        "openAi/gpt-3.5-turbo",
        "openAi/gpt-3.5-turbo-instruct",
        "openAi/gpt-3.5-turbo-raw",
        "openAi/gpt-4-classic",
        "openAi/gpt-4-classic-0314",
        "openAi/gpt-4-turbo",
        "openAi/gpt-4.1",
        "openAi/gpt-4.1-mini",
        "openAi/gpt-4.1-nano",
        "openAi/gpt-4o",
        "openAi/gpt-4o-aug",
        "openAi/gpt-4o-mini",
        "openAi/gpt-4o-mini-search",
        "openAi/gpt-4o-search",
        "openAi/gpt-5",
        "openAi/gpt-5-chat",
        "openAi/gpt-5-codex",
        "openAi/gpt-5-mini",
        "openAi/gpt-5-nano",
        "openAi/gpt-5-pro",
        "openAi/gpt-image-1",
        "openAi/gpt-image-1-mini",
        "openAi/o1",
        "openAi/o1-pro",
        "openAi/o3",
        "openAi/o3-deep-research",
        "openAi/o3-mini",
        "openAi/o3-mini-high",
        "openAi/o3-pro",
        "openAi/o4-mini",
        "openAi/o4-mini-deep-research",
        "openAi/sora-2",
        "openAi/sora-2-pro",
        "openai/gpt-5.1",
        "openai/gpt-5.1-codex",
        "openai/gpt-5.1-codex-mini",
        "openai/gpt-5.1-instant",
        "runwayml/runway",
        "runwayml/runway-gen-4-turbo",
        "stabilityai/stablediffusionxl",
        "topazlabs-co/topazlabs",
        "trytako/tako",
        "xai/grok-2",
        "xai/grok-3",
        "xai/grok-3-mini",
        "xai/grok-4",
        "xai/grok-4-fast-non-reasoning",
        "xai/grok-4-fast-reasoning",
        "xai/grok-code-fast-1"
      ],
      docUrl: "https://creator.poe.com/docs/external-applications/openai-compatible-api",
      gateway: "models.dev"
    },
    cerebras: {
      url: "https://api.cerebras.ai/v1",
      apiKeyEnvVar: "CEREBRAS_API_KEY",
      apiKeyHeader: "Authorization",
      name: "Cerebras",
      models: ["gpt-oss-120b", "qwen-3-235b-a22b-instruct-2507", "zai-glm-4.6"],
      docUrl: "https://inference-docs.cerebras.ai/models/overview",
      gateway: "models.dev"
    },
    netlify: {
      apiKeyEnvVar: ["NETLIFY_TOKEN", "NETLIFY_SITE_ID"],
      apiKeyHeader: "Authorization",
      name: "Netlify",
      gateway: "netlify",
      models: [
        "anthropic/claude-3-5-haiku-20241022",
        "anthropic/claude-3-7-sonnet-20250219",
        "anthropic/claude-3-haiku-20240307",
        "anthropic/claude-haiku-4-5-20251001",
        "anthropic/claude-opus-4-1-20250805",
        "anthropic/claude-opus-4-20250514",
        "anthropic/claude-opus-4-5-20251101",
        "anthropic/claude-sonnet-4-20250514",
        "anthropic/claude-sonnet-4-5-20250929",
        "gemini/gemini-2.0-flash",
        "gemini/gemini-2.0-flash-lite",
        "gemini/gemini-2.5-flash",
        "gemini/gemini-2.5-flash-image",
        "gemini/gemini-2.5-flash-image-preview",
        "gemini/gemini-2.5-flash-lite",
        "gemini/gemini-2.5-flash-lite-preview-09-2025",
        "gemini/gemini-2.5-flash-preview-09-2025",
        "gemini/gemini-2.5-pro",
        "gemini/gemini-3-pro-image-preview",
        "gemini/gemini-3-pro-preview",
        "gemini/gemini-flash-latest",
        "gemini/gemini-flash-lite-latest",
        "openai/codex-mini-latest",
        "openai/gpt-4.1",
        "openai/gpt-4.1-mini",
        "openai/gpt-4.1-nano",
        "openai/gpt-4o",
        "openai/gpt-4o-mini",
        "openai/gpt-5",
        "openai/gpt-5-2025-08-07",
        "openai/gpt-5-codex",
        "openai/gpt-5-mini",
        "openai/gpt-5-mini-2025-08-07",
        "openai/gpt-5-nano",
        "openai/gpt-5-pro",
        "openai/gpt-5.1",
        "openai/gpt-5.1-2025-11-13",
        "openai/gpt-5.1-codex",
        "openai/gpt-5.1-codex-mini",
        "openai/o3",
        "openai/o3-mini",
        "openai/o4-mini"
      ],
      docUrl: "https://docs.netlify.com/build/ai-gateway/overview/"
    }
  },
  models: {
    "moonshotai-cn": [
      "kimi-k2-0711-preview",
      "kimi-k2-0905-preview",
      "kimi-k2-thinking",
      "kimi-k2-thinking-turbo",
      "kimi-k2-turbo-preview"
    ],
    lucidquery: ["lucidnova-rf1-100b", "lucidquery-nexus-coder"],
    moonshotai: [
      "kimi-k2-0711-preview",
      "kimi-k2-0905-preview",
      "kimi-k2-thinking",
      "kimi-k2-thinking-turbo",
      "kimi-k2-turbo-preview"
    ],
    "zai-coding-plan": ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
    alibaba: [
      "qvq-max",
      "qwen-flash",
      "qwen-max",
      "qwen-mt-plus",
      "qwen-mt-turbo",
      "qwen-omni-turbo",
      "qwen-omni-turbo-realtime",
      "qwen-plus",
      "qwen-plus-character-ja",
      "qwen-turbo",
      "qwen-vl-max",
      "qwen-vl-ocr",
      "qwen-vl-plus",
      "qwen2-5-14b-instruct",
      "qwen2-5-32b-instruct",
      "qwen2-5-72b-instruct",
      "qwen2-5-7b-instruct",
      "qwen2-5-omni-7b",
      "qwen2-5-vl-72b-instruct",
      "qwen2-5-vl-7b-instruct",
      "qwen3-14b",
      "qwen3-235b-a22b",
      "qwen3-32b",
      "qwen3-8b",
      "qwen3-asr-flash",
      "qwen3-coder-30b-a3b-instruct",
      "qwen3-coder-480b-a35b-instruct",
      "qwen3-coder-flash",
      "qwen3-coder-plus",
      "qwen3-livetranslate-flash-realtime",
      "qwen3-max",
      "qwen3-next-80b-a3b-instruct",
      "qwen3-next-80b-a3b-thinking",
      "qwen3-omni-flash",
      "qwen3-omni-flash-realtime",
      "qwen3-vl-235b-a22b",
      "qwen3-vl-30b-a3b",
      "qwen3-vl-plus",
      "qwq-plus"
    ],
    xai: [
      "grok-2",
      "grok-2-1212",
      "grok-2-latest",
      "grok-2-vision",
      "grok-2-vision-1212",
      "grok-2-vision-latest",
      "grok-3",
      "grok-3-fast",
      "grok-3-fast-latest",
      "grok-3-latest",
      "grok-3-mini",
      "grok-3-mini-fast",
      "grok-3-mini-fast-latest",
      "grok-3-mini-latest",
      "grok-4",
      "grok-4-1-fast",
      "grok-4-1-fast-non-reasoning",
      "grok-4-fast",
      "grok-4-fast-non-reasoning",
      "grok-beta",
      "grok-code-fast-1",
      "grok-vision-beta"
    ],
    vultr: [
      "deepseek-r1-distill-llama-70b",
      "deepseek-r1-distill-qwen-32b",
      "gpt-oss-120b",
      "kimi-k2-instruct",
      "qwen2.5-coder-32b-instruct"
    ],
    nvidia: [
      "black-forest-labs/flux.1-dev",
      "deepseek-ai/deepseek-v3.1",
      "deepseek-ai/deepseek-v3.1-terminus",
      "google/gemma-3-27b-it",
      "microsoft/phi-4-mini-instruct",
      "minimaxai/minimax-m2",
      "moonshotai/kimi-k2-instruct",
      "moonshotai/kimi-k2-instruct-0905",
      "nvidia/cosmos-nemotron-34b",
      "nvidia/llama-3.1-nemotron-ultra-253b-v1",
      "nvidia/llama-embed-nemotron-8b",
      "nvidia/nemoretriever-ocr-v1",
      "nvidia/nvidia-nemotron-nano-9b-v2",
      "nvidia/parakeet-tdt-0.6b-v2",
      "openai/gpt-oss-120b",
      "openai/whisper-large-v3",
      "qwen/qwen3-235b-a22b",
      "qwen/qwen3-coder-480b-a35b-instruct",
      "qwen/qwen3-next-80b-a3b-instruct",
      "qwen/qwen3-next-80b-a3b-thinking"
    ],
    upstage: ["solar-mini", "solar-pro2"],
    groq: [
      "deepseek-r1-distill-llama-70b",
      "gemma2-9b-it",
      "llama-3.1-8b-instant",
      "llama-3.3-70b-versatile",
      "llama-guard-3-8b",
      "llama3-70b-8192",
      "llama3-8b-8192",
      "meta-llama/llama-4-maverick-17b-128e-instruct",
      "meta-llama/llama-4-scout-17b-16e-instruct",
      "meta-llama/llama-guard-4-12b",
      "mistral-saba-24b",
      "moonshotai/kimi-k2-instruct",
      "moonshotai/kimi-k2-instruct-0905",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "qwen-qwq-32b",
      "qwen/qwen3-32b"
    ],
    mistral: [
      "codestral-latest",
      "devstral-medium-2507",
      "devstral-small-2505",
      "devstral-small-2507",
      "magistral-medium-latest",
      "magistral-small",
      "ministral-3b-latest",
      "ministral-8b-latest",
      "mistral-large-latest",
      "mistral-medium-2505",
      "mistral-medium-2508",
      "mistral-medium-latest",
      "mistral-nemo",
      "mistral-small-latest",
      "open-mistral-7b",
      "open-mixtral-8x22b",
      "open-mixtral-8x7b",
      "pixtral-12b",
      "pixtral-large-latest"
    ],
    vercel: [
      "alibaba/qwen3-coder-plus",
      "alibaba/qwen3-max",
      "alibaba/qwen3-next-80b-a3b-instruct",
      "alibaba/qwen3-next-80b-a3b-thinking",
      "alibaba/qwen3-vl-instruct",
      "alibaba/qwen3-vl-thinking",
      "amazon/nova-lite",
      "amazon/nova-micro",
      "amazon/nova-pro",
      "anthropic/claude-3-haiku",
      "anthropic/claude-3-opus",
      "anthropic/claude-3.5-haiku",
      "anthropic/claude-3.5-sonnet",
      "anthropic/claude-3.7-sonnet",
      "anthropic/claude-4-1-opus",
      "anthropic/claude-4-opus",
      "anthropic/claude-4-sonnet",
      "anthropic/claude-4.5-sonnet",
      "anthropic/claude-haiku-4.5",
      "anthropic/claude-opus-4.5",
      "deepseek/deepseek-r1",
      "deepseek/deepseek-r1-distill-llama-70b",
      "deepseek/deepseek-v3.1-terminus",
      "deepseek/deepseek-v3.2-exp",
      "deepseek/deepseek-v3.2-exp-thinking",
      "google/gemini-2.0-flash",
      "google/gemini-2.0-flash-lite",
      "google/gemini-2.5-flash",
      "google/gemini-2.5-flash-lite",
      "google/gemini-2.5-flash-lite-preview-09-2025",
      "google/gemini-2.5-flash-preview-09-2025",
      "google/gemini-2.5-pro",
      "google/gemini-3-pro-preview",
      "meta/llama-3.3-70b",
      "meta/llama-4-maverick",
      "meta/llama-4-scout",
      "minimax/minimax-m2",
      "mistral/codestral",
      "mistral/magistral-medium",
      "mistral/magistral-small",
      "mistral/ministral-3b",
      "mistral/ministral-8b",
      "mistral/mistral-large",
      "mistral/mistral-small",
      "mistral/mixtral-8x22b-instruct",
      "mistral/pixtral-12b",
      "mistral/pixtral-large",
      "moonshotai/kimi-k2",
      "morph/morph-v3-fast",
      "morph/morph-v3-large",
      "openai/gpt-4-turbo",
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/gpt-4.1-nano",
      "openai/gpt-4o",
      "openai/gpt-4o-mini",
      "openai/gpt-5",
      "openai/gpt-5-codex",
      "openai/gpt-5-mini",
      "openai/gpt-5-nano",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "openai/o1",
      "openai/o3",
      "openai/o3-mini",
      "openai/o4-mini",
      "perplexity/sonar",
      "perplexity/sonar-pro",
      "perplexity/sonar-reasoning",
      "perplexity/sonar-reasoning-pro",
      "vercel/v0-1.0-md",
      "vercel/v0-1.5-md",
      "xai/grok-2",
      "xai/grok-2-vision",
      "xai/grok-3",
      "xai/grok-3-fast",
      "xai/grok-3-mini",
      "xai/grok-3-mini-fast",
      "xai/grok-4",
      "xai/grok-4-fast",
      "xai/grok-4-fast-non-reasoning",
      "xai/grok-code-fast-1",
      "zai/glm-4.5",
      "zai/glm-4.5-air",
      "zai/glm-4.5v",
      "zai/glm-4.6"
    ],
    nebius: [
      "NousResearch/hermes-4-405b",
      "NousResearch/hermes-4-70b",
      "deepseek-ai/deepseek-v3",
      "meta-llama/llama-3.3-70b-instruct-base",
      "meta-llama/llama-3.3-70b-instruct-fast",
      "meta-llama/llama-3_1-405b-instruct",
      "moonshotai/kimi-k2-instruct",
      "nvidia/llama-3_1-nemotron-ultra-253b-v1",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "qwen/qwen3-235b-a22b-instruct-2507",
      "qwen/qwen3-235b-a22b-thinking-2507",
      "qwen/qwen3-coder-480b-a35b-instruct",
      "zai-org/glm-4.5",
      "zai-org/glm-4.5-air"
    ],
    deepseek: ["deepseek-chat", "deepseek-reasoner"],
    "alibaba-cn": [
      "deepseek-r1",
      "deepseek-r1-0528",
      "deepseek-r1-distill-llama-70b",
      "deepseek-r1-distill-llama-8b",
      "deepseek-r1-distill-qwen-1-5b",
      "deepseek-r1-distill-qwen-14b",
      "deepseek-r1-distill-qwen-32b",
      "deepseek-r1-distill-qwen-7b",
      "deepseek-v3",
      "deepseek-v3-1",
      "deepseek-v3-2-exp",
      "moonshot-kimi-k2-instruct",
      "qvq-max",
      "qwen-deep-research",
      "qwen-doc-turbo",
      "qwen-flash",
      "qwen-long",
      "qwen-math-plus",
      "qwen-math-turbo",
      "qwen-max",
      "qwen-mt-plus",
      "qwen-mt-turbo",
      "qwen-omni-turbo",
      "qwen-omni-turbo-realtime",
      "qwen-plus",
      "qwen-plus-character",
      "qwen-turbo",
      "qwen-vl-max",
      "qwen-vl-ocr",
      "qwen-vl-plus",
      "qwen2-5-14b-instruct",
      "qwen2-5-32b-instruct",
      "qwen2-5-72b-instruct",
      "qwen2-5-7b-instruct",
      "qwen2-5-coder-32b-instruct",
      "qwen2-5-coder-7b-instruct",
      "qwen2-5-math-72b-instruct",
      "qwen2-5-math-7b-instruct",
      "qwen2-5-omni-7b",
      "qwen2-5-vl-72b-instruct",
      "qwen2-5-vl-7b-instruct",
      "qwen3-14b",
      "qwen3-235b-a22b",
      "qwen3-32b",
      "qwen3-8b",
      "qwen3-asr-flash",
      "qwen3-coder-30b-a3b-instruct",
      "qwen3-coder-480b-a35b-instruct",
      "qwen3-coder-flash",
      "qwen3-coder-plus",
      "qwen3-max",
      "qwen3-next-80b-a3b-instruct",
      "qwen3-next-80b-a3b-thinking",
      "qwen3-omni-flash",
      "qwen3-omni-flash-realtime",
      "qwen3-vl-235b-a22b",
      "qwen3-vl-30b-a3b",
      "qwen3-vl-plus",
      "qwq-32b",
      "qwq-plus",
      "tongyi-intent-detect-v3"
    ],
    venice: [
      "deepseek-coder-v2-lite",
      "deepseek-r1-671b",
      "dolphin-2.9.2-qwen2-72b",
      "llama-3.1-405b",
      "llama-3.2-3b",
      "llama-3.3-70b",
      "mistral-31-24b",
      "qwen-2.5-coder-32b",
      "qwen-2.5-qwq-32b",
      "qwen-2.5-vl",
      "qwen3-235b",
      "qwen3-4b",
      "venice-uncensored",
      "zai-org-glm-4.6"
    ],
    chutes: [
      "Alibaba-NLP/Tongyi-DeepResearch-30B-A3B",
      "ArliAI/QwQ-32B-ArliAI-RpR-v1",
      "MiniMaxAI/MiniMax-M2",
      "NousResearch/DeepHermes-3-Mistral-24B-Preview",
      "NousResearch/Hermes-4-14B",
      "NousResearch/Hermes-4-405B-FP8",
      "NousResearch/Hermes-4-70B",
      "OpenGVLab/InternVL3-78B",
      "Qwen/Qwen2.5-72B-Instruct",
      "Qwen/Qwen2.5-Coder-32B-Instruct",
      "Qwen/Qwen2.5-VL-32B-Instruct",
      "Qwen/Qwen2.5-VL-72B-Instruct",
      "Qwen/Qwen3-14B",
      "Qwen/Qwen3-235B-A22B",
      "Qwen/Qwen3-235B-A22B-Instruct-2507",
      "Qwen/Qwen3-235B-A22B-Thinking-2507",
      "Qwen/Qwen3-30B-A3B",
      "Qwen/Qwen3-30B-A3B-Instruct-2507",
      "Qwen/Qwen3-32B",
      "Qwen/Qwen3-Coder-30B-A3B-Instruct",
      "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
      "Qwen/Qwen3-Next-80B-A3B-Instruct",
      "Qwen/Qwen3-VL-235B-A22B-Instruct",
      "Qwen/Qwen3-VL-235B-A22B-Thinking",
      "chutesai/Mistral-Small-3.1-24B-Instruct-2503",
      "chutesai/Mistral-Small-3.2-24B-Instruct-2506",
      "deepseek-ai/DeepSeek-R1",
      "deepseek-ai/DeepSeek-R1-0528",
      "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B",
      "deepseek-ai/DeepSeek-R1-Distill-Llama-70B",
      "deepseek-ai/DeepSeek-V3",
      "deepseek-ai/DeepSeek-V3-0324",
      "deepseek-ai/DeepSeek-V3.1",
      "deepseek-ai/DeepSeek-V3.1-Terminus",
      "deepseek-ai/DeepSeek-V3.2-Exp",
      "meituan-longcat/LongCat-Flash-Chat-FP8",
      "microsoft/MAI-DS-R1-FP8",
      "moonshotai/Kimi-K2-Instruct-0905",
      "moonshotai/Kimi-K2-Thinking",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "rednote-hilab/dots.ocr",
      "tngtech/DeepSeek-R1T-Chimera",
      "tngtech/DeepSeek-TNG-R1T2-Chimera",
      "unsloth/Mistral-Nemo-Instruct-2407",
      "unsloth/Mistral-Small-24B-Instruct-2501",
      "unsloth/gemma-3-12b-it",
      "unsloth/gemma-3-27b-it",
      "unsloth/gemma-3-4b-it",
      "zai-org/GLM-4.5",
      "zai-org/GLM-4.5-Air",
      "zai-org/GLM-4.6"
    ],
    cortecs: [
      "claude-4-5-sonnet",
      "claude-sonnet-4",
      "deepseek-v3-0324",
      "gemini-2.5-pro",
      "gpt-4.1",
      "gpt-oss-120b",
      "kimi-k2-instruct",
      "llama-3.1-405b-instruct",
      "nova-pro-v1",
      "qwen3-32b",
      "qwen3-coder-480b-a35b-instruct"
    ],
    "github-models": [
      "ai21-labs/ai21-jamba-1.5-large",
      "ai21-labs/ai21-jamba-1.5-mini",
      "cohere/cohere-command-a",
      "cohere/cohere-command-r",
      "cohere/cohere-command-r-08-2024",
      "cohere/cohere-command-r-plus",
      "cohere/cohere-command-r-plus-08-2024",
      "core42/jais-30b-chat",
      "deepseek/deepseek-r1",
      "deepseek/deepseek-r1-0528",
      "deepseek/deepseek-v3-0324",
      "meta/llama-3.2-11b-vision-instruct",
      "meta/llama-3.2-90b-vision-instruct",
      "meta/llama-3.3-70b-instruct",
      "meta/llama-4-maverick-17b-128e-instruct-fp8",
      "meta/llama-4-scout-17b-16e-instruct",
      "meta/meta-llama-3-70b-instruct",
      "meta/meta-llama-3-8b-instruct",
      "meta/meta-llama-3.1-405b-instruct",
      "meta/meta-llama-3.1-70b-instruct",
      "meta/meta-llama-3.1-8b-instruct",
      "microsoft/mai-ds-r1",
      "microsoft/phi-3-medium-128k-instruct",
      "microsoft/phi-3-medium-4k-instruct",
      "microsoft/phi-3-mini-128k-instruct",
      "microsoft/phi-3-mini-4k-instruct",
      "microsoft/phi-3-small-128k-instruct",
      "microsoft/phi-3-small-8k-instruct",
      "microsoft/phi-3.5-mini-instruct",
      "microsoft/phi-3.5-moe-instruct",
      "microsoft/phi-3.5-vision-instruct",
      "microsoft/phi-4",
      "microsoft/phi-4-mini-instruct",
      "microsoft/phi-4-mini-reasoning",
      "microsoft/phi-4-multimodal-instruct",
      "microsoft/phi-4-reasoning",
      "mistral-ai/codestral-2501",
      "mistral-ai/ministral-3b",
      "mistral-ai/mistral-large-2411",
      "mistral-ai/mistral-medium-2505",
      "mistral-ai/mistral-nemo",
      "mistral-ai/mistral-small-2503",
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/gpt-4.1-nano",
      "openai/gpt-4o",
      "openai/gpt-4o-mini",
      "openai/o1",
      "openai/o1-mini",
      "openai/o1-preview",
      "openai/o3",
      "openai/o3-mini",
      "openai/o4-mini",
      "xai/grok-3",
      "xai/grok-3-mini"
    ],
    togetherai: [
      "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
      "deepseek-ai/DeepSeek-R1",
      "deepseek-ai/DeepSeek-V3",
      "meta-llama/Llama-3.3-70B-Instruct-Turbo",
      "moonshotai/Kimi-K2-Instruct",
      "openai/gpt-oss-120b"
    ],
    baseten: [
      "Qwen/Qwen3-Coder-480B-A35B-Instruct",
      "moonshotai/Kimi-K2-Instruct-0905",
      "moonshotai/Kimi-K2-Thinking",
      "zai-org/GLM-4.6"
    ],
    siliconflow: [
      "baidu-ernie-4.5-300b-a47b",
      "bytedance-seed-seed-oss-36b-instruct",
      "deepseek-ai-deepseek-r1",
      "deepseek-ai-deepseek-r1-distill-qwen-14b",
      "deepseek-ai-deepseek-r1-distill-qwen-32b",
      "deepseek-ai-deepseek-r1-distill-qwen-7b",
      "deepseek-ai-deepseek-v3",
      "deepseek-ai-deepseek-v3.1",
      "deepseek-ai-deepseek-v3.1-terminus",
      "deepseek-ai-deepseek-v3.2-exp",
      "deepseek-ai-deepseek-vl2",
      "inclusionai-ling-flash-2.0",
      "inclusionai-ling-mini-2.0",
      "inclusionai-ring-flash-2.0",
      "meta-llama-meta-llama-3.1-8b-instruct",
      "minimaxai-minimax-m1-80k",
      "minimaxai-minimax-m2",
      "moonshotai-kimi-dev-72b",
      "moonshotai-kimi-k2-instruct",
      "moonshotai-kimi-k2-instruct-0905",
      "moonshotai-kimi-k2-thinking",
      "nex-agi-deepseek-v3.1-nex-n1",
      "openai-gpt-oss-120b",
      "openai-gpt-oss-20b",
      "qwen-qwen2.5-14b-instruct",
      "qwen-qwen2.5-32b-instruct",
      "qwen-qwen2.5-72b-instruct",
      "qwen-qwen2.5-72b-instruct-128k",
      "qwen-qwen2.5-7b-instruct",
      "qwen-qwen2.5-coder-32b-instruct",
      "qwen-qwen2.5-vl-32b-instruct",
      "qwen-qwen2.5-vl-72b-instruct",
      "qwen-qwen2.5-vl-7b-instruct",
      "qwen-qwen3-14b",
      "qwen-qwen3-235b-a22b",
      "qwen-qwen3-235b-a22b-instruct-2507",
      "qwen-qwen3-235b-a22b-thinking-2507",
      "qwen-qwen3-30b-a3b",
      "qwen-qwen3-30b-a3b-instruct-2507",
      "qwen-qwen3-30b-a3b-thinking-2507",
      "qwen-qwen3-32b",
      "qwen-qwen3-8b",
      "qwen-qwen3-coder-30b-a3b-instruct",
      "qwen-qwen3-coder-480b-a35b-instruct",
      "qwen-qwen3-next-80b-a3b-instruct",
      "qwen-qwen3-next-80b-a3b-thinking",
      "qwen-qwen3-omni-30b-a3b-captioner",
      "qwen-qwen3-omni-30b-a3b-instruct",
      "qwen-qwen3-omni-30b-a3b-thinking",
      "qwen-qwen3-vl-235b-a22b-instruct",
      "qwen-qwen3-vl-235b-a22b-thinking",
      "qwen-qwen3-vl-30b-a3b-instruct",
      "qwen-qwen3-vl-30b-a3b-thinking",
      "qwen-qwen3-vl-32b-instruct",
      "qwen-qwen3-vl-32b-thinking",
      "qwen-qwen3-vl-8b-instruct",
      "qwen-qwen3-vl-8b-thinking",
      "qwen-qwq-32b",
      "stepfun-ai-step3",
      "tencent-hunyuan-a13b-instruct",
      "tencent-hunyuan-mt-7b",
      "thudm-glm-4-32b-0414",
      "thudm-glm-4-9b-0414",
      "thudm-glm-4.1v-9b-thinking",
      "thudm-glm-z1-32b-0414",
      "thudm-glm-z1-9b-0414",
      "z-ai-glm-4.5",
      "z-ai-glm-4.5-air",
      "zai-org-glm-4.5",
      "zai-org-glm-4.5-air",
      "zai-org-glm-4.5v",
      "zai-org-glm-4.6"
    ],
    huggingface: [
      "MiniMaxAI/MiniMax-M2",
      "Qwen/Qwen3-235B-A22B-Thinking-2507",
      "Qwen/Qwen3-Coder-480B-A35B-Instruct",
      "Qwen/Qwen3-Embedding-4B",
      "Qwen/Qwen3-Embedding-8B",
      "Qwen/Qwen3-Next-80B-A3B-Instruct",
      "Qwen/Qwen3-Next-80B-A3B-Thinking",
      "deepseek-ai/DeepSeek-R1-0528",
      "deepseek-ai/Deepseek-V3-0324",
      "moonshotai/Kimi-K2-Instruct",
      "moonshotai/Kimi-K2-Instruct-0905",
      "zai-org/GLM-4.5",
      "zai-org/GLM-4.5-Air",
      "zai-org/GLM-4.6"
    ],
    opencode: [
      "alpha-doubao-seed-code",
      "alpha-gd4",
      "alpha-minimax-m2",
      "big-pickle",
      "claude-3-5-haiku",
      "claude-haiku-4-5",
      "claude-opus-4-1",
      "claude-opus-4-5",
      "claude-sonnet-4",
      "claude-sonnet-4-5",
      "gemini-3-pro",
      "glm-4.6",
      "gpt-5",
      "gpt-5-codex",
      "gpt-5-nano",
      "gpt-5.1",
      "gpt-5.1-codex",
      "grok-code",
      "kimi-k2",
      "kimi-k2-thinking",
      "qwen3-coder"
    ],
    fastrouter: [
      "anthropic/claude-opus-4.1",
      "anthropic/claude-sonnet-4",
      "deepseek-ai/deepseek-r1-distill-llama-70b",
      "google/gemini-2.5-flash",
      "google/gemini-2.5-pro",
      "moonshotai/kimi-k2",
      "openai/gpt-4.1",
      "openai/gpt-5",
      "openai/gpt-5-mini",
      "openai/gpt-5-nano",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "qwen/qwen3-coder",
      "x-ai/grok-4"
    ],
    minimax: ["MiniMax-M2"],
    google: [
      "gemini-1.5-flash",
      "gemini-1.5-flash-8b",
      "gemini-1.5-pro",
      "gemini-2.0-flash",
      "gemini-2.0-flash-lite",
      "gemini-2.5-flash",
      "gemini-2.5-flash-image",
      "gemini-2.5-flash-image-preview",
      "gemini-2.5-flash-lite",
      "gemini-2.5-flash-lite-preview-06-17",
      "gemini-2.5-flash-lite-preview-09-2025",
      "gemini-2.5-flash-preview-04-17",
      "gemini-2.5-flash-preview-05-20",
      "gemini-2.5-flash-preview-09-2025",
      "gemini-2.5-flash-preview-tts",
      "gemini-2.5-pro",
      "gemini-2.5-pro-preview-05-06",
      "gemini-2.5-pro-preview-06-05",
      "gemini-2.5-pro-preview-tts",
      "gemini-3-pro-preview",
      "gemini-embedding-001",
      "gemini-flash-latest",
      "gemini-flash-lite-latest",
      "gemini-live-2.5-flash",
      "gemini-live-2.5-flash-preview-native-audio"
    ],
    inception: ["mercury", "mercury-coder"],
    wandb: [
      "Qwen/Qwen3-235B-A22B-Instruct-2507",
      "Qwen/Qwen3-235B-A22B-Thinking-2507",
      "Qwen/Qwen3-Coder-480B-A35B-Instruct",
      "deepseek-ai/DeepSeek-R1-0528",
      "deepseek-ai/DeepSeek-V3-0324",
      "meta-llama/Llama-3.1-8B-Instruct",
      "meta-llama/Llama-3.3-70B-Instruct",
      "meta-llama/Llama-4-Scout-17B-16E-Instruct",
      "microsoft/Phi-4-mini-instruct",
      "moonshotai/Kimi-K2-Instruct"
    ],
    openai: [
      "codex-mini-latest",
      "gpt-3.5-turbo",
      "gpt-4",
      "gpt-4-turbo",
      "gpt-4.1",
      "gpt-4.1-mini",
      "gpt-4.1-nano",
      "gpt-4o",
      "gpt-4o-2024-05-13",
      "gpt-4o-2024-08-06",
      "gpt-4o-2024-11-20",
      "gpt-4o-mini",
      "gpt-5",
      "gpt-5-chat-latest",
      "gpt-5-codex",
      "gpt-5-mini",
      "gpt-5-nano",
      "gpt-5-pro",
      "gpt-5.1",
      "gpt-5.1-chat-latest",
      "gpt-5.1-codex",
      "gpt-5.1-codex-mini",
      "o1",
      "o1-mini",
      "o1-preview",
      "o1-pro",
      "o3",
      "o3-deep-research",
      "o3-mini",
      "o3-pro",
      "o4-mini",
      "o4-mini-deep-research",
      "text-embedding-3-large",
      "text-embedding-3-small",
      "text-embedding-ada-002"
    ],
    "zhipuai-coding-plan": ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
    perplexity: ["sonar", "sonar-pro", "sonar-reasoning", "sonar-reasoning-pro"],
    openrouter: [
      "anthropic/claude-3.5-haiku",
      "anthropic/claude-3.7-sonnet",
      "anthropic/claude-haiku-4.5",
      "anthropic/claude-opus-4",
      "anthropic/claude-opus-4.1",
      "anthropic/claude-opus-4.5",
      "anthropic/claude-sonnet-4",
      "anthropic/claude-sonnet-4.5",
      "cognitivecomputations/dolphin3.0-mistral-24b",
      "cognitivecomputations/dolphin3.0-r1-mistral-24b",
      "deepseek/deepseek-chat-v3-0324",
      "deepseek/deepseek-chat-v3.1",
      "deepseek/deepseek-r1-0528-qwen3-8b:free",
      "deepseek/deepseek-r1-0528:free",
      "deepseek/deepseek-r1-distill-llama-70b",
      "deepseek/deepseek-r1-distill-qwen-14b",
      "deepseek/deepseek-r1:free",
      "deepseek/deepseek-v3-base:free",
      "deepseek/deepseek-v3.1-terminus",
      "deepseek/deepseek-v3.1-terminus:exacto",
      "featherless/qwerky-72b",
      "google/gemini-2.0-flash-001",
      "google/gemini-2.0-flash-exp:free",
      "google/gemini-2.5-flash",
      "google/gemini-2.5-flash-lite",
      "google/gemini-2.5-flash-lite-preview-09-2025",
      "google/gemini-2.5-flash-preview-09-2025",
      "google/gemini-2.5-pro",
      "google/gemini-2.5-pro-preview-05-06",
      "google/gemini-2.5-pro-preview-06-05",
      "google/gemini-3-pro-preview",
      "google/gemma-2-9b-it:free",
      "google/gemma-3-12b-it",
      "google/gemma-3-27b-it",
      "google/gemma-3n-e4b-it",
      "google/gemma-3n-e4b-it:free",
      "kwaipilot/kat-coder-pro:free",
      "meta-llama/llama-3.2-11b-vision-instruct",
      "meta-llama/llama-3.3-70b-instruct:free",
      "meta-llama/llama-4-scout:free",
      "microsoft/mai-ds-r1:free",
      "minimax/minimax-01",
      "minimax/minimax-m1",
      "minimax/minimax-m2",
      "mistralai/codestral-2508",
      "mistralai/devstral-medium-2507",
      "mistralai/devstral-small-2505",
      "mistralai/devstral-small-2505:free",
      "mistralai/devstral-small-2507",
      "mistralai/mistral-7b-instruct:free",
      "mistralai/mistral-medium-3",
      "mistralai/mistral-medium-3.1",
      "mistralai/mistral-nemo:free",
      "mistralai/mistral-small-3.1-24b-instruct",
      "mistralai/mistral-small-3.2-24b-instruct",
      "mistralai/mistral-small-3.2-24b-instruct:free",
      "moonshotai/kimi-dev-72b:free",
      "moonshotai/kimi-k2",
      "moonshotai/kimi-k2-0905",
      "moonshotai/kimi-k2-0905:exacto",
      "moonshotai/kimi-k2-thinking",
      "moonshotai/kimi-k2:free",
      "nousresearch/deephermes-3-llama-3-8b-preview",
      "nousresearch/hermes-4-405b",
      "nousresearch/hermes-4-70b",
      "nvidia/nemotron-nano-9b-v2",
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/gpt-4o-mini",
      "openai/gpt-5",
      "openai/gpt-5-chat",
      "openai/gpt-5-codex",
      "openai/gpt-5-image",
      "openai/gpt-5-mini",
      "openai/gpt-5-nano",
      "openai/gpt-5-pro",
      "openai/gpt-5.1",
      "openai/gpt-5.1-chat",
      "openai/gpt-5.1-codex",
      "openai/gpt-5.1-codex-mini",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-120b:exacto",
      "openai/gpt-oss-20b",
      "openai/gpt-oss-safeguard-20b",
      "openai/o4-mini",
      "qwen/qwen-2.5-coder-32b-instruct",
      "qwen/qwen2.5-vl-32b-instruct:free",
      "qwen/qwen2.5-vl-72b-instruct",
      "qwen/qwen2.5-vl-72b-instruct:free",
      "qwen/qwen3-14b:free",
      "qwen/qwen3-235b-a22b-07-25",
      "qwen/qwen3-235b-a22b-07-25:free",
      "qwen/qwen3-235b-a22b-thinking-2507",
      "qwen/qwen3-235b-a22b:free",
      "qwen/qwen3-30b-a3b-instruct-2507",
      "qwen/qwen3-30b-a3b-thinking-2507",
      "qwen/qwen3-30b-a3b:free",
      "qwen/qwen3-32b:free",
      "qwen/qwen3-8b:free",
      "qwen/qwen3-coder",
      "qwen/qwen3-coder-flash",
      "qwen/qwen3-coder:exacto",
      "qwen/qwen3-coder:free",
      "qwen/qwen3-max",
      "qwen/qwen3-next-80b-a3b-instruct",
      "qwen/qwen3-next-80b-a3b-thinking",
      "qwen/qwq-32b:free",
      "rekaai/reka-flash-3",
      "sarvamai/sarvam-m:free",
      "thudm/glm-z1-32b:free",
      "tngtech/deepseek-r1t2-chimera:free",
      "x-ai/grok-3",
      "x-ai/grok-3-beta",
      "x-ai/grok-3-mini",
      "x-ai/grok-3-mini-beta",
      "x-ai/grok-4",
      "x-ai/grok-4-fast",
      "x-ai/grok-4.1-fast",
      "x-ai/grok-code-fast-1",
      "z-ai/glm-4.5",
      "z-ai/glm-4.5-air",
      "z-ai/glm-4.5-air:free",
      "z-ai/glm-4.5v",
      "z-ai/glm-4.6",
      "z-ai/glm-4.6:exacto"
    ],
    zenmux: [
      "anthropic/claude-haiku-4.5",
      "anthropic/claude-opus-4.1",
      "anthropic/claude-sonnet-4.5",
      "deepseek/deepseek-chat",
      "google/gemini-2.5-pro",
      "inclusionai/lint-1t",
      "inclusionai/ring-1t",
      "kuaishou/kat-coder-pro-v1",
      "minimax/minimax-m2",
      "moonshotai/kimi-k2-0905",
      "moonshotai/kimi-k2-thinking",
      "moonshotai/kimi-k2-thinking-turbo",
      "openai/gpt-5",
      "openai/gpt-5-codex",
      "qwen/qwen3-coder-plus",
      "x-ai/grok-4",
      "x-ai/grok-4-fast",
      "x-ai/grok-4-fast-non-reasoning",
      "x-ai/grok-code-fast-1",
      "z-ai/glm-4.5-air",
      "z-ai/glm-4.6"
    ],
    ovhcloud: [
      "deepseek-r1-distill-llama-70b",
      "gpt-oss-120b",
      "gpt-oss-20b",
      "llama-3.1-8b-instruct",
      "llava-next-mistral-7b",
      "meta-llama-3_1-70b-instruct",
      "meta-llama-3_3-70b-instruct",
      "mistral-7b-instruct-v0.3",
      "mistral-nemo-instruct-2407",
      "mistral-small-3.2-24b-instruct-2506",
      "mixtral-8x7b-instruct-v0.1",
      "qwen2.5-coder-32b-instruct",
      "qwen2.5-vl-72b-instruct",
      "qwen3-32b",
      "qwen3-coder-30b-a3b-instruct"
    ],
    iflowcn: [
      "deepseek-r1",
      "deepseek-v3",
      "deepseek-v3.1",
      "deepseek-v3.2",
      "glm-4.6",
      "kimi-k2",
      "kimi-k2-0905",
      "minimax-m2",
      "qwen3-235b",
      "qwen3-235b-a22b-instruct",
      "qwen3-235b-a22b-thinking-2507",
      "qwen3-32b",
      "qwen3-coder",
      "qwen3-coder-plus",
      "qwen3-max",
      "qwen3-max-preview",
      "qwen3-vl-plus",
      "tstars2.0"
    ],
    synthetic: [
      "hf:MiniMaxAI/MiniMax-M2",
      "hf:Qwen/Qwen2.5-Coder-32B-Instruct",
      "hf:Qwen/Qwen3-235B-A22B-Instruct-2507",
      "hf:Qwen/Qwen3-235B-A22B-Thinking-2507",
      "hf:Qwen/Qwen3-Coder-480B-A35B-Instruct",
      "hf:deepseek-ai/DeepSeek-R1",
      "hf:deepseek-ai/DeepSeek-R1-0528",
      "hf:deepseek-ai/DeepSeek-V3",
      "hf:deepseek-ai/DeepSeek-V3-0324",
      "hf:deepseek-ai/DeepSeek-V3.1",
      "hf:deepseek-ai/DeepSeek-V3.1-Terminus",
      "hf:meta-llama/Llama-3.1-405B-Instruct",
      "hf:meta-llama/Llama-3.1-70B-Instruct",
      "hf:meta-llama/Llama-3.1-8B-Instruct",
      "hf:meta-llama/Llama-3.3-70B-Instruct",
      "hf:meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
      "hf:meta-llama/Llama-4-Scout-17B-16E-Instruct",
      "hf:moonshotai/Kimi-K2-Instruct",
      "hf:moonshotai/Kimi-K2-Instruct-0905",
      "hf:moonshotai/Kimi-K2-Thinking",
      "hf:openai/gpt-oss-120b",
      "hf:zai-org/GLM-4.5",
      "hf:zai-org/GLM-4.6"
    ],
    deepinfra: [
      "Qwen/Qwen3-Coder-480B-A35B-Instruct",
      "Qwen/Qwen3-Coder-480B-A35B-Instruct-Turbo",
      "moonshotai/Kimi-K2-Instruct",
      "openai/gpt-oss-120b",
      "openai/gpt-oss-20b",
      "zai-org/GLM-4.5"
    ],
    zhipuai: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
    submodel: [
      "Qwen/Qwen3-235B-A22B-Instruct-2507",
      "Qwen/Qwen3-235B-A22B-Thinking-2507",
      "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8",
      "deepseek-ai/DeepSeek-R1-0528",
      "deepseek-ai/DeepSeek-V3-0324",
      "deepseek-ai/DeepSeek-V3.1",
      "openai/gpt-oss-120b",
      "zai-org/GLM-4.5-Air",
      "zai-org/GLM-4.5-FP8"
    ],
    zai: ["glm-4.5", "glm-4.5-air", "glm-4.5-flash", "glm-4.5v", "glm-4.6"],
    inference: [
      "google/gemma-3",
      "meta/llama-3.1-8b-instruct",
      "meta/llama-3.2-11b-vision-instruct",
      "meta/llama-3.2-1b-instruct",
      "meta/llama-3.2-3b-instruct",
      "mistral/mistral-nemo-12b-instruct",
      "osmosis/osmosis-structure-0.6b",
      "qwen/qwen-2.5-7b-vision-instruct",
      "qwen/qwen3-embedding-4b"
    ],
    requesty: [
      "anthropic/claude-3-7-sonnet",
      "anthropic/claude-haiku-4-5",
      "anthropic/claude-opus-4",
      "anthropic/claude-opus-4-1",
      "anthropic/claude-sonnet-4",
      "anthropic/claude-sonnet-4-5",
      "google/gemini-2.5-flash",
      "google/gemini-2.5-pro",
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/gpt-4o-mini",
      "openai/gpt-5",
      "openai/gpt-5-mini",
      "openai/gpt-5-nano",
      "openai/o4-mini",
      "xai/grok-4",
      "xai/grok-4-fast"
    ],
    morph: ["auto", "morph-v3-fast", "morph-v3-large"],
    lmstudio: ["openai/gpt-oss-20b", "qwen/qwen3-30b-a3b-2507", "qwen/qwen3-coder-30b"],
    anthropic: [
      "claude-3-5-haiku-20241022",
      "claude-3-5-haiku-latest",
      "claude-3-5-sonnet-20240620",
      "claude-3-5-sonnet-20241022",
      "claude-3-7-sonnet-20250219",
      "claude-3-7-sonnet-latest",
      "claude-3-haiku-20240307",
      "claude-3-opus-20240229",
      "claude-3-sonnet-20240229",
      "claude-haiku-4-5",
      "claude-haiku-4-5-20251001",
      "claude-opus-4-0",
      "claude-opus-4-1",
      "claude-opus-4-1-20250805",
      "claude-opus-4-20250514",
      "claude-opus-4-5",
      "claude-sonnet-4-0",
      "claude-sonnet-4-20250514",
      "claude-sonnet-4-5",
      "claude-sonnet-4-5-20250929"
    ],
    "fireworks-ai": [
      "accounts/fireworks/models/deepseek-r1-0528",
      "accounts/fireworks/models/deepseek-v3-0324",
      "accounts/fireworks/models/deepseek-v3p1",
      "accounts/fireworks/models/glm-4p5",
      "accounts/fireworks/models/glm-4p5-air",
      "accounts/fireworks/models/gpt-oss-120b",
      "accounts/fireworks/models/gpt-oss-20b",
      "accounts/fireworks/models/kimi-k2-instruct",
      "accounts/fireworks/models/kimi-k2-thinking",
      "accounts/fireworks/models/minimax-m2",
      "accounts/fireworks/models/qwen3-235b-a22b",
      "accounts/fireworks/models/qwen3-coder-480b-a35b-instruct"
    ],
    modelscope: [
      "Qwen/Qwen3-235B-A22B-Instruct-2507",
      "Qwen/Qwen3-235B-A22B-Thinking-2507",
      "Qwen/Qwen3-30B-A3B-Instruct-2507",
      "Qwen/Qwen3-30B-A3B-Thinking-2507",
      "Qwen/Qwen3-Coder-30B-A3B-Instruct",
      "ZhipuAI/GLM-4.5",
      "ZhipuAI/GLM-4.6"
    ],
    llama: [
      "cerebras-llama-4-maverick-17b-128e-instruct",
      "cerebras-llama-4-scout-17b-16e-instruct",
      "groq-llama-4-maverick-17b-128e-instruct",
      "llama-3.3-70b-instruct",
      "llama-3.3-8b-instruct",
      "llama-4-maverick-17b-128e-instruct-fp8",
      "llama-4-scout-17b-16e-instruct-fp8"
    ],
    scaleway: [
      "bge-multilingual-gemma2",
      "deepseek-r1-distill-llama-70b",
      "gemma-3-27b-it",
      "gpt-oss-120b",
      "llama-3.1-8b-instruct",
      "llama-3.3-70b-instruct",
      "mistral-nemo-instruct-2407",
      "mistral-small-3.2-24b-instruct-2506",
      "pixtral-12b-2409",
      "qwen3-235b-a22b-instruct-2507",
      "qwen3-coder-30b-a3b-instruct",
      "voxtral-small-24b-2507",
      "whisper-large-v3"
    ],
    poe: [
      "anthropic/claude-haiku-3",
      "anthropic/claude-haiku-3.5",
      "anthropic/claude-haiku-3.5-search",
      "anthropic/claude-haiku-4.5",
      "anthropic/claude-opus-3",
      "anthropic/claude-opus-4",
      "anthropic/claude-opus-4-reasoning",
      "anthropic/claude-opus-4-search",
      "anthropic/claude-opus-4.1",
      "anthropic/claude-sonnet-3.5",
      "anthropic/claude-sonnet-3.5-june",
      "anthropic/claude-sonnet-3.7",
      "anthropic/claude-sonnet-3.7-reasoning",
      "anthropic/claude-sonnet-3.7-search",
      "anthropic/claude-sonnet-4",
      "anthropic/claude-sonnet-4-reasoning",
      "anthropic/claude-sonnet-4-search",
      "anthropic/claude-sonnet-4.5",
      "elevenlabs/elevenlabs-music",
      "elevenlabs/elevenlabs-v2.5-turbo",
      "elevenlabs/elevenlabs-v3",
      "facebook/llama-3.1-405b",
      "facebook/llama-3.1-70b",
      "facebook/llama-3.1-8b",
      "google/gemini-2.0-flash",
      "google/gemini-2.0-flash-lite",
      "google/gemini-2.5-flash",
      "google/gemini-2.5-flash-lite",
      "google/gemini-2.5-pro",
      "google/gemini-3.0-pro",
      "google/imagen-3",
      "google/imagen-3-fast",
      "google/imagen-4",
      "google/imagen-4-fast",
      "google/imagen-4-ultra",
      "google/lyria",
      "google/nano-banana",
      "google/veo-2",
      "google/veo-3",
      "google/veo-3-fast",
      "google/veo-3.1",
      "google/veo-3.1-fast",
      "ideogramai/ideogram",
      "ideogramai/ideogram-v2",
      "ideogramai/ideogram-v2a",
      "ideogramai/ideogram-v2a-turbo",
      "lumalabs/dream-machine",
      "lumalabs/ray2",
      "novita/glm-4.6",
      "openAi/chatgpt-4o-latest",
      "openAi/dall-e-3",
      "openAi/gpt-3.5-turbo",
      "openAi/gpt-3.5-turbo-instruct",
      "openAi/gpt-3.5-turbo-raw",
      "openAi/gpt-4-classic",
      "openAi/gpt-4-classic-0314",
      "openAi/gpt-4-turbo",
      "openAi/gpt-4.1",
      "openAi/gpt-4.1-mini",
      "openAi/gpt-4.1-nano",
      "openAi/gpt-4o",
      "openAi/gpt-4o-aug",
      "openAi/gpt-4o-mini",
      "openAi/gpt-4o-mini-search",
      "openAi/gpt-4o-search",
      "openAi/gpt-5",
      "openAi/gpt-5-chat",
      "openAi/gpt-5-codex",
      "openAi/gpt-5-mini",
      "openAi/gpt-5-nano",
      "openAi/gpt-5-pro",
      "openAi/gpt-image-1",
      "openAi/gpt-image-1-mini",
      "openAi/o1",
      "openAi/o1-pro",
      "openAi/o3",
      "openAi/o3-deep-research",
      "openAi/o3-mini",
      "openAi/o3-mini-high",
      "openAi/o3-pro",
      "openAi/o4-mini",
      "openAi/o4-mini-deep-research",
      "openAi/sora-2",
      "openAi/sora-2-pro",
      "openai/gpt-5.1",
      "openai/gpt-5.1-codex",
      "openai/gpt-5.1-codex-mini",
      "openai/gpt-5.1-instant",
      "runwayml/runway",
      "runwayml/runway-gen-4-turbo",
      "stabilityai/stablediffusionxl",
      "topazlabs-co/topazlabs",
      "trytako/tako",
      "xai/grok-2",
      "xai/grok-3",
      "xai/grok-3-mini",
      "xai/grok-4",
      "xai/grok-4-fast-non-reasoning",
      "xai/grok-4-fast-reasoning",
      "xai/grok-code-fast-1"
    ],
    cerebras: ["gpt-oss-120b", "qwen-3-235b-a22b-instruct-2507", "zai-glm-4.6"],
    netlify: [
      "anthropic/claude-3-5-haiku-20241022",
      "anthropic/claude-3-7-sonnet-20250219",
      "anthropic/claude-3-haiku-20240307",
      "anthropic/claude-haiku-4-5-20251001",
      "anthropic/claude-opus-4-1-20250805",
      "anthropic/claude-opus-4-20250514",
      "anthropic/claude-opus-4-5-20251101",
      "anthropic/claude-sonnet-4-20250514",
      "anthropic/claude-sonnet-4-5-20250929",
      "gemini/gemini-2.0-flash",
      "gemini/gemini-2.0-flash-lite",
      "gemini/gemini-2.5-flash",
      "gemini/gemini-2.5-flash-image",
      "gemini/gemini-2.5-flash-image-preview",
      "gemini/gemini-2.5-flash-lite",
      "gemini/gemini-2.5-flash-lite-preview-09-2025",
      "gemini/gemini-2.5-flash-preview-09-2025",
      "gemini/gemini-2.5-pro",
      "gemini/gemini-3-pro-image-preview",
      "gemini/gemini-3-pro-preview",
      "gemini/gemini-flash-latest",
      "gemini/gemini-flash-lite-latest",
      "openai/codex-mini-latest",
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/gpt-4.1-nano",
      "openai/gpt-4o",
      "openai/gpt-4o-mini",
      "openai/gpt-5",
      "openai/gpt-5-2025-08-07",
      "openai/gpt-5-codex",
      "openai/gpt-5-mini",
      "openai/gpt-5-mini-2025-08-07",
      "openai/gpt-5-nano",
      "openai/gpt-5-pro",
      "openai/gpt-5.1",
      "openai/gpt-5.1-2025-11-13",
      "openai/gpt-5.1-codex",
      "openai/gpt-5.1-codex-mini",
      "openai/o3",
      "openai/o3-mini",
      "openai/o4-mini"
    ]
  },
  version: "1.0.0"
};
var registryData = null;
var CACHE_DIR = /* @__PURE__ */ __name(() => path2.join(os.homedir(), ".cache", "mastra"), "CACHE_DIR");
var CACHE_FILE = /* @__PURE__ */ __name(() => path2.join(CACHE_DIR(), "gateway-refresh-time"), "CACHE_FILE");
var GLOBAL_PROVIDER_REGISTRY_JSON = /* @__PURE__ */ __name(() => path2.join(CACHE_DIR(), "provider-registry.json"), "GLOBAL_PROVIDER_REGISTRY_JSON");
var GLOBAL_PROVIDER_TYPES_DTS = /* @__PURE__ */ __name(() => path2.join(CACHE_DIR(), "provider-types.generated.d.ts"), "GLOBAL_PROVIDER_TYPES_DTS");
var modelRouterCacheFailed = false;
function atomicWriteFileSync(filePath, content, encoding = "utf-8") {
  const randomSuffix = Math.random().toString(36).substring(2, 15);
  const tempPath = `${filePath}.${process.pid}.${Date.now()}.${randomSuffix}.tmp`;
  try {
    fs2.writeFileSync(tempPath, content, encoding);
    fs2.renameSync(tempPath, filePath);
  } catch (error87) {
    try {
      fs2.unlinkSync(tempPath);
    } catch {
    }
    throw error87;
  }
}
__name(atomicWriteFileSync, "atomicWriteFileSync");
function syncGlobalCacheToLocal() {
  try {
    const globalJsonExists = fs2.existsSync(GLOBAL_PROVIDER_REGISTRY_JSON());
    const globalDtsExists = fs2.existsSync(GLOBAL_PROVIDER_TYPES_DTS());
    if (!globalJsonExists && !globalDtsExists) {
      return;
    }
    const packageRoot = getPackageRoot();
    const localJsonPath = path2.join(packageRoot, "dist", "provider-registry.json");
    const localDtsPath = path2.join(packageRoot, "dist", "llm", "model", "provider-types.generated.d.ts");
    fs2.mkdirSync(path2.dirname(localJsonPath), { recursive: true });
    fs2.mkdirSync(path2.dirname(localDtsPath), { recursive: true });
    if (globalJsonExists) {
      const globalJsonContent = fs2.readFileSync(GLOBAL_PROVIDER_REGISTRY_JSON(), "utf-8");
      try {
        JSON.parse(globalJsonContent);
      } catch {
        console.warn(
          `[GatewayRegistry] Detected corrupted global cache at ${GLOBAL_PROVIDER_REGISTRY_JSON()}. Deleting corrupted file.`
        );
        try {
          fs2.unlinkSync(GLOBAL_PROVIDER_REGISTRY_JSON());
        } catch {
        }
        return;
      }
      let shouldCopyJson = true;
      if (fs2.existsSync(localJsonPath)) {
        const localJsonContent = fs2.readFileSync(localJsonPath, "utf-8");
        shouldCopyJson = globalJsonContent !== localJsonContent;
      }
      if (shouldCopyJson) {
        atomicWriteFileSync(localJsonPath, globalJsonContent, "utf-8");
      }
    }
    if (globalDtsExists) {
      const globalDtsContent = fs2.readFileSync(GLOBAL_PROVIDER_TYPES_DTS(), "utf-8");
      let shouldCopyDts = true;
      if (fs2.existsSync(localDtsPath)) {
        const localDtsContent = fs2.readFileSync(localDtsPath, "utf-8");
        shouldCopyDts = globalDtsContent !== localDtsContent;
      }
      if (shouldCopyDts) {
        atomicWriteFileSync(localDtsPath, globalDtsContent, "utf-8");
      }
    }
  } catch (error87) {
    console.warn("Failed to sync global cache to local:", error87);
  }
}
__name(syncGlobalCacheToLocal, "syncGlobalCacheToLocal");
function getLastRefreshTimeFromDisk() {
  try {
    if (!fs2.existsSync(CACHE_FILE())) {
      return null;
    }
    const timestamp = fs2.readFileSync(CACHE_FILE(), "utf-8").trim();
    return new Date(parseInt(timestamp, 10));
  } catch (err) {
    console.warn("[GatewayRegistry] Failed to read cache file:", err);
    modelRouterCacheFailed = true;
    return null;
  }
}
__name(getLastRefreshTimeFromDisk, "getLastRefreshTimeFromDisk");
function saveLastRefreshTimeToDisk(date9) {
  try {
    if (!fs2.existsSync(CACHE_DIR())) {
      fs2.mkdirSync(CACHE_DIR(), { recursive: true });
    }
    fs2.writeFileSync(CACHE_FILE(), date9.getTime().toString(), "utf-8");
  } catch (err) {
    modelRouterCacheFailed = true;
    console.warn("[GatewayRegistry] Failed to write cache file:", err);
  }
}
__name(saveLastRefreshTimeToDisk, "saveLastRefreshTimeToDisk");
function getPackageRoot() {
  try {
    const require2 = createRequire(import.meta.url || "file://");
    const packageJsonPath = require2.resolve("@mastra/core/package.json");
    return path2.dirname(packageJsonPath);
  } catch {
    return process.cwd();
  }
}
__name(getPackageRoot, "getPackageRoot");
function loadRegistry(useDynamicLoading) {
  if (!useDynamicLoading) {
    return provider_registry_default;
  }
  syncGlobalCacheToLocal();
  if (registryData) {
    return registryData;
  }
  const packageRoot = getPackageRoot();
  const possiblePaths = [
    // Built: in dist/ relative to package root (first priority - what gets distributed)
    path2.join(packageRoot, "dist", "provider-registry.json"),
    // Development: in src/ relative to package root
    path2.join(packageRoot, "src", "llm", "model", "provider-registry.json"),
    // Fallback: relative to cwd (for monorepo setups)
    path2.join(process.cwd(), "packages/core/src/llm/model/provider-registry.json"),
    path2.join(process.cwd(), "src/llm/model/provider-registry.json")
  ];
  const errors = [];
  for (const jsonPath of possiblePaths) {
    try {
      const content = fs2.readFileSync(jsonPath, "utf-8");
      registryData = JSON.parse(content);
      return registryData;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      errors.push(`${jsonPath}: ${errorMessage}`);
      const isFileNotFound = err instanceof Error && "code" in err && err.code === "ENOENT";
      const isJsonParseError = err instanceof SyntaxError;
      if (!isFileNotFound && isJsonParseError) {
        console.warn(
          `[GatewayRegistry] Detected corrupted provider-registry.json at ${jsonPath}. Deleting corrupted file and falling back to static registry.`
        );
        try {
          fs2.unlinkSync(jsonPath);
        } catch {
        }
        registryData = provider_registry_default;
        return registryData;
      }
      continue;
    }
  }
  console.warn(
    `[GatewayRegistry] Could not load provider registry from any path. Falling back to static registry.
Tried paths:
${errors.join("\n")}`
  );
  registryData = provider_registry_default;
  return registryData;
}
__name(loadRegistry, "loadRegistry");
var PROVIDER_REGISTRY = new Proxy({}, {
  get(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const providers = registry3.getProviders();
    return providers[prop];
  },
  ownKeys() {
    const registry3 = GatewayRegistry.getInstance();
    const providers = registry3.getProviders();
    return Object.keys(providers);
  },
  has(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const providers = registry3.getProviders();
    return prop in providers;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const providers = registry3.getProviders();
    if (prop in providers) {
      return {
        enumerable: true,
        configurable: true
      };
    }
    return void 0;
  }
});
var PROVIDER_MODELS = new Proxy({}, {
  get(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const models = registry3.getModels();
    return models[prop];
  },
  ownKeys() {
    const registry3 = GatewayRegistry.getInstance();
    const models = registry3.getModels();
    return Object.keys(models);
  },
  has(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const models = registry3.getModels();
    return prop in models;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const registry3 = GatewayRegistry.getInstance();
    const models = registry3.getModels();
    if (prop in models) {
      return {
        enumerable: true,
        configurable: true
      };
    }
    return void 0;
  }
});
var GatewayRegistry = class _GatewayRegistry {
  static {
    __name(this, "_GatewayRegistry");
  }
  static instance = null;
  lastRefreshTime = null;
  refreshInterval = null;
  isRefreshing = false;
  useDynamicLoading;
  customGateways = [];
  constructor(options = {}) {
    const isDev2 = process.env.MASTRA_DEV === "true" || process.env.MASTRA_DEV === "1";
    this.useDynamicLoading = options.useDynamicLoading ?? isDev2;
  }
  /**
   * Get the singleton instance
   */
  static getInstance(options) {
    if (!_GatewayRegistry.instance) {
      _GatewayRegistry.instance = new _GatewayRegistry(options);
    }
    return _GatewayRegistry.instance;
  }
  /**
   * Register custom gateways for type generation
   * @param gateways - Array of custom gateway instances
   */
  registerCustomGateways(gateways) {
    this.customGateways = gateways;
  }
  /**
   * Get all registered custom gateways
   */
  getCustomGateways() {
    return this.customGateways;
  }
  /**
   * Sync providers from all gateways
   * Requires dynamic loading to be enabled (useDynamicLoading=true).
   * @param forceRefresh - Force refresh even if recently synced
   * @param writeToSrc - Write to src/ directory in addition to dist/ (useful for manual generation in repo)
   */
  async syncGateways(forceRefresh = false, writeToSrc = false) {
    if (!this.useDynamicLoading && !writeToSrc) {
      return;
    }
    if (this.isRefreshing && !forceRefresh) {
      return;
    }
    this.isRefreshing = true;
    try {
      const { ModelsDevGateway: ModelsDevGateway2 } = await Promise.resolve().then(() => (init_models_dev_LJ4O6FNF(), models_dev_LJ4O6FNF_exports));
      const { NetlifyGateway: NetlifyGateway2 } = await Promise.resolve().then(() => (init_netlify_L7AZ74PV(), netlify_L7AZ74PV_exports));
      const { fetchProvidersFromGateways: fetchProvidersFromGateways2, writeRegistryFiles: writeRegistryFiles2 } = await Promise.resolve().then(() => (init_registry_generator_I6S4ARS6(), registry_generator_I6S4ARS6_exports));
      const defaultGateways2 = [new ModelsDevGateway2({}), new NetlifyGateway2()];
      const gateways = [...defaultGateways2, ...this.customGateways];
      const { providers, models } = await fetchProvidersFromGateways2(gateways);
      const packageRoot = getPackageRoot();
      try {
        fs2.mkdirSync(CACHE_DIR(), { recursive: true });
        await writeRegistryFiles2(GLOBAL_PROVIDER_REGISTRY_JSON(), GLOBAL_PROVIDER_TYPES_DTS(), providers, models);
      } catch (error87) {
        console.warn("[GatewayRegistry] Failed to write to global cache:", error87);
      }
      const distJsonPath = path2.join(packageRoot, "dist", "provider-registry.json");
      const distTypesPath = path2.join(packageRoot, "dist", "llm", "model", "provider-types.generated.d.ts");
      await writeRegistryFiles2(distJsonPath, distTypesPath, providers, models);
      const shouldWriteToSrc = writeToSrc;
      if (shouldWriteToSrc) {
        const srcJsonPath = path2.join(packageRoot, "src", "llm", "model", "provider-registry.json");
        const srcTypesPath = path2.join(packageRoot, "src", "llm", "model", "provider-types.generated.d.ts");
        await fs2.promises.copyFile(distJsonPath, srcJsonPath);
        await fs2.promises.copyFile(distTypesPath, srcTypesPath);
      }
      if (this.useDynamicLoading) {
        registryData = null;
      }
      this.lastRefreshTime = /* @__PURE__ */ new Date();
      saveLastRefreshTimeToDisk(this.lastRefreshTime);
    } catch (error87) {
      console.error("[GatewayRegistry] \u274C Gateway sync failed:", error87);
      throw error87;
    } finally {
      this.isRefreshing = false;
    }
  }
  /**
   * Get the last refresh time (from memory or disk cache)
   */
  getLastRefreshTime() {
    return this.lastRefreshTime || getLastRefreshTimeFromDisk();
  }
  /**
   * Start auto-refresh on an interval
   * Requires dynamic loading to be enabled (useDynamicLoading=true).
   * @param intervalMs - Interval in milliseconds (default: 1 hour)
   */
  startAutoRefresh(intervalMs = 60 * 60 * 1e3) {
    if (!this.useDynamicLoading) {
      return;
    }
    if (this.refreshInterval) {
      return;
    }
    const lastRefresh = getLastRefreshTimeFromDisk();
    const now2 = Date.now();
    const shouldRefresh = !modelRouterCacheFailed && (!lastRefresh || now2 - lastRefresh.getTime() > intervalMs);
    if (shouldRefresh) {
      this.syncGateways().catch((err) => {
        console.error("[GatewayRegistry] Initial auto-refresh failed:", err);
      });
    }
    this.refreshInterval = setInterval(() => {
      if (modelRouterCacheFailed && this.refreshInterval) {
        clearInterval(this.refreshInterval);
        this.refreshInterval = null;
        return;
      }
      this.syncGateways().catch((err) => {
        console.error("[GatewayRegistry] Auto-refresh failed:", err);
      });
    }, intervalMs);
    if (this.refreshInterval.unref) {
      this.refreshInterval.unref();
    }
  }
  /**
   * Stop auto-refresh
   */
  stopAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
  /**
   * Get provider configuration by ID
   */
  getProviderConfig(providerId) {
    const data = loadRegistry(this.useDynamicLoading);
    return data.providers[providerId];
  }
  /**
   * Check if a provider is registered
   */
  isProviderRegistered(providerId) {
    const data = loadRegistry(this.useDynamicLoading);
    return providerId in data.providers;
  }
  /**
   * Get all registered providers
   */
  getProviders() {
    const data = loadRegistry(this.useDynamicLoading);
    return data.providers;
  }
  /**
   * Get all models
   */
  getModels() {
    return loadRegistry(this.useDynamicLoading).models;
  }
};
var isDev = process.env.MASTRA_DEV === "true" || process.env.MASTRA_DEV === "1";
var autoRefreshEnabled = process.env.MASTRA_AUTO_REFRESH_PROVIDERS === "true" || process.env.MASTRA_AUTO_REFRESH_PROVIDERS !== "false" && isDev;
if (autoRefreshEnabled) {
  GatewayRegistry.getInstance({ useDynamicLoading: isDev }).startAutoRefresh();
}

// node_modules/@mastra/core/dist/chunk-72F4RGK7.js
init_chunk_R6XC4DV5();
init_chunk_HSX2K7HB();
init_chunk_PZUZNPFM();
init_dist14();
import { createHash as createHash2, randomUUID as randomUUID2 } from "crypto";
function findGatewayForModel(gatewayId, gateways) {
  const prefixedGateway = gateways.find(
    (g) => g.id !== "models.dev" && (g.id === gatewayId || gatewayId.startsWith(`${g.id}/`))
  );
  if (prefixedGateway) {
    return prefixedGateway;
  }
  const modelsDevGateway = gateways.find((g) => g.id === "models.dev");
  if (modelsDevGateway) {
    return modelsDevGateway;
  }
  throw new MastraError({
    id: "MODEL_ROUTER_NO_GATEWAY_FOUND",
    category: "USER",
    domain: "MODEL_ROUTER",
    text: `No Mastra model router gateway found for model id ${gatewayId}`
  });
}
__name(findGatewayForModel, "findGatewayForModel");
var AISDKV5LanguageModel = class {
  static {
    __name(this, "AISDKV5LanguageModel");
  }
  /**
   * The language model must specify which language model interface version it implements.
   */
  specificationVersion = "v2";
  /**
   * Name of the provider for logging purposes.
   */
  provider;
  /**
   * Provider-specific model ID for logging purposes.
   */
  modelId;
  /**
   * Supported URL patterns by media type for the provider.
   *
   * The keys are media type patterns or full media types (e.g. `*\/*` for everything, `audio/*`, `video/*`, or `application/pdf`).
   * and the values are arrays of regular expressions that match the URL paths.
   * The matching should be against lower-case URLs.
   * Matched URLs are supported natively by the model and are not downloaded.
   * @returns A map of supported URL patterns by media type (as a promise or a plain object).
   */
  supportedUrls;
  #model;
  constructor(config4) {
    this.#model = config4;
    this.provider = this.#model.provider;
    this.modelId = this.#model.modelId;
    this.supportedUrls = this.#model.supportedUrls;
  }
  async doGenerate(options) {
    const result = await this.#model.doGenerate(options);
    return {
      request: result.request,
      response: result.response,
      stream: new ReadableStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings: result.warnings });
          controller.enqueue({
            type: "response-metadata",
            id: result.response?.id,
            modelId: result.response?.modelId,
            timestamp: result.response?.timestamp
          });
          for (const message of result.content) {
            if (message.type === "tool-call") {
              const toolCall = message;
              controller.enqueue({
                type: "tool-input-start",
                id: toolCall.toolCallId,
                toolName: toolCall.toolName
              });
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: toolCall.input
              });
              controller.enqueue({
                type: "tool-input-end",
                id: toolCall.toolCallId
              });
              controller.enqueue(toolCall);
            } else if (message.type === "tool-result") {
              const toolResult = message;
              controller.enqueue(toolResult);
            } else if (message.type === "text") {
              const text3 = message;
              const id = `msg_${randomUUID2()}`;
              controller.enqueue({
                type: "text-start",
                id,
                providerMetadata: text3.providerMetadata
              });
              controller.enqueue({
                type: "text-delta",
                id,
                delta: text3.text
              });
              controller.enqueue({
                type: "text-end",
                id
              });
            } else if (message.type === "reasoning") {
              const id = `reasoning_${randomUUID2()}`;
              const reasoning = message;
              controller.enqueue({
                type: "reasoning-start",
                id,
                providerMetadata: reasoning.providerMetadata
              });
              controller.enqueue({
                type: "reasoning-delta",
                id,
                delta: reasoning.text,
                providerMetadata: reasoning.providerMetadata
              });
              controller.enqueue({
                type: "reasoning-end",
                id,
                providerMetadata: reasoning.providerMetadata
              });
            } else if (message.type === "file") {
              const file3 = message;
              controller.enqueue({
                type: "file",
                mediaType: file3.mediaType,
                data: file3.data
              });
            } else if (message.type === "source") {
              const source = message;
              if (source.sourceType === "url") {
                controller.enqueue({
                  type: "source",
                  id: source.id,
                  sourceType: "url",
                  url: source.url,
                  title: source.title,
                  providerMetadata: source.providerMetadata
                });
              } else {
                controller.enqueue({
                  type: "source",
                  id: source.id,
                  sourceType: "document",
                  mediaType: source.mediaType,
                  filename: source.filename,
                  title: source.title,
                  providerMetadata: source.providerMetadata
                });
              }
            }
          }
          controller.enqueue({
            type: "finish",
            finishReason: result.finishReason,
            usage: result.usage,
            providerMetadata: result.providerMetadata
          });
          controller.close();
        }
      })
    };
  }
  async doStream(options) {
    return await this.#model.doStream(options);
  }
};
function getStaticProvidersByGateway(name51) {
  return Object.fromEntries(Object.entries(PROVIDER_REGISTRY).filter(([_provider, config4]) => config4.gateway === name51));
}
__name(getStaticProvidersByGateway, "getStaticProvidersByGateway");
var defaultGateways = [new NetlifyGateway(), new ModelsDevGateway(getStaticProvidersByGateway(`models.dev`))];
var ModelRouterLanguageModel = class _ModelRouterLanguageModel {
  static {
    __name(this, "_ModelRouterLanguageModel");
  }
  specificationVersion = "v2";
  defaultObjectGenerationMode = "json";
  supportsStructuredOutputs = true;
  supportsImageUrls = true;
  supportedUrls = {};
  modelId;
  provider;
  config;
  gateway;
  constructor(config4, customGateways) {
    let normalizedConfig;
    if (typeof config4 === "string") {
      normalizedConfig = { id: config4 };
    } else if ("providerId" in config4 && "modelId" in config4) {
      normalizedConfig = {
        id: `${config4.providerId}/${config4.modelId}`,
        url: config4.url,
        apiKey: config4.apiKey,
        headers: config4.headers
      };
    } else {
      normalizedConfig = {
        id: config4.id,
        url: config4.url,
        apiKey: config4.apiKey,
        headers: config4.headers
      };
    }
    const parsedConfig = {
      ...normalizedConfig,
      routerId: normalizedConfig.id
    };
    this.gateway = findGatewayForModel(normalizedConfig.id, [...customGateways || [], ...defaultGateways]);
    const gatewayPrefix = this.gateway.id === "models.dev" ? void 0 : this.gateway.id;
    const parsed = parseModelRouterId(normalizedConfig.id, gatewayPrefix);
    this.provider = parsed.providerId || "openai-compatible";
    if (parsed.providerId && parsed.modelId !== normalizedConfig.id) {
      parsedConfig.id = parsed.modelId;
    }
    this.modelId = parsedConfig.id;
    this.config = parsedConfig;
  }
  async doGenerate(options) {
    let apiKey;
    try {
      if (this.config.url) {
        apiKey = this.config.apiKey || "";
      } else {
        apiKey = this.config.apiKey || await this.gateway.getApiKey(this.config.routerId);
      }
    } catch (error87) {
      return {
        stream: new ReadableStream({
          start(controller) {
            controller.enqueue({
              type: "error",
              error: error87
            });
            controller.close();
          }
        })
      };
    }
    const gatewayPrefix = this.gateway.id === "models.dev" ? void 0 : this.gateway.id;
    const model = await this.resolveLanguageModel({
      apiKey,
      headers: this.config.headers,
      ...parseModelRouterId(this.config.routerId, gatewayPrefix)
    });
    const aiSDKV5Model = new AISDKV5LanguageModel(model);
    return aiSDKV5Model.doGenerate(options);
  }
  async doStream(options) {
    let apiKey;
    try {
      if (this.config.url) {
        apiKey = this.config.apiKey || "";
      } else {
        apiKey = this.config.apiKey || await this.gateway.getApiKey(this.config.routerId);
      }
    } catch (error87) {
      return {
        stream: new ReadableStream({
          start(controller) {
            controller.enqueue({
              type: "error",
              error: error87
            });
            controller.close();
          }
        })
      };
    }
    const gatewayPrefix = this.gateway.id === "models.dev" ? void 0 : this.gateway.id;
    const model = await this.resolveLanguageModel({
      apiKey,
      headers: this.config.headers,
      ...parseModelRouterId(this.config.routerId, gatewayPrefix)
    });
    const aiSDKV5Model = new AISDKV5LanguageModel(model);
    return aiSDKV5Model.doStream(options);
  }
  async resolveLanguageModel({
    modelId,
    providerId,
    apiKey,
    headers
  }) {
    const key = createHash2("sha256").update(
      this.gateway.id + modelId + providerId + apiKey + (this.config.url || "") + (headers ? JSON.stringify(headers) : "")
    ).digest("hex");
    if (_ModelRouterLanguageModel.modelInstances.has(key)) return _ModelRouterLanguageModel.modelInstances.get(key);
    if (this.config.url) {
      const modelInstance2 = createOpenAICompatible({
        name: providerId,
        apiKey,
        baseURL: this.config.url,
        headers: this.config.headers,
        supportsStructuredOutputs: true
      }).chatModel(modelId);
      _ModelRouterLanguageModel.modelInstances.set(key, modelInstance2);
      return modelInstance2;
    }
    const modelInstance = await this.gateway.resolveLanguageModel({ modelId, providerId, apiKey, headers });
    _ModelRouterLanguageModel.modelInstances.set(key, modelInstance);
    return modelInstance;
  }
  static modelInstances = /* @__PURE__ */ new Map();
};
function isOpenAICompatibleObjectConfig(modelConfig) {
  if (typeof modelConfig === "object" && "specificationVersion" in modelConfig) return false;
  if (typeof modelConfig === "object" && !("model" in modelConfig)) {
    if ("id" in modelConfig) return true;
    if ("providerId" in modelConfig && "modelId" in modelConfig) return true;
  }
  return false;
}
__name(isOpenAICompatibleObjectConfig, "isOpenAICompatibleObjectConfig");
async function resolveModelConfig(modelConfig, runtimeContext = new RuntimeContext(), mastra) {
  if (typeof modelConfig === "function") {
    modelConfig = await modelConfig({ runtimeContext, mastra });
  }
  if (modelConfig instanceof ModelRouterLanguageModel || modelConfig instanceof AISDKV5LanguageModel) {
    return modelConfig;
  }
  if (typeof modelConfig === "object" && "specificationVersion" in modelConfig) {
    if (modelConfig.specificationVersion === "v2") {
      return new AISDKV5LanguageModel(modelConfig);
    }
    return modelConfig;
  }
  const gatewayRecord = mastra?.listGateways();
  const customGateways = gatewayRecord ? Object.values(gatewayRecord) : void 0;
  if (typeof modelConfig === "string" || isOpenAICompatibleObjectConfig(modelConfig)) {
    return new ModelRouterLanguageModel(modelConfig, customGateways);
  }
  throw new Error("Invalid model configuration provided");
}
__name(resolveModelConfig, "resolveModelConfig");

// node_modules/@mastra/core/dist/chunk-ZZIYFEVM.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
init_chunk_PZUZNPFM();
init_chunk_VQASQG5D();

// node_modules/@mastra/schema-compat/dist/zod-to-json.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-ZZIYFEVM.js
init_zod();
var MastraLLMV1 = class extends MastraBase {
  static {
    __name(this, "MastraLLMV1");
  }
  #model;
  #mastra;
  #options;
  constructor({ model, mastra, options }) {
    super({ name: "aisdk" });
    this.#model = model;
    this.#options = options;
    if (mastra) {
      this.#mastra = mastra;
      if (mastra.getLogger()) {
        this.__setLogger(this.#mastra.getLogger());
      }
    }
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  __registerMastra(p) {
    this.#mastra = p;
  }
  getProvider() {
    return this.#model.provider;
  }
  getModelId() {
    return this.#model.modelId;
  }
  getModel() {
    return this.#model;
  }
  _applySchemaCompat(schema) {
    const model = this.#model;
    const schemaCompatLayers = [];
    if (model) {
      const modelInfo = {
        modelId: model.modelId,
        supportsStructuredOutputs: model.supportsStructuredOutputs ?? false,
        provider: model.provider
      };
      schemaCompatLayers.push(
        new OpenAIReasoningSchemaCompatLayer(modelInfo),
        new OpenAISchemaCompatLayer(modelInfo),
        new GoogleSchemaCompatLayer(modelInfo),
        new AnthropicSchemaCompatLayer(modelInfo),
        new DeepSeekSchemaCompatLayer(modelInfo),
        new MetaSchemaCompatLayer(modelInfo)
      );
    }
    return applyCompatLayer({
      schema,
      compatLayers: schemaCompatLayers,
      mode: "aiSdkSchema"
    });
  }
  async __text({
    runId,
    messages,
    maxSteps = 5,
    tools = {},
    temperature,
    toolChoice = "auto",
    onStepFinish,
    experimental_output,
    telemetry,
    threadId,
    resourceId,
    runtimeContext,
    tracingContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Generating text`, {
      runId,
      messages,
      maxSteps,
      threadId,
      resourceId,
      tools: Object.keys(tools)
    });
    let schema = void 0;
    if (experimental_output) {
      this.logger.debug("[LLM] - Using experimental output", {
        runId
      });
      if (isZodType2(experimental_output)) {
        schema = experimental_output;
        if (schema instanceof external_exports2.ZodArray) {
          schema = schema._def.type;
        }
        let jsonSchemaToUse;
        jsonSchemaToUse = zodToJsonSchema3(schema, "jsonSchema7");
        schema = jsonSchema2(jsonSchemaToUse);
      } else {
        schema = jsonSchema2(experimental_output);
      }
    }
    const llmSpan = tracingContext.currentSpan?.createChildSpan({
      name: `llm: '${model.modelId}'`,
      type: "model_generation",
      input: {
        messages,
        schema
      },
      attributes: {
        model: model.modelId,
        provider: model.provider,
        parameters: {
          temperature,
          maxOutputTokens: rest.maxTokens,
          topP: rest.topP,
          frequencyPenalty: rest.frequencyPenalty,
          presencePenalty: rest.presencePenalty
        },
        streaming: false
      },
      metadata: {
        runId,
        threadId,
        resourceId
      },
      tracingPolicy: this.#options?.tracingPolicy
    });
    const argsForExecute = {
      ...rest,
      messages,
      model,
      temperature,
      tools: {
        ...tools
      },
      toolChoice,
      maxSteps,
      onStepFinish: /* @__PURE__ */ __name(async (props) => {
        try {
          await onStepFinish?.({ ...props, runId });
        } catch (e) {
          const mastraError = new MastraError(
            {
              id: "LLM_TEXT_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED",
              domain: "LLM",
              category: "USER",
              details: {
                modelId: model.modelId,
                modelProvider: model.provider,
                runId: runId ?? "unknown",
                threadId: threadId ?? "unknown",
                resourceId: resourceId ?? "unknown",
                finishReason: props?.finishReason,
                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                usage: props?.usage ? JSON.stringify(props.usage) : ""
              }
            },
            e
          );
          throw mastraError;
        }
        this.logger.debug("[LLM] - Text Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId
        });
        const remainingTokens = parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"] ?? "", 10);
        if (!isNaN(remainingTokens) && remainingTokens > 0 && remainingTokens < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay2(10 * 1e3);
        }
      }, "onStepFinish"),
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      },
      experimental_output: schema ? output_exports2.object({
        schema
      }) : void 0
    };
    try {
      const result = await generateText(argsForExecute);
      if (schema && result.finishReason === "stop") {
        result.object = result.experimental_output;
      }
      llmSpan?.end({
        output: {
          text: result.text,
          object: result.object,
          reasoning: result.reasoningDetails,
          reasoningText: result.reasoning,
          files: result.files,
          sources: result.sources,
          warnings: result.warnings
        },
        attributes: {
          finishReason: result.finishReason,
          usage: result.usage
        }
      });
      return result;
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "LLM_GENERATE_TEXT_AI_SDK_EXECUTION_FAILED",
          domain: "LLM",
          category: "THIRD_PARTY",
          details: {
            modelId: model.modelId,
            modelProvider: model.provider,
            runId: runId ?? "unknown",
            threadId: threadId ?? "unknown",
            resourceId: resourceId ?? "unknown"
          }
        },
        e
      );
      llmSpan?.error({ error: mastraError });
      throw mastraError;
    }
  }
  async __textObject({
    messages,
    structuredOutput,
    runId,
    telemetry,
    threadId,
    resourceId,
    runtimeContext,
    tracingContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Generating a text object`, { runId });
    const llmSpan = tracingContext.currentSpan?.createChildSpan({
      name: `llm: '${model.modelId}'`,
      type: "model_generation",
      input: {
        messages
      },
      attributes: {
        model: model.modelId,
        provider: model.provider,
        parameters: {
          temperature: rest.temperature,
          maxOutputTokens: rest.maxTokens,
          topP: rest.topP,
          frequencyPenalty: rest.frequencyPenalty,
          presencePenalty: rest.presencePenalty
        },
        streaming: false
      },
      metadata: {
        runId,
        threadId,
        resourceId
      },
      tracingPolicy: this.#options?.tracingPolicy
    });
    try {
      let output = "object";
      if (structuredOutput instanceof external_exports2.ZodArray) {
        output = "array";
        structuredOutput = structuredOutput._def.type;
      }
      const processedSchema = this._applySchemaCompat(structuredOutput);
      llmSpan?.update({
        input: {
          messages,
          schema: processedSchema
        }
      });
      const argsForExecute = {
        ...rest,
        messages,
        model,
        // @ts-expect-error - output in our implementation can only be object or array
        output,
        schema: processedSchema,
        experimental_telemetry: {
          ...this.experimental_telemetry,
          ...telemetry
        }
      };
      try {
        const result = await generateObject(argsForExecute);
        llmSpan?.end({
          output: {
            object: result.object,
            warnings: result.warnings
          },
          attributes: {
            finishReason: result.finishReason,
            usage: result.usage
          }
        });
        return result;
      } catch (e) {
        const mastraError = new MastraError(
          {
            id: "LLM_GENERATE_OBJECT_AI_SDK_EXECUTION_FAILED",
            domain: "LLM",
            category: "THIRD_PARTY",
            details: {
              modelId: model.modelId,
              modelProvider: model.provider,
              runId: runId ?? "unknown",
              threadId: threadId ?? "unknown",
              resourceId: resourceId ?? "unknown"
            }
          },
          e
        );
        llmSpan?.error({ error: mastraError });
        throw mastraError;
      }
    } catch (e) {
      if (e instanceof MastraError) {
        throw e;
      }
      const mastraError = new MastraError(
        {
          id: "LLM_GENERATE_OBJECT_AI_SDK_SCHEMA_CONVERSION_FAILED",
          domain: "LLM",
          category: "USER",
          details: {
            modelId: model.modelId,
            modelProvider: model.provider,
            runId: runId ?? "unknown",
            threadId: threadId ?? "unknown",
            resourceId: resourceId ?? "unknown"
          }
        },
        e
      );
      llmSpan?.error({ error: mastraError });
      throw mastraError;
    }
  }
  __stream({
    messages,
    onStepFinish,
    onFinish,
    maxSteps = 5,
    tools = {},
    runId,
    temperature,
    toolChoice = "auto",
    experimental_output,
    telemetry,
    threadId,
    resourceId,
    runtimeContext,
    tracingContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Streaming text`, {
      runId,
      threadId,
      resourceId,
      messages,
      maxSteps,
      tools: Object.keys(tools || {})
    });
    let schema;
    if (experimental_output) {
      this.logger.debug("[LLM] - Using experimental output", {
        runId
      });
      if (typeof experimental_output.parse === "function") {
        schema = experimental_output;
        if (schema instanceof external_exports2.ZodArray) {
          schema = schema._def.type;
        }
      } else {
        schema = jsonSchema2(experimental_output);
      }
    }
    const llmSpan = tracingContext.currentSpan?.createChildSpan({
      name: `llm: '${model.modelId}'`,
      type: "model_generation",
      input: {
        messages
      },
      attributes: {
        model: model.modelId,
        provider: model.provider,
        parameters: {
          temperature,
          maxOutputTokens: rest.maxTokens,
          topP: rest.topP,
          frequencyPenalty: rest.frequencyPenalty,
          presencePenalty: rest.presencePenalty
        },
        streaming: true
      },
      metadata: {
        runId,
        threadId,
        resourceId
      },
      tracingPolicy: this.#options?.tracingPolicy
    });
    const argsForExecute = {
      model,
      temperature,
      tools: {
        ...tools
      },
      maxSteps,
      toolChoice,
      onStepFinish: /* @__PURE__ */ __name(async (props) => {
        try {
          await onStepFinish?.({ ...props, runId });
        } catch (e) {
          const mastraError = new MastraError(
            {
              id: "LLM_STREAM_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED",
              domain: "LLM",
              category: "USER",
              details: {
                modelId: model.modelId,
                modelProvider: model.provider,
                runId: runId ?? "unknown",
                threadId: threadId ?? "unknown",
                resourceId: resourceId ?? "unknown",
                finishReason: props?.finishReason,
                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                usage: props?.usage ? JSON.stringify(props.usage) : ""
              }
            },
            e
          );
          this.logger.trackException(mastraError);
          llmSpan?.error({ error: mastraError });
          throw mastraError;
        }
        this.logger.debug("[LLM] - Stream Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId
        });
        const remainingTokens = parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"] ?? "", 10);
        if (!isNaN(remainingTokens) && remainingTokens > 0 && remainingTokens < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay2(10 * 1e3);
        }
      }, "onStepFinish"),
      onFinish: /* @__PURE__ */ __name(async (props) => {
        llmSpan?.end({
          output: {
            text: props?.text,
            reasoning: props?.reasoningDetails,
            reasoningText: props?.reasoning,
            files: props?.files,
            sources: props?.sources,
            warnings: props?.warnings
          },
          attributes: {
            finishReason: props?.finishReason,
            usage: props?.usage
          }
        });
        try {
          await onFinish?.({ ...props, runId });
        } catch (e) {
          const mastraError = new MastraError(
            {
              id: "LLM_STREAM_ON_FINISH_CALLBACK_EXECUTION_FAILED",
              domain: "LLM",
              category: "USER",
              details: {
                modelId: model.modelId,
                modelProvider: model.provider,
                runId: runId ?? "unknown",
                threadId: threadId ?? "unknown",
                resourceId: resourceId ?? "unknown",
                finishReason: props?.finishReason,
                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                usage: props?.usage ? JSON.stringify(props.usage) : ""
              }
            },
            e
          );
          llmSpan?.error({ error: mastraError });
          this.logger.trackException(mastraError);
          throw mastraError;
        }
        this.logger.debug("[LLM] - Stream Finished:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId,
          threadId,
          resourceId
        });
      }, "onFinish"),
      ...rest,
      messages,
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      },
      experimental_output: schema ? output_exports2.object({
        schema
      }) : void 0
    };
    try {
      return streamText(argsForExecute);
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "LLM_STREAM_TEXT_AI_SDK_EXECUTION_FAILED",
          domain: "LLM",
          category: "THIRD_PARTY",
          details: {
            modelId: model.modelId,
            modelProvider: model.provider,
            runId: runId ?? "unknown",
            threadId: threadId ?? "unknown",
            resourceId: resourceId ?? "unknown"
          }
        },
        e
      );
      llmSpan?.error({ error: mastraError });
      throw mastraError;
    }
  }
  __streamObject({
    messages,
    runId,
    runtimeContext,
    threadId,
    resourceId,
    onFinish,
    structuredOutput,
    telemetry,
    tracingContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Streaming structured output`, {
      runId,
      messages
    });
    const llmSpan = tracingContext.currentSpan?.createChildSpan({
      name: `llm: '${model.modelId}'`,
      type: "model_generation",
      input: {
        messages
      },
      attributes: {
        model: model.modelId,
        provider: model.provider,
        parameters: {
          temperature: rest.temperature,
          maxOutputTokens: rest.maxTokens,
          topP: rest.topP,
          frequencyPenalty: rest.frequencyPenalty,
          presencePenalty: rest.presencePenalty
        },
        streaming: true
      },
      metadata: {
        runId,
        threadId,
        resourceId
      },
      tracingPolicy: this.#options?.tracingPolicy
    });
    try {
      let output = "object";
      if (structuredOutput instanceof external_exports2.ZodArray) {
        output = "array";
        structuredOutput = structuredOutput._def.type;
      }
      const processedSchema = this._applySchemaCompat(structuredOutput);
      llmSpan?.update({
        input: {
          messages,
          schema: processedSchema
        }
      });
      const argsForExecute = {
        ...rest,
        model,
        onFinish: /* @__PURE__ */ __name(async (props) => {
          llmSpan?.end({
            output: {
              text: props?.text,
              object: props?.object,
              reasoning: props?.reasoningDetails,
              reasoningText: props?.reasoning,
              files: props?.files,
              sources: props?.sources,
              warnings: props?.warnings
            },
            attributes: {
              finishReason: props?.finishReason,
              usage: props?.usage
            }
          });
          try {
            await onFinish?.({ ...props, runId });
          } catch (e) {
            const mastraError = new MastraError(
              {
                id: "LLM_STREAM_OBJECT_ON_FINISH_CALLBACK_EXECUTION_FAILED",
                domain: "LLM",
                category: "USER",
                details: {
                  modelId: model.modelId,
                  modelProvider: model.provider,
                  runId: runId ?? "unknown",
                  threadId: threadId ?? "unknown",
                  resourceId: resourceId ?? "unknown",
                  toolCalls: "",
                  toolResults: "",
                  finishReason: "",
                  usage: props?.usage ? JSON.stringify(props.usage) : ""
                }
              },
              e
            );
            this.logger.trackException(mastraError);
            llmSpan?.error({ error: mastraError });
            throw mastraError;
          }
          this.logger.debug("[LLM] - Object Stream Finished:", {
            usage: props?.usage,
            runId,
            threadId,
            resourceId
          });
        }, "onFinish"),
        messages,
        // @ts-expect-error - output in our implementation can only be object or array
        output,
        experimental_telemetry: {
          ...this.experimental_telemetry,
          ...telemetry
        },
        schema: processedSchema
      };
      try {
        return streamObject(argsForExecute);
      } catch (e) {
        const mastraError = new MastraError(
          {
            id: "LLM_STREAM_OBJECT_AI_SDK_EXECUTION_FAILED",
            domain: "LLM",
            category: "THIRD_PARTY",
            details: {
              modelId: model.modelId,
              modelProvider: model.provider,
              runId: runId ?? "unknown",
              threadId: threadId ?? "unknown",
              resourceId: resourceId ?? "unknown"
            }
          },
          e
        );
        llmSpan?.error({ error: mastraError });
        throw mastraError;
      }
    } catch (e) {
      if (e instanceof MastraError) {
        llmSpan?.error({ error: e });
        throw e;
      }
      const mastraError = new MastraError(
        {
          id: "LLM_STREAM_OBJECT_AI_SDK_SCHEMA_CONVERSION_FAILED",
          domain: "LLM",
          category: "USER",
          details: {
            modelId: model.modelId,
            modelProvider: model.provider,
            runId: runId ?? "unknown",
            threadId: threadId ?? "unknown",
            resourceId: resourceId ?? "unknown"
          }
        },
        e
      );
      llmSpan?.error({ error: mastraError });
      throw mastraError;
    }
  }
  convertToMessages(messages) {
    if (Array.isArray(messages)) {
      return messages.map((m) => {
        if (typeof m === "string") {
          return {
            role: "user",
            content: m
          };
        }
        return m;
      });
    }
    return [
      {
        role: "user",
        content: messages
      }
    ];
  }
  async generate(messages, {
    output,
    ...rest
  }) {
    const msgs = this.convertToMessages(messages);
    if (!output) {
      const { maxSteps, onStepFinish, ...textOptions } = rest;
      return await this.__text({
        messages: msgs,
        maxSteps,
        onStepFinish,
        ...textOptions
      });
    }
    return await this.__textObject({
      messages: msgs,
      structuredOutput: output,
      ...rest
    });
  }
  stream(messages, {
    maxSteps = 5,
    output,
    onFinish,
    ...rest
  }) {
    const msgs = this.convertToMessages(messages);
    if (!output) {
      return this.__stream({
        messages: msgs,
        maxSteps,
        onFinish,
        ...rest
      });
    }
    return this.__streamObject({
      messages: msgs,
      structuredOutput: output,
      onFinish,
      ...rest
    });
  }
};

// node_modules/@mastra/core/dist/chunk-TTELJD4F.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function mitt(all) {
  all = all || /* @__PURE__ */ new Map();
  return {
    /**
     * A Map of event names to registered handler functions.
     */
    all,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        handlers.push(handler);
      } else {
        all.set(type, [handler]);
      }
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        if (handler) {
          handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        } else {
          all.set(type, []);
        }
      }
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(type, evt) {
      let handlers = all.get(type);
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(evt);
        });
      }
      handlers = all.get("*");
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(type, evt);
        });
      }
    }
  };
}
__name(mitt, "mitt");
var hooks = mitt();
function executeHook(hook, data) {
  setImmediate(() => {
    hooks.emit(hook, data);
  });
}
__name(executeHook, "executeHook");

// node_modules/@mastra/core/dist/chunk-PJKCPRYF.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-GSQD3QNR.js
init_chunk_PZUZNPFM();
init_chunk_VQASQG5D();
init_chunk_UXG7PYML();
init_zod();
var import_api5 = __toESM(require_src(), 1);
import EventEmitter2, { EventEmitter as EventEmitter$1 } from "events";
import { ReadableStream as ReadableStream$1, TransformStream as TransformStream3, WritableStream as WritableStream$1 } from "stream/web";
import * as crypto2 from "crypto";
import { randomUUID as randomUUID3 } from "crypto";

// node_modules/@ai-sdk/provider-v5/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var marker50 = "vercel.ai.error";
var symbol51 = Symbol.for(marker50);
var _a51;
var _AISDKError23 = class _AISDKError24 extends Error {
  static {
    __name(this, "_AISDKError");
  }
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a51] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error87) {
    return _AISDKError24.hasMarker(error87, marker50);
  }
  static hasMarker(error87, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error87 != null && typeof error87 === "object" && markerSymbol in error87 && typeof error87[markerSymbol] === "boolean" && error87[markerSymbol] === true;
  }
};
_a51 = symbol51;
var AISDKError12 = _AISDKError23;
var name50 = "AI_APICallError";
var marker215 = `vercel.ai.error.${name50}`;
var symbol216 = Symbol.for(marker215);
var _a216;
_a216 = symbol216;
var name215 = "AI_EmptyResponseBodyError";
var marker314 = `vercel.ai.error.${name215}`;
var symbol314 = Symbol.for(marker314);
var _a314;
_a314 = symbol314;
function getErrorMessage13(error87) {
  if (error87 == null) {
    return "unknown error";
  }
  if (typeof error87 === "string") {
    return error87;
  }
  if (error87 instanceof Error) {
    return error87.message;
  }
  return JSON.stringify(error87);
}
__name(getErrorMessage13, "getErrorMessage");
var name314 = "AI_InvalidArgumentError";
var marker414 = `vercel.ai.error.${name314}`;
var symbol414 = Symbol.for(marker414);
var _a414;
_a414 = symbol414;
var name414 = "AI_InvalidPromptError";
var marker514 = `vercel.ai.error.${name414}`;
var symbol514 = Symbol.for(marker514);
var _a514;
_a514 = symbol514;
var name514 = "AI_InvalidResponseDataError";
var marker614 = `vercel.ai.error.${name514}`;
var symbol614 = Symbol.for(marker614);
var _a614;
_a614 = symbol614;
var name614 = "AI_JSONParseError";
var marker714 = `vercel.ai.error.${name614}`;
var symbol714 = Symbol.for(marker714);
var _a714;
_a714 = symbol714;
var name714 = "AI_LoadAPIKeyError";
var marker814 = `vercel.ai.error.${name714}`;
var symbol814 = Symbol.for(marker814);
var _a814;
_a814 = symbol814;
var name814 = "AI_LoadSettingError";
var marker914 = `vercel.ai.error.${name814}`;
var symbol914 = Symbol.for(marker914);
var _a914;
_a914 = symbol914;
var name914 = "AI_NoContentGeneratedError";
var marker1014 = `vercel.ai.error.${name914}`;
var symbol1014 = Symbol.for(marker1014);
var _a1014;
_a1014 = symbol1014;
var name1014 = "AI_NoSuchModelError";
var marker1114 = `vercel.ai.error.${name1014}`;
var symbol1114 = Symbol.for(marker1114);
var _a1114;
_a1114 = symbol1114;
var name1114 = "AI_TooManyEmbeddingValuesForCallError";
var marker1214 = `vercel.ai.error.${name1114}`;
var symbol1214 = Symbol.for(marker1214);
var _a1214;
_a1214 = symbol1214;
var name1214 = "AI_TypeValidationError";
var marker1314 = `vercel.ai.error.${name1214}`;
var symbol1314 = Symbol.for(marker1314);
var _a1314;
var _TypeValidationError20 = class _TypeValidationError21 extends AISDKError12 {
  static {
    __name(this, "_TypeValidationError");
  }
  constructor({ value, cause }) {
    super({
      name: name1214,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage13(cause)}`,
      cause
    });
    this[_a1314] = true;
    this.value = value;
  }
  static isInstance(error87) {
    return AISDKError12.hasMarker(error87, marker1314);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError21.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError21({ value, cause });
  }
};
_a1314 = symbol1314;
var TypeValidationError11 = _TypeValidationError20;
var name1314 = "AI_UnsupportedFunctionalityError";
var marker1414 = `vercel.ai.error.${name1314}`;
var symbol1414 = Symbol.for(marker1414);
var _a1414;
_a1414 = symbol1414;

// node_modules/@sindresorhus/slugify/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/escape-string-regexp/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
function escapeStringRegexp(string7) {
  if (typeof string7 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string7.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
__name(escapeStringRegexp, "escapeStringRegexp");

// node_modules/@sindresorhus/transliterate/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@sindresorhus/transliterate/replacements.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var replacements = [
  // German umlauts
  ["\xDF", "ss"],
  ["\u1E9E", "Ss"],
  ["\xE4", "ae"],
  ["\xC4", "Ae"],
  ["\xF6", "oe"],
  ["\xD6", "Oe"],
  ["\xFC", "ue"],
  ["\xDC", "Ue"],
  // Latin
  ["\xC0", "A"],
  ["\xC1", "A"],
  ["\xC2", "A"],
  ["\xC3", "A"],
  ["\xC4", "Ae"],
  ["\xC5", "A"],
  ["\xC6", "AE"],
  ["\xC7", "C"],
  ["\xC8", "E"],
  ["\xC9", "E"],
  ["\xCA", "E"],
  ["\xCB", "E"],
  ["\xCC", "I"],
  ["\xCD", "I"],
  ["\xCE", "I"],
  ["\xCF", "I"],
  ["\xD0", "D"],
  ["\xD1", "N"],
  ["\xD2", "O"],
  ["\xD3", "O"],
  ["\xD4", "O"],
  ["\xD5", "O"],
  ["\xD6", "Oe"],
  ["\u0150", "O"],
  ["\xD8", "O"],
  ["\xD9", "U"],
  ["\xDA", "U"],
  ["\xDB", "U"],
  ["\xDC", "Ue"],
  ["\u0170", "U"],
  ["\xDD", "Y"],
  ["\xDE", "TH"],
  ["\xDF", "ss"],
  ["\xE0", "a"],
  ["\xE1", "a"],
  ["\xE2", "a"],
  ["\xE3", "a"],
  ["\xE4", "ae"],
  ["\xE5", "a"],
  ["\xE6", "ae"],
  ["\xE7", "c"],
  ["\xE8", "e"],
  ["\xE9", "e"],
  ["\xEA", "e"],
  ["\xEB", "e"],
  ["\xEC", "i"],
  ["\xED", "i"],
  ["\xEE", "i"],
  ["\xEF", "i"],
  ["\xF0", "d"],
  ["\xF1", "n"],
  ["\xF2", "o"],
  ["\xF3", "o"],
  ["\xF4", "o"],
  ["\xF5", "o"],
  ["\xF6", "oe"],
  ["\u0151", "o"],
  ["\xF8", "o"],
  ["\xF9", "u"],
  ["\xFA", "u"],
  ["\xFB", "u"],
  ["\xFC", "ue"],
  ["\u0171", "u"],
  ["\xFD", "y"],
  ["\xFE", "th"],
  ["\xFF", "y"],
  ["\u1E9E", "SS"],
  // Vietnamese
  ["\xE0", "a"],
  ["\xC0", "A"],
  ["\xE1", "a"],
  ["\xC1", "A"],
  ["\xE2", "a"],
  ["\xC2", "A"],
  ["\xE3", "a"],
  ["\xC3", "A"],
  ["\xE8", "e"],
  ["\xC8", "E"],
  ["\xE9", "e"],
  ["\xC9", "E"],
  ["\xEA", "e"],
  ["\xCA", "E"],
  ["\xEC", "i"],
  ["\xCC", "I"],
  ["\xED", "i"],
  ["\xCD", "I"],
  ["\xF2", "o"],
  ["\xD2", "O"],
  ["\xF3", "o"],
  ["\xD3", "O"],
  ["\xF4", "o"],
  ["\xD4", "O"],
  ["\xF5", "o"],
  ["\xD5", "O"],
  ["\xF9", "u"],
  ["\xD9", "U"],
  ["\xFA", "u"],
  ["\xDA", "U"],
  ["\xFD", "y"],
  ["\xDD", "Y"],
  ["\u0103", "a"],
  ["\u0102", "A"],
  ["\u0110", "D"],
  ["\u0111", "d"],
  ["\u0129", "i"],
  ["\u0128", "I"],
  ["\u0169", "u"],
  ["\u0168", "U"],
  ["\u01A1", "o"],
  ["\u01A0", "O"],
  ["\u01B0", "u"],
  ["\u01AF", "U"],
  ["\u1EA1", "a"],
  ["\u1EA0", "A"],
  ["\u1EA3", "a"],
  ["\u1EA2", "A"],
  ["\u1EA5", "a"],
  ["\u1EA4", "A"],
  ["\u1EA7", "a"],
  ["\u1EA6", "A"],
  ["\u1EA9", "a"],
  ["\u1EA8", "A"],
  ["\u1EAB", "a"],
  ["\u1EAA", "A"],
  ["\u1EAD", "a"],
  ["\u1EAC", "A"],
  ["\u1EAF", "a"],
  ["\u1EAE", "A"],
  ["\u1EB1", "a"],
  ["\u1EB0", "A"],
  ["\u1EB3", "a"],
  ["\u1EB2", "A"],
  ["\u1EB5", "a"],
  ["\u1EB4", "A"],
  ["\u1EB7", "a"],
  ["\u1EB6", "A"],
  ["\u1EB9", "e"],
  ["\u1EB8", "E"],
  ["\u1EBB", "e"],
  ["\u1EBA", "E"],
  ["\u1EBD", "e"],
  ["\u1EBC", "E"],
  ["\u1EBF", "e"],
  ["\u1EBE", "E"],
  ["\u1EC1", "e"],
  ["\u1EC0", "E"],
  ["\u1EC3", "e"],
  ["\u1EC2", "E"],
  ["\u1EC5", "e"],
  ["\u1EC4", "E"],
  ["\u1EC7", "e"],
  ["\u1EC6", "E"],
  ["\u1EC9", "i"],
  ["\u1EC8", "I"],
  ["\u1ECB", "i"],
  ["\u1ECA", "I"],
  ["\u1ECD", "o"],
  ["\u1ECC", "O"],
  ["\u1ECF", "o"],
  ["\u1ECE", "O"],
  ["\u1ED1", "o"],
  ["\u1ED0", "O"],
  ["\u1ED3", "o"],
  ["\u1ED2", "O"],
  ["\u1ED5", "o"],
  ["\u1ED4", "O"],
  ["\u1ED7", "o"],
  ["\u1ED6", "O"],
  ["\u1ED9", "o"],
  ["\u1ED8", "O"],
  ["\u1EDB", "o"],
  ["\u1EDA", "O"],
  ["\u1EDD", "o"],
  ["\u1EDC", "O"],
  ["\u1EDF", "o"],
  ["\u1EDE", "O"],
  ["\u1EE1", "o"],
  ["\u1EE0", "O"],
  ["\u1EE3", "o"],
  ["\u1EE2", "O"],
  ["\u1EE5", "u"],
  ["\u1EE4", "U"],
  ["\u1EE7", "u"],
  ["\u1EE6", "U"],
  ["\u1EE9", "u"],
  ["\u1EE8", "U"],
  ["\u1EEB", "u"],
  ["\u1EEA", "U"],
  ["\u1EED", "u"],
  ["\u1EEC", "U"],
  ["\u1EEF", "u"],
  ["\u1EEE", "U"],
  ["\u1EF1", "u"],
  ["\u1EF0", "U"],
  ["\u1EF3", "y"],
  ["\u1EF2", "Y"],
  ["\u1EF5", "y"],
  ["\u1EF4", "Y"],
  ["\u1EF7", "y"],
  ["\u1EF6", "Y"],
  ["\u1EF9", "y"],
  ["\u1EF8", "Y"],
  // Arabic
  ["\u0621", "e"],
  ["\u0622", "a"],
  ["\u0623", "a"],
  ["\u0624", "w"],
  ["\u0625", "i"],
  ["\u0626", "y"],
  ["\u0627", "a"],
  ["\u0628", "b"],
  ["\u0629", "t"],
  ["\u062A", "t"],
  ["\u062B", "th"],
  ["\u062C", "j"],
  ["\u062D", "h"],
  ["\u062E", "kh"],
  ["\u062F", "d"],
  ["\u0630", "dh"],
  ["\u0631", "r"],
  ["\u0632", "z"],
  ["\u0633", "s"],
  ["\u0634", "sh"],
  ["\u0635", "s"],
  ["\u0636", "d"],
  ["\u0637", "t"],
  ["\u0638", "z"],
  ["\u0639", "e"],
  ["\u063A", "gh"],
  ["\u0640", "_"],
  ["\u0641", "f"],
  ["\u0642", "q"],
  ["\u0643", "k"],
  ["\u0644", "l"],
  ["\u0645", "m"],
  ["\u0646", "n"],
  ["\u0647", "h"],
  ["\u0648", "w"],
  ["\u0649", "a"],
  ["\u064A", "y"],
  ["\u064E\u200E", "a"],
  ["\u064F", "u"],
  ["\u0650\u200E", "i"],
  ["\u0660", "0"],
  ["\u0661", "1"],
  ["\u0662", "2"],
  ["\u0663", "3"],
  ["\u0664", "4"],
  ["\u0665", "5"],
  ["\u0666", "6"],
  ["\u0667", "7"],
  ["\u0668", "8"],
  ["\u0669", "9"],
  // Persian / Farsi
  ["\u0686", "ch"],
  ["\u06A9", "k"],
  ["\u06AF", "g"],
  ["\u067E", "p"],
  ["\u0698", "zh"],
  ["\u06CC", "y"],
  ["\u06F0", "0"],
  ["\u06F1", "1"],
  ["\u06F2", "2"],
  ["\u06F3", "3"],
  ["\u06F4", "4"],
  ["\u06F5", "5"],
  ["\u06F6", "6"],
  ["\u06F7", "7"],
  ["\u06F8", "8"],
  ["\u06F9", "9"],
  // Pashto
  ["\u067C", "p"],
  ["\u0681", "z"],
  ["\u0685", "c"],
  ["\u0689", "d"],
  ["\uFEAB", "d"],
  ["\uFEAD", "r"],
  ["\u0693", "r"],
  ["\uFEAF", "z"],
  ["\u0696", "g"],
  ["\u069A", "x"],
  ["\u06AB", "g"],
  ["\u06BC", "n"],
  ["\u06C0", "e"],
  ["\u06D0", "e"],
  ["\u06CD", "ai"],
  // Urdu
  ["\u0679", "t"],
  ["\u0688", "d"],
  ["\u0691", "r"],
  ["\u06BA", "n"],
  ["\u06C1", "h"],
  ["\u06BE", "h"],
  ["\u06D2", "e"],
  // Russian
  ["\u0410", "A"],
  ["\u0430", "a"],
  ["\u0411", "B"],
  ["\u0431", "b"],
  ["\u0412", "V"],
  ["\u0432", "v"],
  ["\u0413", "G"],
  ["\u0433", "g"],
  ["\u0414", "D"],
  ["\u0434", "d"],
  ["\u044A\u0435", "ye"],
  ["\u042A\u0435", "Ye"],
  ["\u044A\u0415", "yE"],
  ["\u042A\u0415", "YE"],
  ["\u0415", "E"],
  ["\u0435", "e"],
  ["\u0401", "Yo"],
  ["\u0451", "yo"],
  ["\u0416", "Zh"],
  ["\u0436", "zh"],
  ["\u0417", "Z"],
  ["\u0437", "z"],
  ["\u0418", "I"],
  ["\u0438", "i"],
  ["\u044B\u0439", "iy"],
  ["\u042B\u0439", "Iy"],
  ["\u042B\u0419", "IY"],
  ["\u044B\u0419", "iY"],
  ["\u0419", "Y"],
  ["\u0439", "y"],
  ["\u041A", "K"],
  ["\u043A", "k"],
  ["\u041B", "L"],
  ["\u043B", "l"],
  ["\u041C", "M"],
  ["\u043C", "m"],
  ["\u041D", "N"],
  ["\u043D", "n"],
  ["\u041E", "O"],
  ["\u043E", "o"],
  ["\u041F", "P"],
  ["\u043F", "p"],
  ["\u0420", "R"],
  ["\u0440", "r"],
  ["\u0421", "S"],
  ["\u0441", "s"],
  ["\u0422", "T"],
  ["\u0442", "t"],
  ["\u0423", "U"],
  ["\u0443", "u"],
  ["\u0424", "F"],
  ["\u0444", "f"],
  ["\u0425", "Kh"],
  ["\u0445", "kh"],
  ["\u0426", "Ts"],
  ["\u0446", "ts"],
  ["\u0427", "Ch"],
  ["\u0447", "ch"],
  ["\u0428", "Sh"],
  ["\u0448", "sh"],
  ["\u0429", "Sch"],
  ["\u0449", "sch"],
  ["\u042A", ""],
  ["\u044A", ""],
  ["\u042B", "Y"],
  ["\u044B", "y"],
  ["\u042C", ""],
  ["\u044C", ""],
  ["\u042D", "E"],
  ["\u044D", "e"],
  ["\u042E", "Yu"],
  ["\u044E", "yu"],
  ["\u042F", "Ya"],
  ["\u044F", "ya"],
  // Romanian
  ["\u0103", "a"],
  ["\u0102", "A"],
  ["\u0219", "s"],
  ["\u0218", "S"],
  ["\u021B", "t"],
  ["\u021A", "T"],
  ["\u0163", "t"],
  ["\u0162", "T"],
  // Turkish
  ["\u015F", "s"],
  ["\u015E", "S"],
  ["\xE7", "c"],
  ["\xC7", "C"],
  ["\u011F", "g"],
  ["\u011E", "G"],
  ["\u0131", "i"],
  ["\u0130", "I"],
  // Armenian
  ["\u0561", "a"],
  ["\u0531", "A"],
  ["\u0562", "b"],
  ["\u0532", "B"],
  ["\u0563", "g"],
  ["\u0533", "G"],
  ["\u0564", "d"],
  ["\u0534", "D"],
  ["\u0565", "ye"],
  ["\u0535", "Ye"],
  ["\u0566", "z"],
  ["\u0536", "Z"],
  ["\u0567", "e"],
  ["\u0537", "E"],
  ["\u0568", "y"],
  ["\u0538", "Y"],
  ["\u0569", "t"],
  ["\u0539", "T"],
  ["\u056A", "zh"],
  ["\u053A", "Zh"],
  ["\u056B", "i"],
  ["\u053B", "I"],
  ["\u056C", "l"],
  ["\u053C", "L"],
  ["\u056D", "kh"],
  ["\u053D", "Kh"],
  ["\u056E", "ts"],
  ["\u053E", "Ts"],
  ["\u056F", "k"],
  ["\u053F", "K"],
  ["\u0570", "h"],
  ["\u0540", "H"],
  ["\u0571", "dz"],
  ["\u0541", "Dz"],
  ["\u0572", "gh"],
  ["\u0542", "Gh"],
  ["\u0573", "tch"],
  ["\u0543", "Tch"],
  ["\u0574", "m"],
  ["\u0544", "M"],
  ["\u0575", "y"],
  ["\u0545", "Y"],
  ["\u0576", "n"],
  ["\u0546", "N"],
  ["\u0577", "sh"],
  ["\u0547", "Sh"],
  ["\u0578", "vo"],
  ["\u0548", "Vo"],
  ["\u0579", "ch"],
  ["\u0549", "Ch"],
  ["\u057A", "p"],
  ["\u054A", "P"],
  ["\u057B", "j"],
  ["\u054B", "J"],
  ["\u057C", "r"],
  ["\u054C", "R"],
  ["\u057D", "s"],
  ["\u054D", "S"],
  ["\u057E", "v"],
  ["\u054E", "V"],
  ["\u057F", "t"],
  ["\u054F", "T"],
  ["\u0580", "r"],
  ["\u0550", "R"],
  ["\u0581", "c"],
  ["\u0551", "C"],
  ["\u0578\u0582", "u"],
  ["\u0548\u0552", "U"],
  ["\u0548\u0582", "U"],
  ["\u0583", "p"],
  ["\u0553", "P"],
  ["\u0584", "q"],
  ["\u0554", "Q"],
  ["\u0585", "o"],
  ["\u0555", "O"],
  ["\u0586", "f"],
  ["\u0556", "F"],
  ["\u0587", "yev"],
  // Georgian
  ["\u10D0", "a"],
  ["\u10D1", "b"],
  ["\u10D2", "g"],
  ["\u10D3", "d"],
  ["\u10D4", "e"],
  ["\u10D5", "v"],
  ["\u10D6", "z"],
  ["\u10D7", "t"],
  ["\u10D8", "i"],
  ["\u10D9", "k"],
  ["\u10DA", "l"],
  ["\u10DB", "m"],
  ["\u10DC", "n"],
  ["\u10DD", "o"],
  ["\u10DE", "p"],
  ["\u10DF", "zh"],
  ["\u10E0", "r"],
  ["\u10E1", "s"],
  ["\u10E2", "t"],
  ["\u10E3", "u"],
  ["\u10E4", "ph"],
  ["\u10E5", "q"],
  ["\u10E6", "gh"],
  ["\u10E7", "k"],
  ["\u10E8", "sh"],
  ["\u10E9", "ch"],
  ["\u10EA", "ts"],
  ["\u10EB", "dz"],
  ["\u10EC", "ts"],
  ["\u10ED", "tch"],
  ["\u10EE", "kh"],
  ["\u10EF", "j"],
  ["\u10F0", "h"],
  // Czech
  ["\u010D", "c"],
  ["\u010F", "d"],
  ["\u011B", "e"],
  ["\u0148", "n"],
  ["\u0159", "r"],
  ["\u0161", "s"],
  ["\u0165", "t"],
  ["\u016F", "u"],
  ["\u017E", "z"],
  ["\u010C", "C"],
  ["\u010E", "D"],
  ["\u011A", "E"],
  ["\u0147", "N"],
  ["\u0158", "R"],
  ["\u0160", "S"],
  ["\u0164", "T"],
  ["\u016E", "U"],
  ["\u017D", "Z"],
  // Dhivehi
  ["\u0780", "h"],
  ["\u0781", "sh"],
  ["\u0782", "n"],
  ["\u0783", "r"],
  ["\u0784", "b"],
  ["\u0785", "lh"],
  ["\u0786", "k"],
  ["\u0787", "a"],
  ["\u0788", "v"],
  ["\u0789", "m"],
  ["\u078A", "f"],
  ["\u078B", "dh"],
  ["\u078C", "th"],
  ["\u078D", "l"],
  ["\u078E", "g"],
  ["\u078F", "gn"],
  ["\u0790", "s"],
  ["\u0791", "d"],
  ["\u0792", "z"],
  ["\u0793", "t"],
  ["\u0794", "y"],
  ["\u0795", "p"],
  ["\u0796", "j"],
  ["\u0797", "ch"],
  ["\u0798", "tt"],
  ["\u0799", "hh"],
  ["\u079A", "kh"],
  ["\u079B", "th"],
  ["\u079C", "z"],
  ["\u079D", "sh"],
  ["\u079E", "s"],
  ["\u079F", "d"],
  ["\u07A0", "t"],
  ["\u07A1", "z"],
  ["\u07A2", "a"],
  ["\u07A3", "gh"],
  ["\u07A4", "q"],
  ["\u07A5", "w"],
  ["\u07A6", "a"],
  ["\u07A7", "aa"],
  ["\u07A8", "i"],
  ["\u07A9", "ee"],
  ["\u07AA", "u"],
  ["\u07AB", "oo"],
  ["\u07AC", "e"],
  ["\u07AD", "ey"],
  ["\u07AE", "o"],
  ["\u07AF", "oa"],
  ["\u07B0", ""],
  // Greek
  ["\u03B1", "a"],
  ["\u03B2", "v"],
  ["\u03B3", "g"],
  ["\u03B4", "d"],
  ["\u03B5", "e"],
  ["\u03B6", "z"],
  ["\u03B7", "i"],
  ["\u03B8", "th"],
  ["\u03B9", "i"],
  ["\u03BA", "k"],
  ["\u03BB", "l"],
  ["\u03BC", "m"],
  ["\u03BD", "n"],
  ["\u03BE", "ks"],
  ["\u03BF", "o"],
  ["\u03C0", "p"],
  ["\u03C1", "r"],
  ["\u03C3", "s"],
  ["\u03C4", "t"],
  ["\u03C5", "y"],
  ["\u03C6", "f"],
  ["\u03C7", "x"],
  ["\u03C8", "ps"],
  ["\u03C9", "o"],
  ["\u03AC", "a"],
  ["\u03AD", "e"],
  ["\u03AF", "i"],
  ["\u03CC", "o"],
  ["\u03CD", "y"],
  ["\u03AE", "i"],
  ["\u03CE", "o"],
  ["\u03C2", "s"],
  ["\u03CA", "i"],
  ["\u03B0", "y"],
  ["\u03CB", "y"],
  ["\u0390", "i"],
  ["\u0391", "A"],
  ["\u0392", "B"],
  ["\u0393", "G"],
  ["\u0394", "D"],
  ["\u0395", "E"],
  ["\u0396", "Z"],
  ["\u0397", "I"],
  ["\u0398", "TH"],
  ["\u0399", "I"],
  ["\u039A", "K"],
  ["\u039B", "L"],
  ["\u039C", "M"],
  ["\u039D", "N"],
  ["\u039E", "KS"],
  ["\u039F", "O"],
  ["\u03A0", "P"],
  ["\u03A1", "R"],
  ["\u03A3", "S"],
  ["\u03A4", "T"],
  ["\u03A5", "Y"],
  ["\u03A6", "F"],
  ["\u03A7", "X"],
  ["\u03A8", "PS"],
  ["\u03A9", "O"],
  ["\u0386", "A"],
  ["\u0388", "E"],
  ["\u038A", "I"],
  ["\u038C", "O"],
  ["\u038E", "Y"],
  ["\u0389", "I"],
  ["\u038F", "O"],
  ["\u03AA", "I"],
  ["\u03AB", "Y"],
  // Disabled as it conflicts with German and Latin.
  // Hungarian
  // ['', 'a'],
  // ['', 'A'],
  // ['', 'o'],
  // ['', 'O'],
  // ['', 'u'],
  // ['', 'U'],
  // ['', 'u'],
  // ['', 'U'],
  // Latvian
  ["\u0101", "a"],
  ["\u0113", "e"],
  ["\u0123", "g"],
  ["\u012B", "i"],
  ["\u0137", "k"],
  ["\u013C", "l"],
  ["\u0146", "n"],
  ["\u016B", "u"],
  ["\u0100", "A"],
  ["\u0112", "E"],
  ["\u0122", "G"],
  ["\u012A", "I"],
  ["\u0136", "K"],
  ["\u013B", "L"],
  ["\u0145", "N"],
  ["\u016A", "U"],
  ["\u010D", "c"],
  ["\u0161", "s"],
  ["\u017E", "z"],
  ["\u010C", "C"],
  ["\u0160", "S"],
  ["\u017D", "Z"],
  // Lithuanian
  ["\u0105", "a"],
  ["\u010D", "c"],
  ["\u0119", "e"],
  ["\u0117", "e"],
  ["\u012F", "i"],
  ["\u0161", "s"],
  ["\u0173", "u"],
  ["\u016B", "u"],
  ["\u017E", "z"],
  ["\u0104", "A"],
  ["\u010C", "C"],
  ["\u0118", "E"],
  ["\u0116", "E"],
  ["\u012E", "I"],
  ["\u0160", "S"],
  ["\u0172", "U"],
  ["\u016A", "U"],
  // Macedonian
  ["\u040C", "Kj"],
  ["\u045C", "kj"],
  ["\u0409", "Lj"],
  ["\u0459", "lj"],
  ["\u040A", "Nj"],
  ["\u045A", "nj"],
  ["\u0422\u0441", "Ts"],
  ["\u0442\u0441", "ts"],
  // Polish
  ["\u0105", "a"],
  ["\u0107", "c"],
  ["\u0119", "e"],
  ["\u0142", "l"],
  ["\u0144", "n"],
  ["\u015B", "s"],
  ["\u017A", "z"],
  ["\u017C", "z"],
  ["\u0104", "A"],
  ["\u0106", "C"],
  ["\u0118", "E"],
  ["\u0141", "L"],
  ["\u0143", "N"],
  ["\u015A", "S"],
  ["\u0179", "Z"],
  ["\u017B", "Z"],
  // Disabled as it conflicts with Vietnamese.
  // Serbian
  // ['', 'lj'],
  // ['', 'nj'],
  // ['', 'Lj'],
  // ['', 'Nj'],
  // ['', 'dj'],
  // ['', 'Dj'],
  // ['', 'dj'],
  // ['', 'j'],
  // ['', 'c'],
  // ['', 'dz'],
  // ['', 'Dj'],
  // ['', 'j'],
  // ['', 'C'],
  // ['', 'Dz'],
  // Disabled as it conflicts with German and Latin.
  // Slovak
  // ['', 'a'],
  // ['', 'A'],
  // ['', 'l'],
  // ['', 'l'],
  // ['', 'r'],
  // ['', 'L'],
  // ['', 'L'],
  // ['', 'R'],
  // Disabled as it conflicts with German and Latin.
  // Swedish
  // ['', 'o'],
  // ['', 'o'],
  // ['', 'a'],
  // ['', 'A'],
  // ['', 'e'],
  // ['', 'E'],
  // ['', 'o'],
  // ['', 'O'],
  // Ukrainian
  ["\u0404", "Ye"],
  ["\u0406", "I"],
  ["\u0407", "Yi"],
  ["\u0490", "G"],
  ["\u0454", "ye"],
  ["\u0456", "i"],
  ["\u0457", "yi"],
  ["\u0491", "g"],
  // Dutch
  ["\u0132", "IJ"],
  ["\u0133", "ij"],
  // Danish
  // ['', 'Ae'],
  // ['', 'Oe'],
  // ['', 'Aa'],
  // ['', 'ae'],
  // ['', 'oe'],
  // ['', 'aa']
  // Currencies
  ["\xA2", "c"],
  ["\xA5", "Y"],
  ["\u07FF", "b"],
  ["\u09F3", "t"],
  ["\u0AF1", "Bo"],
  ["\u0E3F", "B"],
  ["\u20A0", "CE"],
  ["\u20A1", "C"],
  ["\u20A2", "Cr"],
  ["\u20A3", "F"],
  ["\u20A5", "m"],
  ["\u20A6", "N"],
  ["\u20A7", "Pt"],
  ["\u20A8", "Rs"],
  ["\u20A9", "W"],
  ["\u20AB", "s"],
  ["\u20AC", "E"],
  ["\u20AD", "K"],
  ["\u20AE", "T"],
  ["\u20AF", "Dp"],
  ["\u20B0", "S"],
  ["\u20B1", "P"],
  ["\u20B2", "G"],
  ["\u20B3", "A"],
  ["\u20B4", "S"],
  ["\u20B5", "C"],
  ["\u20B6", "tt"],
  ["\u20B7", "S"],
  ["\u20B8", "T"],
  ["\u20B9", "R"],
  ["\u20BA", "L"],
  ["\u20BD", "P"],
  ["\u20BF", "B"],
  ["\uFE69", "$"],
  ["\uFFE0", "c"],
  ["\uFFE5", "Y"],
  ["\uFFE6", "W"],
  // Latin
  ["\u{1D400}", "A"],
  ["\u{1D401}", "B"],
  ["\u{1D402}", "C"],
  ["\u{1D403}", "D"],
  ["\u{1D404}", "E"],
  ["\u{1D405}", "F"],
  ["\u{1D406}", "G"],
  ["\u{1D407}", "H"],
  ["\u{1D408}", "I"],
  ["\u{1D409}", "J"],
  ["\u{1D40A}", "K"],
  ["\u{1D40B}", "L"],
  ["\u{1D40C}", "M"],
  ["\u{1D40D}", "N"],
  ["\u{1D40E}", "O"],
  ["\u{1D40F}", "P"],
  ["\u{1D410}", "Q"],
  ["\u{1D411}", "R"],
  ["\u{1D412}", "S"],
  ["\u{1D413}", "T"],
  ["\u{1D414}", "U"],
  ["\u{1D415}", "V"],
  ["\u{1D416}", "W"],
  ["\u{1D417}", "X"],
  ["\u{1D418}", "Y"],
  ["\u{1D419}", "Z"],
  ["\u{1D41A}", "a"],
  ["\u{1D41B}", "b"],
  ["\u{1D41C}", "c"],
  ["\u{1D41D}", "d"],
  ["\u{1D41E}", "e"],
  ["\u{1D41F}", "f"],
  ["\u{1D420}", "g"],
  ["\u{1D421}", "h"],
  ["\u{1D422}", "i"],
  ["\u{1D423}", "j"],
  ["\u{1D424}", "k"],
  ["\u{1D425}", "l"],
  ["\u{1D426}", "m"],
  ["\u{1D427}", "n"],
  ["\u{1D428}", "o"],
  ["\u{1D429}", "p"],
  ["\u{1D42A}", "q"],
  ["\u{1D42B}", "r"],
  ["\u{1D42C}", "s"],
  ["\u{1D42D}", "t"],
  ["\u{1D42E}", "u"],
  ["\u{1D42F}", "v"],
  ["\u{1D430}", "w"],
  ["\u{1D431}", "x"],
  ["\u{1D432}", "y"],
  ["\u{1D433}", "z"],
  ["\u{1D434}", "A"],
  ["\u{1D435}", "B"],
  ["\u{1D436}", "C"],
  ["\u{1D437}", "D"],
  ["\u{1D438}", "E"],
  ["\u{1D439}", "F"],
  ["\u{1D43A}", "G"],
  ["\u{1D43B}", "H"],
  ["\u{1D43C}", "I"],
  ["\u{1D43D}", "J"],
  ["\u{1D43E}", "K"],
  ["\u{1D43F}", "L"],
  ["\u{1D440}", "M"],
  ["\u{1D441}", "N"],
  ["\u{1D442}", "O"],
  ["\u{1D443}", "P"],
  ["\u{1D444}", "Q"],
  ["\u{1D445}", "R"],
  ["\u{1D446}", "S"],
  ["\u{1D447}", "T"],
  ["\u{1D448}", "U"],
  ["\u{1D449}", "V"],
  ["\u{1D44A}", "W"],
  ["\u{1D44B}", "X"],
  ["\u{1D44C}", "Y"],
  ["\u{1D44D}", "Z"],
  ["\u{1D44E}", "a"],
  ["\u{1D44F}", "b"],
  ["\u{1D450}", "c"],
  ["\u{1D451}", "d"],
  ["\u{1D452}", "e"],
  ["\u{1D453}", "f"],
  ["\u{1D454}", "g"],
  ["\u{1D456}", "i"],
  ["\u{1D457}", "j"],
  ["\u{1D458}", "k"],
  ["\u{1D459}", "l"],
  ["\u{1D45A}", "m"],
  ["\u{1D45B}", "n"],
  ["\u{1D45C}", "o"],
  ["\u{1D45D}", "p"],
  ["\u{1D45E}", "q"],
  ["\u{1D45F}", "r"],
  ["\u{1D460}", "s"],
  ["\u{1D461}", "t"],
  ["\u{1D462}", "u"],
  ["\u{1D463}", "v"],
  ["\u{1D464}", "w"],
  ["\u{1D465}", "x"],
  ["\u{1D466}", "y"],
  ["\u{1D467}", "z"],
  ["\u{1D468}", "A"],
  ["\u{1D469}", "B"],
  ["\u{1D46A}", "C"],
  ["\u{1D46B}", "D"],
  ["\u{1D46C}", "E"],
  ["\u{1D46D}", "F"],
  ["\u{1D46E}", "G"],
  ["\u{1D46F}", "H"],
  ["\u{1D470}", "I"],
  ["\u{1D471}", "J"],
  ["\u{1D472}", "K"],
  ["\u{1D473}", "L"],
  ["\u{1D474}", "M"],
  ["\u{1D475}", "N"],
  ["\u{1D476}", "O"],
  ["\u{1D477}", "P"],
  ["\u{1D478}", "Q"],
  ["\u{1D479}", "R"],
  ["\u{1D47A}", "S"],
  ["\u{1D47B}", "T"],
  ["\u{1D47C}", "U"],
  ["\u{1D47D}", "V"],
  ["\u{1D47E}", "W"],
  ["\u{1D47F}", "X"],
  ["\u{1D480}", "Y"],
  ["\u{1D481}", "Z"],
  ["\u{1D482}", "a"],
  ["\u{1D483}", "b"],
  ["\u{1D484}", "c"],
  ["\u{1D485}", "d"],
  ["\u{1D486}", "e"],
  ["\u{1D487}", "f"],
  ["\u{1D488}", "g"],
  ["\u{1D489}", "h"],
  ["\u{1D48A}", "i"],
  ["\u{1D48B}", "j"],
  ["\u{1D48C}", "k"],
  ["\u{1D48D}", "l"],
  ["\u{1D48E}", "m"],
  ["\u{1D48F}", "n"],
  ["\u{1D490}", "o"],
  ["\u{1D491}", "p"],
  ["\u{1D492}", "q"],
  ["\u{1D493}", "r"],
  ["\u{1D494}", "s"],
  ["\u{1D495}", "t"],
  ["\u{1D496}", "u"],
  ["\u{1D497}", "v"],
  ["\u{1D498}", "w"],
  ["\u{1D499}", "x"],
  ["\u{1D49A}", "y"],
  ["\u{1D49B}", "z"],
  ["\u{1D49C}", "A"],
  ["\u{1D49E}", "C"],
  ["\u{1D49F}", "D"],
  ["\u{1D4A2}", "g"],
  ["\u{1D4A5}", "J"],
  ["\u{1D4A6}", "K"],
  ["\u{1D4A9}", "N"],
  ["\u{1D4AA}", "O"],
  ["\u{1D4AB}", "P"],
  ["\u{1D4AC}", "Q"],
  ["\u{1D4AE}", "S"],
  ["\u{1D4AF}", "T"],
  ["\u{1D4B0}", "U"],
  ["\u{1D4B1}", "V"],
  ["\u{1D4B2}", "W"],
  ["\u{1D4B3}", "X"],
  ["\u{1D4B4}", "Y"],
  ["\u{1D4B5}", "Z"],
  ["\u{1D4B6}", "a"],
  ["\u{1D4B7}", "b"],
  ["\u{1D4B8}", "c"],
  ["\u{1D4B9}", "d"],
  ["\u{1D4BB}", "f"],
  ["\u{1D4BD}", "h"],
  ["\u{1D4BE}", "i"],
  ["\u{1D4BF}", "j"],
  ["\u{1D4C0}", "h"],
  ["\u{1D4C1}", "l"],
  ["\u{1D4C2}", "m"],
  ["\u{1D4C3}", "n"],
  ["\u{1D4C5}", "p"],
  ["\u{1D4C6}", "q"],
  ["\u{1D4C7}", "r"],
  ["\u{1D4C8}", "s"],
  ["\u{1D4C9}", "t"],
  ["\u{1D4CA}", "u"],
  ["\u{1D4CB}", "v"],
  ["\u{1D4CC}", "w"],
  ["\u{1D4CD}", "x"],
  ["\u{1D4CE}", "y"],
  ["\u{1D4CF}", "z"],
  ["\u{1D4D0}", "A"],
  ["\u{1D4D1}", "B"],
  ["\u{1D4D2}", "C"],
  ["\u{1D4D3}", "D"],
  ["\u{1D4D4}", "E"],
  ["\u{1D4D5}", "F"],
  ["\u{1D4D6}", "G"],
  ["\u{1D4D7}", "H"],
  ["\u{1D4D8}", "I"],
  ["\u{1D4D9}", "J"],
  ["\u{1D4DA}", "K"],
  ["\u{1D4DB}", "L"],
  ["\u{1D4DC}", "M"],
  ["\u{1D4DD}", "N"],
  ["\u{1D4DE}", "O"],
  ["\u{1D4DF}", "P"],
  ["\u{1D4E0}", "Q"],
  ["\u{1D4E1}", "R"],
  ["\u{1D4E2}", "S"],
  ["\u{1D4E3}", "T"],
  ["\u{1D4E4}", "U"],
  ["\u{1D4E5}", "V"],
  ["\u{1D4E6}", "W"],
  ["\u{1D4E7}", "X"],
  ["\u{1D4E8}", "Y"],
  ["\u{1D4E9}", "Z"],
  ["\u{1D4EA}", "a"],
  ["\u{1D4EB}", "b"],
  ["\u{1D4EC}", "c"],
  ["\u{1D4ED}", "d"],
  ["\u{1D4EE}", "e"],
  ["\u{1D4EF}", "f"],
  ["\u{1D4F0}", "g"],
  ["\u{1D4F1}", "h"],
  ["\u{1D4F2}", "i"],
  ["\u{1D4F3}", "j"],
  ["\u{1D4F4}", "k"],
  ["\u{1D4F5}", "l"],
  ["\u{1D4F6}", "m"],
  ["\u{1D4F7}", "n"],
  ["\u{1D4F8}", "o"],
  ["\u{1D4F9}", "p"],
  ["\u{1D4FA}", "q"],
  ["\u{1D4FB}", "r"],
  ["\u{1D4FC}", "s"],
  ["\u{1D4FD}", "t"],
  ["\u{1D4FE}", "u"],
  ["\u{1D4FF}", "v"],
  ["\u{1D500}", "w"],
  ["\u{1D501}", "x"],
  ["\u{1D502}", "y"],
  ["\u{1D503}", "z"],
  ["\u{1D504}", "A"],
  ["\u{1D505}", "B"],
  ["\u{1D507}", "D"],
  ["\u{1D508}", "E"],
  ["\u{1D509}", "F"],
  ["\u{1D50A}", "G"],
  ["\u{1D50D}", "J"],
  ["\u{1D50E}", "K"],
  ["\u{1D50F}", "L"],
  ["\u{1D510}", "M"],
  ["\u{1D511}", "N"],
  ["\u{1D512}", "O"],
  ["\u{1D513}", "P"],
  ["\u{1D514}", "Q"],
  ["\u{1D516}", "S"],
  ["\u{1D517}", "T"],
  ["\u{1D518}", "U"],
  ["\u{1D519}", "V"],
  ["\u{1D51A}", "W"],
  ["\u{1D51B}", "X"],
  ["\u{1D51C}", "Y"],
  ["\u{1D51E}", "a"],
  ["\u{1D51F}", "b"],
  ["\u{1D520}", "c"],
  ["\u{1D521}", "d"],
  ["\u{1D522}", "e"],
  ["\u{1D523}", "f"],
  ["\u{1D524}", "g"],
  ["\u{1D525}", "h"],
  ["\u{1D526}", "i"],
  ["\u{1D527}", "j"],
  ["\u{1D528}", "k"],
  ["\u{1D529}", "l"],
  ["\u{1D52A}", "m"],
  ["\u{1D52B}", "n"],
  ["\u{1D52C}", "o"],
  ["\u{1D52D}", "p"],
  ["\u{1D52E}", "q"],
  ["\u{1D52F}", "r"],
  ["\u{1D530}", "s"],
  ["\u{1D531}", "t"],
  ["\u{1D532}", "u"],
  ["\u{1D533}", "v"],
  ["\u{1D534}", "w"],
  ["\u{1D535}", "x"],
  ["\u{1D536}", "y"],
  ["\u{1D537}", "z"],
  ["\u{1D538}", "A"],
  ["\u{1D539}", "B"],
  ["\u{1D53B}", "D"],
  ["\u{1D53C}", "E"],
  ["\u{1D53D}", "F"],
  ["\u{1D53E}", "G"],
  ["\u{1D540}", "I"],
  ["\u{1D541}", "J"],
  ["\u{1D542}", "K"],
  ["\u{1D543}", "L"],
  ["\u{1D544}", "M"],
  ["\u{1D546}", "N"],
  ["\u{1D54A}", "S"],
  ["\u{1D54B}", "T"],
  ["\u{1D54C}", "U"],
  ["\u{1D54D}", "V"],
  ["\u{1D54E}", "W"],
  ["\u{1D54F}", "X"],
  ["\u{1D550}", "Y"],
  ["\u{1D552}", "a"],
  ["\u{1D553}", "b"],
  ["\u{1D554}", "c"],
  ["\u{1D555}", "d"],
  ["\u{1D556}", "e"],
  ["\u{1D557}", "f"],
  ["\u{1D558}", "g"],
  ["\u{1D559}", "h"],
  ["\u{1D55A}", "i"],
  ["\u{1D55B}", "j"],
  ["\u{1D55C}", "k"],
  ["\u{1D55D}", "l"],
  ["\u{1D55E}", "m"],
  ["\u{1D55F}", "n"],
  ["\u{1D560}", "o"],
  ["\u{1D561}", "p"],
  ["\u{1D562}", "q"],
  ["\u{1D563}", "r"],
  ["\u{1D564}", "s"],
  ["\u{1D565}", "t"],
  ["\u{1D566}", "u"],
  ["\u{1D567}", "v"],
  ["\u{1D568}", "w"],
  ["\u{1D569}", "x"],
  ["\u{1D56A}", "y"],
  ["\u{1D56B}", "z"],
  ["\u{1D56C}", "A"],
  ["\u{1D56D}", "B"],
  ["\u{1D56E}", "C"],
  ["\u{1D56F}", "D"],
  ["\u{1D570}", "E"],
  ["\u{1D571}", "F"],
  ["\u{1D572}", "G"],
  ["\u{1D573}", "H"],
  ["\u{1D574}", "I"],
  ["\u{1D575}", "J"],
  ["\u{1D576}", "K"],
  ["\u{1D577}", "L"],
  ["\u{1D578}", "M"],
  ["\u{1D579}", "N"],
  ["\u{1D57A}", "O"],
  ["\u{1D57B}", "P"],
  ["\u{1D57C}", "Q"],
  ["\u{1D57D}", "R"],
  ["\u{1D57E}", "S"],
  ["\u{1D57F}", "T"],
  ["\u{1D580}", "U"],
  ["\u{1D581}", "V"],
  ["\u{1D582}", "W"],
  ["\u{1D583}", "X"],
  ["\u{1D584}", "Y"],
  ["\u{1D585}", "Z"],
  ["\u{1D586}", "a"],
  ["\u{1D587}", "b"],
  ["\u{1D588}", "c"],
  ["\u{1D589}", "d"],
  ["\u{1D58A}", "e"],
  ["\u{1D58B}", "f"],
  ["\u{1D58C}", "g"],
  ["\u{1D58D}", "h"],
  ["\u{1D58E}", "i"],
  ["\u{1D58F}", "j"],
  ["\u{1D590}", "k"],
  ["\u{1D591}", "l"],
  ["\u{1D592}", "m"],
  ["\u{1D593}", "n"],
  ["\u{1D594}", "o"],
  ["\u{1D595}", "p"],
  ["\u{1D596}", "q"],
  ["\u{1D597}", "r"],
  ["\u{1D598}", "s"],
  ["\u{1D599}", "t"],
  ["\u{1D59A}", "u"],
  ["\u{1D59B}", "v"],
  ["\u{1D59C}", "w"],
  ["\u{1D59D}", "x"],
  ["\u{1D59E}", "y"],
  ["\u{1D59F}", "z"],
  ["\u{1D5A0}", "A"],
  ["\u{1D5A1}", "B"],
  ["\u{1D5A2}", "C"],
  ["\u{1D5A3}", "D"],
  ["\u{1D5A4}", "E"],
  ["\u{1D5A5}", "F"],
  ["\u{1D5A6}", "G"],
  ["\u{1D5A7}", "H"],
  ["\u{1D5A8}", "I"],
  ["\u{1D5A9}", "J"],
  ["\u{1D5AA}", "K"],
  ["\u{1D5AB}", "L"],
  ["\u{1D5AC}", "M"],
  ["\u{1D5AD}", "N"],
  ["\u{1D5AE}", "O"],
  ["\u{1D5AF}", "P"],
  ["\u{1D5B0}", "Q"],
  ["\u{1D5B1}", "R"],
  ["\u{1D5B2}", "S"],
  ["\u{1D5B3}", "T"],
  ["\u{1D5B4}", "U"],
  ["\u{1D5B5}", "V"],
  ["\u{1D5B6}", "W"],
  ["\u{1D5B7}", "X"],
  ["\u{1D5B8}", "Y"],
  ["\u{1D5B9}", "Z"],
  ["\u{1D5BA}", "a"],
  ["\u{1D5BB}", "b"],
  ["\u{1D5BC}", "c"],
  ["\u{1D5BD}", "d"],
  ["\u{1D5BE}", "e"],
  ["\u{1D5BF}", "f"],
  ["\u{1D5C0}", "g"],
  ["\u{1D5C1}", "h"],
  ["\u{1D5C2}", "i"],
  ["\u{1D5C3}", "j"],
  ["\u{1D5C4}", "k"],
  ["\u{1D5C5}", "l"],
  ["\u{1D5C6}", "m"],
  ["\u{1D5C7}", "n"],
  ["\u{1D5C8}", "o"],
  ["\u{1D5C9}", "p"],
  ["\u{1D5CA}", "q"],
  ["\u{1D5CB}", "r"],
  ["\u{1D5CC}", "s"],
  ["\u{1D5CD}", "t"],
  ["\u{1D5CE}", "u"],
  ["\u{1D5CF}", "v"],
  ["\u{1D5D0}", "w"],
  ["\u{1D5D1}", "x"],
  ["\u{1D5D2}", "y"],
  ["\u{1D5D3}", "z"],
  ["\u{1D5D4}", "A"],
  ["\u{1D5D5}", "B"],
  ["\u{1D5D6}", "C"],
  ["\u{1D5D7}", "D"],
  ["\u{1D5D8}", "E"],
  ["\u{1D5D9}", "F"],
  ["\u{1D5DA}", "G"],
  ["\u{1D5DB}", "H"],
  ["\u{1D5DC}", "I"],
  ["\u{1D5DD}", "J"],
  ["\u{1D5DE}", "K"],
  ["\u{1D5DF}", "L"],
  ["\u{1D5E0}", "M"],
  ["\u{1D5E1}", "N"],
  ["\u{1D5E2}", "O"],
  ["\u{1D5E3}", "P"],
  ["\u{1D5E4}", "Q"],
  ["\u{1D5E5}", "R"],
  ["\u{1D5E6}", "S"],
  ["\u{1D5E7}", "T"],
  ["\u{1D5E8}", "U"],
  ["\u{1D5E9}", "V"],
  ["\u{1D5EA}", "W"],
  ["\u{1D5EB}", "X"],
  ["\u{1D5EC}", "Y"],
  ["\u{1D5ED}", "Z"],
  ["\u{1D5EE}", "a"],
  ["\u{1D5EF}", "b"],
  ["\u{1D5F0}", "c"],
  ["\u{1D5F1}", "d"],
  ["\u{1D5F2}", "e"],
  ["\u{1D5F3}", "f"],
  ["\u{1D5F4}", "g"],
  ["\u{1D5F5}", "h"],
  ["\u{1D5F6}", "i"],
  ["\u{1D5F7}", "j"],
  ["\u{1D5F8}", "k"],
  ["\u{1D5F9}", "l"],
  ["\u{1D5FA}", "m"],
  ["\u{1D5FB}", "n"],
  ["\u{1D5FC}", "o"],
  ["\u{1D5FD}", "p"],
  ["\u{1D5FE}", "q"],
  ["\u{1D5FF}", "r"],
  ["\u{1D600}", "s"],
  ["\u{1D601}", "t"],
  ["\u{1D602}", "u"],
  ["\u{1D603}", "v"],
  ["\u{1D604}", "w"],
  ["\u{1D605}", "x"],
  ["\u{1D606}", "y"],
  ["\u{1D607}", "z"],
  ["\u{1D608}", "A"],
  ["\u{1D609}", "B"],
  ["\u{1D60A}", "C"],
  ["\u{1D60B}", "D"],
  ["\u{1D60C}", "E"],
  ["\u{1D60D}", "F"],
  ["\u{1D60E}", "G"],
  ["\u{1D60F}", "H"],
  ["\u{1D610}", "I"],
  ["\u{1D611}", "J"],
  ["\u{1D612}", "K"],
  ["\u{1D613}", "L"],
  ["\u{1D614}", "M"],
  ["\u{1D615}", "N"],
  ["\u{1D616}", "O"],
  ["\u{1D617}", "P"],
  ["\u{1D618}", "Q"],
  ["\u{1D619}", "R"],
  ["\u{1D61A}", "S"],
  ["\u{1D61B}", "T"],
  ["\u{1D61C}", "U"],
  ["\u{1D61D}", "V"],
  ["\u{1D61E}", "W"],
  ["\u{1D61F}", "X"],
  ["\u{1D620}", "Y"],
  ["\u{1D621}", "Z"],
  ["\u{1D622}", "a"],
  ["\u{1D623}", "b"],
  ["\u{1D624}", "c"],
  ["\u{1D625}", "d"],
  ["\u{1D626}", "e"],
  ["\u{1D627}", "f"],
  ["\u{1D628}", "g"],
  ["\u{1D629}", "h"],
  ["\u{1D62A}", "i"],
  ["\u{1D62B}", "j"],
  ["\u{1D62C}", "k"],
  ["\u{1D62D}", "l"],
  ["\u{1D62E}", "m"],
  ["\u{1D62F}", "n"],
  ["\u{1D630}", "o"],
  ["\u{1D631}", "p"],
  ["\u{1D632}", "q"],
  ["\u{1D633}", "r"],
  ["\u{1D634}", "s"],
  ["\u{1D635}", "t"],
  ["\u{1D636}", "u"],
  ["\u{1D637}", "v"],
  ["\u{1D638}", "w"],
  ["\u{1D639}", "x"],
  ["\u{1D63A}", "y"],
  ["\u{1D63B}", "z"],
  ["\u{1D63C}", "A"],
  ["\u{1D63D}", "B"],
  ["\u{1D63E}", "C"],
  ["\u{1D63F}", "D"],
  ["\u{1D640}", "E"],
  ["\u{1D641}", "F"],
  ["\u{1D642}", "G"],
  ["\u{1D643}", "H"],
  ["\u{1D644}", "I"],
  ["\u{1D645}", "J"],
  ["\u{1D646}", "K"],
  ["\u{1D647}", "L"],
  ["\u{1D648}", "M"],
  ["\u{1D649}", "N"],
  ["\u{1D64A}", "O"],
  ["\u{1D64B}", "P"],
  ["\u{1D64C}", "Q"],
  ["\u{1D64D}", "R"],
  ["\u{1D64E}", "S"],
  ["\u{1D64F}", "T"],
  ["\u{1D650}", "U"],
  ["\u{1D651}", "V"],
  ["\u{1D652}", "W"],
  ["\u{1D653}", "X"],
  ["\u{1D654}", "Y"],
  ["\u{1D655}", "Z"],
  ["\u{1D656}", "a"],
  ["\u{1D657}", "b"],
  ["\u{1D658}", "c"],
  ["\u{1D659}", "d"],
  ["\u{1D65A}", "e"],
  ["\u{1D65B}", "f"],
  ["\u{1D65C}", "g"],
  ["\u{1D65D}", "h"],
  ["\u{1D65E}", "i"],
  ["\u{1D65F}", "j"],
  ["\u{1D660}", "k"],
  ["\u{1D661}", "l"],
  ["\u{1D662}", "m"],
  ["\u{1D663}", "n"],
  ["\u{1D664}", "o"],
  ["\u{1D665}", "p"],
  ["\u{1D666}", "q"],
  ["\u{1D667}", "r"],
  ["\u{1D668}", "s"],
  ["\u{1D669}", "t"],
  ["\u{1D66A}", "u"],
  ["\u{1D66B}", "v"],
  ["\u{1D66C}", "w"],
  ["\u{1D66D}", "x"],
  ["\u{1D66E}", "y"],
  ["\u{1D66F}", "z"],
  ["\u{1D670}", "A"],
  ["\u{1D671}", "B"],
  ["\u{1D672}", "C"],
  ["\u{1D673}", "D"],
  ["\u{1D674}", "E"],
  ["\u{1D675}", "F"],
  ["\u{1D676}", "G"],
  ["\u{1D677}", "H"],
  ["\u{1D678}", "I"],
  ["\u{1D679}", "J"],
  ["\u{1D67A}", "K"],
  ["\u{1D67B}", "L"],
  ["\u{1D67C}", "M"],
  ["\u{1D67D}", "N"],
  ["\u{1D67E}", "O"],
  ["\u{1D67F}", "P"],
  ["\u{1D680}", "Q"],
  ["\u{1D681}", "R"],
  ["\u{1D682}", "S"],
  ["\u{1D683}", "T"],
  ["\u{1D684}", "U"],
  ["\u{1D685}", "V"],
  ["\u{1D686}", "W"],
  ["\u{1D687}", "X"],
  ["\u{1D688}", "Y"],
  ["\u{1D689}", "Z"],
  ["\u{1D68A}", "a"],
  ["\u{1D68B}", "b"],
  ["\u{1D68C}", "c"],
  ["\u{1D68D}", "d"],
  ["\u{1D68E}", "e"],
  ["\u{1D68F}", "f"],
  ["\u{1D690}", "g"],
  ["\u{1D691}", "h"],
  ["\u{1D692}", "i"],
  ["\u{1D693}", "j"],
  ["\u{1D694}", "k"],
  ["\u{1D695}", "l"],
  ["\u{1D696}", "m"],
  ["\u{1D697}", "n"],
  ["\u{1D698}", "o"],
  ["\u{1D699}", "p"],
  ["\u{1D69A}", "q"],
  ["\u{1D69B}", "r"],
  ["\u{1D69C}", "s"],
  ["\u{1D69D}", "t"],
  ["\u{1D69E}", "u"],
  ["\u{1D69F}", "v"],
  ["\u{1D6A0}", "w"],
  ["\u{1D6A1}", "x"],
  ["\u{1D6A2}", "y"],
  ["\u{1D6A3}", "z"],
  // Dotless letters
  ["\u{1D6A4}", "l"],
  ["\u{1D6A5}", "j"],
  // Greek
  ["\u{1D6E2}", "A"],
  ["\u{1D6E3}", "B"],
  ["\u{1D6E4}", "G"],
  ["\u{1D6E5}", "D"],
  ["\u{1D6E6}", "E"],
  ["\u{1D6E7}", "Z"],
  ["\u{1D6E8}", "I"],
  ["\u{1D6E9}", "TH"],
  ["\u{1D6EA}", "I"],
  ["\u{1D6EB}", "K"],
  ["\u{1D6EC}", "L"],
  ["\u{1D6ED}", "M"],
  ["\u{1D6EE}", "N"],
  ["\u{1D6EF}", "KS"],
  ["\u{1D6F0}", "O"],
  ["\u{1D6F1}", "P"],
  ["\u{1D6F2}", "R"],
  ["\u{1D6F3}", "TH"],
  ["\u{1D6F4}", "S"],
  ["\u{1D6F5}", "T"],
  ["\u{1D6F6}", "Y"],
  ["\u{1D6F7}", "F"],
  ["\u{1D6F8}", "x"],
  ["\u{1D6F9}", "PS"],
  ["\u{1D6FA}", "O"],
  ["\u{1D6FB}", "D"],
  ["\u{1D6FC}", "a"],
  ["\u{1D6FD}", "b"],
  ["\u{1D6FE}", "g"],
  ["\u{1D6FF}", "d"],
  ["\u{1D700}", "e"],
  ["\u{1D701}", "z"],
  ["\u{1D702}", "i"],
  ["\u{1D703}", "th"],
  ["\u{1D704}", "i"],
  ["\u{1D705}", "k"],
  ["\u{1D706}", "l"],
  ["\u{1D707}", "m"],
  ["\u{1D708}", "n"],
  ["\u{1D709}", "ks"],
  ["\u{1D70A}", "o"],
  ["\u{1D70B}", "p"],
  ["\u{1D70C}", "r"],
  ["\u{1D70D}", "s"],
  ["\u{1D70E}", "s"],
  ["\u{1D70F}", "t"],
  ["\u{1D710}", "y"],
  ["\u{1D711}", "f"],
  ["\u{1D712}", "x"],
  ["\u{1D713}", "ps"],
  ["\u{1D714}", "o"],
  ["\u{1D715}", "d"],
  ["\u{1D716}", "E"],
  ["\u{1D717}", "TH"],
  ["\u{1D718}", "K"],
  ["\u{1D719}", "f"],
  ["\u{1D71A}", "r"],
  ["\u{1D71B}", "p"],
  ["\u{1D71C}", "A"],
  ["\u{1D71D}", "V"],
  ["\u{1D71E}", "G"],
  ["\u{1D71F}", "D"],
  ["\u{1D720}", "E"],
  ["\u{1D721}", "Z"],
  ["\u{1D722}", "I"],
  ["\u{1D723}", "TH"],
  ["\u{1D724}", "I"],
  ["\u{1D725}", "K"],
  ["\u{1D726}", "L"],
  ["\u{1D727}", "M"],
  ["\u{1D728}", "N"],
  ["\u{1D729}", "KS"],
  ["\u{1D72A}", "O"],
  ["\u{1D72B}", "P"],
  ["\u{1D72C}", "S"],
  ["\u{1D72D}", "TH"],
  ["\u{1D72E}", "S"],
  ["\u{1D72F}", "T"],
  ["\u{1D730}", "Y"],
  ["\u{1D731}", "F"],
  ["\u{1D732}", "X"],
  ["\u{1D733}", "PS"],
  ["\u{1D734}", "O"],
  ["\u{1D735}", "D"],
  ["\u{1D736}", "a"],
  ["\u{1D737}", "v"],
  ["\u{1D738}", "g"],
  ["\u{1D739}", "d"],
  ["\u{1D73A}", "e"],
  ["\u{1D73B}", "z"],
  ["\u{1D73C}", "i"],
  ["\u{1D73D}", "th"],
  ["\u{1D73E}", "i"],
  ["\u{1D73F}", "k"],
  ["\u{1D740}", "l"],
  ["\u{1D741}", "m"],
  ["\u{1D742}", "n"],
  ["\u{1D743}", "ks"],
  ["\u{1D744}", "o"],
  ["\u{1D745}", "p"],
  ["\u{1D746}", "r"],
  ["\u{1D747}", "s"],
  ["\u{1D748}", "s"],
  ["\u{1D749}", "t"],
  ["\u{1D74A}", "y"],
  ["\u{1D74B}", "f"],
  ["\u{1D74C}", "x"],
  ["\u{1D74D}", "ps"],
  ["\u{1D74E}", "o"],
  ["\u{1D74F}", "a"],
  ["\u{1D750}", "e"],
  ["\u{1D751}", "i"],
  ["\u{1D752}", "k"],
  ["\u{1D753}", "f"],
  ["\u{1D754}", "r"],
  ["\u{1D755}", "p"],
  ["\u{1D756}", "A"],
  ["\u{1D757}", "B"],
  ["\u{1D758}", "G"],
  ["\u{1D759}", "D"],
  ["\u{1D75A}", "E"],
  ["\u{1D75B}", "Z"],
  ["\u{1D75C}", "I"],
  ["\u{1D75D}", "TH"],
  ["\u{1D75E}", "I"],
  ["\u{1D75F}", "K"],
  ["\u{1D760}", "L"],
  ["\u{1D761}", "M"],
  ["\u{1D762}", "N"],
  ["\u{1D763}", "KS"],
  ["\u{1D764}", "O"],
  ["\u{1D765}", "P"],
  ["\u{1D766}", "R"],
  ["\u{1D767}", "TH"],
  ["\u{1D768}", "S"],
  ["\u{1D769}", "T"],
  ["\u{1D76A}", "Y"],
  ["\u{1D76B}", "F"],
  ["\u{1D76C}", "X"],
  ["\u{1D76D}", "PS"],
  ["\u{1D76E}", "O"],
  ["\u{1D76F}", "D"],
  ["\u{1D770}", "a"],
  ["\u{1D771}", "v"],
  ["\u{1D772}", "g"],
  ["\u{1D773}", "d"],
  ["\u{1D774}", "e"],
  ["\u{1D775}", "z"],
  ["\u{1D776}", "i"],
  ["\u{1D777}", "th"],
  ["\u{1D778}", "i"],
  ["\u{1D779}", "k"],
  ["\u{1D77A}", "l"],
  ["\u{1D77B}", "m"],
  ["\u{1D77C}", "n"],
  ["\u{1D77D}", "ks"],
  ["\u{1D77E}", "o"],
  ["\u{1D77F}", "p"],
  ["\u{1D780}", "r"],
  ["\u{1D781}", "s"],
  ["\u{1D782}", "s"],
  ["\u{1D783}", "t"],
  ["\u{1D784}", "y"],
  ["\u{1D785}", "f"],
  ["\u{1D786}", "x"],
  ["\u{1D787}", "ps"],
  ["\u{1D788}", "o"],
  ["\u{1D789}", "a"],
  ["\u{1D78A}", "e"],
  ["\u{1D78B}", "i"],
  ["\u{1D78C}", "k"],
  ["\u{1D78D}", "f"],
  ["\u{1D78E}", "r"],
  ["\u{1D78F}", "p"],
  ["\u{1D790}", "A"],
  ["\u{1D791}", "V"],
  ["\u{1D792}", "G"],
  ["\u{1D793}", "D"],
  ["\u{1D794}", "E"],
  ["\u{1D795}", "Z"],
  ["\u{1D796}", "I"],
  ["\u{1D797}", "TH"],
  ["\u{1D798}", "I"],
  ["\u{1D799}", "K"],
  ["\u{1D79A}", "L"],
  ["\u{1D79B}", "M"],
  ["\u{1D79C}", "N"],
  ["\u{1D79D}", "KS"],
  ["\u{1D79E}", "O"],
  ["\u{1D79F}", "P"],
  ["\u{1D7A0}", "S"],
  ["\u{1D7A1}", "TH"],
  ["\u{1D7A2}", "S"],
  ["\u{1D7A3}", "T"],
  ["\u{1D7A4}", "Y"],
  ["\u{1D7A5}", "F"],
  ["\u{1D7A6}", "X"],
  ["\u{1D7A7}", "PS"],
  ["\u{1D7A8}", "O"],
  ["\u{1D7A9}", "D"],
  ["\u{1D7AA}", "av"],
  ["\u{1D7AB}", "g"],
  ["\u{1D7AC}", "d"],
  ["\u{1D7AD}", "e"],
  ["\u{1D7AE}", "z"],
  ["\u{1D7AF}", "i"],
  ["\u{1D7B0}", "i"],
  ["\u{1D7B1}", "th"],
  ["\u{1D7B2}", "i"],
  ["\u{1D7B3}", "k"],
  ["\u{1D7B4}", "l"],
  ["\u{1D7B5}", "m"],
  ["\u{1D7B6}", "n"],
  ["\u{1D7B7}", "ks"],
  ["\u{1D7B8}", "o"],
  ["\u{1D7B9}", "p"],
  ["\u{1D7BA}", "r"],
  ["\u{1D7BB}", "s"],
  ["\u{1D7BC}", "s"],
  ["\u{1D7BD}", "t"],
  ["\u{1D7BE}", "y"],
  ["\u{1D7BF}", "f"],
  ["\u{1D7C0}", "x"],
  ["\u{1D7C1}", "ps"],
  ["\u{1D7C2}", "o"],
  ["\u{1D7C3}", "a"],
  ["\u{1D7C4}", "e"],
  ["\u{1D7C5}", "i"],
  ["\u{1D7C6}", "k"],
  ["\u{1D7C7}", "f"],
  ["\u{1D7C8}", "r"],
  ["\u{1D7C9}", "p"],
  ["\u{1D7CA}", "F"],
  ["\u{1D7CB}", "f"],
  ["\u249C", "(a)"],
  ["\u249D", "(b)"],
  ["\u249E", "(c)"],
  ["\u249F", "(d)"],
  ["\u24A0", "(e)"],
  ["\u24A1", "(f)"],
  ["\u24A2", "(g)"],
  ["\u24A3", "(h)"],
  ["\u24A4", "(i)"],
  ["\u24A5", "(j)"],
  ["\u24A6", "(k)"],
  ["\u24A7", "(l)"],
  ["\u24A8", "(m)"],
  ["\u24A9", "(n)"],
  ["\u24AA", "(o)"],
  ["\u24AB", "(p)"],
  ["\u24AC", "(q)"],
  ["\u24AD", "(r)"],
  ["\u24AE", "(s)"],
  ["\u24AF", "(t)"],
  ["\u24B0", "(u)"],
  ["\u24B1", "(v)"],
  ["\u24B2", "(w)"],
  ["\u24B3", "(x)"],
  ["\u24B4", "(y)"],
  ["\u24B5", "(z)"],
  ["\u24B6", "(A)"],
  ["\u24B7", "(B)"],
  ["\u24B8", "(C)"],
  ["\u24B9", "(D)"],
  ["\u24BA", "(E)"],
  ["\u24BB", "(F)"],
  ["\u24BC", "(G)"],
  ["\u24BD", "(H)"],
  ["\u24BE", "(I)"],
  ["\u24BF", "(J)"],
  ["\u24C0", "(K)"],
  ["\u24C1", "(L)"],
  ["\u24C3", "(N)"],
  ["\u24C4", "(O)"],
  ["\u24C5", "(P)"],
  ["\u24C6", "(Q)"],
  ["\u24C7", "(R)"],
  ["\u24C8", "(S)"],
  ["\u24C9", "(T)"],
  ["\u24CA", "(U)"],
  ["\u24CB", "(V)"],
  ["\u24CC", "(W)"],
  ["\u24CD", "(X)"],
  ["\u24CE", "(Y)"],
  ["\u24CF", "(Z)"],
  ["\u24D0", "(a)"],
  ["\u24D1", "(b)"],
  ["\u24D2", "(b)"],
  ["\u24D3", "(c)"],
  ["\u24D4", "(e)"],
  ["\u24D5", "(f)"],
  ["\u24D6", "(g)"],
  ["\u24D7", "(h)"],
  ["\u24D8", "(i)"],
  ["\u24D9", "(j)"],
  ["\u24DA", "(k)"],
  ["\u24DB", "(l)"],
  ["\u24DC", "(m)"],
  ["\u24DD", "(n)"],
  ["\u24DE", "(o)"],
  ["\u24DF", "(p)"],
  ["\u24E0", "(q)"],
  ["\u24E1", "(r)"],
  ["\u24E2", "(s)"],
  ["\u24E3", "(t)"],
  ["\u24E4", "(u)"],
  ["\u24E5", "(v)"],
  ["\u24E6", "(w)"],
  ["\u24E7", "(x)"],
  ["\u24E8", "(y)"],
  ["\u24E9", "(z)"],
  // Maltese
  ["\u010A", "C"],
  ["\u010B", "c"],
  ["\u0120", "G"],
  ["\u0121", "g"],
  ["\u0126", "H"],
  ["\u0127", "h"],
  ["\u017B", "Z"],
  ["\u017C", "z"],
  // Numbers
  ["\u{1D7CE}", "0"],
  ["\u{1D7CF}", "1"],
  ["\u{1D7D0}", "2"],
  ["\u{1D7D1}", "3"],
  ["\u{1D7D2}", "4"],
  ["\u{1D7D3}", "5"],
  ["\u{1D7D4}", "6"],
  ["\u{1D7D5}", "7"],
  ["\u{1D7D6}", "8"],
  ["\u{1D7D7}", "9"],
  ["\u{1D7D8}", "0"],
  ["\u{1D7D9}", "1"],
  ["\u{1D7DA}", "2"],
  ["\u{1D7DB}", "3"],
  ["\u{1D7DC}", "4"],
  ["\u{1D7DD}", "5"],
  ["\u{1D7DE}", "6"],
  ["\u{1D7DF}", "7"],
  ["\u{1D7E0}", "8"],
  ["\u{1D7E1}", "9"],
  ["\u{1D7E2}", "0"],
  ["\u{1D7E3}", "1"],
  ["\u{1D7E4}", "2"],
  ["\u{1D7E5}", "3"],
  ["\u{1D7E6}", "4"],
  ["\u{1D7E7}", "5"],
  ["\u{1D7E8}", "6"],
  ["\u{1D7E9}", "7"],
  ["\u{1D7EA}", "8"],
  ["\u{1D7EB}", "9"],
  ["\u{1D7EC}", "0"],
  ["\u{1D7ED}", "1"],
  ["\u{1D7EE}", "2"],
  ["\u{1D7EF}", "3"],
  ["\u{1D7F0}", "4"],
  ["\u{1D7F1}", "5"],
  ["\u{1D7F2}", "6"],
  ["\u{1D7F3}", "7"],
  ["\u{1D7F4}", "8"],
  ["\u{1D7F5}", "9"],
  ["\u{1D7F6}", "0"],
  ["\u{1D7F7}", "1"],
  ["\u{1D7F8}", "2"],
  ["\u{1D7F9}", "3"],
  ["\u{1D7FA}", "4"],
  ["\u{1D7FB}", "5"],
  ["\u{1D7FC}", "6"],
  ["\u{1D7FD}", "7"],
  ["\u{1D7FE}", "8"],
  ["\u{1D7FF}", "9"],
  ["\u2460", "1"],
  ["\u2461", "2"],
  ["\u2462", "3"],
  ["\u2463", "4"],
  ["\u2464", "5"],
  ["\u2465", "6"],
  ["\u2466", "7"],
  ["\u2467", "8"],
  ["\u2468", "9"],
  ["\u2469", "10"],
  ["\u246A", "11"],
  ["\u246B", "12"],
  ["\u246C", "13"],
  ["\u246D", "14"],
  ["\u246E", "15"],
  ["\u246F", "16"],
  ["\u2470", "17"],
  ["\u2471", "18"],
  ["\u2472", "19"],
  ["\u2473", "20"],
  ["\u2474", "1"],
  ["\u2475", "2"],
  ["\u2476", "3"],
  ["\u2477", "4"],
  ["\u2478", "5"],
  ["\u2479", "6"],
  ["\u247A", "7"],
  ["\u247B", "8"],
  ["\u247C", "9"],
  ["\u247D", "10"],
  ["\u247E", "11"],
  ["\u247F", "12"],
  ["\u2480", "13"],
  ["\u2481", "14"],
  ["\u2482", "15"],
  ["\u2483", "16"],
  ["\u2484", "17"],
  ["\u2485", "18"],
  ["\u2486", "19"],
  ["\u2487", "20"],
  ["\u2488", "1."],
  ["\u2489", "2."],
  ["\u248A", "3."],
  ["\u248B", "4."],
  ["\u248C", "5."],
  ["\u248D", "6."],
  ["\u248E", "7."],
  ["\u248F", "8."],
  ["\u2490", "9."],
  ["\u2491", "10."],
  ["\u2492", "11."],
  ["\u2493", "12."],
  ["\u2494", "13."],
  ["\u2495", "14."],
  ["\u2496", "15."],
  ["\u2497", "16."],
  ["\u2498", "17."],
  ["\u2499", "18."],
  ["\u249A", "19."],
  ["\u249B", "20."],
  ["\u24EA", "0"],
  ["\u24EB", "11"],
  ["\u24EC", "12"],
  ["\u24ED", "13"],
  ["\u24EE", "14"],
  ["\u24EF", "15"],
  ["\u24F0", "16"],
  ["\u24F1", "17"],
  ["\u24F2", "18"],
  ["\u24F3", "19"],
  ["\u24F4", "20"],
  ["\u24F5", "1"],
  ["\u24F6", "2"],
  ["\u24F7", "3"],
  ["\u24F8", "4"],
  ["\u24F9", "5"],
  ["\u24FA", "6"],
  ["\u24FB", "7"],
  ["\u24FC", "8"],
  ["\u24FD", "9"],
  ["\u24FE", "10"],
  ["\u24FF", "0"],
  // Punctuation
  ["\u{1F670}", "&"],
  ["\u{1F671}", "&"],
  ["\u{1F672}", "&"],
  ["\u{1F673}", "&"],
  ["\u{1F674}", "&"],
  ["\u{1F675}", "&"],
  ["\u{1F676}", '"'],
  ["\u{1F677}", '"'],
  ["\u{1F678}", '"'],
  ["\u203D", "?!"],
  ["\u{1F679}", "?!"],
  ["\u{1F67A}", "?!"],
  ["\u{1F67B}", "?!"],
  ["\u{1F67C}", "/"],
  ["\u{1F67D}", "\\"],
  // Alchemy
  ["\u{1F707}", "AR"],
  ["\u{1F708}", "V"],
  ["\u{1F709}", "V"],
  ["\u{1F706}", "VR"],
  ["\u{1F705}", "VF"],
  ["\u{1F729}", "2"],
  ["\u{1F72A}", "5"],
  ["\u{1F761}", "f"],
  ["\u{1F762}", "W"],
  ["\u{1F763}", "U"],
  ["\u{1F767}", "V"],
  ["\u{1F768}", "T"],
  ["\u{1F76A}", "V"],
  ["\u{1F76B}", "MB"],
  ["\u{1F76C}", "VB"],
  ["\u{1F772}", "3B"],
  ["\u{1F773}", "3B"],
  // Emojis
  ["\u{1F4AF}", "100"],
  ["\u{1F519}", "BACK"],
  ["\u{1F51A}", "END"],
  ["\u{1F51B}", "ON!"],
  ["\u{1F51C}", "SOON"],
  ["\u{1F51D}", "TOP"],
  ["\u{1F51E}", "18"],
  ["\u{1F524}", "abc"],
  ["\u{1F520}", "ABCD"],
  ["\u{1F521}", "abcd"],
  ["\u{1F522}", "1234"],
  ["\u{1F523}", "T&@%"],
  ["#\uFE0F\u20E3", "#"],
  ["*\uFE0F\u20E3", "*"],
  ["0\uFE0F\u20E3", "0"],
  ["1\uFE0F\u20E3", "1"],
  ["2\uFE0F\u20E3", "2"],
  ["3\uFE0F\u20E3", "3"],
  ["4\uFE0F\u20E3", "4"],
  ["5\uFE0F\u20E3", "5"],
  ["6\uFE0F\u20E3", "6"],
  ["7\uFE0F\u20E3", "7"],
  ["8\uFE0F\u20E3", "8"],
  ["9\uFE0F\u20E3", "9"],
  ["\u{1F51F}", "10"],
  ["\u{1F170}\uFE0F", "A"],
  ["\u{1F171}\uFE0F", "B"],
  ["\u{1F18E}", "AB"],
  ["\u{1F191}", "CL"],
  ["\u{1F17E}\uFE0F", "O"],
  ["\u{1F17F}", "P"],
  ["\u{1F198}", "SOS"],
  ["\u{1F172}", "C"],
  ["\u{1F173}", "D"],
  ["\u{1F174}", "E"],
  ["\u{1F175}", "F"],
  ["\u{1F176}", "G"],
  ["\u{1F177}", "H"],
  ["\u{1F178}", "I"],
  ["\u{1F179}", "J"],
  ["\u{1F17A}", "K"],
  ["\u{1F17B}", "L"],
  ["\u{1F17C}", "M"],
  ["\u{1F17D}", "N"],
  ["\u{1F180}", "Q"],
  ["\u{1F181}", "R"],
  ["\u{1F182}", "S"],
  ["\u{1F183}", "T"],
  ["\u{1F184}", "U"],
  ["\u{1F185}", "V"],
  ["\u{1F186}", "W"],
  ["\u{1F187}", "X"],
  ["\u{1F188}", "Y"],
  ["\u{1F189}", "Z"]
];
var replacements_default = replacements;

// node_modules/@sindresorhus/transliterate/index.js
var doCustomReplacements = /* @__PURE__ */ __name((string7, replacements2) => {
  for (const [key, value] of replacements2) {
    string7 = string7.replace(new RegExp(escapeStringRegexp(key), "g"), value);
  }
  return string7;
}, "doCustomReplacements");
function transliterate(string7, options) {
  if (typeof string7 !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string7}\``);
  }
  options = {
    customReplacements: [],
    ...options
  };
  const customReplacements = new Map([
    ...replacements_default,
    ...options.customReplacements
  ]);
  string7 = string7.normalize();
  string7 = doCustomReplacements(string7, customReplacements);
  string7 = string7.normalize("NFD").replace(/\p{Diacritic}/gu, "").normalize();
  return string7;
}
__name(transliterate, "transliterate");

// node_modules/@sindresorhus/slugify/overridable-replacements.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var overridableReplacements = [
  ["&", " and "],
  ["\u{1F984}", " unicorn "],
  ["\u2665", " love "]
];
var overridable_replacements_default = overridableReplacements;

// node_modules/@sindresorhus/slugify/index.js
var decamelize = /* @__PURE__ */ __name((string7) => {
  return string7.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-rt-z\d]+)/g, "$1 $2");
}, "decamelize");
var removeMootSeparators = /* @__PURE__ */ __name((string7, separator) => {
  const escapedSeparator = escapeStringRegexp(separator);
  return string7.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
}, "removeMootSeparators");
var buildPatternSlug = /* @__PURE__ */ __name((options) => {
  let negationSetPattern = "a-z\\d";
  negationSetPattern += options.lowercase ? "" : "A-Z";
  if (options.preserveCharacters.length > 0) {
    for (const character of options.preserveCharacters) {
      if (character === options.separator) {
        throw new Error(`The separator character \`${options.separator}\` cannot be included in preserved characters: ${options.preserveCharacters}`);
      }
      negationSetPattern += escapeStringRegexp(character);
    }
  }
  return new RegExp(`[^${negationSetPattern}]+`, "g");
}, "buildPatternSlug");
function slugify2(string7, options) {
  if (typeof string7 !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string7}\``);
  }
  options = {
    separator: "-",
    lowercase: true,
    decamelize: true,
    customReplacements: [],
    preserveLeadingUnderscore: false,
    preserveTrailingDash: false,
    preserveCharacters: [],
    ...options
  };
  const shouldPrependUnderscore = options.preserveLeadingUnderscore && string7.startsWith("_");
  const shouldAppendDash = options.preserveTrailingDash && string7.endsWith("-");
  const customReplacements = new Map([
    ...overridable_replacements_default,
    ...options.customReplacements
  ]);
  string7 = transliterate(string7, { customReplacements });
  if (options.decamelize) {
    string7 = decamelize(string7);
  }
  const patternSlug = buildPatternSlug(options);
  if (options.lowercase) {
    string7 = string7.toLowerCase();
  }
  string7 = string7.replace(/([a-zA-Z\d]+)'([ts])(\s|$)/g, "$1$2$3");
  string7 = string7.replace(patternSlug, options.separator);
  string7 = string7.replace(/\\/g, "");
  if (options.separator) {
    string7 = removeMootSeparators(string7, options.separator);
  }
  if (shouldPrependUnderscore) {
    string7 = `_${string7}`;
  }
  if (shouldAppendDash) {
    string7 = `${string7}-`;
  }
  return string7;
}
__name(slugify2, "slugify");

// node_modules/radash/dist/esm/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/radash/dist/esm/typed.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var isSymbol = /* @__PURE__ */ __name((value) => {
  return !!value && value.constructor === Symbol;
}, "isSymbol");
var isFunction = /* @__PURE__ */ __name((value) => {
  return !!(value && value.constructor && value.call && value.apply);
}, "isFunction");
var isNumber = /* @__PURE__ */ __name((value) => {
  try {
    return Number(value) === value;
  } catch {
    return false;
  }
}, "isNumber");
var isDate2 = /* @__PURE__ */ __name((value) => {
  return Object.prototype.toString.call(value) === "[object Date]";
}, "isDate");
var isEmpty = /* @__PURE__ */ __name((value) => {
  if (value === true || value === false)
    return true;
  if (value === null || value === void 0)
    return true;
  if (isNumber(value))
    return value === 0;
  if (isDate2(value))
    return isNaN(value.getTime());
  if (isFunction(value))
    return false;
  if (isSymbol(value))
    return false;
  const length = value.length;
  if (isNumber(length))
    return length === 0;
  const size = value.size;
  if (isNumber(size))
    return size === 0;
  const keys = Object.keys(value).length;
  return keys === 0;
}, "isEmpty");

// node_modules/js-tiktoken/dist/lite.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/js-tiktoken/dist/chunk-VL2OQCWN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp6 = Object.defineProperty;
var __defNormalProp3 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
__name(bytePairMerge, "bytePairMerge");
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
__name(bytePairEncode, "bytePairEncode");
function escapeRegex3(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
__name(escapeRegex3, "escapeRegex");
var _Tiktoken = class {
  static {
    __name(this, "_Tiktoken");
  }
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(ranks, extendedSpecialTokens) {
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text3, rank]) => {
      memo[rank] = this.textEncoder.encode(text3);
      return memo;
    }, {});
  }
  encode(text3, allowedSpecial = [], disallowedSpecial = "all") {
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text3.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text3);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = nextSpecial?.index ?? text3.length;
      for (const match2 of text3.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match2[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    const res = [];
    let length = 0;
    for (let i2 = 0; i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex3(i)).join("|"), "g");
});

// node_modules/js-tiktoken/dist/ranks/o200k_base.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_performance2();

// node_modules/@mastra/core/dist/chunk-GSQD3QNR.js
init_v4();
var require_fast_deep_equal = __commonJS2({ "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
  module.exports = /* @__PURE__ */ __name(function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }, "equal");
} });
var noopSpanContext2 = { traceId: "", spanId: "", traceFlags: 0 };
var noopSpan2 = { spanContext() {
  return noopSpanContext2;
}, setAttribute() {
  return this;
}, setAttributes() {
  return this;
}, addEvent() {
  return this;
}, addLink() {
  return this;
}, addLinks() {
  return this;
}, setStatus() {
  return this;
}, updateName() {
  return this;
}, end() {
  return this;
}, isRecording() {
  return false;
}, recordException() {
  return this;
} };
var noopTracer2 = { startSpan() {
  return noopSpan2;
}, startActiveSpan(name51, arg1, arg2, arg3) {
  if (typeof arg1 === "function") {
    return arg1(noopSpan2);
  }
  if (typeof arg2 === "function") {
    return arg2(noopSpan2);
  }
  if (typeof arg3 === "function") {
    return arg3(noopSpan2);
  }
} };
function getTracer2({ isEnabled = false, tracer } = {}) {
  if (!isEnabled) {
    return noopTracer2;
  }
  if (tracer) {
    return tracer;
  }
  return import_api5.trace.getTracer("mastra");
}
__name(getTracer2, "getTracer");
function assembleOperationName2({ operationId, telemetry }) {
  return { "mastra.operationId": operationId, "operation.name": `${operationId}${telemetry?.functionId != null ? ` ${telemetry.functionId}` : ""}`, ...telemetry?.functionId ? { "resource.name": telemetry?.functionId } : {} };
}
__name(assembleOperationName2, "assembleOperationName");
function getTelemetryAttributes({ model, settings, telemetry, headers }) {
  return {
    "aisdk.model.provider": model.provider,
    "aisdk.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`stream.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries(telemetry?.metadata ?? {}).reduce((attributes, [key, value]) => {
      attributes[`stream.telemetry.metadata.${key}`] = value;
      return attributes;
    }, {}),
    // request headers
    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`stream.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
__name(getTelemetryAttributes, "getTelemetryAttributes");
function getRootSpan({ operationId, model, modelSettings, telemetry_settings, headers }) {
  const tracer = getTracer2({ isEnabled: telemetry_settings?.isEnabled, tracer: telemetry_settings?.tracer });
  const baseTelemetryAttributes = getTelemetryAttributes({ model: { modelId: model.modelId, provider: model.provider }, settings: modelSettings ?? { maxRetries: 2 }, telemetry: telemetry_settings, headers });
  const rootSpan = tracer.startSpan(operationId).setAttributes({ ...assembleOperationName2({ operationId, telemetry: telemetry_settings }), ...baseTelemetryAttributes });
  return { rootSpan };
}
__name(getRootSpan, "getRootSpan");
var TripWire = class extends Error {
  static {
    __name(this, "TripWire");
  }
  constructor(reason) {
    super(reason);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var getModelOutputForTripwire = /* @__PURE__ */ __name(async ({ tripwireReason, runId, tracingContext, options, model, messageList }) => {
  const tripwireStream = new ReadableStream$1({ start(controller) {
    controller.enqueue({ type: "tripwire", runId, from: "AGENT", payload: { tripwireReason: tripwireReason || "" } });
    controller.close();
  } });
  const { rootSpan } = getRootSpan({ operationId: `mastra.stream.tripwire`, model: { modelId: model.modelId || "unknown", provider: model.provider || "unknown" }, modelSettings: options.modelSettings, headers: options.modelSettings?.headers, telemetry_settings: options.telemetry });
  const modelOutput = new MastraModelOutput({ model: { modelId: model.modelId, provider: model.provider, version: model.specificationVersion || "v2" }, stream: tripwireStream, messageList, options: {
    runId,
    rootSpan,
    telemetry_settings: options.telemetry,
    structuredOutput: options.structuredOutput,
    tracingContext,
    onFinish: options.onFinish,
    // Fix these types after the types PR is merged
    onStepFinish: options.onStepFinish,
    returnScorerData: options.returnScorerData
  }, messageId: randomUUID3() });
  return modelOutput;
}, "getModelOutputForTripwire");
function getResponseUIMessageId({ originalMessages, responseMessageId }) {
  if (originalMessages == null) {
    return void 0;
  }
  const lastMessage = originalMessages[originalMessages.length - 1];
  return lastMessage?.role === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
}
__name(getResponseUIMessageId, "getResponseUIMessageId");
function convertFullStreamChunkToUIMessageStream({ part, messageMetadataValue, sendReasoning, sendSources, onError, sendStart, sendFinish, responseMessageId }) {
  const partType = part.type;
  switch (partType) {
    case "text-start": {
      return { type: "text-start", id: part.id, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
    }
    case "text-delta": {
      return { type: "text-delta", id: part.id, delta: part.text, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
    }
    case "text-end": {
      return { type: "text-end", id: part.id, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
    }
    case "reasoning-start": {
      return { type: "reasoning-start", id: part.id, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
    }
    case "reasoning-delta": {
      if (sendReasoning) {
        return { type: "reasoning-delta", id: part.id, delta: part.text, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
      }
      return;
    }
    case "reasoning-end": {
      return { type: "reasoning-end", id: part.id, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
    }
    case "file": {
      return { type: "file", mediaType: part.file.mediaType, url: `data:${part.file.mediaType};base64,${part.file.base64}` };
    }
    case "source": {
      if (sendSources && part.sourceType === "url") {
        return { type: "source-url", sourceId: part.id, url: part.url, title: part.title, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
      }
      if (sendSources && part.sourceType === "document") {
        return { type: "source-document", sourceId: part.id, mediaType: part.mediaType, title: part.title, filename: part.filename, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {} };
      }
      return;
    }
    case "tool-input-start": {
      return { type: "tool-input-start", toolCallId: part.id, toolName: part.toolName, ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {}, ...part.dynamic != null ? { dynamic: part.dynamic } : {} };
    }
    case "tool-input-delta": {
      return { type: "tool-input-delta", toolCallId: part.id, inputTextDelta: part.delta };
    }
    case "tool-call": {
      return { type: "tool-input-available", toolCallId: part.toolCallId, toolName: part.toolName, input: part.input, ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {}, ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}, ...part.dynamic != null ? { dynamic: part.dynamic } : {} };
    }
    case "tool-result": {
      return { type: "tool-output-available", toolCallId: part.toolCallId, output: part.output, ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {}, ...part.dynamic != null ? { dynamic: part.dynamic } : {} };
    }
    case "tool-output": {
      return { ...part.output };
    }
    case "tool-error": {
      return { type: "tool-output-error", toolCallId: part.toolCallId, errorText: onError(part.error), ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {}, ...part.dynamic != null ? { dynamic: part.dynamic } : {} };
    }
    case "error": {
      return { type: "error", errorText: onError(part.error) };
    }
    case "start-step": {
      return { type: "start-step" };
    }
    case "finish-step": {
      return { type: "finish-step" };
    }
    case "start": {
      if (sendStart) {
        return { type: "start", ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}, ...responseMessageId != null ? { messageId: responseMessageId } : {} };
      }
      return;
    }
    case "finish": {
      if (sendFinish) {
        return { type: "finish", ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {} };
      }
      return;
    }
    case "abort": {
      return part;
    }
    case "tool-input-end": {
      return;
    }
    case "raw": {
      return;
    }
    default: {
      const exhaustiveCheck = partType;
      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
    }
  }
}
__name(convertFullStreamChunkToUIMessageStream, "convertFullStreamChunkToUIMessageStream");
async function safeValidateTypes11({ value, schema }) {
  try {
    if (!schema.validate) {
      return { success: true, value };
    }
    const result = await schema.validate(value);
    if (!result.success) {
      return { success: false, error: new TypeValidationError11({ value, cause: "Validation failed" }) };
    }
    return { success: true, value: result.value };
  } catch (error87) {
    return { success: false, error: error87 instanceof Error ? error87 : new Error(String(error87)) };
  }
}
__name(safeValidateTypes11, "safeValidateTypes");
var DelayedPromise2 = class {
  static {
    __name(this, "DelayedPromise");
  }
  status = { type: "pending" };
  _promise;
  _resolve = void 0;
  _reject = void 0;
  get promise() {
    if (this._promise) {
      return this._promise;
    }
    this._promise = new Promise((resolve3, reject) => {
      if (this.status.type === "resolved") {
        resolve3(this.status.value);
      } else if (this.status.type === "rejected") {
        reject(this.status.error);
      }
      this._resolve = resolve3;
      this._reject = reject;
    });
    return this._promise;
  }
  resolve(value) {
    this.status = { type: "resolved", value };
    if (this._promise) {
      this._resolve?.(value);
    }
  }
  reject(error87) {
    this.status = { type: "rejected", error: error87 };
    if (this._promise) {
      this._reject?.(error87);
    }
  }
};
function prepareToolsAndToolChoice2({ tools, toolChoice, activeTools }) {
  if (Object.keys(tools || {}).length === 0) {
    return { tools: void 0, toolChoice: void 0 };
  }
  const filteredTools = activeTools != null ? Object.entries(tools || {}).filter(([name51]) => activeTools.includes(name51)) : Object.entries(tools || {});
  return { tools: filteredTools.map(([name51, tool$1]) => {
    try {
      let inputSchema;
      if ("inputSchema" in tool$1) {
        inputSchema = tool$1.inputSchema;
      } else if ("parameters" in tool$1) {
        inputSchema = tool$1.parameters;
      }
      const sdkTool = tool({ type: "function", ...tool$1, inputSchema });
      const toolType = sdkTool?.type ?? "function";
      switch (toolType) {
        case void 0:
        case "dynamic":
        case "function":
          return { type: "function", name: name51, description: sdkTool.description, inputSchema: asSchema(sdkTool.inputSchema).jsonSchema, providerOptions: sdkTool.providerOptions };
        case "provider-defined": {
          const providerId = sdkTool.id;
          let providerToolName = name51;
          if (providerId && providerId.includes(".")) {
            providerToolName = providerId.split(".").slice(1).join(".");
          } else if (providerId) {
            providerToolName = providerId;
          }
          return {
            type: "provider-defined",
            name: providerToolName,
            // TODO: as any seems wrong here. are there cases where we don't have an id?
            id: providerId,
            args: sdkTool.args
          };
        }
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    } catch (e) {
      console.error("Error preparing tool", e);
      return null;
    }
  }).filter((tool5) => tool5 !== null), toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName } };
}
__name(prepareToolsAndToolChoice2, "prepareToolsAndToolChoice");
async function consumeStream2({ stream, onError }) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done) break;
    }
  } catch (error87) {
    console.error("consumeStream error", error87);
    onError?.(error87);
  } finally {
    reader.releaseLock();
  }
}
__name(consumeStream2, "consumeStream");
var import_fast_deep_equal2 = __toESM2(require_fast_deep_equal(), 1);
function isV2Model(model) {
  return model.specificationVersion === "v2";
}
__name(isV2Model, "isV2Model");
async function consumeStream22({ stream, onError }) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done) break;
    }
  } catch (error87) {
    onError == null ? void 0 : onError(error87);
  } finally {
    reader.releaseLock();
  }
}
__name(consumeStream22, "consumeStream2");
var WorkflowRunOutput = class {
  static {
    __name(this, "WorkflowRunOutput");
  }
  #status = "running";
  #usageCount = { inputTokens: 0, outputTokens: 0, totalTokens: 0, cachedInputTokens: 0, reasoningTokens: 0 };
  #consumptionStarted = false;
  #baseStream;
  #emitter = new EventEmitter2();
  #bufferedChunks = [];
  #streamFinished = false;
  #streamError;
  #delayedPromises = { usage: new DelayedPromise2(), result: new DelayedPromise2() };
  /**
  * Unique identifier for this workflow run
  */
  runId;
  /**
  * Unique identifier for this workflow
  */
  workflowId;
  constructor({ runId, workflowId, stream }) {
    const self2 = this;
    this.runId = runId;
    this.workflowId = workflowId;
    this.#baseStream = stream;
    stream.pipeTo(new WritableStream({ start() {
      const chunk = { type: "workflow-start", runId: self2.runId, from: "WORKFLOW", payload: { workflowId: self2.workflowId } };
      self2.#bufferedChunks.push(chunk);
      self2.#emitter.emit("chunk", chunk);
    }, write(chunk) {
      if (chunk.type !== "workflow-step-finish") {
        self2.#bufferedChunks.push(chunk);
        self2.#emitter.emit("chunk", chunk);
      }
      if (chunk.type === "workflow-step-finish" && chunk.payload.usage) {
        self2.#updateUsageCount(chunk.payload.usage);
      } else if (chunk.type === "workflow-canceled") {
        self2.#status = "canceled";
      } else if (chunk.type === "workflow-step-suspended") {
        self2.#status = "suspended";
      } else if (chunk.type === "workflow-step-result" && chunk.payload.status === "failed") {
        self2.#status = "failed";
      }
    }, close() {
      if (self2.#status === "running") {
        self2.#status = "success";
      }
      self2.#emitter.emit("chunk", { type: "workflow-finish", runId: self2.runId, from: "WORKFLOW", payload: { workflowStatus: self2.#status, metadata: self2.#streamError ? { error: self2.#streamError, errorMessage: self2.#streamError?.message } : {}, output: {
        // @ts-ignore
        usage: self2.#usageCount
      } } });
      self2.#delayedPromises.usage.resolve(self2.#usageCount);
      Object.entries(self2.#delayedPromises).forEach(([key, promise3]) => {
        if (promise3.status.type === "pending") {
          promise3.reject(new Error(`promise '${key}' was not resolved or rejected when stream finished`));
        }
      });
      self2.#streamFinished = true;
      self2.#emitter.emit("finish");
    } })).catch((reason) => {
      console.log(" something went wrong", reason);
    });
  }
  #getDelayedPromise(promise3) {
    if (!this.#consumptionStarted) {
      void this.consumeStream();
    }
    return promise3.promise;
  }
  #updateUsageCount(usage) {
    let totalUsage = { inputTokens: 0, outputTokens: 0, totalTokens: 0, reasoningTokens: 0, cachedInputTokens: 0 };
    if ("inputTokens" in usage) {
      totalUsage.inputTokens += parseInt(usage?.inputTokens?.toString() ?? "0", 10);
      totalUsage.outputTokens += parseInt(usage?.outputTokens?.toString() ?? "0", 10);
    } else if ("promptTokens" in usage) {
      totalUsage.inputTokens += parseInt(usage?.promptTokens?.toString() ?? "0", 10);
      totalUsage.outputTokens += parseInt(usage?.completionTokens?.toString() ?? "0", 10);
    }
    totalUsage.totalTokens += parseInt(usage?.totalTokens?.toString() ?? "0", 10);
    totalUsage.reasoningTokens += parseInt(usage?.reasoningTokens?.toString() ?? "0", 10);
    totalUsage.cachedInputTokens += parseInt(usage?.cachedInputTokens?.toString() ?? "0", 10);
    this.#usageCount = totalUsage;
  }
  /**
  * @internal
  */
  updateResults(results) {
    this.#delayedPromises.result.resolve(results);
  }
  /**
  * @internal
  */
  rejectResults(error87) {
    this.#delayedPromises.result.reject(error87);
    this.#status = "failed";
    this.#streamError = error87;
  }
  /**
  * @internal
  */
  resume(stream) {
    this.#baseStream = stream;
    this.#streamFinished = false;
    this.#consumptionStarted = false;
    this.#status = "running";
    this.#delayedPromises = { usage: new DelayedPromise2(), result: new DelayedPromise2() };
    const self2 = this;
    stream.pipeTo(new WritableStream({ start() {
      const chunk = { type: "workflow-start", runId: self2.runId, from: "WORKFLOW", payload: { workflowId: self2.workflowId } };
      self2.#bufferedChunks.push(chunk);
      self2.#emitter.emit("chunk", chunk);
    }, write(chunk) {
      if (chunk.type !== "workflow-step-finish") {
        self2.#bufferedChunks.push(chunk);
        self2.#emitter.emit("chunk", chunk);
      }
      if (chunk.type === "workflow-step-finish" && chunk.payload.usage) {
        self2.#updateUsageCount(chunk.payload.usage);
      } else if (chunk.type === "workflow-canceled") {
        self2.#status = "canceled";
      } else if (chunk.type === "workflow-step-suspended") {
        self2.#status = "suspended";
      } else if (chunk.type === "workflow-step-result" && chunk.payload.status === "failed") {
        self2.#status = "failed";
      }
    }, close() {
      if (self2.#status === "running") {
        self2.#status = "success";
      }
      self2.#emitter.emit("chunk", { type: "workflow-finish", runId: self2.runId, from: "WORKFLOW", payload: { workflowStatus: self2.#status, metadata: self2.#streamError ? { error: self2.#streamError, errorMessage: self2.#streamError?.message } : {}, output: {
        // @ts-ignore
        usage: self2.#usageCount
      } } });
      self2.#streamFinished = true;
      self2.#emitter.emit("finish");
    } })).catch((reason) => {
      console.log(" something went wrong", reason);
    });
  }
  async consumeStream(options) {
    if (this.#consumptionStarted) {
      return;
    }
    this.#consumptionStarted = true;
    try {
      await consumeStream22({ stream: this.#baseStream, onError: options?.onError });
    } catch (error87) {
      options?.onError?.(error87);
    }
  }
  get fullStream() {
    const self2 = this;
    return new ReadableStream$1({ start(controller) {
      self2.#bufferedChunks.forEach((chunk) => {
        controller.enqueue(chunk);
      });
      if (self2.#streamFinished) {
        controller.close();
        return;
      }
      const chunkHandler = /* @__PURE__ */ __name((chunk) => {
        controller.enqueue(chunk);
      }, "chunkHandler");
      const finishHandler = /* @__PURE__ */ __name(() => {
        self2.#emitter.off("chunk", chunkHandler);
        self2.#emitter.off("finish", finishHandler);
        controller.close();
      }, "finishHandler");
      self2.#emitter.on("chunk", chunkHandler);
      self2.#emitter.on("finish", finishHandler);
    }, pull(_controller) {
      if (!self2.#consumptionStarted) {
        void self2.consumeStream();
      }
    }, cancel() {
      self2.#emitter.removeAllListeners();
    } });
  }
  get status() {
    return this.#status;
  }
  get result() {
    return this.#getDelayedPromise(this.#delayedPromises.result);
  }
  get usage() {
    return this.#getDelayedPromise(this.#delayedPromises.usage);
  }
  /**
  * @deprecated Use `fullStream.locked` instead
  */
  get locked() {
    console.warn("WorkflowRunOutput.locked is deprecated. Use fullStream.locked instead.");
    return this.fullStream.locked;
  }
  /**
  * @deprecated Use `fullStream.cancel()` instead
  */
  cancel(reason) {
    console.warn("WorkflowRunOutput.cancel() is deprecated. Use fullStream.cancel() instead.");
    return this.fullStream.cancel(reason);
  }
  /**
  * @deprecated Use `fullStream.getReader()` instead
  */
  getReader(options) {
    console.warn("WorkflowRunOutput.getReader() is deprecated. Use fullStream.getReader() instead.");
    return this.fullStream.getReader(options);
  }
  /**
  * @deprecated Use `fullStream.pipeThrough()` instead
  */
  pipeThrough(transform3, options) {
    console.warn("WorkflowRunOutput.pipeThrough() is deprecated. Use fullStream.pipeThrough() instead.");
    return this.fullStream.pipeThrough(transform3, options);
  }
  /**
  * @deprecated Use `fullStream.pipeTo()` instead
  */
  pipeTo(destination, options) {
    console.warn("WorkflowRunOutput.pipeTo() is deprecated. Use fullStream.pipeTo() instead.");
    return this.fullStream.pipeTo(destination, options);
  }
  /**
  * @deprecated Use `fullStream.tee()` instead
  */
  tee() {
    console.warn("WorkflowRunOutput.tee() is deprecated. Use fullStream.tee() instead.");
    return this.fullStream.tee();
  }
  /**
  * @deprecated Use `fullStream[Symbol.asyncIterator]()` instead
  */
  [Symbol.asyncIterator]() {
    console.warn("WorkflowRunOutput[Symbol.asyncIterator]() is deprecated. Use fullStream[Symbol.asyncIterator]() instead.");
    return this.fullStream[Symbol.asyncIterator]();
  }
  /**
  * Helper method to treat this object as a ReadableStream
  * @deprecated Use `fullStream` directly instead
  */
  toReadableStream() {
    console.warn("WorkflowRunOutput.toReadableStream() is deprecated. Use fullStream directly instead.");
    return this.fullStream;
  }
};
function runScorer({ runId, scorerId, scorerObject, input, output, runtimeContext, entity, structuredOutput, source, entityType, threadId, resourceId, tracingContext }) {
  let shouldExecute = false;
  if (!scorerObject?.sampling || scorerObject?.sampling?.type === "none") {
    shouldExecute = true;
  }
  if (scorerObject?.sampling?.type) {
    switch (scorerObject?.sampling?.type) {
      case "ratio":
        shouldExecute = Math.random() < scorerObject?.sampling?.rate;
        break;
      default:
        shouldExecute = true;
    }
  }
  if (!shouldExecute) {
    return;
  }
  const payload = { scorer: { id: scorerId, name: scorerObject.scorer.name, description: scorerObject.scorer.description }, input, output, runtimeContext: Object.fromEntries(runtimeContext.entries()), runId, source, entity, structuredOutput, entityType, threadId, resourceId, tracingContext };
  executeHook("onScorerRun", payload);
}
__name(runScorer, "runScorer");
var ExecutionEngine = class extends MastraBase {
  static {
    __name(this, "ExecutionEngine");
  }
  mastra;
  options;
  constructor({ mastra, options }) {
    super({ name: "ExecutionEngine", component: RegisteredLogger.WORKFLOW });
    this.mastra = mastra;
    this.options = options;
  }
  __registerMastra(mastra) {
    this.mastra = mastra;
  }
};
var getStepResult = /* @__PURE__ */ __name((stepResults, step) => {
  let result;
  if (typeof step === "string") {
    result = stepResults[step];
  } else {
    if (!step?.id) {
      return null;
    }
    result = stepResults[step.id];
  }
  return result?.status === "success" ? result.output : null;
}, "getStepResult");
function getZodErrors(error87) {
  const errors = error87.issues;
  return errors;
}
__name(getZodErrors, "getZodErrors");
async function validateStepInput({ prevOutput, step, validateInputs }) {
  let inputData = prevOutput;
  let validationError;
  if (validateInputs) {
    const inputSchema = step.inputSchema;
    const validatedInput = await inputSchema.safeParseAsync(prevOutput);
    if (!validatedInput.success) {
      const errors = getZodErrors(validatedInput.error);
      const errorMessages2 = errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n");
      validationError = new Error("Step input validation failed: \n" + errorMessages2);
    } else {
      const isEmptyData = isEmpty(validatedInput.data);
      inputData = isEmptyData ? prevOutput : validatedInput.data;
    }
  }
  return { inputData, validationError };
}
__name(validateStepInput, "validateStepInput");
async function validateStepResumeData({ resumeData, step }) {
  if (!resumeData) {
    return { resumeData: void 0, validationError: void 0 };
  }
  let validationError;
  const resumeSchema = step.resumeSchema;
  if (resumeSchema) {
    const validatedResumeData = await resumeSchema.safeParseAsync(resumeData);
    if (!validatedResumeData.success) {
      const errors = getZodErrors(validatedResumeData.error);
      const errorMessages2 = errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n");
      validationError = new Error("Step resume data validation failed: \n" + errorMessages2);
    } else {
      resumeData = validatedResumeData.data;
    }
  }
  return { resumeData, validationError };
}
__name(validateStepResumeData, "validateStepResumeData");
function getResumeLabelsByStepId(resumeLabels, stepId) {
  return Object.entries(resumeLabels).filter(([_, value]) => value.stepId === stepId).reduce((acc, [key, value]) => {
    acc[key] = value;
    return acc;
  }, {});
}
__name(getResumeLabelsByStepId, "getResumeLabelsByStepId");
var getStepIds = /* @__PURE__ */ __name((entry) => {
  if (entry.type === "step" || entry.type === "foreach" || entry.type === "loop") {
    return [entry.step.id];
  }
  if (entry.type === "parallel" || entry.type === "conditional") {
    return entry.steps.map((s) => s.step.id);
  }
  if (entry.type === "sleep" || entry.type === "sleepUntil") {
    return [entry.id];
  }
  return [];
}, "getStepIds");
var createTimeTravelExecutionParams = /* @__PURE__ */ __name((params) => {
  const { steps, inputData, resumeData, context: context3, nestedStepsContext, snapshot, initialState, graph } = params;
  const firstStepId = steps[0];
  let executionPath = [];
  const stepResults = {};
  const snapshotContext = snapshot.context;
  for (const [index, entry] of graph.steps.entries()) {
    const currentExecPathLength = executionPath.length;
    if (currentExecPathLength > 0 && !resumeData) {
      break;
    }
    const stepIds = getStepIds(entry);
    if (stepIds.includes(firstStepId)) {
      const innerExecutionPath = stepIds?.length > 1 ? [stepIds?.findIndex((s) => s === firstStepId)] : [];
      executionPath = [index, ...innerExecutionPath];
    }
    const prevStep = graph.steps[index - 1];
    let stepPayload = void 0;
    if (prevStep) {
      const prevStepIds = getStepIds(prevStep);
      if (prevStepIds.length > 0) {
        if (prevStepIds.length === 1) {
          stepPayload = stepResults?.[prevStepIds[0]]?.output ?? {};
        } else {
          stepPayload = prevStepIds.reduce((acc, stepId) => {
            acc[stepId] = stepResults?.[stepId]?.output ?? {};
            return acc;
          }, {});
        }
      }
    }
    if (index === 0 && stepIds.includes(firstStepId)) {
      stepResults.input = context3?.[firstStepId]?.payload ?? inputData ?? snapshotContext?.input;
    } else if (index === 0) {
      stepResults.input = stepIds?.reduce((acc, stepId) => {
        if (acc) return acc;
        return context3?.[stepId]?.payload ?? snapshotContext?.[stepId]?.payload;
      }, null) ?? snapshotContext?.input ?? {};
    }
    let stepOutput = void 0;
    const nextStep = graph.steps[index + 1];
    if (nextStep) {
      const nextStepIds = getStepIds(nextStep);
      if (nextStepIds.length > 0 && inputData && nextStepIds.includes(firstStepId) && steps.length === 1) {
        stepOutput = inputData;
      }
    }
    stepIds.forEach((stepId) => {
      let result;
      const stepContext = context3?.[stepId] ?? snapshotContext[stepId];
      const defaultStepStatus = steps?.includes(stepId) ? "running" : "success";
      const status = ["failed", "canceled"].includes(stepContext?.status) ? defaultStepStatus : stepContext?.status ?? defaultStepStatus;
      const isCompleteStatus = ["success", "failed", "canceled"].includes(status);
      result = { status, payload: context3?.[stepId]?.payload ?? stepPayload ?? snapshotContext[stepId]?.payload ?? {}, output: isCompleteStatus ? context3?.[stepId]?.output ?? stepOutput ?? snapshotContext[stepId]?.output ?? {} : void 0, resumePayload: stepContext?.resumePayload, suspendPayload: stepContext?.suspendPayload, suspendOutput: stepContext?.suspendOutput, startedAt: stepContext?.startedAt ?? Date.now(), endedAt: isCompleteStatus ? stepContext?.endedAt ?? Date.now() : void 0, suspendedAt: stepContext?.suspendedAt, resumedAt: stepContext?.resumedAt };
      if (currentExecPathLength > 0 && (!snapshotContext[stepId] || snapshotContext[stepId] && snapshotContext[stepId].status !== "suspended")) {
        result = void 0;
      }
      if (result) {
        const formattedResult = removeUndefinedValues(result);
        stepResults[stepId] = formattedResult;
      }
    });
  }
  if (!executionPath.length) {
    throw new Error(`Time travel target step not found in execution graph: '${steps?.join(".")}'. Verify the step id/path.`);
  }
  const timeTravelData = { inputData, executionPath, steps, stepResults, nestedStepResults: nestedStepsContext, state: initialState ?? snapshot.value ?? {}, resumeData };
  return timeTravelData;
}, "createTimeTravelExecutionParams");
var DefaultExecutionEngine = class extends ExecutionEngine {
  static {
    __name(this, "DefaultExecutionEngine");
  }
  /**
  * Preprocesses an error caught during workflow execution.
  *
  * - Wraps a non-MastraError exception
  * - Logs error details
  */
  preprocessExecutionError(e, errorDefinition, logPrefix) {
    const error87 = e instanceof MastraError ? e : new MastraError(errorDefinition, e);
    if (!(e instanceof MastraError) && e instanceof Error && e.stack) {
      error87.stack = e.stack;
    }
    this.logger?.trackException(error87);
    this.logger?.error(logPrefix + error87?.stack);
    return error87;
  }
  /**
  * The runCounts map is used to keep track of the run count for each step.
  * The step id is used as the key and the run count is the value.
  */
  runCounts = /* @__PURE__ */ new Map();
  /**
  * Get or generate the run count for a step.
  * If the step id is not in the map, it will be added and the run count will be 0.
  * If the step id is in the map, it will return the run count.
  *
  * @param stepId - The id of the step.
  * @returns The run count for the step.
  */
  getOrGenerateRunCount(stepId) {
    if (this.runCounts.has(stepId)) {
      const currentRunCount = this.runCounts.get(stepId);
      const nextRunCount = currentRunCount + 1;
      this.runCounts.set(stepId, nextRunCount);
      return nextRunCount;
    }
    const runCount = 0;
    this.runCounts.set(stepId, runCount);
    return runCount;
  }
  async fmtReturnValue(executionSpan, emitter, stepResults, lastOutput, error87) {
    const base = { status: lastOutput.status, steps: stepResults, input: stepResults.input };
    if (lastOutput.status === "success") {
      await emitter.emit("watch", { type: "watch", payload: { workflowState: { status: lastOutput.status, steps: stepResults, result: lastOutput.output } }, eventTimestamp: Date.now() });
      base.result = lastOutput.output;
    } else if (lastOutput.status === "failed") {
      await emitter.emit("watch", { type: "watch", payload: { workflowState: { status: lastOutput.status, steps: stepResults, result: null, error: lastOutput.error } }, eventTimestamp: Date.now() });
      if (error87 instanceof Error) {
        base.error = error87?.stack ?? error87;
      } else if (lastOutput.error) {
        base.error = lastOutput.error;
      } else if (typeof error87 === "string") {
        base.error = error87;
      } else {
        const errorMessage = safeParseErrorObject(error87);
        const errorObj = new Error("Unknown error: " + errorMessage);
        base.error = errorObj?.stack ?? errorObj;
      }
    } else if (lastOutput.status === "suspended") {
      const suspendedStepIds = Object.entries(stepResults).flatMap(([stepId, stepResult]) => {
        if (stepResult?.status === "suspended") {
          const nestedPath = stepResult?.suspendPayload?.__workflow_meta?.path;
          return nestedPath ? [[stepId, ...nestedPath]] : [[stepId]];
        }
        return [];
      });
      base.suspended = suspendedStepIds;
      await emitter.emit("watch", { type: "watch", payload: { workflowState: { status: lastOutput.status, steps: stepResults, result: null, error: null } }, eventTimestamp: Date.now() });
    }
    executionSpan?.end();
    return base;
  }
  /**
  * Executes a workflow run with the provided execution graph and input
  * @param graph The execution graph to execute
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  async execute(params) {
    const { workflowId, runId, resourceId, graph, input, initialState, resume, retryConfig, workflowAISpan, disableScorers, restart, timeTravel } = params;
    const { attempts = 0, delay: delay22 = 0 } = retryConfig ?? {};
    const steps = graph.steps;
    this.runCounts.clear();
    if (steps.length === 0) {
      const empty_graph_error = new MastraError({
        id: "WORKFLOW_EXECUTE_EMPTY_GRAPH",
        text: "Workflow must have at least one step",
        domain: "MASTRA_WORKFLOW",
        category: "USER"
        /* USER */
      });
      workflowAISpan?.error({ error: empty_graph_error });
      throw empty_graph_error;
    }
    const executionSpan = this.mastra?.getTelemetry()?.tracer.startSpan(`workflow.${workflowId}.execute`, { attributes: { componentName: workflowId, runId, resourceId } });
    let startIdx = 0;
    if (timeTravel) {
      startIdx = timeTravel.executionPath[0];
      timeTravel.executionPath.shift();
    } else if (restart) {
      startIdx = restart.activePaths[0];
      restart.activePaths.shift();
    } else if (resume?.resumePath) {
      startIdx = resume.resumePath[0];
      resume.resumePath.shift();
    }
    const stepResults = timeTravel?.stepResults || restart?.stepResults || resume?.stepResults || { input };
    let lastOutput;
    let lastState = timeTravel?.state ?? restart?.state ?? initialState ?? {};
    for (let i = startIdx; i < steps.length; i++) {
      const entry = steps[i];
      const executionContext = { workflowId, runId, executionPath: [i], activeStepsPath: {}, suspendedPaths: {}, resumeLabels: {}, retryConfig: { attempts, delay: delay22 }, executionSpan, format: params.format, state: lastState ?? initialState };
      try {
        lastOutput = await this.executeEntry({ workflowId, runId, resourceId, entry, executionContext, serializedStepGraph: params.serializedStepGraph, prevStep: steps[i - 1], stepResults, resume, timeTravel, restart, tracingContext: { currentSpan: workflowAISpan }, abortController: params.abortController, emitter: params.emitter, runtimeContext: params.runtimeContext, writableStream: params.writableStream, disableScorers });
        if (lastOutput.executionContext?.state) {
          lastState = lastOutput.executionContext.state;
        }
        if (lastOutput.result.status !== "success") {
          if (lastOutput.result.status === "bailed") {
            lastOutput.result.status = "success";
          }
          const result2 = await this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput.result);
          await this.persistStepUpdate({ workflowId, runId, resourceId, stepResults: lastOutput.stepResults, serializedStepGraph: params.serializedStepGraph, executionContext: lastOutput.executionContext, workflowStatus: result2.status, result: result2.result, error: result2.error, runtimeContext: params.runtimeContext });
          if (result2.error) {
            workflowAISpan?.error({ error: result2.error, attributes: { status: result2.status } });
          } else {
            workflowAISpan?.end({ output: result2.result, attributes: { status: result2.status } });
          }
          return { ...result2, ...lastOutput.result.status === "suspended" && params.outputOptions?.includeResumeLabels ? { resumeLabels: lastOutput.executionContext?.resumeLabels } : {}, ...params.outputOptions?.includeState ? { state: lastState } : {} };
        }
      } catch (e) {
        const error87 = this.preprocessExecutionError(e, { id: "WORKFLOW_ENGINE_STEP_EXECUTION_FAILED", domain: "MASTRA_WORKFLOW", category: "USER", details: { workflowId, runId } }, "Error executing step: ");
        const result2 = await this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput.result, e);
        await this.persistStepUpdate({ workflowId, runId, resourceId, stepResults: lastOutput.stepResults, serializedStepGraph: params.serializedStepGraph, executionContext: lastOutput.executionContext, workflowStatus: result2.status, result: result2.result, error: result2.error, runtimeContext: params.runtimeContext });
        workflowAISpan?.error({ error: error87, attributes: { status: result2.status } });
        return result2;
      }
    }
    const result = await this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput.result);
    await this.persistStepUpdate({ workflowId, runId, resourceId, stepResults: lastOutput.stepResults, serializedStepGraph: params.serializedStepGraph, executionContext: lastOutput.executionContext, workflowStatus: result.status, result: result.result, error: result.error, runtimeContext: params.runtimeContext });
    workflowAISpan?.end({ output: result.result, attributes: { status: result.status } });
    if (params.outputOptions?.includeState) {
      return { ...result, state: lastState };
    }
    return result;
  }
  getStepOutput(stepResults, step) {
    if (!step) {
      return stepResults.input;
    } else if (step.type === "step" || step.type === "waitForEvent") {
      return stepResults[step.step.id]?.output;
    } else if (step.type === "sleep" || step.type === "sleepUntil") {
      return stepResults[step.id]?.output;
    } else if (step.type === "parallel" || step.type === "conditional") {
      return step.steps.reduce((acc, entry) => {
        acc[entry.step.id] = stepResults[entry.step.id]?.output;
        return acc;
      }, {});
    } else if (step.type === "loop") {
      return stepResults[step.step.id]?.output;
    } else if (step.type === "foreach") {
      return stepResults[step.step.id]?.output;
    }
  }
  async executeSleep({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext }) {
    let { duration: duration5, fn } = entry;
    const sleepSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_sleep", name: `sleep: ${duration5 ? `${duration5}ms` : "dynamic"}`, attributes: { durationMs: duration5, sleepType: fn ? "dynamic" : "fixed" }, tracingPolicy: this.options?.tracingPolicy });
    if (fn) {
      const stepCallId = randomUUID3();
      duration5 = await fn({
        runId,
        workflowId,
        mastra: this.mastra,
        runtimeContext,
        inputData: prevOutput,
        state: executionContext.state,
        setState: /* @__PURE__ */ __name((state) => {
          executionContext.state = state;
        }, "setState"),
        runCount: -1,
        tracingContext: { currentSpan: sleepSpan },
        getInitData: /* @__PURE__ */ __name(() => stepResults?.input, "getInitData"),
        getStepResult: getStepResult.bind(this, stepResults),
        // TODO: this function shouldn't have suspend probably?
        suspend: /* @__PURE__ */ __name(async (_suspendPayload) => {
        }, "suspend"),
        bail: /* @__PURE__ */ __name(() => {
        }, "bail"),
        abort: /* @__PURE__ */ __name(() => {
          abortController?.abort();
        }, "abort"),
        [EMITTER_SYMBOL]: emitter,
        [STREAM_FORMAT_SYMBOL]: executionContext.format,
        engine: {},
        abortSignal: abortController?.signal,
        writer: new ToolStream({ prefix: "workflow-step", callId: stepCallId, name: "sleep", runId }, writableStream)
      });
      sleepSpan?.update({ attributes: { durationMs: duration5 } });
    }
    try {
      await new Promise((resolve3) => setTimeout(resolve3, !duration5 || duration5 < 0 ? 0 : duration5));
      sleepSpan?.end();
    } catch (e) {
      sleepSpan?.error({ error: e });
    }
  }
  async executeSleepUntil({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext }) {
    let { date: date9, fn } = entry;
    const sleepUntilSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_sleep", name: `sleepUntil: ${date9 ? date9.toISOString() : "dynamic"}`, attributes: { untilDate: date9, durationMs: date9 ? Math.max(0, date9.getTime() - Date.now()) : void 0, sleepType: fn ? "dynamic" : "fixed" }, tracingPolicy: this.options?.tracingPolicy });
    if (fn) {
      const stepCallId = randomUUID3();
      date9 = await fn({
        runId,
        workflowId,
        mastra: this.mastra,
        runtimeContext,
        inputData: prevOutput,
        state: executionContext.state,
        setState: /* @__PURE__ */ __name((state) => {
          executionContext.state = state;
        }, "setState"),
        runCount: -1,
        tracingContext: { currentSpan: sleepUntilSpan },
        getInitData: /* @__PURE__ */ __name(() => stepResults?.input, "getInitData"),
        getStepResult: getStepResult.bind(this, stepResults),
        // TODO: this function shouldn't have suspend probably?
        suspend: /* @__PURE__ */ __name(async (_suspendPayload) => {
        }, "suspend"),
        bail: /* @__PURE__ */ __name(() => {
        }, "bail"),
        abort: /* @__PURE__ */ __name(() => {
          abortController?.abort();
        }, "abort"),
        [EMITTER_SYMBOL]: emitter,
        [STREAM_FORMAT_SYMBOL]: executionContext.format,
        engine: {},
        abortSignal: abortController?.signal,
        writer: new ToolStream({ prefix: "workflow-step", callId: stepCallId, name: "sleepUntil", runId }, writableStream)
      });
      const time22 = !date9 ? 0 : date9.getTime() - Date.now();
      sleepUntilSpan?.update({ attributes: { durationMs: Math.max(0, time22) } });
    }
    const time5 = !date9 ? 0 : date9?.getTime() - Date.now();
    try {
      await new Promise((resolve3) => setTimeout(resolve3, time5 < 0 ? 0 : time5));
      sleepUntilSpan?.end();
    } catch (e) {
      sleepUntilSpan?.error({ error: e });
    }
  }
  async executeWaitForEvent({ event, emitter, timeout, tracingContext }) {
    const waitSpan = tracingContext?.currentSpan?.createChildSpan({ type: "workflow_wait_event", name: `wait: ${event}`, attributes: { eventName: event, timeoutMs: timeout }, tracingPolicy: this.options?.tracingPolicy });
    const startTime = Date.now();
    return new Promise((resolve3, reject) => {
      const cb = /* @__PURE__ */ __name((eventData) => {
        waitSpan?.end({ output: eventData, attributes: { eventReceived: true, waitDurationMs: Date.now() - startTime } });
        resolve3(eventData);
      }, "cb");
      if (timeout) {
        setTimeout(() => {
          emitter.off(`user-event-${event}`, cb);
          const error87 = new Error("Timeout waiting for event");
          waitSpan?.error({ error: error87, attributes: { eventReceived: false, waitDurationMs: Date.now() - startTime } });
          reject(error87);
        }, timeout);
      }
      emitter.once(`user-event-${event}`, cb);
    });
  }
  async executeStep({ workflowId, runId, resourceId, step, stepResults, executionContext, restart, resume, timeTravel, prevOutput, emitter, abortController, runtimeContext, skipEmits = false, writableStream, disableScorers, serializedStepGraph, tracingContext, iterationCount }) {
    const stepCallId = randomUUID3();
    const { inputData, validationError } = await validateStepInput({ prevOutput, step, validateInputs: this.options?.validateInputs ?? false });
    const { resumeData: timeTravelResumeData, validationError: timeTravelResumeValidationError } = await validateStepResumeData({ resumeData: timeTravel?.stepResults[step.id]?.status === "suspended" ? timeTravel?.resumeData : void 0, step });
    let resumeDataToUse;
    if (timeTravelResumeData && !timeTravelResumeValidationError) {
      resumeDataToUse = timeTravelResumeData;
    } else if (timeTravelResumeData && timeTravelResumeValidationError) {
      this.logger.warn("Time travel resume data validation failed", { stepId: step.id, error: timeTravelResumeValidationError.message });
    } else if (resume?.steps[0] === step.id) {
      resumeDataToUse = resume?.resumePayload;
    }
    const startTime = resumeDataToUse ? void 0 : Date.now();
    const resumeTime = resumeDataToUse ? Date.now() : void 0;
    const stepInfo = { ...stepResults[step.id], ...resumeDataToUse ? { resumePayload: resumeDataToUse } : { payload: inputData }, ...startTime ? { startedAt: startTime } : {}, ...resumeTime ? { resumedAt: resumeTime } : {}, status: "running", ...iterationCount ? { metadata: { iterationCount } } : {} };
    executionContext.activeStepsPath[step.id] = executionContext.executionPath;
    const stepAISpan = tracingContext.currentSpan?.createChildSpan({ name: `workflow step: '${step.id}'`, type: "workflow_step", input: inputData, attributes: { stepId: step.id }, tracingPolicy: this.options?.tracingPolicy });
    if (!skipEmits) {
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: step.id, ...stepInfo }, workflowState: { status: "running", steps: { ...stepResults, [step.id]: { ...stepInfo } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-start", payload: { id: step.id, stepCallId, ...stepInfo } });
    }
    await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults: { ...stepResults, [step.id]: stepInfo }, executionContext, workflowStatus: "running", runtimeContext });
    const _runStep = /* @__PURE__ */ __name((step2, spanName, attributes) => {
      return async (data) => {
        const telemetry = this.mastra?.getTelemetry();
        const span = executionContext.executionSpan;
        if (!telemetry || !span) {
          return step2.execute(data);
        }
        return import_api5.context.with(import_api5.trace.setSpan(import_api5.context.active(), span), async () => {
          return telemetry.traceMethod(step2.execute.bind(step2), { spanName, attributes })(data);
        });
      };
    }, "_runStep");
    const runStep = _runStep(step, `workflow.${workflowId}.step.${step.id}`, { componentName: workflowId, runId, resourceId: resourceId ?? "" });
    let execResults;
    const retries = step.retries ?? executionContext.retryConfig.attempts ?? 0;
    const delay22 = executionContext.retryConfig.delay ?? 0;
    let executionContextState = executionContext.state;
    for (let i = 0; i < retries + 1; i++) {
      if (i > 0 && delay22) {
        await new Promise((resolve3) => setTimeout(resolve3, delay22));
      }
      try {
        let suspended;
        let bailed;
        if (validationError) {
          throw validationError;
        }
        let timeTravelSteps = [];
        if (timeTravel && timeTravel.steps.length > 0) {
          timeTravelSteps = timeTravel.steps[0] === step.id ? timeTravel.steps.slice(1) : [];
        }
        const result = await runStep({
          runId,
          resourceId,
          workflowId,
          mastra: this.mastra ? wrapMastra(this.mastra, { currentSpan: stepAISpan }) : void 0,
          runtimeContext,
          inputData,
          state: executionContext.state,
          setState: /* @__PURE__ */ __name((state) => {
            executionContext.state = state;
            executionContextState = state;
          }, "setState"),
          runCount: this.getOrGenerateRunCount(step.id),
          resumeData: resumeDataToUse,
          tracingContext: { currentSpan: stepAISpan },
          getInitData: /* @__PURE__ */ __name(() => stepResults?.input, "getInitData"),
          getStepResult: getStepResult.bind(this, stepResults),
          suspend: /* @__PURE__ */ __name(async (suspendPayload, suspendOptions) => {
            executionContext.suspendedPaths[step.id] = executionContext.executionPath;
            if (suspendOptions?.resumeLabel) {
              const resumeLabel = Array.isArray(suspendOptions.resumeLabel) ? suspendOptions.resumeLabel : [suspendOptions.resumeLabel];
              for (const label of resumeLabel) {
                executionContext.resumeLabels[label] = { stepId: step.id, foreachIndex: executionContext.foreachIndex };
              }
            }
            suspended = { payload: suspendPayload };
          }, "suspend"),
          bail: /* @__PURE__ */ __name((result2) => {
            bailed = { payload: result2 };
          }, "bail"),
          abort: /* @__PURE__ */ __name(() => {
            abortController?.abort();
          }, "abort"),
          // Only pass resume data if this step was actually suspended before
          // This prevents pending nested workflows from trying to resume instead of start
          resume: stepResults[step.id]?.status === "suspended" ? {
            steps: resume?.steps?.slice(1) || [],
            resumePayload: resume?.resumePayload,
            // @ts-ignore
            runId: stepResults[step.id]?.suspendPayload?.__workflow_meta?.runId,
            label: resume?.label,
            forEachIndex: resume?.forEachIndex
          } : void 0,
          // Only pass restart data if this step is part of activeStepsPath
          // This prevents pending nested workflows from trying to restart instead of start
          restart: !!restart?.activeStepsPath?.[step.id],
          timeTravel: timeTravelSteps.length > 0 ? { inputData: timeTravel?.inputData, steps: timeTravelSteps, nestedStepResults: timeTravel?.nestedStepResults, resumeData: timeTravel?.resumeData } : void 0,
          [EMITTER_SYMBOL]: emitter,
          [STREAM_FORMAT_SYMBOL]: executionContext.format,
          engine: {},
          abortSignal: abortController?.signal,
          writer: new ToolStream({ prefix: "workflow-step", callId: stepCallId, name: step.id, runId }, writableStream),
          // Disable scorers must be explicitly set to false they are on by default
          scorers: disableScorers === false ? void 0 : step.scorers,
          validateInputs: this.options?.validateInputs
        });
        if (step.scorers) {
          await this.runScorers({ scorers: step.scorers, runId, input: inputData, output: result, workflowId, stepId: step.id, runtimeContext, disableScorers, tracingContext: { currentSpan: stepAISpan } });
        }
        if (suspended) {
          execResults = { status: "suspended", suspendPayload: suspended.payload, suspendedAt: Date.now() };
        } else if (bailed) {
          execResults = { status: "bailed", output: bailed.payload, endedAt: Date.now() };
        } else {
          execResults = { status: "success", output: result, endedAt: Date.now() };
        }
        break;
      } catch (e) {
        const error87 = this.preprocessExecutionError(e, { id: "WORKFLOW_STEP_INVOKE_FAILED", domain: "MASTRA_WORKFLOW", category: "USER", details: { workflowId, runId, stepId: step.id } }, `Error executing step ${step.id}: `);
        stepAISpan?.error({ error: error87, attributes: { status: "failed" } });
        execResults = { status: "failed", error: error87?.stack, endedAt: Date.now() };
      }
    }
    delete executionContext.activeStepsPath[step.id];
    if (!skipEmits) {
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: step.id, ...stepInfo, ...execResults }, workflowState: { status: "running", steps: { ...stepResults, [step.id]: { ...stepInfo, ...execResults } }, result: null, error: null } }, eventTimestamp: Date.now() });
      if (execResults.status === "suspended") {
        await emitter.emit("watch-v2", { type: "workflow-step-suspended", payload: { id: step.id, stepCallId, ...execResults } });
      } else {
        await emitter.emit("watch-v2", { type: "workflow-step-result", payload: { id: step.id, stepCallId, ...execResults } });
        await emitter.emit("watch-v2", { type: "workflow-step-finish", payload: { id: step.id, stepCallId, metadata: {} } });
      }
    }
    if (execResults.status != "failed") {
      stepAISpan?.end({ output: execResults.output, attributes: { status: execResults.status } });
    }
    return { result: { ...stepInfo, ...execResults }, executionContextState };
  }
  async runScorers({ scorers, runId, input, output, workflowId, stepId, runtimeContext, disableScorers, tracingContext }) {
    let scorersToUse = scorers;
    if (typeof scorersToUse === "function") {
      try {
        scorersToUse = await scorersToUse({ runtimeContext });
      } catch (error87) {
        this.preprocessExecutionError(error87, { id: "WORKFLOW_FAILED_TO_FETCH_SCORERS", domain: "MASTRA_WORKFLOW", category: "USER", details: { runId, workflowId, stepId } }, "Error fetching scorers: ");
      }
    }
    if (!disableScorers && scorersToUse && Object.keys(scorersToUse || {}).length > 0) {
      for (const [_id, scorerObject] of Object.entries(scorersToUse || {})) {
        runScorer({ scorerId: scorerObject.name, scorerObject, runId, input, output, runtimeContext, entity: { id: workflowId, stepId }, structuredOutput: true, source: "LIVE", entityType: "WORKFLOW", tracingContext });
      }
    }
  }
  async executeParallel({ workflowId, runId, resourceId, entry, prevStep, serializedStepGraph, stepResults, resume, restart, timeTravel, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers }) {
    const parallelSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_parallel", name: `parallel: '${entry.steps.length} branches'`, input: this.getStepOutput(stepResults, prevStep), attributes: { branchCount: entry.steps.length, parallelSteps: entry.steps.map((s) => s.type === "step" ? s.step.id : `control-${s.type}`) }, tracingPolicy: this.options?.tracingPolicy });
    const prevOutput = this.getStepOutput(stepResults, prevStep);
    for (const [stepIndex, step] of entry.steps.entries()) {
      let makeStepRunning = true;
      if (restart) {
        makeStepRunning = !!restart.activeStepsPath[step.step.id];
      }
      if (timeTravel && timeTravel.executionPath.length > 0) {
        makeStepRunning = timeTravel.steps[0] === step.step.id;
      }
      if (!makeStepRunning) {
        continue;
      }
      const startTime = resume?.steps[0] === step.step.id ? void 0 : Date.now();
      const resumeTime = resume?.steps[0] === step.step.id ? Date.now() : void 0;
      stepResults[step.step.id] = { ...stepResults[step.step.id], status: "running", ...resumeTime ? { resumePayload: resume?.resumePayload } : { payload: prevOutput }, ...startTime ? { startedAt: startTime } : {}, ...resumeTime ? { resumedAt: resumeTime } : {} };
      executionContext.activeStepsPath[step.step.id] = [...executionContext.executionPath, stepIndex];
    }
    if (timeTravel && timeTravel.executionPath.length > 0) {
      timeTravel.executionPath.shift();
    }
    let execResults;
    const results = await Promise.all(entry.steps.map(async (step, i) => {
      const currStepResult = stepResults[step.step.id];
      if (currStepResult && currStepResult.status !== "running") {
        return currStepResult;
      }
      const result = await this.executeStep({ workflowId, runId, resourceId, step: step.step, prevOutput, stepResults, serializedStepGraph, restart, timeTravel, resume, executionContext: { activeStepsPath: executionContext.activeStepsPath, workflowId, runId, executionPath: [...executionContext.executionPath, i], suspendedPaths: executionContext.suspendedPaths, resumeLabels: executionContext.resumeLabels, retryConfig: executionContext.retryConfig, executionSpan: executionContext.executionSpan, state: executionContext.state }, tracingContext: { currentSpan: parallelSpan }, emitter, abortController, runtimeContext, writableStream, disableScorers });
      stepResults[step.step.id] = result.result;
      executionContext.state = result.executionContextState;
      return result.result;
    }));
    const hasFailed = results.find((result) => result.status === "failed");
    const hasSuspended = results.find((result) => result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", payload: hasSuspended.suspendPayload };
    } else if (abortController?.signal?.aborted) {
      execResults = { status: "canceled" };
    } else {
      execResults = { status: "success", output: results.reduce((acc, result, index) => {
        if (result.status === "success") {
          acc[entry.steps[index].step.id] = result.output;
        }
        return acc;
      }, {}) };
    }
    if (execResults.status === "failed") {
      parallelSpan?.error({ error: new Error(execResults.error) });
    } else {
      parallelSpan?.end({ output: execResults.output || execResults });
    }
    return execResults;
  }
  async executeConditional({ workflowId, runId, resourceId, entry, prevOutput, serializedStepGraph, stepResults, resume, restart, timeTravel, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers }) {
    const conditionalSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_conditional", name: `conditional: '${entry.conditions.length} conditions'`, input: prevOutput, attributes: { conditionCount: entry.conditions.length }, tracingPolicy: this.options?.tracingPolicy });
    let execResults;
    const truthyIndexes = (await Promise.all(entry.conditions.map(async (cond, index) => {
      const evalSpan = conditionalSpan?.createChildSpan({ type: "workflow_conditional_eval", name: `condition '${index}'`, input: prevOutput, attributes: { conditionIndex: index }, tracingPolicy: this.options?.tracingPolicy });
      try {
        const result = await cond({
          runId,
          workflowId,
          mastra: this.mastra,
          runtimeContext,
          inputData: prevOutput,
          state: executionContext.state,
          setState: /* @__PURE__ */ __name((state) => {
            executionContext.state = state;
          }, "setState"),
          runCount: -1,
          tracingContext: { currentSpan: evalSpan },
          getInitData: /* @__PURE__ */ __name(() => stepResults?.input, "getInitData"),
          getStepResult: getStepResult.bind(this, stepResults),
          // TODO: this function shouldn't have suspend probably?
          suspend: /* @__PURE__ */ __name(async (_suspendPayload) => {
          }, "suspend"),
          bail: /* @__PURE__ */ __name(() => {
          }, "bail"),
          abort: /* @__PURE__ */ __name(() => {
            abortController?.abort();
          }, "abort"),
          [EMITTER_SYMBOL]: emitter,
          [STREAM_FORMAT_SYMBOL]: executionContext.format,
          engine: {},
          abortSignal: abortController?.signal,
          writer: new ToolStream({ prefix: "workflow-step", callId: randomUUID3(), name: "conditional", runId }, writableStream)
        });
        evalSpan?.end({ output: result, attributes: { result: !!result } });
        return result ? index : null;
      } catch (e) {
        const error87 = this.preprocessExecutionError(e, { id: "WORKFLOW_CONDITION_EVALUATION_FAILED", domain: "MASTRA_WORKFLOW", category: "USER", details: { workflowId, runId } }, "Error evaluating condition: ");
        evalSpan?.error({ error: error87, attributes: { result: false } });
        return null;
      }
    }))).filter((index) => index !== null);
    const stepsToRun = entry.steps.filter((_, index) => truthyIndexes.includes(index));
    conditionalSpan?.update({ attributes: { truthyIndexes, selectedSteps: stepsToRun.map((s) => s.type === "step" ? s.step.id : `control-${s.type}`) } });
    const results = await Promise.all(stepsToRun.map(async (step, index) => {
      const currStepResult = stepResults[step.step.id];
      const isRestartStep = restart ? !!restart.activeStepsPath[step.step.id] : void 0;
      if (currStepResult && timeTravel && timeTravel.executionPath.length > 0) {
        if (timeTravel.steps[0] !== step.step.id) {
          return currStepResult;
        }
      }
      if (currStepResult && ["success", "failed"].includes(currStepResult.status) && isRestartStep === void 0) {
        return currStepResult;
      }
      const result = await this.executeStep({ workflowId, runId, resourceId, step: step.step, prevOutput, stepResults, serializedStepGraph, resume, restart, timeTravel, executionContext: { workflowId, runId, executionPath: [...executionContext.executionPath, index], activeStepsPath: executionContext.activeStepsPath, suspendedPaths: executionContext.suspendedPaths, resumeLabels: executionContext.resumeLabels, retryConfig: executionContext.retryConfig, executionSpan: executionContext.executionSpan, state: executionContext.state }, tracingContext: { currentSpan: conditionalSpan }, emitter, abortController, runtimeContext, writableStream, disableScorers });
      stepResults[step.step.id] = result.result;
      executionContext.state = result.executionContextState;
      return result.result;
    }));
    const hasFailed = results.find((result) => result.status === "failed");
    const hasSuspended = results.find((result) => result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", payload: hasSuspended.suspendPayload, suspendedAt: Date.now() };
    } else if (abortController?.signal?.aborted) {
      execResults = { status: "canceled" };
    } else {
      execResults = { status: "success", output: results.reduce((acc, result, index) => {
        if (result.status === "success") {
          acc[stepsToRun[index].step.id] = result.output;
        }
        return acc;
      }, {}) };
    }
    if (execResults.status === "failed") {
      conditionalSpan?.error({ error: new Error(execResults.error) });
    } else {
      conditionalSpan?.end({ output: execResults.output || execResults });
    }
    return execResults;
  }
  async executeLoop({ workflowId, runId, resourceId, entry, prevOutput, stepResults, resume, restart, timeTravel, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph }) {
    const { step, condition } = entry;
    const loopSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_loop", name: `loop: '${entry.loopType}'`, input: prevOutput, attributes: { loopType: entry.loopType }, tracingPolicy: this.options?.tracingPolicy });
    let isTrue = true;
    const prevIterationCount = stepResults[step.id]?.metadata?.iterationCount;
    let iteration = prevIterationCount ? prevIterationCount - 1 : 0;
    const prevPayload = stepResults[step.id]?.payload;
    let result = { status: "success", output: prevPayload ?? prevOutput };
    let currentResume = resume;
    let currentRestart = restart;
    let currentTimeTravel = timeTravel;
    do {
      const { result: stepResult, executionContextState } = await this.executeStep({ workflowId, runId, resourceId, step, stepResults, executionContext, restart: currentRestart, resume: currentResume, timeTravel: currentTimeTravel, prevOutput: result.output, tracingContext: { currentSpan: loopSpan }, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph, iterationCount: iteration + 1 });
      result = stepResult;
      executionContext.state = executionContextState;
      currentRestart = void 0;
      currentTimeTravel = void 0;
      if (currentResume && result.status !== "suspended") {
        currentResume = void 0;
      }
      if (result.status !== "success") {
        loopSpan?.end({ attributes: { totalIterations: iteration } });
        return result;
      }
      const evalSpan = loopSpan?.createChildSpan({ type: "workflow_conditional_eval", name: `condition: '${entry.loopType}'`, input: selectFields2(result.output, ["stepResult", "output.text", "output.object", "messages"]), attributes: { conditionIndex: iteration }, tracingPolicy: this.options?.tracingPolicy });
      isTrue = await condition({ workflowId, runId, mastra: this.mastra, runtimeContext, inputData: result.output, state: executionContext.state, setState: /* @__PURE__ */ __name((state) => {
        executionContext.state = state;
      }, "setState"), runCount: -1, tracingContext: { currentSpan: evalSpan }, iterationCount: iteration + 1, getInitData: /* @__PURE__ */ __name(() => stepResults?.input, "getInitData"), getStepResult: getStepResult.bind(this, stepResults), suspend: /* @__PURE__ */ __name(async (_suspendPayload) => {
      }, "suspend"), bail: /* @__PURE__ */ __name(() => {
      }, "bail"), abort: /* @__PURE__ */ __name(() => {
        abortController?.abort();
      }, "abort"), [EMITTER_SYMBOL]: emitter, [STREAM_FORMAT_SYMBOL]: executionContext.format, engine: {}, abortSignal: abortController?.signal, writer: new ToolStream({ prefix: "workflow-step", callId: randomUUID3(), name: "loop", runId }, writableStream) });
      evalSpan?.end({ output: isTrue });
      iteration++;
    } while (entry.loopType === "dowhile" ? isTrue : !isTrue);
    loopSpan?.end({ output: result.output, attributes: { totalIterations: iteration } });
    return result;
  }
  async executeForeach({ workflowId, runId, resourceId, entry, prevOutput, stepResults, restart, resume, timeTravel, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph }) {
    const { step, opts } = entry;
    const results = [];
    const concurrency = opts.concurrency;
    const startTime = resume?.steps[0] === step.id ? void 0 : Date.now();
    const resumeTime = resume?.steps[0] === step.id ? Date.now() : void 0;
    const stepInfo = { ...stepResults[step.id], ...resume?.steps[0] === step.id ? { resumePayload: resume?.resumePayload } : { payload: prevOutput }, ...startTime ? { startedAt: startTime } : {}, ...resumeTime ? { resumedAt: resumeTime } : {} };
    const loopSpan = tracingContext.currentSpan?.createChildSpan({ type: "workflow_loop", name: `loop: 'foreach'`, input: prevOutput, attributes: { loopType: "foreach", concurrency }, tracingPolicy: this.options?.tracingPolicy });
    await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: step.id, status: "running", ...stepInfo }, workflowState: { status: "running", steps: { ...stepResults, [step.id]: { status: "running", ...stepInfo } }, result: null, error: null } }, eventTimestamp: Date.now() });
    await emitter.emit("watch-v2", { type: "workflow-step-start", payload: { id: step.id, ...stepInfo, status: "running" } });
    const prevPayload = stepResults[step.id];
    const foreachIndexObj = {};
    const resumeIndex = prevPayload?.status === "suspended" ? prevPayload?.suspendPayload?.__workflow_meta?.foreachIndex || 0 : 0;
    const prevForeachOutput = prevPayload?.suspendPayload?.__workflow_meta?.foreachOutput || [];
    const prevResumeLabels = prevPayload?.suspendPayload?.__workflow_meta?.resumeLabels || {};
    const resumeLabels = getResumeLabelsByStepId(prevResumeLabels, step.id);
    for (let i = 0; i < prevOutput.length; i += concurrency) {
      const items = prevOutput.slice(i, i + concurrency);
      const itemsResults = await Promise.all(items.map(async (item, j) => {
        const k = i + j;
        const prevItemResult = prevForeachOutput[k];
        if (prevItemResult?.status === "success" || prevItemResult?.status === "suspended" && resume?.forEachIndex !== k && resume?.forEachIndex !== void 0) {
          return prevItemResult;
        }
        let resumeToUse = void 0;
        if (resume?.forEachIndex !== void 0) {
          resumeToUse = resume.forEachIndex === k ? resume : void 0;
        } else {
          const isIndexSuspended = prevItemResult?.status === "suspended" || resumeIndex === k;
          if (isIndexSuspended) {
            resumeToUse = resume;
          }
        }
        const stepResult = await this.executeStep({ workflowId, runId, resourceId, step, stepResults, restart, timeTravel, executionContext: { ...executionContext, foreachIndex: k }, resume: resumeToUse, prevOutput: item, tracingContext: { currentSpan: loopSpan }, emitter, abortController, runtimeContext, skipEmits: true, writableStream, disableScorers, serializedStepGraph });
        stepResults[step.id] = stepResult.result;
        executionContext.state = stepResult.executionContextState;
        return stepResult.result;
      }));
      for (const [resultIndex, result] of itemsResults.entries()) {
        if (result.status !== "success") {
          const { status, error: error87, suspendPayload, suspendedAt, endedAt, output } = result;
          const execResults = { status, error: error87, suspendPayload, suspendedAt, endedAt, output };
          await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: step.id, ...stepInfo, ...execResults }, workflowState: { status: "running", steps: { ...stepResults, [step.id]: { ...stepInfo, ...execResults } }, result: null, error: null } }, eventTimestamp: Date.now() });
          if (execResults.status === "suspended") {
            foreachIndexObj[i + resultIndex] = execResults;
          } else {
            await emitter.emit("watch-v2", { type: "workflow-step-result", payload: { id: step.id, ...execResults } });
            await emitter.emit("watch-v2", { type: "workflow-step-finish", payload: { id: step.id, metadata: {} } });
            return result;
          }
        } else {
          const indexResumeLabel = Object.keys(resumeLabels).find((key) => resumeLabels[key]?.foreachIndex === i + resultIndex);
          delete resumeLabels[indexResumeLabel];
        }
        if (result?.output) {
          results[i + resultIndex] = result?.output;
        }
        prevForeachOutput[i + resultIndex] = { ...result, suspendPayload: {} };
      }
      if (Object.keys(foreachIndexObj).length > 0) {
        const suspendedIndices = Object.keys(foreachIndexObj).map(Number);
        const foreachIndex = suspendedIndices[0];
        await emitter.emit("watch-v2", { type: "workflow-step-suspended", payload: { id: step.id, ...foreachIndexObj[foreachIndex] } });
        executionContext.suspendedPaths[step.id] = executionContext.executionPath;
        executionContext.resumeLabels = { ...resumeLabels, ...executionContext.resumeLabels };
        return { ...stepInfo, suspendedAt: Date.now(), status: "suspended", suspendPayload: { ...foreachIndexObj[foreachIndex].suspendPayload, __workflow_meta: { ...foreachIndexObj[foreachIndex].suspendPayload?.__workflow_meta, foreachIndex, foreachOutput: prevForeachOutput, resumeLabels: executionContext.resumeLabels } } };
      }
    }
    await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: step.id, ...stepInfo, status: "success", output: results, endedAt: Date.now() }, workflowState: { status: "running", steps: { ...stepResults, [step.id]: { ...stepInfo, status: "success", output: results, endedAt: Date.now() } }, result: null, error: null } }, eventTimestamp: Date.now() });
    await emitter.emit("watch-v2", { type: "workflow-step-result", payload: { id: step.id, status: "success", output: results, endedAt: Date.now() } });
    await emitter.emit("watch-v2", { type: "workflow-step-finish", payload: { id: step.id, metadata: {} } });
    loopSpan?.end({ output: results });
    return {
      ...stepInfo,
      status: "success",
      output: results,
      //@ts-ignore
      endedAt: Date.now()
    };
  }
  async persistStepUpdate({ workflowId, runId, resourceId, stepResults, serializedStepGraph, executionContext, workflowStatus, result, error: error87, runtimeContext }) {
    const shouldPersistSnapshot = this.options?.shouldPersistSnapshot?.({ stepResults, workflowStatus });
    if (!shouldPersistSnapshot) {
      return;
    }
    const runtimeContextObj = {};
    runtimeContext.forEach((value, key) => {
      runtimeContextObj[key] = value;
    });
    await this.mastra?.getStorage()?.persistWorkflowSnapshot({ workflowName: workflowId, runId, resourceId, snapshot: {
      runId,
      status: workflowStatus,
      value: executionContext.state,
      context: stepResults,
      activePaths: executionContext.executionPath,
      activeStepsPath: executionContext.activeStepsPath,
      serializedStepGraph,
      suspendedPaths: executionContext.suspendedPaths,
      waitingPaths: {},
      resumeLabels: executionContext.resumeLabels,
      result,
      error: error87,
      runtimeContext: runtimeContextObj,
      // @ts-ignore
      timestamp: Date.now()
    } });
  }
  async executeEntry({ workflowId, runId, resourceId, entry, prevStep, serializedStepGraph, stepResults, restart, timeTravel, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers }) {
    const prevOutput = this.getStepOutput(stepResults, prevStep);
    let execResults;
    if (entry.type === "step") {
      const { step } = entry;
      const { result, executionContextState } = await this.executeStep({ workflowId, runId, resourceId, step, stepResults, executionContext, timeTravel, restart, resume, prevOutput, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph });
      execResults = result;
      executionContext.state = executionContextState;
    } else if (resume?.resumePath?.length && entry.type === "parallel") {
      const idx = resume.resumePath.shift();
      const resumedStepResult = await this.executeEntry({ workflowId, runId, resourceId, entry: entry.steps[idx], prevStep, serializedStepGraph, stepResults, resume, executionContext: { workflowId, runId, executionPath: [...executionContext.executionPath, idx], suspendedPaths: executionContext.suspendedPaths, resumeLabels: executionContext.resumeLabels, retryConfig: executionContext.retryConfig, executionSpan: executionContext.executionSpan, activeStepsPath: executionContext.activeStepsPath, state: executionContext.state }, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers });
      if (resumedStepResult.stepResults) {
        Object.assign(stepResults, resumedStepResult.stepResults);
      }
      const allParallelStepsComplete = entry.steps.every((parallelStep) => {
        if (parallelStep.type === "step") {
          const stepResult = stepResults[parallelStep.step.id];
          return stepResult && stepResult.status === "success";
        }
        return true;
      });
      if (allParallelStepsComplete) {
        execResults = { status: "success", output: entry.steps.reduce((acc, parallelStep) => {
          if (parallelStep.type === "step") {
            const stepResult = stepResults[parallelStep.step.id];
            if (stepResult && stepResult.status === "success") {
              acc[parallelStep.step.id] = stepResult.output;
            }
          }
          return acc;
        }, {}) };
      } else {
        const stillSuspended = entry.steps.find((parallelStep) => {
          if (parallelStep.type === "step") {
            const stepResult = stepResults[parallelStep.step.id];
            return stepResult && stepResult.status === "suspended";
          }
          return false;
        });
        execResults = { status: "suspended", payload: stillSuspended && stillSuspended.type === "step" ? stepResults[stillSuspended.step.id]?.suspendPayload : {} };
      }
      const updatedExecutionContext = { ...executionContext, ...resumedStepResult.executionContext, suspendedPaths: { ...executionContext.suspendedPaths, ...resumedStepResult.executionContext?.suspendedPaths } };
      if (execResults.status === "suspended") {
        entry.steps.forEach((parallelStep, stepIndex) => {
          if (parallelStep.type === "step") {
            const stepResult = stepResults[parallelStep.step.id];
            if (stepResult && stepResult.status === "suspended") {
              updatedExecutionContext.suspendedPaths[parallelStep.step.id] = [...executionContext.executionPath, stepIndex];
            }
          }
        });
      }
      return { result: execResults, stepResults: resumedStepResult.stepResults, executionContext: updatedExecutionContext };
    } else if (entry.type === "parallel") {
      execResults = await this.executeParallel({ workflowId, runId, entry, prevStep, stepResults, serializedStepGraph, timeTravel, restart, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers });
    } else if (entry.type === "conditional") {
      execResults = await this.executeConditional({ workflowId, runId, entry, prevOutput, stepResults, serializedStepGraph, timeTravel, restart, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers });
    } else if (entry.type === "loop") {
      execResults = await this.executeLoop({ workflowId, runId, entry, prevStep, prevOutput, stepResults, timeTravel, restart, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph });
    } else if (entry.type === "foreach") {
      execResults = await this.executeForeach({ workflowId, runId, entry, prevStep, prevOutput, stepResults, timeTravel, restart, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph });
    } else if (entry.type === "sleep") {
      const startedAt = Date.now();
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: entry.id, status: "waiting", payload: prevOutput, startedAt }, workflowState: { status: "waiting", steps: { ...stepResults, [entry.id]: { status: "waiting", payload: prevOutput, startedAt } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-waiting", payload: { id: entry.id, payload: prevOutput, startedAt, status: "waiting" } });
      stepResults[entry.id] = { status: "waiting", payload: prevOutput, startedAt };
      executionContext.activeStepsPath[entry.id] = executionContext.executionPath;
      await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: "waiting", runtimeContext });
      await this.executeSleep({ workflowId, runId, entry, prevStep, prevOutput, stepResults, serializedStepGraph, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream });
      delete executionContext.activeStepsPath[entry.id];
      await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: "running", runtimeContext });
      const endedAt = Date.now();
      const stepInfo = { payload: prevOutput, startedAt, endedAt };
      execResults = { ...stepInfo, status: "success", output: prevOutput };
      stepResults[entry.id] = { ...stepInfo, status: "success", output: prevOutput };
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: entry.id, ...execResults }, workflowState: { status: "running", steps: { ...stepResults, [entry.id]: { ...execResults } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-result", payload: { id: entry.id, endedAt, status: "success", output: prevOutput } });
      await emitter.emit("watch-v2", { type: "workflow-step-finish", payload: { id: entry.id, metadata: {} } });
    } else if (entry.type === "sleepUntil") {
      const startedAt = Date.now();
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: entry.id, status: "waiting", payload: prevOutput, startedAt }, workflowState: { status: "waiting", steps: { ...stepResults, [entry.id]: { status: "waiting", payload: prevOutput, startedAt } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-waiting", payload: { id: entry.id, payload: prevOutput, startedAt, status: "waiting" } });
      stepResults[entry.id] = { status: "waiting", payload: prevOutput, startedAt };
      executionContext.activeStepsPath[entry.id] = executionContext.executionPath;
      await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: "waiting", runtimeContext });
      await this.executeSleepUntil({ workflowId, runId, entry, prevStep, prevOutput, stepResults, serializedStepGraph, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream });
      delete executionContext.activeStepsPath[entry.id];
      await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: "running", runtimeContext });
      const endedAt = Date.now();
      const stepInfo = { payload: prevOutput, startedAt, endedAt };
      execResults = { ...stepInfo, status: "success", output: prevOutput };
      stepResults[entry.id] = { ...stepInfo, status: "success", output: prevOutput };
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: entry.id, ...execResults }, workflowState: { status: "running", steps: { ...stepResults, [entry.id]: { ...execResults } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-result", payload: { id: entry.id, endedAt, status: "success", output: prevOutput } });
      await emitter.emit("watch-v2", { type: "workflow-step-finish", payload: { id: entry.id, metadata: {} } });
    } else if (entry.type === "waitForEvent") {
      const startedAt = Date.now();
      let eventData;
      await emitter.emit("watch", { type: "watch", payload: { currentStep: { id: entry.step.id, status: "waiting", payload: prevOutput, startedAt }, workflowState: { status: "waiting", steps: { ...stepResults, [entry.step.id]: { status: "waiting", payload: prevOutput, startedAt } }, result: null, error: null } }, eventTimestamp: Date.now() });
      await emitter.emit("watch-v2", { type: "workflow-step-waiting", payload: { id: entry.step.id, payload: prevOutput, startedAt, status: "waiting" } });
      stepResults[entry.step.id] = { status: "waiting", payload: prevOutput, startedAt };
      await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: "waiting", runtimeContext });
      try {
        eventData = await this.executeWaitForEvent({ event: entry.event, emitter, timeout: entry.timeout, tracingContext });
        const { step } = entry;
        const { result, executionContextState } = await this.executeStep({ workflowId, runId, resourceId, step, stepResults, executionContext, resume: { resumePayload: eventData, steps: [entry.step.id] }, prevOutput, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph });
        execResults = result;
        executionContext.state = executionContextState;
      } catch (error87) {
        execResults = { status: "failed", error: error87 };
      }
      const endedAt = Date.now();
      const stepInfo = { payload: prevOutput, startedAt, endedAt };
      execResults = { ...execResults, ...stepInfo };
    }
    if (entry.type === "step" || entry.type === "waitForEvent" || entry.type === "loop" || entry.type === "foreach") {
      stepResults[entry.step.id] = execResults;
    }
    if (abortController?.signal?.aborted) {
      execResults = { ...execResults, status: "canceled" };
    }
    await this.persistStepUpdate({ workflowId, runId, resourceId, serializedStepGraph, stepResults, executionContext, workflowStatus: execResults.status === "success" ? "running" : execResults.status, runtimeContext });
    if (execResults.status === "canceled") {
      await emitter.emit("watch-v2", { type: "workflow-canceled", payload: {} });
    }
    return { result: execResults, stepResults, executionContext };
  }
};
function createStep(params, agentOptions) {
  if (params instanceof Agent) {
    return {
      id: params.name,
      description: params.getDescription(),
      // @ts-ignore
      inputSchema: external_exports2.object({
        prompt: external_exports2.string()
        // resourceId: z.string().optional(),
        // threadId: z.string().optional(),
      }),
      // @ts-ignore
      outputSchema: external_exports2.object({ text: external_exports2.string() }),
      execute: /* @__PURE__ */ __name(async ({ inputData, [EMITTER_SYMBOL]: emitter, [STREAM_FORMAT_SYMBOL]: streamFormat, runtimeContext, tracingContext, abortSignal, abort: abort2, writer }) => {
        let streamPromise = {};
        streamPromise.promise = new Promise((resolve3, reject) => {
          streamPromise.resolve = resolve3;
          streamPromise.reject = reject;
        });
        const toolData = { name: params.name, args: inputData };
        let stream;
        if ((await params.getModel()).specificationVersion === "v1") {
          const { fullStream } = await params.streamLegacy(inputData.prompt, {
            ...agentOptions ?? {},
            // resourceId: inputData.resourceId,
            // threadId: inputData.threadId,
            runtimeContext,
            tracingContext,
            onFinish: /* @__PURE__ */ __name((result) => {
              streamPromise.resolve(result.text);
              void agentOptions?.onFinish?.(result);
            }, "onFinish"),
            abortSignal
          });
          stream = fullStream;
        } else {
          const modelOutput = await params.stream(inputData.prompt, { ...agentOptions ?? {}, runtimeContext, tracingContext, onFinish: /* @__PURE__ */ __name((result) => {
            streamPromise.resolve(result.text);
            void agentOptions?.onFinish?.(result);
          }, "onFinish"), abortSignal });
          stream = modelOutput.fullStream;
        }
        if (streamFormat === "legacy") {
          await emitter.emit("watch-v2", { type: "tool-call-streaming-start", ...toolData ?? {} });
          for await (const chunk of stream) {
            if (chunk.type === "text-delta") {
              await emitter.emit("watch-v2", { type: "tool-call-delta", ...toolData ?? {}, argsTextDelta: chunk.textDelta });
            }
          }
          await emitter.emit("watch-v2", { type: "tool-call-streaming-finish", ...toolData ?? {} });
        } else {
          for await (const chunk of stream) {
            await writer.write(chunk);
          }
        }
        if (abortSignal.aborted) {
          return abort2();
        }
        return { text: await streamPromise.promise };
      }, "execute"),
      component: params.component
    };
  }
  if (params instanceof Tool) {
    if (!params.inputSchema || !params.outputSchema) {
      throw new Error("Tool must have input and output schemas defined");
    }
    return {
      // TODO: tool probably should have strong id type
      // @ts-ignore
      id: params.id,
      description: params.description,
      inputSchema: params.inputSchema,
      outputSchema: params.outputSchema,
      execute: /* @__PURE__ */ __name(async ({ inputData, mastra, runtimeContext, tracingContext, suspend, resumeData }) => {
        return params.execute({ context: inputData, mastra, runtimeContext, tracingContext, suspend, resumeData });
      }, "execute"),
      component: "TOOL"
    };
  }
  return { id: params.id, description: params.description, inputSchema: params.inputSchema, stateSchema: params.stateSchema, outputSchema: params.outputSchema, resumeSchema: params.resumeSchema, suspendSchema: params.suspendSchema, scorers: params.scorers, retries: params.retries, execute: params.execute.bind(params) };
}
__name(createStep, "createStep");
function createWorkflow(params) {
  return new Workflow(params);
}
__name(createWorkflow, "createWorkflow");
var Workflow = class extends MastraBase {
  static {
    __name(this, "Workflow");
  }
  id;
  description;
  inputSchema;
  outputSchema;
  stateSchema;
  steps;
  stepDefs;
  engineType = "default";
  #nestedWorkflowInput;
  committed = false;
  stepFlow;
  serializedStepFlow;
  executionEngine;
  executionGraph;
  #options;
  retryConfig;
  #mastra;
  #runs = /* @__PURE__ */ new Map();
  constructor({ mastra, id, inputSchema, outputSchema: outputSchema2, stateSchema, description, executionEngine, retryConfig, steps, options = {} }) {
    super({ name: id, component: RegisteredLogger.WORKFLOW });
    this.id = id;
    this.description = description;
    this.inputSchema = inputSchema;
    this.outputSchema = outputSchema2;
    this.stateSchema = stateSchema;
    this.retryConfig = retryConfig ?? { attempts: 0, delay: 0 };
    this.executionGraph = this.buildExecutionGraph();
    this.stepFlow = [];
    this.serializedStepFlow = [];
    this.#mastra = mastra;
    this.steps = {};
    this.stepDefs = steps;
    this.#options = { validateInputs: options.validateInputs ?? false, shouldPersistSnapshot: options.shouldPersistSnapshot ?? (() => true), tracingPolicy: options.tracingPolicy };
    if (!executionEngine) {
      this.executionEngine = new DefaultExecutionEngine({ mastra: this.#mastra, options: this.#options });
    } else {
      this.executionEngine = executionEngine;
    }
    this.engineType = "default";
    this.#runs = /* @__PURE__ */ new Map();
  }
  get runs() {
    return this.#runs;
  }
  get mastra() {
    return this.#mastra;
  }
  get options() {
    return this.#options;
  }
  __registerMastra(mastra) {
    this.#mastra = mastra;
    this.executionEngine.__registerMastra(mastra);
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  setStepFlow(stepFlow) {
    this.stepFlow = stepFlow;
  }
  /**
  * Adds a step to the workflow
  * @param step The step to add to the workflow
  * @returns The workflow instance for chaining
  */
  then(step) {
    this.stepFlow.push({ type: "step", step });
    this.serializedStepFlow.push({ type: "step", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow } });
    this.steps[step.id] = step;
    return this;
  }
  /**
  * Adds a sleep step to the workflow
  * @param duration The duration to sleep for
  * @returns The workflow instance for chaining
  */
  sleep(duration5) {
    const id = `sleep_${this.#mastra?.generateId() || randomUUID3()}`;
    const opts = typeof duration5 === "function" ? { type: "sleep", id, fn: duration5 } : { type: "sleep", id, duration: duration5 };
    const serializedOpts = typeof duration5 === "function" ? { type: "sleep", id, fn: duration5.toString() } : { type: "sleep", id, duration: duration5 };
    this.stepFlow.push(opts);
    this.serializedStepFlow.push(serializedOpts);
    this.steps[id] = createStep({ id, inputSchema: external_exports2.object({}), outputSchema: external_exports2.object({}), execute: /* @__PURE__ */ __name(async () => {
      return {};
    }, "execute") });
    return this;
  }
  /**
  * Adds a sleep until step to the workflow
  * @param date The date to sleep until
  * @returns The workflow instance for chaining
  */
  sleepUntil(date9) {
    const id = `sleep_${this.#mastra?.generateId() || randomUUID3()}`;
    const opts = typeof date9 === "function" ? { type: "sleepUntil", id, fn: date9 } : { type: "sleepUntil", id, date: date9 };
    const serializedOpts = typeof date9 === "function" ? { type: "sleepUntil", id, fn: date9.toString() } : { type: "sleepUntil", id, date: date9 };
    this.stepFlow.push(opts);
    this.serializedStepFlow.push(serializedOpts);
    this.steps[id] = createStep({ id, inputSchema: external_exports2.object({}), outputSchema: external_exports2.object({}), execute: /* @__PURE__ */ __name(async () => {
      return {};
    }, "execute") });
    return this;
  }
  waitForEvent(event, step, opts) {
    this.stepFlow.push({ type: "waitForEvent", event, step, timeout: opts?.timeout });
    this.serializedStepFlow.push({ type: "waitForEvent", event, step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow }, timeout: opts?.timeout });
    this.steps[step.id] = step;
    return this;
  }
  map(mappingConfig, stepOptions) {
    if (typeof mappingConfig === "function") {
      const mappingStep2 = createStep({ id: stepOptions?.id || `mapping_${this.#mastra?.generateId() || randomUUID3()}`, inputSchema: external_exports2.object({}), outputSchema: external_exports2.object({}), execute: mappingConfig });
      this.stepFlow.push({ type: "step", step: mappingStep2 });
      this.serializedStepFlow.push({ type: "step", step: { id: mappingStep2.id, mapConfig: mappingConfig.toString() } });
      return this;
    }
    const newMappingConfig = Object.entries(mappingConfig).reduce((a, [key, mapping]) => {
      const m = mapping;
      if (m.value !== void 0) {
        a[key] = m;
      } else if (m.fn !== void 0) {
        a[key] = { fn: m.fn.toString(), schema: m.schema };
      } else if (m.runtimeContextPath) {
        a[key] = { runtimeContextPath: m.runtimeContextPath, schema: m.schema };
      } else {
        a[key] = m;
      }
      return a;
    }, {});
    const mappingStep = createStep({ id: stepOptions?.id || `mapping_${this.#mastra?.generateId() || randomUUID3()}`, inputSchema: external_exports2.any(), outputSchema: external_exports2.any(), execute: /* @__PURE__ */ __name(async (ctx) => {
      const { getStepResult: getStepResult3, getInitData, runtimeContext } = ctx;
      const result = {};
      for (const [key, mapping] of Object.entries(mappingConfig)) {
        const m = mapping;
        if (m.value !== void 0) {
          result[key] = m.value;
          continue;
        }
        if (m.fn !== void 0) {
          result[key] = await m.fn(ctx);
          continue;
        }
        if (m.runtimeContextPath) {
          result[key] = runtimeContext.get(m.runtimeContextPath);
          continue;
        }
        const stepResult = m.initData ? getInitData() : getStepResult3(Array.isArray(m.step) ? m.step.find((s) => getStepResult3(s)) : m.step);
        if (m.path === ".") {
          result[key] = stepResult;
          continue;
        }
        const pathParts = m.path.split(".");
        let value = stepResult;
        for (const part of pathParts) {
          if (typeof value === "object" && value !== null) {
            value = value[part];
          } else {
            throw new Error(`Invalid path ${m.path} in step ${m?.step?.id ?? "initData"}`);
          }
        }
        result[key] = value;
      }
      return result;
    }, "execute") });
    this.stepFlow.push({ type: "step", step: mappingStep });
    this.serializedStepFlow.push({ type: "step", step: { id: mappingStep.id, mapConfig: JSON.stringify(newMappingConfig, null, 2) } });
    return this;
  }
  // TODO: make typing better here
  parallel(steps) {
    this.stepFlow.push({ type: "parallel", steps: steps.map((step) => ({ type: "step", step })) });
    this.serializedStepFlow.push({ type: "parallel", steps: steps.map((step) => ({ type: "step", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow } })) });
    steps.forEach((step) => {
      this.steps[step.id] = step;
    });
    return this;
  }
  // TODO: make typing better here
  // TODO: add state schema to the type, this is currently broken
  branch(steps) {
    this.stepFlow.push({
      type: "conditional",
      steps: steps.map(([_cond, step]) => ({ type: "step", step })),
      // @ts-ignore
      conditions: steps.map(([cond]) => cond),
      serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() }))
    });
    this.serializedStepFlow.push({ type: "conditional", steps: steps.map(([_cond, step]) => ({ type: "step", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow } })), serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() })) });
    steps.forEach(([_, step]) => {
      this.steps[step.id] = step;
    });
    return this;
  }
  dowhile(step, condition) {
    this.stepFlow.push({
      type: "loop",
      step,
      // @ts-ignore
      condition,
      loopType: "dowhile",
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }
    });
    this.serializedStepFlow.push({ type: "loop", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow }, serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }, loopType: "dowhile" });
    this.steps[step.id] = step;
    return this;
  }
  dountil(step, condition) {
    this.stepFlow.push({
      type: "loop",
      step,
      // @ts-ignore
      condition,
      loopType: "dountil",
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }
    });
    this.serializedStepFlow.push({ type: "loop", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow }, serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }, loopType: "dountil" });
    this.steps[step.id] = step;
    return this;
  }
  foreach(step, opts) {
    this.stepFlow.push({ type: "foreach", step, opts: opts ?? { concurrency: 1 } });
    this.serializedStepFlow.push({ type: "foreach", step: { id: step.id, description: step.description, component: step.component, serializedStepFlow: step.serializedStepFlow }, opts: opts ?? { concurrency: 1 } });
    this.steps[step.id] = step;
    return this;
  }
  /**
  * Builds the execution graph for this workflow
  * @returns The execution graph that can be used to execute the workflow
  */
  buildExecutionGraph() {
    return { id: this.id, steps: this.stepFlow };
  }
  /**
  * Finalizes the workflow definition and prepares it for execution
  * This method should be called after all steps have been added to the workflow
  * @returns A built workflow instance ready for execution
  */
  commit() {
    this.committed = true;
    this.executionGraph = this.buildExecutionGraph();
    return this;
  }
  get stepGraph() {
    return this.stepFlow;
  }
  get serializedStepGraph() {
    return this.serializedStepFlow;
  }
  /**
  * @deprecated Use createRunAsync() instead.
  * @throws {Error} Always throws an error directing users to use createRunAsync()
  */
  createRun(_options) {
    throw new Error("createRun() has been deprecated. Please use createRunAsync() instead.\n\nMigration guide:\n  Before: const run = workflow.createRun();\n  After:  const run = await workflow.createRunAsync();\n\nNote: createRunAsync() is an async method, so make sure your calling function is async.");
  }
  /**
  * Creates a new workflow run instance and stores a snapshot of the workflow in the storage
  * @param options Optional configuration for the run
  * @param options.runId Optional custom run ID, defaults to a random UUID
  * @param options.resourceId Optional resource ID to associate with this run
  * @param options.disableScorers Optional flag to disable scorers for this run
  * @returns A Run instance that can be used to execute the workflow
  */
  async createRunAsync(options) {
    if (this.stepFlow.length === 0) {
      throw new Error("Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.");
    }
    if (!this.executionGraph.steps) {
      throw new Error("Uncommitted step flow changes detected. Call .commit() to register the steps.");
    }
    const runIdToUse = options?.runId || this.#mastra?.generateId() || randomUUID3();
    const run = this.#runs.get(runIdToUse) ?? new Run({ workflowId: this.id, stateSchema: this.stateSchema, inputSchema: this.inputSchema, runId: runIdToUse, resourceId: options?.resourceId, executionEngine: this.executionEngine, executionGraph: this.executionGraph, mastra: this.#mastra, retryConfig: this.retryConfig, serializedStepGraph: this.serializedStepGraph, disableScorers: options?.disableScorers, cleanup: /* @__PURE__ */ __name(() => this.#runs.delete(runIdToUse), "cleanup"), tracingPolicy: this.#options?.tracingPolicy, workflowSteps: this.steps, validateInputs: this.#options?.validateInputs, workflowEngineType: this.engineType });
    this.#runs.set(runIdToUse, run);
    const shouldPersistSnapshot = this.#options.shouldPersistSnapshot({ workflowStatus: run.workflowRunStatus, stepResults: {} });
    const workflowSnapshotInStorage = await this.getWorkflowRunExecutionResult(runIdToUse, false);
    if (!workflowSnapshotInStorage && shouldPersistSnapshot) {
      await this.mastra?.getStorage()?.persistWorkflowSnapshot({ workflowName: this.id, runId: runIdToUse, resourceId: options?.resourceId, snapshot: {
        runId: runIdToUse,
        status: "pending",
        value: {},
        context: this.#nestedWorkflowInput ? { input: this.#nestedWorkflowInput } : {},
        activePaths: [],
        activeStepsPath: {},
        serializedStepGraph: this.serializedStepGraph,
        suspendedPaths: {},
        resumeLabels: {},
        waitingPaths: {},
        result: void 0,
        error: void 0,
        // @ts-ignore
        timestamp: Date.now()
      } });
    }
    return run;
  }
  async getScorers({ runtimeContext = new RuntimeContext() } = {}) {
    const steps = this.steps;
    if (!steps || Object.keys(steps).length === 0) {
      return {};
    }
    const scorers = {};
    for (const step of Object.values(steps)) {
      if (step.scorers) {
        let scorersToUse = step.scorers;
        if (typeof scorersToUse === "function") {
          scorersToUse = await scorersToUse({ runtimeContext });
        }
        for (const [id, scorer] of Object.entries(scorersToUse)) {
          scorers[id] = scorer;
        }
      }
    }
    return scorers;
  }
  // This method should only be called internally for nested workflow execution, as well as from mastra server handlers
  // To run a workflow use `.createRunAsync` and then `.start` or `.resume`
  async execute({ runId, inputData, resumeData, state, setState, suspend, restart, resume, timeTravel, [EMITTER_SYMBOL]: emitter, mastra, runtimeContext, abort: abort2, abortSignal, runCount, tracingContext, writer, validateInputs }) {
    this.__registerMastra(mastra);
    if (validateInputs) {
      this.#options = { ...this.#options || {}, validateInputs };
    }
    this.executionEngine.options = { ...this.executionEngine.options || {}, validateInputs: validateInputs ?? false };
    const isResume = !!(resume?.steps && resume.steps.length > 0) || !!resume?.label || !!(resume?.steps && resume.steps.length === 0 && (!runCount || runCount === 0));
    if (!restart && !isResume) {
      this.#nestedWorkflowInput = inputData;
    }
    const isTimeTravel = !!(timeTravel && timeTravel.steps.length > 0);
    const run = isResume ? await this.createRunAsync({ runId: resume.runId }) : await this.createRunAsync({ runId });
    const nestedAbortCb = /* @__PURE__ */ __name(() => {
      abort2();
    }, "nestedAbortCb");
    run.abortController.signal.addEventListener("abort", nestedAbortCb);
    abortSignal.addEventListener("abort", async () => {
      run.abortController.signal.removeEventListener("abort", nestedAbortCb);
      await run.cancel();
    });
    const unwatchV2 = run.watch((event) => {
      emitter.emit("nested-watch-v2", { event, workflowId: this.id });
    }, "watch-v2");
    const unwatch = run.watch((event) => {
      emitter.emit("nested-watch", { event, workflowId: this.id, runId: run.runId, isResume: !!resume?.steps?.length });
    }, "watch");
    if (runCount && runCount > 0 && isResume && runtimeContext) {
      runtimeContext.set("__mastraWorflowInputData", inputData);
    }
    let res;
    if (isTimeTravel) {
      res = await run.timeTravel({ inputData: timeTravel?.inputData, resumeData: timeTravel?.resumeData, initialState: state, step: timeTravel?.steps, context: timeTravel?.nestedStepResults?.[this.id] ?? {}, nestedStepsContext: timeTravel?.nestedStepResults, runtimeContext, tracingContext, writableStream: writer, outputOptions: { includeState: true, includeResumeLabels: true } });
    } else if (restart) {
      res = await run.restart({ runtimeContext, tracingContext, writableStream: writer });
    } else if (isResume) {
      res = await run.resume({ resumeData, step: resume.steps?.length > 0 ? resume.steps : void 0, runtimeContext, tracingContext, writableStream: writer, outputOptions: { includeState: true, includeResumeLabels: true }, label: resume.label });
    } else {
      res = await run.start({ inputData, runtimeContext, tracingContext, writableStream: writer, initialState: state, outputOptions: { includeState: true, includeResumeLabels: true } });
    }
    unwatch();
    unwatchV2();
    const suspendedSteps = Object.entries(res.steps).filter(([_stepName, stepResult]) => {
      const stepRes = stepResult;
      return stepRes?.status === "suspended";
    });
    if (res.state) {
      setState(res.state);
    }
    if (suspendedSteps?.length) {
      for (const [stepName, stepResult] of suspendedSteps) {
        const suspendPath = [stepName, ...stepResult?.suspendPayload?.__workflow_meta?.path ?? []];
        await suspend({ ...stepResult?.suspendPayload, __workflow_meta: { runId: run.runId, path: suspendPath } }, { resumeLabel: Object.keys(res.resumeLabels ?? {}) });
      }
    }
    if (res.status === "failed") {
      throw res.error;
    }
    return res.status === "success" ? res.result : void 0;
  }
  async getWorkflowRuns(args) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra storage is not initialized");
      return { runs: [], total: 0 };
    }
    return storage.getWorkflowRuns({ workflowName: this.id, ...args ?? {} });
  }
  async getActiveWorkflowRuns() {
    const runningRuns = await this.getWorkflowRuns({ status: "running" });
    const waitingRuns = await this.getWorkflowRuns({ status: "waiting" });
    return { runs: [...runningRuns.runs, ...waitingRuns.runs], total: runningRuns.total + waitingRuns.total };
  }
  async restartAllActiveWorkflowRuns() {
    if (this.engineType !== "default") {
      this.logger.debug(`Cannot restart active workflow runs for ${this.engineType} engine`);
      return;
    }
    const activeRuns = await this.getActiveWorkflowRuns();
    if (activeRuns.runs.length > 0) {
      this.logger.debug(`Restarting ${activeRuns.runs.length} active workflow run${activeRuns.runs.length > 1 ? "s" : ""}`);
    }
    for (const runSnapshot of activeRuns.runs) {
      try {
        const run = await this.createRunAsync({ runId: runSnapshot.runId });
        await run.restart();
        this.logger.debug(`Restarted ${this.id} workflow run ${runSnapshot.runId}`);
      } catch (error87) {
        this.logger.error(`Failed to restart ${this.id} workflow run ${runSnapshot.runId}: ${error87}`);
      }
    }
  }
  async getWorkflowRunById(runId) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs from storage. Mastra storage is not initialized");
      return this.#runs.get(runId) ? { ...this.#runs.get(runId), workflowName: this.id } : null;
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });
    return run ?? (this.#runs.get(runId) ? { ...this.#runs.get(runId), workflowName: this.id } : null);
  }
  async getWorkflowRunSteps({ runId, workflowId }) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow run steps. Mastra storage is not initialized");
      return {};
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: workflowId });
    let snapshot = run?.snapshot;
    if (!snapshot) {
      return {};
    }
    if (typeof snapshot === "string") {
      try {
        snapshot = JSON.parse(snapshot);
      } catch (e) {
        this.logger.debug("Cannot get workflow run execution result. Snapshot is not a valid JSON string", e);
        return {};
      }
    }
    const { serializedStepGraph, context: context3 } = snapshot;
    const { input, ...steps } = context3;
    let finalSteps = {};
    for (const step of Object.keys(steps)) {
      const stepGraph = serializedStepGraph.find((stepGraph2) => stepGraph2?.step?.id === step);
      finalSteps[step] = steps[step];
      if (stepGraph && stepGraph?.step?.component === "WORKFLOW") {
        const nestedSteps = await this.getWorkflowRunSteps({ runId, workflowId: step });
        if (nestedSteps) {
          const updatedNestedSteps = Object.entries(nestedSteps).reduce((acc, [key, value]) => {
            acc[`${step}.${key}`] = value;
            return acc;
          }, {});
          finalSteps = { ...finalSteps, ...updatedNestedSteps };
        }
      }
    }
    return finalSteps;
  }
  async getWorkflowRunExecutionResult(runId, withNestedWorkflows = true) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow run execution result. Mastra storage is not initialized");
      return null;
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });
    let snapshot = run?.snapshot;
    if (!snapshot) {
      return null;
    }
    if (typeof snapshot === "string") {
      try {
        snapshot = JSON.parse(snapshot);
      } catch (e) {
        this.logger.debug("Cannot get workflow run execution result. Snapshot is not a valid JSON string", e);
        return null;
      }
    }
    const fullSteps = withNestedWorkflows ? await this.getWorkflowRunSteps({ runId, workflowId: this.id }) : snapshot.context;
    return { status: snapshot.status, result: snapshot.result, error: snapshot.error, payload: snapshot.context?.input, steps: fullSteps, activeStepsPath: snapshot.activeStepsPath, serializedStepGraph: snapshot.serializedStepGraph };
  }
};
var Run = class {
  static {
    __name(this, "Run");
  }
  #abortController;
  emitter;
  /**
  * Unique identifier for this workflow
  */
  workflowId;
  /**
  * Unique identifier for this run
  */
  runId;
  /**
  * Unique identifier for the resource this run is associated with
  */
  resourceId;
  /**
  * Whether to disable scorers for this run
  */
  disableScorers;
  /**
  * Options around how to trace this run
  */
  tracingPolicy;
  /**
  * Options around how to trace this run
  */
  validateInputs;
  /**
  * Internal state of the workflow run
  */
  state = {};
  /**
  * The execution engine for this run
  */
  executionEngine;
  /**
  * The execution graph for this run
  */
  executionGraph;
  /**
  * The serialized step graph for this run
  */
  serializedStepGraph;
  /**
  * The steps for this workflow
  */
  workflowSteps;
  workflowRunStatus;
  workflowEngineType;
  /**
  * The storage for this run
  */
  #mastra;
  #observerHandlers = [];
  get mastra() {
    return this.#mastra;
  }
  #streamOutput;
  closeStreamAction;
  executionResults;
  stateSchema;
  inputSchema;
  cleanup;
  retryConfig;
  constructor(params) {
    this.workflowId = params.workflowId;
    this.runId = params.runId;
    this.resourceId = params.resourceId;
    this.serializedStepGraph = params.serializedStepGraph;
    this.executionEngine = params.executionEngine;
    this.executionGraph = params.executionGraph;
    this.#mastra = params.mastra;
    this.emitter = new EventEmitter2();
    this.retryConfig = params.retryConfig;
    this.cleanup = params.cleanup;
    this.disableScorers = params.disableScorers;
    this.tracingPolicy = params.tracingPolicy;
    this.workflowSteps = params.workflowSteps;
    this.validateInputs = params.validateInputs;
    this.stateSchema = params.stateSchema;
    this.inputSchema = params.inputSchema;
    this.workflowRunStatus = "pending";
    this.workflowEngineType = params.workflowEngineType;
  }
  get abortController() {
    if (!this.#abortController) {
      this.#abortController = new AbortController();
    }
    return this.#abortController;
  }
  /**
  * Cancels the workflow execution
  */
  async cancel() {
    this.abortController?.abort();
  }
  async sendEvent(event, data) {
    this.emitter.emit(`user-event-${event}`, data);
  }
  async _validateInput(inputData) {
    let inputDataToUse = inputData;
    if (this.validateInputs && this.inputSchema) {
      const validatedInputData = await this.inputSchema.safeParseAsync(inputData);
      if (!validatedInputData.success) {
        const errors = getZodErrors(validatedInputData.error);
        throw new Error("Invalid input data: \n" + errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n"));
      }
      inputDataToUse = validatedInputData.data;
    }
    return inputDataToUse;
  }
  async _validateInitialState(initialState) {
    let initialStateToUse = initialState;
    if (this.validateInputs) {
      let inputSchema = this.stateSchema;
      if (inputSchema) {
        const validatedInputData = await inputSchema.safeParseAsync(initialState);
        if (!validatedInputData.success) {
          const errors = getZodErrors(validatedInputData.error);
          throw new Error("Invalid input data: \n" + errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n"));
        }
        initialStateToUse = validatedInputData.data;
      }
    }
    return initialStateToUse;
  }
  async _validateResumeData(resumeData, suspendedStep) {
    let resumeDataToUse = resumeData;
    if (suspendedStep && suspendedStep.resumeSchema && this.validateInputs) {
      const resumeSchema = suspendedStep.resumeSchema;
      const validatedResumeData = await resumeSchema.safeParseAsync(resumeData);
      if (!validatedResumeData.success) {
        const errors = getZodErrors(validatedResumeData.error);
        throw new Error("Invalid resume data: \n" + errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n"));
      }
      resumeDataToUse = validatedResumeData.data;
    }
    return resumeDataToUse;
  }
  async _validateTimetravelInputData(inputData, step) {
    let inputDataToUse = inputData;
    if (step && step.inputSchema && this.validateInputs) {
      const inputSchema = step.inputSchema;
      const validatedInputData = await inputSchema.safeParseAsync(inputData);
      if (!validatedInputData.success) {
        const errors = getZodErrors(validatedInputData.error);
        const errorMessages2 = errors.map((e) => `- ${e.path?.join(".")}: ${e.message}`).join("\n");
        throw new Error("Invalid inputData: \n" + errorMessages2);
      }
      inputDataToUse = validatedInputData.data;
    }
    return inputDataToUse;
  }
  async _start({ inputData, initialState, runtimeContext, writableStream, tracingContext, tracingOptions, format, outputOptions }) {
    const workflowAISpan = getOrCreateSpan({ type: "workflow_run", name: `workflow run: '${this.workflowId}'`, input: inputData, attributes: { workflowId: this.workflowId }, metadata: { resourceId: this.resourceId, runId: this.runId }, tracingPolicy: this.tracingPolicy, tracingOptions, tracingContext, runtimeContext });
    const traceId = getValidTraceId(workflowAISpan);
    const inputDataToUse = await this._validateInput(inputData);
    const initialStateToUse = await this._validateInitialState(initialState ?? {});
    const result = await this.executionEngine.execute({ workflowId: this.workflowId, runId: this.runId, resourceId: this.resourceId, disableScorers: this.disableScorers, graph: this.executionGraph, serializedStepGraph: this.serializedStepGraph, input: inputDataToUse, initialState: initialStateToUse, emitter: { emit: /* @__PURE__ */ __name(async (event, data) => {
      this.emitter.emit(event, data);
    }, "emit"), on: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.on(event, callback);
    }, "on"), off: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.off(event, callback);
    }, "off"), once: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.once(event, callback);
    }, "once") }, retryConfig: this.retryConfig, runtimeContext: runtimeContext ?? new RuntimeContext(), abortController: this.abortController, writableStream, workflowAISpan, format, outputOptions });
    if (result.status !== "suspended") {
      this.cleanup?.();
    }
    result.traceId = traceId;
    return result;
  }
  /**
  * Starts the workflow execution with the provided input
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  async start(args) {
    return this._start(args);
  }
  /**
  * Starts the workflow execution with the provided input as a stream
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  streamLegacy({ inputData, runtimeContext, onChunk, tracingContext, tracingOptions } = {}) {
    if (this.closeStreamAction) {
      return { stream: this.observeStreamLegacy().stream, getWorkflowState: /* @__PURE__ */ __name(() => this.executionResults, "getWorkflowState") };
    }
    const { readable, writable } = new TransformStream3();
    const writer = writable.getWriter();
    const unwatch = this.watch(async (event) => {
      try {
        const e = { ...event, type: event.type.replace("workflow-", "") };
        await writer.write(e);
        if (onChunk) {
          await onChunk(e);
        }
      } catch {
      }
    }, "watch-v2");
    this.closeStreamAction = async () => {
      this.emitter.emit("watch-v2", { type: "workflow-finish", payload: { runId: this.runId } });
      unwatch();
      await Promise.all(this.#observerHandlers.map((handler) => handler()));
      this.#observerHandlers = [];
      try {
        await writer.close();
      } catch (err) {
        console.error("Error closing stream:", err);
      } finally {
        writer.releaseLock();
      }
    };
    this.emitter.emit("watch-v2", { type: "workflow-start", payload: { runId: this.runId } });
    this.executionResults = this._start({ inputData, runtimeContext, format: "legacy", tracingContext, tracingOptions }).then((result) => {
      if (result.status !== "suspended") {
        this.closeStreamAction?.().catch(() => {
        });
      }
      return result;
    });
    return { stream: readable, getWorkflowState: /* @__PURE__ */ __name(() => this.executionResults, "getWorkflowState") };
  }
  /**
  * Starts the workflow execution with the provided input as a stream
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  stream(args = {}) {
    return this.streamVNext(args);
  }
  /**
  * Observe the workflow stream
  * @returns A readable stream of the workflow events
  */
  observeStreamLegacy() {
    const { readable, writable } = new TransformStream3();
    const writer = writable.getWriter();
    const unwatch = this.watch(async (event) => {
      try {
        const e = { ...event, type: event.type.replace("workflow-", "") };
        await writer.write(e);
      } catch {
      }
    }, "watch-v2");
    this.#observerHandlers.push(async () => {
      unwatch();
      try {
        await writer.close();
      } catch (err) {
        console.error("Error closing stream:", err);
      } finally {
        writer.releaseLock();
      }
    });
    return { stream: readable };
  }
  /**
  * Observe the workflow stream
  * @returns A readable stream of the workflow events
  */
  observeStream() {
    return this.observeStreamVNext();
  }
  /**
  * Observe the workflow stream vnext
  * @returns A readable stream of the workflow events
  */
  observeStreamVNext() {
    if (!this.#streamOutput) {
      return new ReadableStream$1({ pull(controller) {
        controller.close();
      }, cancel(controller) {
        controller.close();
      } });
    }
    return this.#streamOutput.fullStream;
  }
  async streamAsync({ inputData, runtimeContext } = {}) {
    return this.stream({ inputData, runtimeContext });
  }
  /**
  * Starts the workflow execution with the provided input as a stream
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  streamVNext({ inputData, runtimeContext, tracingContext, tracingOptions, closeOnSuspend = true, initialState } = {}) {
    if (this.closeStreamAction && this.#streamOutput) {
      return this.#streamOutput;
    }
    this.closeStreamAction = async () => {
    };
    const self2 = this;
    const stream = new ReadableStream$1({ async start(controller) {
      const unwatch = self2.watch(async ({ type, from = "WORKFLOW", payload }) => {
        controller.enqueue({ type, runId: self2.runId, from, payload: { stepName: payload?.id, ...payload } });
      }, "watch-v2");
      self2.closeStreamAction = async () => {
        unwatch();
        try {
          await controller.close();
        } catch (err) {
          console.error("Error closing stream:", err);
        }
      };
      const executionResultsPromise = self2._start({ inputData, runtimeContext, tracingContext, tracingOptions, initialState, writableStream: new WritableStream$1({ write(chunk) {
        controller.enqueue(chunk);
      } }) });
      let executionResults;
      try {
        executionResults = await executionResultsPromise;
        if (closeOnSuspend) {
          self2.closeStreamAction?.().catch(() => {
          });
        } else if (executionResults.status !== "suspended") {
          self2.closeStreamAction?.().catch(() => {
          });
        }
        if (self2.#streamOutput) {
          self2.#streamOutput.updateResults(executionResults);
        }
      } catch (err) {
        self2.#streamOutput?.rejectResults(err);
        self2.closeStreamAction?.().catch(() => {
        });
      }
    } });
    this.#streamOutput = new WorkflowRunOutput({ runId: this.runId, workflowId: this.workflowId, stream });
    return this.#streamOutput;
  }
  /**
  * Resumes the workflow execution with the provided input as a stream
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  resumeStream({ step, resumeData, runtimeContext, tracingContext, tracingOptions } = {}) {
    return this.resumeStreamVNext({ resumeData, step, runtimeContext, tracingContext, tracingOptions });
  }
  /**
  * Resumes the workflow execution with the provided input as a stream
  * @param input The input data for the workflow
  * @returns A promise that resolves to the workflow output
  */
  resumeStreamVNext({ step, resumeData, runtimeContext, tracingContext, tracingOptions, forEachIndex } = {}) {
    this.closeStreamAction = async () => {
    };
    const self2 = this;
    const stream = new ReadableStream$1({ async start(controller) {
      const unwatch = self2.watch(async ({ type, from = "WORKFLOW", payload }) => {
        controller.enqueue({ type, runId: self2.runId, from, payload: { stepName: payload.id, ...payload } });
      }, "watch-v2");
      self2.closeStreamAction = async () => {
        unwatch();
        try {
          await controller.close();
        } catch (err) {
          console.error("Error closing stream:", err);
        }
      };
      const executionResultsPromise = self2._resume({ resumeData, step, runtimeContext, tracingContext, tracingOptions, writableStream: new WritableStream$1({ write(chunk) {
        controller.enqueue(chunk);
      } }), isVNext: true, forEachIndex });
      self2.executionResults = executionResultsPromise;
      let executionResults;
      try {
        executionResults = await executionResultsPromise;
        self2.closeStreamAction?.().catch(() => {
        });
        if (self2.#streamOutput) {
          self2.#streamOutput.updateResults(executionResults);
        }
      } catch (err) {
        self2.#streamOutput?.rejectResults(err);
        self2.closeStreamAction?.().catch(() => {
        });
      }
    } });
    this.#streamOutput = new WorkflowRunOutput({ runId: this.runId, workflowId: this.workflowId, stream });
    return this.#streamOutput;
  }
  watch(cb, type = "watch") {
    const watchCb = /* @__PURE__ */ __name((event) => {
      this.updateState(event.payload);
      cb({ type: event.type, payload: this.getState(), eventTimestamp: event.eventTimestamp });
    }, "watchCb");
    const nestedWatchCb = /* @__PURE__ */ __name(({ event, workflowId }) => {
      try {
        const { type: type2, payload, eventTimestamp } = event;
        const prefixedSteps = Object.fromEntries(Object.entries(payload?.workflowState?.steps ?? {}).map(([stepId, step]) => [`${workflowId}.${stepId}`, step]));
        const newPayload = { currentStep: { ...payload?.currentStep, id: `${workflowId}.${payload?.currentStep?.id}` }, workflowState: { steps: prefixedSteps } };
        this.updateState(newPayload);
        cb({ type: type2, payload: this.getState(), eventTimestamp });
      } catch (e) {
        console.error(e);
      }
    }, "nestedWatchCb");
    const nestedWatchV2Cb = /* @__PURE__ */ __name(({ event, workflowId }) => {
      this.emitter.emit("watch-v2", { ...event, ...event.payload?.id ? { payload: { ...event.payload, id: `${workflowId}.${event.payload.id}` } } : {} });
    }, "nestedWatchV2Cb");
    if (type === "watch") {
      this.emitter.on("watch", watchCb);
      this.emitter.on("nested-watch", nestedWatchCb);
    } else if (type === "watch-v2") {
      this.emitter.on("watch-v2", cb);
      this.emitter.on("nested-watch-v2", nestedWatchV2Cb);
    }
    return () => {
      if (type === "watch-v2") {
        this.emitter.off("watch-v2", cb);
        this.emitter.off("nested-watch-v2", nestedWatchV2Cb);
      } else {
        this.emitter.off("watch", watchCb);
        this.emitter.off("nested-watch", nestedWatchCb);
      }
    };
  }
  async watchAsync(cb, type = "watch") {
    return this.watch(cb, type);
  }
  async resume(params) {
    return this._resume(params);
  }
  /**
  * Restarts the workflow execution that was previously active
  * @returns A promise that resolves to the workflow output
  */
  async restart(args = {}) {
    return this._restart(args);
  }
  async _resume(params) {
    const snapshot = await this.#mastra?.getStorage()?.loadWorkflowSnapshot({ workflowName: this.workflowId, runId: this.runId });
    if (!snapshot) {
      throw new Error("No snapshot found for this workflow run: " + this.workflowId + " " + this.runId);
    }
    if (snapshot.status !== "suspended") {
      throw new Error("This workflow run was not suspended");
    }
    const snapshotResumeLabel = params.label ? snapshot?.resumeLabels?.[params.label] : void 0;
    const stepParam = snapshotResumeLabel?.stepId ?? params.step;
    let steps;
    if (stepParam) {
      let newStepParam = stepParam;
      if (typeof stepParam === "string") {
        newStepParam = stepParam.split(".");
      }
      steps = (Array.isArray(newStepParam) ? newStepParam : [newStepParam]).map((step) => typeof step === "string" ? step : step?.id);
    } else {
      const suspendedStepPaths = [];
      Object.entries(snapshot?.suspendedPaths ?? {}).forEach(([stepId, _executionPath]) => {
        const stepResult = snapshot?.context?.[stepId];
        if (stepResult && typeof stepResult === "object" && "status" in stepResult) {
          const stepRes = stepResult;
          if (stepRes.status === "suspended") {
            const nestedPath = stepRes.suspendPayload?.__workflow_meta?.path;
            if (nestedPath && Array.isArray(nestedPath)) {
              suspendedStepPaths.push([stepId, ...nestedPath]);
            } else {
              suspendedStepPaths.push([stepId]);
            }
          }
        }
      });
      if (suspendedStepPaths.length === 0) {
        throw new Error("No suspended steps found in this workflow run");
      }
      if (suspendedStepPaths.length === 1) {
        steps = suspendedStepPaths[0];
      } else {
        const pathStrings = suspendedStepPaths.map((path3) => `[${path3.join(", ")}]`);
        throw new Error(`Multiple suspended steps found: ${pathStrings.join(", ")}. Please specify which step to resume using the "step" parameter.`);
      }
    }
    if (!params.runCount) {
      const suspendedStepIds = Object.keys(snapshot?.suspendedPaths ?? {});
      const isStepSuspended = suspendedStepIds.includes(steps?.[0] ?? "");
      if (!isStepSuspended) {
        throw new Error(`This workflow step "${steps?.[0]}" was not suspended. Available suspended steps: [${suspendedStepIds.join(", ")}]`);
      }
    }
    const suspendedStep = this.workflowSteps[steps?.[0] ?? ""];
    const resumeDataToUse = await this._validateResumeData(params.resumeData, suspendedStep);
    let runtimeContextInput;
    if (params.runCount && params.runCount > 0 && params.runtimeContext) {
      runtimeContextInput = params.runtimeContext.get("__mastraWorflowInputData");
      params.runtimeContext.delete("__mastraWorflowInputData");
    }
    const stepResults = { ...snapshot?.context ?? {}, input: runtimeContextInput ?? snapshot?.context?.input };
    const runtimeContextToUse = params.runtimeContext ?? new RuntimeContext();
    Object.entries(snapshot?.runtimeContext ?? {}).forEach(([key, value]) => {
      if (!runtimeContextToUse.has(key)) {
        runtimeContextToUse.set(key, value);
      }
    });
    const workflowAISpan = getOrCreateSpan({ type: "workflow_run", name: `workflow run: '${this.workflowId}'`, input: resumeDataToUse, attributes: { workflowId: this.workflowId }, metadata: { resourceId: this.resourceId, runId: this.runId }, tracingPolicy: this.tracingPolicy, tracingOptions: params.tracingOptions, tracingContext: params.tracingContext, runtimeContext: runtimeContextToUse });
    const traceId = getValidTraceId(workflowAISpan);
    const executionResultPromise = this.executionEngine.execute({ workflowId: this.workflowId, runId: this.runId, resourceId: this.resourceId, graph: this.executionGraph, serializedStepGraph: this.serializedStepGraph, input: snapshot?.context?.input, initialState: snapshot?.value ?? {}, resume: {
      steps,
      stepResults,
      resumePayload: resumeDataToUse,
      // @ts-ignore
      resumePath: snapshot?.suspendedPaths?.[steps?.[0]],
      forEachIndex: params.forEachIndex ?? snapshotResumeLabel?.foreachIndex,
      label: params.label
    }, format: params.format, emitter: { emit: /* @__PURE__ */ __name((event, data) => {
      this.emitter.emit(event, data);
      return Promise.resolve();
    }, "emit"), on: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.on(event, callback);
    }, "on"), off: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.off(event, callback);
    }, "off"), once: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.once(event, callback);
    }, "once") }, runtimeContext: runtimeContextToUse, abortController: this.abortController, workflowAISpan, outputOptions: params.outputOptions, writableStream: params.writableStream }).then((result) => {
      if (!params.isVNext && result.status !== "suspended") {
        this.closeStreamAction?.().catch(() => {
        });
      }
      result.traceId = traceId;
      return result;
    });
    this.executionResults = executionResultPromise;
    return executionResultPromise.then((result) => {
      this.#streamOutput?.updateResults(result);
      return result;
    });
  }
  async _restart({ runtimeContext, writableStream, tracingContext, tracingOptions }) {
    if (this.workflowEngineType !== "default") {
      throw new Error(`restart() is not supported on ${this.workflowEngineType} workflows`);
    }
    const snapshot = await this.#mastra?.getStorage()?.loadWorkflowSnapshot({ workflowName: this.workflowId, runId: this.runId });
    let nestedWorkflowPending = false;
    if (!snapshot) {
      throw new Error(`Snapshot not found for run ${this.runId}`);
    }
    if (snapshot.status !== "running" && snapshot.status !== "waiting") {
      if (snapshot.status === "pending" && !!snapshot.context.input) {
        nestedWorkflowPending = true;
      } else {
        throw new Error("This workflow run was not active");
      }
    }
    let nestedWorkflowActiveStepsPath = {};
    const firstEntry = this.executionGraph.steps[0];
    if (firstEntry.type === "step" || firstEntry.type === "foreach" || firstEntry.type === "loop") {
      nestedWorkflowActiveStepsPath = { [firstEntry.step.id]: [0] };
    } else if (firstEntry.type === "sleep" || firstEntry.type === "sleepUntil") {
      nestedWorkflowActiveStepsPath = { [firstEntry.id]: [0] };
    } else if (firstEntry.type === "conditional" || firstEntry.type === "parallel") {
      nestedWorkflowActiveStepsPath = firstEntry.steps.reduce((acc, step) => {
        acc[step.step.id] = [0];
        return acc;
      }, {});
    }
    const restartData = { activePaths: nestedWorkflowPending ? [0] : snapshot.activePaths, activeStepsPath: nestedWorkflowPending ? nestedWorkflowActiveStepsPath : snapshot.activeStepsPath, stepResults: snapshot.context, state: snapshot.value };
    const runtimeContextToUse = runtimeContext ?? new RuntimeContext();
    for (const [key, value] of Object.entries(snapshot.runtimeContext ?? {})) {
      if (!runtimeContextToUse.has(key)) {
        runtimeContextToUse.set(key, value);
      }
    }
    const workflowAISpan = getOrCreateSpan({ type: "workflow_run", name: `workflow run: '${this.workflowId}'`, attributes: { workflowId: this.workflowId }, metadata: { resourceId: this.resourceId, runId: this.runId }, tracingPolicy: this.tracingPolicy, tracingOptions, tracingContext, runtimeContext: runtimeContextToUse });
    const traceId = getValidTraceId(workflowAISpan);
    const result = await this.executionEngine.execute({ workflowId: this.workflowId, runId: this.runId, resourceId: this.resourceId, disableScorers: this.disableScorers, graph: this.executionGraph, serializedStepGraph: this.serializedStepGraph, restart: restartData, emitter: { emit: /* @__PURE__ */ __name(async (event, data) => {
      this.emitter.emit(event, data);
    }, "emit"), on: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.on(event, callback);
    }, "on"), off: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.off(event, callback);
    }, "off"), once: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.once(event, callback);
    }, "once") }, retryConfig: this.retryConfig, runtimeContext: runtimeContextToUse, abortController: this.abortController, writableStream, workflowAISpan });
    if (result.status !== "suspended") {
      this.cleanup?.();
    }
    result.traceId = traceId;
    return result;
  }
  async _timeTravel({ inputData, resumeData, initialState, step: stepParam, context: context3, nestedStepsContext, runtimeContext, writableStream, tracingContext, tracingOptions, outputOptions }) {
    if (!stepParam || Array.isArray(stepParam) && stepParam.length === 0) {
      throw new Error("Step is required and must be a valid step or array of steps");
    }
    const snapshot = await this.#mastra?.getStorage()?.loadWorkflowSnapshot({ workflowName: this.workflowId, runId: this.runId });
    if (!snapshot) {
      throw new Error(`Snapshot not found for run ${this.runId}`);
    }
    if (snapshot.status === "running") {
      throw new Error("This workflow run is still running, cannot time travel");
    }
    let steps;
    let newStepParam = stepParam;
    if (typeof stepParam === "string") {
      newStepParam = stepParam.split(".");
    }
    steps = (Array.isArray(newStepParam) ? newStepParam : [newStepParam]).map((step) => typeof step === "string" ? step : step?.id);
    let inputDataToUse = inputData;
    if (inputDataToUse && steps.length === 1) {
      inputDataToUse = await this._validateTimetravelInputData(inputData, this.workflowSteps[steps[0]]);
    }
    const timeTravelData = createTimeTravelExecutionParams({ steps, inputData: inputDataToUse, resumeData, context: context3, nestedStepsContext, snapshot, initialState, graph: this.executionGraph });
    const runtimeContextToUse = runtimeContext ?? new RuntimeContext();
    for (const [key, value] of Object.entries(snapshot.runtimeContext ?? {})) {
      if (!runtimeContextToUse.has(key)) {
        runtimeContextToUse.set(key, value);
      }
    }
    const workflowAISpan = getOrCreateSpan({ type: "workflow_run", name: `workflow run: '${this.workflowId}'`, input: inputData, attributes: { workflowId: this.workflowId }, metadata: { resourceId: this.resourceId, runId: this.runId }, tracingPolicy: this.tracingPolicy, tracingOptions, tracingContext, runtimeContext: runtimeContextToUse });
    const traceId = getValidTraceId(workflowAISpan);
    const result = await this.executionEngine.execute({ workflowId: this.workflowId, runId: this.runId, resourceId: this.resourceId, disableScorers: this.disableScorers, graph: this.executionGraph, timeTravel: timeTravelData, serializedStepGraph: this.serializedStepGraph, emitter: { emit: /* @__PURE__ */ __name(async (event, data) => {
      this.emitter.emit(event, data);
    }, "emit"), on: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.on(event, callback);
    }, "on"), off: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.off(event, callback);
    }, "off"), once: /* @__PURE__ */ __name((event, callback) => {
      this.emitter.once(event, callback);
    }, "once") }, retryConfig: this.retryConfig, runtimeContext: runtimeContextToUse, abortController: this.abortController, writableStream, workflowAISpan, outputOptions });
    if (result.status !== "suspended") {
      this.cleanup?.();
    }
    result.traceId = traceId;
    return result;
  }
  async timeTravel(args) {
    return this._timeTravel(args);
  }
  timeTravelStream({ inputData, resumeData, initialState, step, context: context3, nestedStepsContext, runtimeContext, tracingContext, tracingOptions, outputOptions }) {
    this.closeStreamAction = async () => {
    };
    const self2 = this;
    const stream = new ReadableStream$1({ async start(controller) {
      const unwatch = self2.watch(async ({ type, from = "WORKFLOW", payload }) => {
        controller.enqueue({ type, runId: self2.runId, from, payload: { stepName: payload.id, ...payload } });
      }, "watch-v2");
      self2.closeStreamAction = async () => {
        unwatch();
        try {
          await controller.close();
        } catch (err) {
          console.error("Error closing stream:", err);
        }
      };
      const executionResultsPromise = self2._timeTravel({ inputData, step, context: context3, nestedStepsContext, resumeData, initialState, runtimeContext, tracingContext, tracingOptions, writableStream: new WritableStream$1({ write(chunk) {
        controller.enqueue(chunk);
      } }), outputOptions });
      self2.executionResults = executionResultsPromise;
      let executionResults;
      try {
        executionResults = await executionResultsPromise;
        self2.closeStreamAction?.().catch(() => {
        });
        if (self2.#streamOutput) {
          self2.#streamOutput.updateResults(executionResults);
        }
      } catch (err) {
        self2.#streamOutput?.rejectResults(err);
        self2.closeStreamAction?.().catch(() => {
        });
      }
    } });
    this.#streamOutput = new WorkflowRunOutput({ runId: this.runId, workflowId: this.workflowId, stream });
    return this.#streamOutput;
  }
  /**
  * Returns the current state of the workflow run
  * @returns The current state of the workflow run
  */
  getState() {
    return this.state;
  }
  updateState(state) {
    if (state.currentStep) {
      this.state.currentStep = state.currentStep;
    } else if (state.workflowState?.status !== "running") {
      delete this.state.currentStep;
    }
    if (state.workflowState) {
      this.state.workflowState = deepMergeWorkflowState(this.state.workflowState ?? {}, state.workflowState ?? {});
    }
  }
  /**
  * @access private
  * @returns The execution results of the workflow run
  */
  _getExecutionResults() {
    return this.executionResults ?? this.#streamOutput?.result;
  }
};
function deepMergeWorkflowState(a, b) {
  if (!a || typeof a !== "object") return b;
  if (!b || typeof b !== "object") return a;
  const result = { ...a };
  for (const key in b) {
    if (b[key] === void 0) continue;
    if (b[key] !== null && typeof b[key] === "object") {
      const aVal = result[key];
      const bVal = b[key];
      if (Array.isArray(bVal)) {
        result[key] = bVal.filter((item) => item !== void 0);
      } else if (typeof aVal === "object" && aVal !== null) {
        result[key] = deepMergeWorkflowState(aVal, bVal);
      } else {
        result[key] = bVal;
      }
    } else {
      result[key] = b[key];
    }
  }
  return result;
}
__name(deepMergeWorkflowState, "deepMergeWorkflowState");
var languageModelUsageSchema = zod_default.object({ inputTokens: zod_default.number(), outputTokens: zod_default.number(), totalTokens: zod_default.number(), reasoningTokens: zod_default.number().optional(), cachedInputTokens: zod_default.number().optional() });
var llmIterationStepResultSchema = zod_default.object({ reason: zod_default.string(), warnings: zod_default.array(zod_default.any()), isContinued: zod_default.boolean(), logprobs: zod_default.any().optional(), totalUsage: languageModelUsageSchema.optional(), headers: zod_default.record(zod_default.string()).optional(), messageId: zod_default.string().optional(), request: zod_default.record(zod_default.any()).optional() });
var llmIterationOutputSchema = zod_default.object({ messageId: zod_default.string(), messages: zod_default.object({
  all: zod_default.array(zod_default.any()),
  // ModelMessage[] but too complex to validate at runtime
  user: zod_default.array(zod_default.any()),
  nonUser: zod_default.array(zod_default.any())
}), output: zod_default.object({
  text: zod_default.string().optional(),
  reasoning: zod_default.array(zod_default.any()).optional(),
  reasoningText: zod_default.string().optional(),
  files: zod_default.array(zod_default.any()).optional(),
  // GeneratedFile[]
  toolCalls: zod_default.array(zod_default.any()).optional(),
  // TypedToolCall[]
  toolResults: zod_default.array(zod_default.any()).optional(),
  // TypedToolResult[]
  sources: zod_default.array(zod_default.any()).optional(),
  // LanguageModelV2Source[]
  staticToolCalls: zod_default.array(zod_default.any()).optional(),
  dynamicToolCalls: zod_default.array(zod_default.any()).optional(),
  staticToolResults: zod_default.array(zod_default.any()).optional(),
  dynamicToolResults: zod_default.array(zod_default.any()).optional(),
  usage: languageModelUsageSchema,
  steps: zod_default.array(zod_default.any())
  // StepResult[]
}), metadata: zod_default.object({ id: zod_default.string().optional(), model: zod_default.string().optional(), modelId: zod_default.string().optional(), modelMetadata: zod_default.object({ modelId: zod_default.string(), modelVersion: zod_default.string(), modelProvider: zod_default.string() }).optional(), timestamp: zod_default.date().optional(), providerMetadata: zod_default.record(zod_default.any()).optional(), headers: zod_default.record(zod_default.string()).optional(), request: zod_default.record(zod_default.any()).optional() }), stepResult: llmIterationStepResultSchema });
var toolCallInputSchema = zod_default.object({ toolCallId: zod_default.string(), toolName: zod_default.string(), args: zod_default.record(zod_default.any()), providerMetadata: zod_default.record(zod_default.any()).optional(), providerExecuted: zod_default.boolean().optional(), output: zod_default.any().optional() });
var toolCallOutputSchema = toolCallInputSchema.extend({ result: zod_default.any(), error: zod_default.any().optional() });
function asJsonSchema(schema) {
  if (!schema) {
    return void 0;
  }
  if (schema && typeof schema === "object" && !schema.safeParse && !schema.jsonSchema) {
    return schema;
  }
  return asSchema(schema).jsonSchema;
}
__name(asJsonSchema, "asJsonSchema");
function getTransformedSchema(schema) {
  let jsonSchema22;
  jsonSchema22 = asJsonSchema(schema);
  if (!jsonSchema22) {
    return void 0;
  }
  const { $schema, ...itemSchema } = jsonSchema22;
  if (itemSchema.type === "array") {
    const innerElement = itemSchema.items;
    const arrayOutputSchema = { $schema, type: "object", properties: { elements: { type: "array", items: innerElement } }, required: ["elements"], additionalProperties: false };
    return { jsonSchema: arrayOutputSchema, outputFormat: "array" };
  }
  if (itemSchema.enum && Array.isArray(itemSchema.enum)) {
    const enumOutputSchema = { $schema, type: "object", properties: { result: { type: itemSchema.type || "string", enum: itemSchema.enum } }, required: ["result"], additionalProperties: false };
    return { jsonSchema: enumOutputSchema, outputFormat: "enum" };
  }
  return {
    jsonSchema: jsonSchema22,
    outputFormat: jsonSchema22.type
    // 'object'
  };
}
__name(getTransformedSchema, "getTransformedSchema");
function getResponseFormat(schema) {
  if (schema) {
    const transformedSchema = getTransformedSchema(schema);
    return { type: "json", schema: transformedSchema?.jsonSchema };
  }
  return { type: "text" };
}
__name(getResponseFormat, "getResponseFormat");
var MastraModelInput = class extends MastraBase {
  static {
    __name(this, "MastraModelInput");
  }
  initialize({ runId, createStream, onResult }) {
    const self2 = this;
    const stream = new ReadableStream({ async start(controller) {
      try {
        const stream2 = await createStream();
        onResult({ warnings: stream2.warnings, request: stream2.request, rawResponse: stream2.rawResponse || stream2.response || {} });
        await self2.transform({ runId, stream: stream2.stream, controller });
        controller.close();
      } catch (error87) {
        controller.error(error87);
      }
    } });
    return stream;
  }
};
function convertFullStreamChunkToMastra(value, ctx) {
  switch (value.type) {
    case "response-metadata":
      return { type: "response-metadata", runId: ctx.runId, from: "AGENT", payload: { ...value } };
    case "text-start":
      return { type: "text-start", runId: ctx.runId, from: "AGENT", payload: { id: value.id, providerMetadata: value.providerMetadata } };
    case "text-delta":
      if (value.delta) {
        return { type: "text-delta", runId: ctx.runId, from: "AGENT", payload: { id: value.id, providerMetadata: value.providerMetadata, text: value.delta } };
      }
      return;
    case "text-end":
      return { type: "text-end", runId: ctx.runId, from: "AGENT", payload: value };
    case "reasoning-start":
      return { type: "reasoning-start", runId: ctx.runId, from: "AGENT", payload: { id: value.id, providerMetadata: value.providerMetadata } };
    case "reasoning-delta":
      return { type: "reasoning-delta", runId: ctx.runId, from: "AGENT", payload: { id: value.id, providerMetadata: value.providerMetadata, text: value.delta } };
    case "reasoning-end":
      return { type: "reasoning-end", runId: ctx.runId, from: "AGENT", payload: { id: value.id, providerMetadata: value.providerMetadata } };
    case "source":
      return { type: "source", runId: ctx.runId, from: "AGENT", payload: { id: value.id, sourceType: value.sourceType, title: value.title || "", mimeType: value.sourceType === "document" ? value.mediaType : void 0, filename: value.sourceType === "document" ? value.filename : void 0, url: value.sourceType === "url" ? value.url : void 0, providerMetadata: value.providerMetadata } };
    case "file":
      return { type: "file", runId: ctx.runId, from: "AGENT", payload: { data: value.data, base64: typeof value.data === "string" ? value.data : void 0, mimeType: value.mediaType } };
    case "tool-call": {
      let toolCallInput = void 0;
      if (value.input) {
        try {
          toolCallInput = JSON.parse(value.input);
        } catch (error87) {
          console.error("Error converting tool call input to JSON", { error: error87, input: value.input });
          toolCallInput = void 0;
        }
      }
      return { type: "tool-call", runId: ctx.runId, from: "AGENT", payload: { toolCallId: value.toolCallId, toolName: value.toolName, args: toolCallInput, providerExecuted: value.providerExecuted, providerMetadata: value.providerMetadata } };
    }
    case "tool-result":
      return { type: "tool-result", runId: ctx.runId, from: "AGENT", payload: { toolCallId: value.toolCallId, toolName: value.toolName, result: value.result, isError: value.isError, providerExecuted: value.providerExecuted, providerMetadata: value.providerMetadata } };
    case "tool-input-start":
      return { type: "tool-call-input-streaming-start", runId: ctx.runId, from: "AGENT", payload: { toolCallId: value.id, toolName: value.toolName, providerExecuted: value.providerExecuted, providerMetadata: value.providerMetadata } };
    case "tool-input-delta":
      if (value.delta) {
        return { type: "tool-call-delta", runId: ctx.runId, from: "AGENT", payload: { argsTextDelta: value.delta, toolCallId: value.id, providerMetadata: value.providerMetadata } };
      }
      return;
    case "tool-input-end":
      return { type: "tool-call-input-streaming-end", runId: ctx.runId, from: "AGENT", payload: { toolCallId: value.id, providerMetadata: value.providerMetadata } };
    case "finish":
      const { finishReason, usage, providerMetadata, messages, ...rest } = value;
      return { type: "finish", runId: ctx.runId, from: "AGENT", payload: { stepResult: { reason: value.finishReason }, output: { usage: { ...value.usage ?? {}, totalTokens: value?.usage?.totalTokens ?? (value.usage?.inputTokens ?? 0) + (value.usage?.outputTokens ?? 0) } }, metadata: { providerMetadata: value.providerMetadata }, messages, ...rest } };
    case "error":
      return { type: "error", runId: ctx.runId, from: "AGENT", payload: value };
    case "raw":
      return { type: "raw", runId: ctx.runId, from: "AGENT", payload: value.rawValue };
  }
  return;
}
__name(convertFullStreamChunkToMastra, "convertFullStreamChunkToMastra");
function convertMastraChunkToAISDKv5({ chunk, mode = "stream" }) {
  switch (chunk.type) {
    case "start":
      return { type: "start" };
    case "step-start":
      const { messageId: _messageId, ...rest } = chunk.payload;
      return { type: "start-step", request: rest.request, warnings: rest.warnings || [] };
    case "raw":
      return { type: "raw", rawValue: chunk.payload };
    case "finish": {
      return { type: "finish", finishReason: chunk.payload.stepResult.reason, totalUsage: chunk.payload.output.usage };
    }
    case "reasoning-start":
      return { type: "reasoning-start", id: chunk.payload.id, providerMetadata: chunk.payload.providerMetadata };
    case "reasoning-delta":
      return { type: "reasoning-delta", id: chunk.payload.id, text: chunk.payload.text, providerMetadata: chunk.payload.providerMetadata };
    case "reasoning-signature":
      throw new Error('AISDKv5 chunk type "reasoning-signature" not supported');
    // return {
    //   type: 'reasoning-signature' as const,
    //   id: chunk.payload.id,
    //   signature: chunk.payload.signature,
    // };
    case "redacted-reasoning":
      throw new Error('AISDKv5 chunk type "redacted-reasoning" not supported');
    // return {
    //   type: 'redacted-reasoning',
    //   id: chunk.payload.id,
    //   data: chunk.payload.data,
    // };
    case "reasoning-end":
      return { type: "reasoning-end", id: chunk.payload.id, providerMetadata: chunk.payload.providerMetadata };
    case "source":
      if (chunk.payload.sourceType === "url") {
        return { type: "source", sourceType: "url", id: chunk.payload.id, url: chunk.payload.url, title: chunk.payload.title, providerMetadata: chunk.payload.providerMetadata };
      } else {
        return { type: "source", sourceType: "document", id: chunk.payload.id, mediaType: chunk.payload.mimeType, title: chunk.payload.title, filename: chunk.payload.filename, providerMetadata: chunk.payload.providerMetadata };
      }
    case "file":
      if (mode === "generate") {
        return { type: "file", file: new DefaultGeneratedFile2({ data: chunk.payload.data, mediaType: chunk.payload.mimeType }) };
      }
      return { type: "file", file: new DefaultGeneratedFileWithType2({ data: chunk.payload.data, mediaType: chunk.payload.mimeType }) };
    case "tool-call":
      return { type: "tool-call", toolCallId: chunk.payload.toolCallId, providerMetadata: chunk.payload.providerMetadata, providerExecuted: chunk.payload.providerExecuted, toolName: chunk.payload.toolName, input: chunk.payload.args };
    case "tool-call-input-streaming-start":
      return { type: "tool-input-start", id: chunk.payload.toolCallId, toolName: chunk.payload.toolName, dynamic: !!chunk.payload.dynamic, providerMetadata: chunk.payload.providerMetadata, providerExecuted: chunk.payload.providerExecuted };
    case "tool-call-input-streaming-end":
      return { type: "tool-input-end", id: chunk.payload.toolCallId, providerMetadata: chunk.payload.providerMetadata };
    case "tool-call-delta":
      return { type: "tool-input-delta", id: chunk.payload.toolCallId, delta: chunk.payload.argsTextDelta, providerMetadata: chunk.payload.providerMetadata };
    case "step-finish": {
      const { request: _request, providerMetadata, ...rest2 } = chunk.payload.metadata;
      return { type: "finish-step", response: { id: chunk.payload.id || "", timestamp: /* @__PURE__ */ new Date(), modelId: rest2.modelId || "", ...rest2 }, usage: chunk.payload.output.usage, finishReason: chunk.payload.stepResult.reason, providerMetadata };
    }
    case "text-delta":
      return { type: "text-delta", id: chunk.payload.id, text: chunk.payload.text, providerMetadata: chunk.payload.providerMetadata };
    case "text-end":
      return { type: "text-end", id: chunk.payload.id, providerMetadata: chunk.payload.providerMetadata };
    case "text-start":
      return { type: "text-start", id: chunk.payload.id, providerMetadata: chunk.payload.providerMetadata };
    case "tool-result":
      return {
        type: "tool-result",
        input: chunk.payload.args,
        toolCallId: chunk.payload.toolCallId,
        providerExecuted: chunk.payload.providerExecuted,
        toolName: chunk.payload.toolName,
        output: chunk.payload.result
        // providerMetadata: chunk.payload.providerMetadata, // AI v5 types don't show this?
      };
    case "tool-error":
      return {
        type: "tool-error",
        error: chunk.payload.error,
        input: chunk.payload.args,
        toolCallId: chunk.payload.toolCallId,
        providerExecuted: chunk.payload.providerExecuted,
        toolName: chunk.payload.toolName
        // providerMetadata: chunk.payload.providerMetadata, // AI v5 types don't show this?
      };
    case "abort":
      return { type: "abort" };
    case "error":
      return { type: "error", error: chunk.payload.error };
    case "object":
      return { type: "object", object: chunk.object };
    default:
      if (chunk.type && "payload" in chunk && chunk.payload) {
        return { type: chunk.type, ...chunk.payload || {} };
      }
      return;
  }
}
__name(convertMastraChunkToAISDKv5, "convertMastraChunkToAISDKv5");
var AISDKV5InputStream = class extends MastraModelInput {
  static {
    __name(this, "AISDKV5InputStream");
  }
  constructor({ component, name: name51 }) {
    super({ component, name: name51 });
  }
  async transform({ runId, stream, controller }) {
    for await (const chunk of stream) {
      const transformedChunk = convertFullStreamChunkToMastra(chunk, { runId });
      if (transformedChunk) {
        controller.enqueue(transformedChunk);
      }
    }
  }
};
function omit4(obj, keys) {
  const newObj = { ...obj };
  for (const key of keys) {
    delete newObj[key];
  }
  return newObj;
}
__name(omit4, "omit");
var hasLoggedModelSettingsAbortSignalDeprecation = false;
function execute({ runId, model, providerOptions, inputMessages, tools, toolChoice, options, onResult, modelStreamSpan, telemetry_settings, includeRawChunks, modelSettings, structuredOutput, headers, shouldThrowError, methodType }) {
  if (modelSettings?.abortSignal && !hasLoggedModelSettingsAbortSignalDeprecation) {
    console.warn("[Deprecation Warning] Using `modelSettings.abortSignal` is deprecated. Please use top-level `abortSignal` instead. The `modelSettings.abortSignal` option will be removed in a future version.");
    hasLoggedModelSettingsAbortSignalDeprecation = true;
  }
  const v5 = new AISDKV5InputStream({ component: "LLM", name: model.modelId });
  const toolsAndToolChoice = prepareToolsAndToolChoice2({ tools, toolChoice, activeTools: options?.activeTools });
  if (modelStreamSpan && toolsAndToolChoice?.tools?.length && telemetry_settings?.recordOutputs !== false) {
    modelStreamSpan.setAttributes({ "stream.prompt.tools": toolsAndToolChoice?.tools?.map((tool5) => JSON.stringify(tool5)) });
  }
  const structuredOutputMode = structuredOutput?.schema ? structuredOutput?.model ? "processor" : "direct" : void 0;
  const responseFormat = structuredOutput?.schema ? getResponseFormat(structuredOutput?.schema) : void 0;
  let prompt = inputMessages;
  if (structuredOutputMode === "direct" && responseFormat?.type === "json" && structuredOutput?.jsonPromptInjection) {
    prompt = injectJsonInstructionIntoMessages({ messages: inputMessages, schema: responseFormat.schema });
  }
  if (structuredOutputMode === "processor" && responseFormat?.type === "json" && responseFormat?.schema) {
    prompt = injectJsonInstructionIntoMessages({ messages: inputMessages, schema: responseFormat.schema, schemaPrefix: `Your response will be processed by another agent to extract structured data. Please ensure your response contains comprehensive information for all the following fields that will be extracted:
`, schemaSuffix: `

You don't need to format your response as JSON unless the user asks you to. Just ensure your natural language response includes relevant information for each field in the schema above.` });
  }
  const providerOptionsToUse = model.provider.startsWith("openai") && responseFormat?.type === "json" && !structuredOutput?.jsonPromptInjection ? { ...providerOptions ?? {}, openai: { strictJsonSchema: true, ...providerOptions?.openai ?? {} } } : providerOptions;
  const stream = v5.initialize({ runId, onResult, createStream: /* @__PURE__ */ __name(async () => {
    try {
      const filteredModelSettings = omit4(modelSettings || {}, ["maxRetries", "headers", "abortSignal"]);
      const abortSignal = options?.abortSignal || modelSettings?.abortSignal;
      const pRetry2 = await Promise.resolve().then(() => (init_p_retry(), p_retry_exports));
      return await pRetry2.default(async () => {
        const fn = (methodType === "stream" ? model.doStream : model.doGenerate).bind(model);
        const streamResult = await fn({ ...toolsAndToolChoice, prompt, providerOptions: providerOptionsToUse, abortSignal, includeRawChunks, responseFormat: structuredOutputMode === "direct" && !structuredOutput?.jsonPromptInjection ? responseFormat : void 0, ...filteredModelSettings, headers });
        return streamResult;
      }, { retries: modelSettings?.maxRetries ?? 2, signal: abortSignal, shouldRetry(context3) {
        if (APICallError.isInstance(context3.error)) {
          return context3.error.isRetryable;
        }
        return true;
      } });
    } catch (error87) {
      if (shouldThrowError) {
        throw error87;
      }
      return { stream: new ReadableStream({ start: /* @__PURE__ */ __name(async (controller) => {
        controller.enqueue({ type: "error", error: error87 });
        controller.close();
      }, "start") }), warnings: [], request: {}, rawResponse: {} };
    }
  }, "createStream") });
  return stream;
}
__name(execute, "execute");
var DefaultStepResult = class {
  static {
    __name(this, "DefaultStepResult");
  }
  content;
  finishReason;
  usage;
  warnings;
  request;
  response;
  providerMetadata;
  constructor({ content, finishReason, usage, warnings, request, response, providerMetadata }) {
    this.content = content;
    this.finishReason = finishReason;
    this.usage = usage;
    this.warnings = warnings;
    this.request = request;
    this.response = response;
    this.providerMetadata = providerMetadata;
  }
  get text() {
    return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
  }
  get reasoning() {
    return this.content.filter((part) => part.type === "reasoning");
  }
  get reasoningText() {
    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join("");
  }
  get files() {
    return this.content.filter((part) => part.type === "file").map((part) => part.file);
  }
  get sources() {
    return this.content.filter((part) => part.type === "source");
  }
  get toolCalls() {
    return this.content.filter((part) => part.type === "tool-call");
  }
  get staticToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic === false);
  }
  get dynamicToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic === true);
  }
  get toolResults() {
    return this.content.filter((part) => part.type === "tool-result");
  }
  get staticToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic === false);
  }
  get dynamicToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic === true);
  }
};
var AgenticRunState = class {
  static {
    __name(this, "AgenticRunState");
  }
  #state;
  constructor({ _internal, model }) {
    this.#state = { responseMetadata: { id: _internal?.generateId?.(), timestamp: _internal?.currentDate?.(), modelId: model.modelId, modelVersion: model.specificationVersion, modelProvider: model.provider, headers: void 0 }, modelMetadata: { modelId: model.modelId, modelVersion: model.specificationVersion, modelProvider: model.provider }, isReasoning: false, isStreaming: false, providerOptions: void 0, hasToolCallStreaming: false, hasErrored: false, reasoningDeltas: [], textDeltas: [], stepResult: void 0 };
  }
  setState(state) {
    this.#state = { ...this.#state, ...state };
  }
  get state() {
    return this.#state;
  }
};
async function processOutputStream({ tools, messageId, messageList, outputStream, runState, options, controller, responseFromModel, includeRawChunks }) {
  for await (const chunk of outputStream._getBaseStream()) {
    if (!chunk) {
      continue;
    }
    if (chunk.type == "object" || chunk.type == "object-result") {
      controller.enqueue(chunk);
      continue;
    }
    if (chunk.type !== "text-delta" && chunk.type !== "tool-call" && // not 100% sure about this being the right fix.
    // basically for some llm providers they add response-metadata after each text-delta
    // we then flush the chunks by calling messageList.add (a few lines down)
    // this results in a bunch of weird separated text chunks on the message instead of combined chunks
    // easiest solution here is to just not flush for response-metadata
    // BUT does this cause other issues?
    // Alternative solution: in message list allow combining text deltas together when the message source is "response" and the text parts are directly next to each other
    // simple solution for now is to not flush text deltas on response-metadata
    chunk.type !== "response-metadata" && runState.state.isStreaming) {
      if (runState.state.textDeltas.length) {
        const textStartPayload = chunk.payload;
        const providerMetadata = textStartPayload.providerMetadata ?? runState.state.providerOptions;
        const message = { id: messageId, role: "assistant", content: { format: 2, parts: [{ type: "text", text: runState.state.textDeltas.join(""), ...providerMetadata ? { providerMetadata } : {} }], ...runState.state.providerOptions ? { providerMetadata: runState.state.providerOptions } : {} }, createdAt: /* @__PURE__ */ new Date() };
        messageList.add(message, "response");
      }
      runState.setState({ isStreaming: false, textDeltas: [] });
    }
    if (chunk.type !== "reasoning-start" && chunk.type !== "reasoning-delta" && chunk.type !== "reasoning-end" && chunk.type !== "redacted-reasoning" && chunk.type !== "reasoning-signature" && chunk.type !== "response-metadata" && runState.state.isReasoning) {
      runState.setState({ isReasoning: false, reasoningDeltas: [] });
    }
    switch (chunk.type) {
      case "response-metadata":
        runState.setState({ responseMetadata: { id: chunk.payload.id, timestamp: chunk.payload.timestamp, modelId: chunk.payload.modelId, headers: chunk.payload.headers } });
        break;
      case "text-delta": {
        const textDeltasFromState = runState.state.textDeltas;
        textDeltasFromState.push(chunk.payload.text);
        runState.setState({ textDeltas: textDeltasFromState, isStreaming: true });
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "tool-call-input-streaming-start": {
        const tool5 = tools?.[chunk.payload.toolName] || Object.values(tools || {})?.find((tool22) => `id` in tool22 && tool22.id === chunk.payload.toolName);
        if (tool5 && "onInputStart" in tool5) {
          try {
            await tool5?.onInputStart?.({ toolCallId: chunk.payload.toolCallId, messages: messageList.get.input.aiV5.model(), abortSignal: options?.abortSignal });
          } catch (error210) {
            console.error("Error calling onInputStart", error210);
          }
        }
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "tool-call-delta": {
        const tool5 = tools?.[chunk.payload.toolName || ""] || Object.values(tools || {})?.find((tool22) => `id` in tool22 && tool22.id === chunk.payload.toolName);
        if (tool5 && "onInputDelta" in tool5) {
          try {
            await tool5?.onInputDelta?.({ inputTextDelta: chunk.payload.argsTextDelta, toolCallId: chunk.payload.toolCallId, messages: messageList.get.input.aiV5.model(), abortSignal: options?.abortSignal });
          } catch (error210) {
            console.error("Error calling onInputDelta", error210);
          }
        }
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "reasoning-start": {
        runState.setState({ isReasoning: true, reasoningDeltas: [], providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions });
        if (Object.values(chunk.payload.providerMetadata || {}).find((v) => v?.redactedData)) {
          const message = { id: messageId, role: "assistant", content: { format: 2, parts: [{ type: "reasoning", reasoning: "", details: [{ type: "redacted", data: "" }], providerMetadata: chunk.payload.providerMetadata ?? runState.state.providerOptions }] }, createdAt: /* @__PURE__ */ new Date() };
          messageList.add(message, "response");
          if (isControllerOpen(controller)) {
            controller.enqueue(chunk);
          }
          break;
        }
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "reasoning-delta": {
        const reasoningDeltasFromState = runState.state.reasoningDeltas;
        reasoningDeltasFromState.push(chunk.payload.text);
        runState.setState({ isReasoning: true, reasoningDeltas: reasoningDeltasFromState, providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions });
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "reasoning-end": {
        const reasoningProviderMetadata = chunk.payload.providerMetadata ?? runState.state.providerOptions;
        const hasReasoningDeltas = runState.state.reasoningDeltas.length > 0;
        const hasProviderMetadata = reasoningProviderMetadata && Object.keys(reasoningProviderMetadata).length > 0;
        if (hasReasoningDeltas || hasProviderMetadata) {
          const message = { id: messageId, role: "assistant", content: { format: 2, parts: [{ type: "reasoning", reasoning: "", details: hasReasoningDeltas ? [{ type: "text", text: runState.state.reasoningDeltas.join("") }] : [], providerMetadata: reasoningProviderMetadata }] }, createdAt: /* @__PURE__ */ new Date() };
          messageList.add(message, "response");
        }
        runState.setState({ isReasoning: false, reasoningDeltas: [] });
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
        break;
      }
      case "file":
        messageList.add({ id: messageId, role: "assistant", content: [{ type: "file", data: chunk.payload.data, mimeType: chunk.payload.mimeType }] }, "response");
        controller.enqueue(chunk);
        break;
      case "source":
        messageList.add({ id: messageId, role: "assistant", content: { format: 2, parts: [{ type: "source", source: { sourceType: "url", id: chunk.payload.id, url: chunk.payload.url || "", title: chunk.payload.title, providerMetadata: chunk.payload.providerMetadata } }] }, createdAt: /* @__PURE__ */ new Date() }, "response");
        controller.enqueue(chunk);
        break;
      case "finish":
        runState.setState({ providerOptions: chunk.payload.metadata.providerMetadata, stepResult: { reason: chunk.payload.reason, logprobs: chunk.payload.logprobs, warnings: responseFromModel.warnings, totalUsage: chunk.payload.totalUsage, headers: responseFromModel.rawResponse?.headers, messageId, isContinued: !["stop", "error"].includes(chunk.payload.stepResult.reason), request: responseFromModel.request } });
        break;
      case "error":
        if (isAbortError3(chunk.payload.error) && options?.abortSignal?.aborted) {
          break;
        }
        runState.setState({ hasErrored: true });
        runState.setState({ stepResult: { isContinued: false, reason: "error" } });
        const error87 = getErrorFromUnknown(chunk.payload.error, { fallbackMessage: "Unknown error in agent stream" });
        controller.enqueue({ ...chunk, payload: { ...chunk.payload, error: error87 } });
        await options?.onError?.({ error: error87 });
        break;
      default:
        if (isControllerOpen(controller)) {
          controller.enqueue(chunk);
        }
    }
    if (["text-delta", "reasoning-delta", "source", "tool-call", "tool-call-input-streaming-start", "tool-call-delta", "raw"].includes(chunk.type)) {
      if (chunk.type === "raw" && !includeRawChunks) {
        continue;
      }
      await options?.onChunk?.(chunk);
    }
    if (runState.state.hasErrored) {
      break;
    }
  }
}
__name(processOutputStream, "processOutputStream");
function executeStreamWithFallbackModels(models) {
  return async (callback) => {
    let index = 0;
    let finalResult;
    let done = false;
    for (const modelConfig of models) {
      index++;
      const maxRetries = modelConfig.maxRetries || 0;
      let attempt = 0;
      if (done) {
        break;
      }
      while (attempt <= maxRetries) {
        try {
          const isLastModel = attempt === maxRetries && index === models.length;
          const result = await callback(modelConfig.model, isLastModel);
          finalResult = result;
          done = true;
          break;
        } catch (err) {
          attempt++;
          console.error(`Error executing model ${modelConfig.model.modelId}, attempt ${attempt}====`, err);
          if (attempt > maxRetries) {
            break;
          }
        }
      }
    }
    if (typeof finalResult === "undefined") {
      console.error("Exhausted all fallback models and reached the maximum number of retries.");
      throw new Error("Exhausted all fallback models and reached the maximum number of retries.");
    }
    return finalResult;
  };
}
__name(executeStreamWithFallbackModels, "executeStreamWithFallbackModels");
function createLLMExecutionStep({ models, _internal, messageId, runId, modelStreamSpan, telemetry_settings, tools, toolChoice, messageList, includeRawChunks, modelSettings, providerOptions, options, toolCallStreaming, controller, structuredOutput, outputProcessors, headers, downloadRetries, downloadConcurrency, processorStates, methodType }) {
  return createStep({ id: "llm-execution", inputSchema: llmIterationOutputSchema, outputSchema: llmIterationOutputSchema, execute: /* @__PURE__ */ __name(async ({ inputData, bail, tracingContext }) => {
    let modelResult;
    let warnings;
    let request;
    let rawResponse;
    const { outputStream, callBail, runState } = await executeStreamWithFallbackModels(models)(async (model, isLastModel) => {
      const runState2 = new AgenticRunState({ _internal, model });
      switch (model.specificationVersion) {
        case "v2": {
          const messageListPromptArgs = { downloadRetries, downloadConcurrency, supportedUrls: model?.supportedUrls };
          let inputMessages = await messageList.get.all.aiV5.llmPrompt(messageListPromptArgs);
          let stepModel = model;
          let stepToolChoice = toolChoice;
          let stepTools = tools;
          if (options?.prepareStep) {
            try {
              const prepareStepResult = await options.prepareStep({ stepNumber: inputData.output?.steps?.length || 0, steps: inputData.output?.steps || [], model, messages: messageList.get.all.aiV5.model() });
              if (prepareStepResult) {
                if (prepareStepResult.model) {
                  stepModel = prepareStepResult.model;
                }
                if (prepareStepResult.toolChoice) {
                  stepToolChoice = prepareStepResult.toolChoice;
                }
                if (prepareStepResult.activeTools && stepTools) {
                  const activeToolsSet = new Set(prepareStepResult.activeTools);
                  stepTools = Object.fromEntries(Object.entries(stepTools).filter(([toolName]) => activeToolsSet.has(toolName)));
                }
                if (prepareStepResult.messages) {
                  const newMessages = prepareStepResult.messages;
                  const newMessageList = new MessageList();
                  for (const message of newMessages) {
                    if (message.role === "system") {
                      newMessageList.addSystem(message);
                    } else if (message.role === "user") {
                      newMessageList.add(message, "input");
                    } else if (message.role === "assistant" || message.role === "tool") {
                      newMessageList.add(message, "response");
                    }
                  }
                  inputMessages = await newMessageList.get.all.aiV5.llmPrompt(messageListPromptArgs);
                }
              }
            } catch (error87) {
              console.error("Error in prepareStep callback:", error87);
            }
          }
          modelResult = execute({ runId, model: stepModel, providerOptions, inputMessages, tools: stepTools, toolChoice: stepToolChoice, options, modelSettings, telemetry_settings, includeRawChunks, structuredOutput, headers, methodType, onResult: /* @__PURE__ */ __name(({ warnings: warningsFromStream, request: requestFromStream, rawResponse: rawResponseFromStream }) => {
            warnings = warningsFromStream;
            request = requestFromStream || {};
            rawResponse = rawResponseFromStream;
            if (!isControllerOpen(controller)) {
              return;
            }
            controller.enqueue({ runId, from: "AGENT", type: "step-start", payload: { request: request || {}, warnings: warnings || [], messageId } });
          }, "onResult"), modelStreamSpan, shouldThrowError: !isLastModel });
          break;
        }
        default: {
          throw new Error(`Unsupported model version: ${model.specificationVersion}`);
        }
      }
      const outputStream2 = new MastraModelOutput({ model: { modelId: model.modelId, provider: model.provider, version: model.specificationVersion }, stream: modelResult, messageList, messageId, options: { runId, rootSpan: modelStreamSpan, toolCallStreaming, telemetry_settings, includeRawChunks, structuredOutput, outputProcessors, isLLMExecutionStep: true, tracingContext, processorStates } });
      try {
        await processOutputStream({ outputStream: outputStream2, includeRawChunks, tools, messageId, messageList, runState: runState2, options, controller, responseFromModel: { warnings, request, rawResponse } });
      } catch (error87) {
        console.error("Error in LLM Execution Step", error87);
        if (isAbortError3(error87) && options?.abortSignal?.aborted) {
          await options?.onAbort?.({ steps: inputData?.output?.steps ?? [] });
          if (isControllerOpen(controller)) {
            controller.enqueue({ type: "abort", runId, from: "AGENT", payload: {} });
          }
          return { callBail: true, outputStream: outputStream2, runState: runState2 };
        }
        if (isLastModel) {
          if (isControllerOpen(controller)) {
            controller.enqueue({ type: "error", runId, from: "AGENT", payload: { error: error87 } });
          }
          runState2.setState({ hasErrored: true, stepResult: { isContinued: false, reason: "error" } });
        } else {
          throw error87;
        }
      }
      return { outputStream: outputStream2, callBail: false, runState: runState2 };
    });
    if (callBail) {
      const usage2 = outputStream._getImmediateUsage();
      const responseMetadata2 = runState.state.responseMetadata;
      const text22 = outputStream._getImmediateText();
      return bail({ messageId, stepResult: { reason: "abort", warnings, isContinued: false }, metadata: { providerMetadata: runState.state.providerOptions, ...responseMetadata2, modelMetadata: runState.state.modelMetadata, headers: rawResponse?.headers, request }, output: { text: text22, toolCalls: [], usage: usage2 ?? inputData.output?.usage, steps: [] }, messages: { all: messageList.get.all.aiV5.model(), user: messageList.get.input.aiV5.model(), nonUser: messageList.get.response.aiV5.model() } });
    }
    if (outputStream.tripwire) {
      runState.setState({ stepResult: { isContinued: false, reason: "abort" } });
    }
    const toolCalls = outputStream._getImmediateToolCalls()?.map((chunk) => chunk.payload);
    if (toolCalls.length > 0) {
      const message = { id: messageId, role: "assistant", content: { format: 2, parts: toolCalls.map((toolCall) => {
        return {
          type: "tool-invocation",
          toolInvocation: { state: "call", toolCallId: toolCall.toolCallId, toolName: toolCall.toolName, args: toolCall.args },
          // Only include providerMetadata if it's actually present
          ...toolCall.providerMetadata ? { providerMetadata: toolCall.providerMetadata } : {}
        };
      }) }, createdAt: /* @__PURE__ */ new Date() };
      messageList.add(message, "response");
    }
    const finishReason = runState?.state?.stepResult?.reason ?? outputStream._getImmediateFinishReason();
    const hasErrored = runState.state.hasErrored;
    const usage = outputStream._getImmediateUsage();
    const responseMetadata = runState.state.responseMetadata;
    const text3 = outputStream._getImmediateText();
    const object5 = outputStream._getImmediateObject();
    const tripwireTriggered = outputStream.tripwire;
    const steps = inputData.output?.steps || [];
    const existingResponseCount = inputData.messages?.nonUser?.length || 0;
    const allResponseContent = messageList.get.response.aiV5.modelContent(steps.length);
    const currentIterationContent = allResponseContent.slice(existingResponseCount);
    steps.push(new DefaultStepResult({ warnings: outputStream._getImmediateWarnings(), providerMetadata: runState.state.providerOptions, finishReason: runState.state.stepResult?.reason, content: currentIterationContent, response: { ...responseMetadata, ...rawResponse, messages: messageList.get.response.aiV5.model() }, request, usage: outputStream._getImmediateUsage() }));
    const messages = { all: messageList.get.all.aiV5.model(), user: messageList.get.input.aiV5.model(), nonUser: messageList.get.response.aiV5.model() };
    return { messageId, stepResult: { reason: tripwireTriggered ? "abort" : hasErrored ? "error" : finishReason, warnings, isContinued: tripwireTriggered ? false : !["stop", "error"].includes(finishReason) }, metadata: { providerMetadata: runState.state.providerOptions, ...responseMetadata, ...rawResponse, modelMetadata: runState.state.modelMetadata, headers: rawResponse?.headers, request }, output: { text: text3, toolCalls, usage: usage ?? inputData.output?.usage, steps, ...object5 ? { object: object5 } : {} }, messages };
  }, "execute") });
}
__name(createLLMExecutionStep, "createLLMExecutionStep");
function createLLMMappingStep({ models, telemetry_settings, _internal, modelStreamSpan, ...rest }, llmExecutionStep) {
  return createStep({ id: "llmExecutionMappingStep", inputSchema: zod_default.array(toolCallOutputSchema), outputSchema: llmIterationOutputSchema, execute: /* @__PURE__ */ __name(async ({ inputData, getStepResult: getStepResult3, bail }) => {
    const initialResult = getStepResult3(llmExecutionStep);
    if (inputData?.every((toolCall) => toolCall?.result === void 0)) {
      const errorResults = inputData.filter((toolCall) => toolCall?.error);
      const toolResultMessageId = rest.experimental_generateMessageId?.() || _internal?.generateId?.();
      if (errorResults?.length) {
        errorResults.forEach((toolCall) => {
          const chunk = { type: "tool-error", runId: rest.runId, from: "AGENT", payload: { error: toolCall.error, args: toolCall.args, toolCallId: toolCall.toolCallId, toolName: toolCall.toolName, providerMetadata: toolCall.providerMetadata } };
          rest.controller.enqueue(chunk);
        });
        const msg = { id: toolResultMessageId, role: "assistant", content: { format: 2, parts: errorResults.map((toolCallErrorResult) => {
          return { type: "tool-invocation", toolInvocation: { state: "result", toolCallId: toolCallErrorResult.toolCallId, toolName: toolCallErrorResult.toolName, args: toolCallErrorResult.args, result: toolCallErrorResult.error?.message ?? toolCallErrorResult.error }, ...toolCallErrorResult.providerMetadata ? { providerMetadata: toolCallErrorResult.providerMetadata } : {} };
        }) }, createdAt: /* @__PURE__ */ new Date() };
        rest.messageList.add(msg, "response");
      }
      initialResult.stepResult.isContinued = false;
      return bail(initialResult);
    }
    if (inputData?.length) {
      for (const toolCall of inputData) {
        const chunk = { type: "tool-result", runId: rest.runId, from: "AGENT", payload: { args: toolCall.args, toolCallId: toolCall.toolCallId, toolName: toolCall.toolName, result: toolCall.result, providerMetadata: toolCall.providerMetadata, providerExecuted: toolCall.providerExecuted } };
        rest.controller.enqueue(chunk);
        if (initialResult?.metadata?.modelVersion === "v2") {
          await rest.options?.onChunk?.({ chunk: convertMastraChunkToAISDKv5({ chunk }) });
        }
        const toolResultMessageId = rest.experimental_generateMessageId?.() || _internal?.generateId?.();
        const toolResultMessage = { id: toolResultMessageId, role: "assistant", content: { format: 2, parts: inputData.map((toolCall2) => {
          return { type: "tool-invocation", toolInvocation: { state: "result", toolCallId: toolCall2.toolCallId, toolName: toolCall2.toolName, args: toolCall2.args, result: toolCall2.result }, ...toolCall2.providerMetadata ? { providerMetadata: toolCall2.providerMetadata } : {} };
        }) }, createdAt: /* @__PURE__ */ new Date() };
        rest.messageList.add(toolResultMessage, "response");
      }
      return { ...initialResult, messages: { all: rest.messageList.get.all.aiV5.model(), user: rest.messageList.get.input.aiV5.model(), nonUser: rest.messageList.get.response.aiV5.model() } };
    }
  }, "execute") });
}
__name(createLLMMappingStep, "createLLMMappingStep");
function createToolCallStep({ tools, messageList, options, telemetry_settings, writer, controller, runId, streamState, modelSpanTracker, _internal }) {
  return createStep({ id: "toolCallStep", inputSchema: toolCallInputSchema, outputSchema: toolCallOutputSchema, execute: /* @__PURE__ */ __name(async ({ inputData, suspend, resumeData, runtimeContext }) => {
    const addToolApprovalMetadata = /* @__PURE__ */ __name((toolCallId, toolName, args) => {
      const responseMessages = messageList.get.response.v2();
      const lastAssistantMessage = [...responseMessages].reverse().find((msg) => msg.role === "assistant");
      if (lastAssistantMessage) {
        const content = lastAssistantMessage.content;
        if (!content) return;
        const metadata = typeof lastAssistantMessage.content.metadata === "object" && lastAssistantMessage.content.metadata !== null ? lastAssistantMessage.content.metadata : {};
        metadata.pendingToolApprovals = metadata.pendingToolApprovals || {};
        metadata.pendingToolApprovals[toolCallId] = {
          toolName,
          args,
          type: "approval",
          runId
          // Store the runId so we can resume after page refresh
        };
        lastAssistantMessage.content.metadata = metadata;
      }
    }, "addToolApprovalMetadata");
    const removeToolApprovalMetadata = /* @__PURE__ */ __name(async (toolCallId) => {
      const { saveQueueManager, memoryConfig, threadId } = _internal || {};
      if (!saveQueueManager || !threadId) {
        return;
      }
      const getMetadata = /* @__PURE__ */ __name((message) => {
        const content = message.content;
        if (!content) return void 0;
        const metadata = typeof content.metadata === "object" && content.metadata !== null ? content.metadata : void 0;
        return metadata;
      }, "getMetadata");
      const allMessages = messageList.get.all.v2();
      const lastAssistantMessage = [...allMessages].reverse().find((msg) => {
        const metadata = getMetadata(msg);
        const pendingToolApprovals = metadata?.pendingToolApprovals;
        return !!pendingToolApprovals?.[toolCallId];
      });
      if (lastAssistantMessage) {
        const metadata = getMetadata(lastAssistantMessage);
        const pendingToolApprovals = metadata?.pendingToolApprovals;
        if (pendingToolApprovals && typeof pendingToolApprovals === "object") {
          delete pendingToolApprovals[toolCallId];
          if (metadata && Object.keys(pendingToolApprovals).length === 0) {
            delete metadata.pendingToolApprovals;
          }
          try {
            await saveQueueManager.flushMessages(messageList, threadId, memoryConfig);
          } catch (error87) {
            console.error("Error removing tool approval metadata:", error87);
          }
        }
      }
    }, "removeToolApprovalMetadata");
    const flushMessagesBeforeSuspension = /* @__PURE__ */ __name(async () => {
      const { saveQueueManager, memoryConfig, threadId, resourceId, memory } = _internal || {};
      if (!saveQueueManager || !threadId) {
        return;
      }
      try {
        if (memory && !_internal.threadExists && resourceId) {
          const thread = await memory.getThreadById?.({ threadId });
          if (!thread) {
            await memory.createThread?.({ threadId, resourceId, memoryConfig });
          }
          _internal.threadExists = true;
        }
        await saveQueueManager.flushMessages(messageList, threadId, memoryConfig);
      } catch (error87) {
        console.error("Error flushing messages before suspension:", error87);
      }
    }, "flushMessagesBeforeSuspension");
    if (inputData.providerExecuted) {
      const tracer2 = getTracer2({ isEnabled: telemetry_settings?.isEnabled, tracer: telemetry_settings?.tracer });
      const span2 = tracer2.startSpan("mastra.stream.toolCall").setAttributes({ ...assembleOperationName2({ operationId: "mastra.stream.toolCall", telemetry: telemetry_settings }), "stream.toolCall.toolName": inputData.toolName, "stream.toolCall.toolCallId": inputData.toolCallId, "stream.toolCall.args": JSON.stringify(inputData.args), "stream.toolCall.providerExecuted": true });
      if (inputData.output) {
        span2.setAttributes({ "stream.toolCall.result": JSON.stringify(inputData.output) });
      }
      span2.end();
      return { ...inputData, result: inputData.output };
    }
    const tool5 = tools?.[inputData.toolName] || Object.values(tools || {})?.find((tool22) => `id` in tool22 && tool22.id === inputData.toolName);
    if (!tool5) {
      throw new Error(`Tool ${inputData.toolName} not found`);
    }
    if (tool5 && "onInputAvailable" in tool5) {
      try {
        await tool5?.onInputAvailable?.({ toolCallId: inputData.toolCallId, input: inputData.args, messages: messageList.get.input.aiV5.model(), abortSignal: options?.abortSignal });
      } catch (error87) {
        console.error("Error calling onInputAvailable", error87);
      }
    }
    if (!tool5.execute) {
      return inputData;
    }
    const tracer = getTracer2({ isEnabled: telemetry_settings?.isEnabled, tracer: telemetry_settings?.tracer });
    const span = tracer.startSpan("mastra.stream.toolCall").setAttributes({ ...assembleOperationName2({ operationId: "mastra.stream.toolCall", telemetry: telemetry_settings }), "stream.toolCall.toolName": inputData.toolName, "stream.toolCall.toolCallId": inputData.toolCallId, "stream.toolCall.args": JSON.stringify(inputData.args) });
    try {
      const requireToolApproval = runtimeContext.get("__mastra_requireToolApproval");
      if (requireToolApproval || tool5.requireApproval) {
        if (!resumeData) {
          controller.enqueue({ type: "tool-call-approval", runId, from: "AGENT", payload: { toolCallId: inputData.toolCallId, toolName: inputData.toolName, args: inputData.args } });
          addToolApprovalMetadata(inputData.toolCallId, inputData.toolName, inputData.args);
          await flushMessagesBeforeSuspension();
          return suspend({ requireToolApproval: { toolCallId: inputData.toolCallId, toolName: inputData.toolName, args: inputData.args }, __streamState: streamState.serialize() }, { resumeLabel: inputData.toolCallId });
        } else {
          await removeToolApprovalMetadata(inputData.toolCallId);
          if (!resumeData.approved) {
            span.end();
            span.setAttributes({ "stream.toolCall.result": "Tool call was not approved by the user" });
            return { result: "Tool call was not approved by the user", ...inputData };
          }
        }
      }
      const toolOptions = {
        abortSignal: options?.abortSignal,
        toolCallId: inputData.toolCallId,
        messages: messageList.get.input.aiV5.model(),
        writableStream: writer,
        // Pass current step span as parent for tool call spans
        tracingContext: modelSpanTracker?.getTracingContext(),
        suspend: /* @__PURE__ */ __name(async (suspendPayload) => {
          controller.enqueue({ type: "tool-call-suspended", runId, from: "AGENT", payload: { toolCallId: inputData.toolCallId, toolName: inputData.toolName, suspendPayload } });
          await flushMessagesBeforeSuspension();
          return await suspend({ toolCallSuspended: suspendPayload, __streamState: streamState.serialize() }, { resumeLabel: inputData.toolCallId });
        }, "suspend"),
        resumeData
      };
      const result = await tool5.execute(inputData.args, toolOptions);
      span.setAttributes({ "stream.toolCall.result": JSON.stringify(result) });
      span.end();
      return { result, ...inputData };
    } catch (error87) {
      span.setStatus({ code: 2, message: error87?.message ?? error87 });
      span.recordException(error87);
      return { error: error87, ...inputData };
    }
  }, "execute") });
}
__name(createToolCallStep, "createToolCallStep");
function createAgenticExecutionWorkflow({ models, telemetry_settings, _internal, modelStreamSpan, ...rest }) {
  const llmExecutionStep = createLLMExecutionStep({ models, _internal, modelStreamSpan, telemetry_settings, ...rest });
  const toolCallStep = createToolCallStep({ telemetry_settings, _internal, ...rest });
  const llmMappingStep = createLLMMappingStep({ models, telemetry_settings, _internal, modelStreamSpan, ...rest }, llmExecutionStep);
  return createWorkflow({ id: "executionWorkflow", inputSchema: llmIterationOutputSchema, outputSchema: llmIterationOutputSchema, options: { tracingPolicy: {
    // mark all workflow spans related to the
    // VNext execution as internal
    internal: 1
    /* WORKFLOW */
  }, shouldPersistSnapshot: /* @__PURE__ */ __name(({ workflowStatus }) => workflowStatus === "suspended", "shouldPersistSnapshot") } }).then(llmExecutionStep).map(async ({ inputData }) => {
    const typedInputData = inputData;
    const responseMessages = typedInputData.messages.nonUser;
    if (responseMessages && responseMessages.length > 0) {
      rest.messageList.add(responseMessages, "response");
    }
    return typedInputData;
  }, { id: "add-response-to-messagelist" }).map(async ({ inputData }) => {
    const typedInputData = inputData;
    if (modelStreamSpan && telemetry_settings?.recordOutputs !== false && typedInputData.output.toolCalls?.length) {
      modelStreamSpan.setAttribute("stream.response.toolCalls", JSON.stringify(typedInputData.output.toolCalls?.map((toolCall) => {
        return {
          toolCallId: toolCall.toolCallId,
          // @ts-ignore TODO: look into the type here
          args: toolCall.args,
          toolName: toolCall.toolName
        };
      })));
    }
    return typedInputData.output.toolCalls || [];
  }, { id: "map-tool-calls" }).foreach(toolCallStep, { concurrency: 10 }).then(llmMappingStep).commit();
}
__name(createAgenticExecutionWorkflow, "createAgenticExecutionWorkflow");
function createAgenticLoopWorkflow(params) {
  const { models, _internal, messageId, runId, modelStreamSpan, telemetry_settings, toolChoice, messageList, modelSettings, controller, writer, ...rest } = params;
  const accumulatedSteps = [];
  let previousContentLength = 0;
  const agenticExecutionWorkflow = createAgenticExecutionWorkflow({ messageId, models, telemetry_settings, _internal, modelSettings, toolChoice, modelStreamSpan, controller, writer, messageList, runId, ...rest });
  return createWorkflow({ id: "agentic-loop", inputSchema: llmIterationOutputSchema, outputSchema: llmIterationOutputSchema, options: { tracingPolicy: {
    // mark all workflow spans related to the
    // VNext execution as internal
    internal: 1
    /* WORKFLOW */
  }, shouldPersistSnapshot: /* @__PURE__ */ __name((params2) => {
    return params2.workflowStatus === "suspended";
  }, "shouldPersistSnapshot") } }).dowhile(agenticExecutionWorkflow, async ({ inputData }) => {
    const typedInputData = inputData;
    let hasFinishedSteps = false;
    const allContent = typedInputData.messages.nonUser.flatMap((message) => message.content);
    const currentContent = allContent.slice(previousContentLength);
    previousContentLength = allContent.length;
    const currentStep = {
      content: currentContent,
      usage: typedInputData.output.usage || { inputTokens: 0, outputTokens: 0, totalTokens: 0 },
      // we need to cast this because we add 'abort' for tripwires
      finishReason: typedInputData.stepResult?.reason || "unknown",
      warnings: typedInputData.stepResult?.warnings || [],
      request: typedInputData.metadata?.request || {},
      response: { ...typedInputData.metadata, modelId: typedInputData.metadata?.modelId || typedInputData.metadata?.model || "", messages: [] },
      text: typedInputData.output.text || "",
      reasoning: typedInputData.output.reasoning || [],
      reasoningText: typedInputData.output.reasoningText || "",
      files: typedInputData.output.files || [],
      toolCalls: typedInputData.output.toolCalls || [],
      toolResults: typedInputData.output.toolResults || [],
      sources: typedInputData.output.sources || [],
      staticToolCalls: typedInputData.output.staticToolCalls || [],
      dynamicToolCalls: typedInputData.output.dynamicToolCalls || [],
      staticToolResults: typedInputData.output.staticToolResults || [],
      dynamicToolResults: typedInputData.output.dynamicToolResults || [],
      providerMetadata: typedInputData.metadata?.providerMetadata
    };
    accumulatedSteps.push(currentStep);
    if (rest.stopWhen && typedInputData.stepResult?.isContinued && accumulatedSteps.length > 0) {
      const conditions = await Promise.all((Array.isArray(rest.stopWhen) ? rest.stopWhen : [rest.stopWhen]).map((condition) => {
        return condition({ steps: accumulatedSteps });
      }));
      const hasStopped = conditions.some((condition) => condition);
      hasFinishedSteps = hasStopped;
    }
    if (typedInputData.stepResult) {
      typedInputData.stepResult.isContinued = hasFinishedSteps ? false : typedInputData.stepResult.isContinued;
    }
    if (typedInputData.stepResult?.reason !== "abort") {
      if (isControllerOpen(controller)) {
        controller.enqueue({
          type: "step-finish",
          runId,
          from: "AGENT",
          // @ts-ignore TODO: Look into the proper types for this
          payload: typedInputData
        });
      }
    }
    modelStreamSpan.setAttributes({ "stream.response.id": typedInputData.metadata?.id, "stream.response.model": typedInputData.metadata?.modelId, ...typedInputData.metadata?.providerMetadata ? { "stream.response.providerMetadata": JSON.stringify(typedInputData.metadata.providerMetadata) } : {}, "stream.response.finishReason": typedInputData.stepResult?.reason, "stream.usage.inputTokens": typedInputData.output.usage?.inputTokens, "stream.usage.outputTokens": typedInputData.output.usage?.outputTokens, "stream.usage.totalTokens": typedInputData.output.usage?.totalTokens, ...telemetry_settings?.recordOutputs !== false ? { "stream.response.text": typedInputData.output.text, "stream.prompt.messages": JSON.stringify(messageList.get.input.aiV5.model()) } : {} });
    modelStreamSpan.end();
    const reason = typedInputData.stepResult?.reason;
    if (reason === void 0) {
      return false;
    }
    return typedInputData.stepResult?.isContinued ?? false;
  }).commit();
}
__name(createAgenticLoopWorkflow, "createAgenticLoopWorkflow");
function isControllerOpen(controller) {
  return controller.desiredSize !== 0 && controller.desiredSize !== null;
}
__name(isControllerOpen, "isControllerOpen");
function workflowLoopStream({ resumeContext, requireToolApproval, telemetry_settings, models, toolChoice, modelSettings, _internal, modelStreamSpan, messageId, runId, messageList, startTimestamp, streamState, agentId, toolCallId, ...rest }) {
  return new ReadableStream$1({ start: /* @__PURE__ */ __name(async (controller) => {
    const writer = new WritableStream({ write: /* @__PURE__ */ __name((chunk) => {
      controller.enqueue(chunk);
    }, "write") });
    modelStreamSpan.setAttributes({ ...telemetry_settings?.recordInputs !== false ? { "stream.prompt.toolChoice": toolChoice ? JSON.stringify(toolChoice) : "auto" } : {} });
    const agenticLoopWorkflow = createAgenticLoopWorkflow({ resumeContext, messageId, models, telemetry_settings, _internal, modelSettings, toolChoice, modelStreamSpan, controller, writer, runId, messageList, startTimestamp, streamState, agentId, ...rest });
    if (rest.mastra) {
      agenticLoopWorkflow.__registerMastra(rest.mastra);
    }
    const initialData = { messageId, messages: { all: messageList.get.all.aiV5.model(), user: messageList.get.input.aiV5.model(), nonUser: [] }, output: { steps: [], usage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 } }, metadata: {}, stepResult: { reason: "undefined", warnings: [], isContinued: true, totalUsage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 } } };
    const msToFirstChunk = _internal?.now?.() - startTimestamp;
    modelStreamSpan.addEvent("ai.stream.firstChunk", { "ai.response.msToFirstChunk": msToFirstChunk });
    modelStreamSpan.setAttributes({ "stream.response.timestamp": new Date(startTimestamp).toISOString(), "stream.response.msToFirstChunk": msToFirstChunk });
    if (!resumeContext) {
      controller.enqueue({ type: "start", runId, from: "AGENT", payload: { id: agentId } });
    }
    const run = await agenticLoopWorkflow.createRunAsync({ runId });
    const runtimeContext = new RuntimeContext();
    if (requireToolApproval) {
      runtimeContext.set("__mastra_requireToolApproval", true);
    }
    const executionResult = resumeContext ? await run.resume({ resumeData: resumeContext.resumeData, tracingContext: rest.modelSpanTracker?.getTracingContext(), label: toolCallId }) : await run.start({ inputData: initialData, tracingContext: rest.modelSpanTracker?.getTracingContext(), runtimeContext });
    if (executionResult.status !== "success") {
      if (executionResult.status === "failed") {
        let executionResultError = executionResult.error;
        if (typeof executionResult.error === "string") {
          const prependedErrorString = "Error: ";
          if (executionResult.error.startsWith(`${prependedErrorString}${prependedErrorString}`)) {
            executionResultError = executionResult.error.substring(`${prependedErrorString}${prependedErrorString}`.length);
          } else if (executionResult.error.startsWith(prependedErrorString)) {
            executionResultError = executionResult.error.substring(prependedErrorString.length);
          }
        }
        const error87 = getErrorFromUnknown(executionResultError, { fallbackMessage: "Unknown error in agent workflow stream" });
        controller.enqueue({ type: "error", runId, from: "AGENT", payload: { error: error87 } });
        if (rest.options?.onError) {
          await rest.options?.onError?.({ error: error87 });
        }
      }
      controller.close();
      return;
    }
    if (executionResult.result.stepResult?.reason === "abort") {
      controller.close();
      return;
    }
    controller.enqueue({ type: "finish", runId, from: "AGENT", payload: { ...executionResult.result, stepResult: {
      ...executionResult.result.stepResult,
      // @ts-ignore we add 'abort' for tripwires so the type is not compatible
      reason: executionResult.result.stepResult.reason
    } } });
    const msToFinish = (_internal?.now?.() ?? Date.now()) - startTimestamp;
    modelStreamSpan.addEvent("ai.stream.finish");
    modelStreamSpan.setAttributes({ "stream.response.msToFinish": msToFinish, "stream.response.avgOutputTokensPerSecond": 1e3 * (executionResult?.result?.output?.usage?.outputTokens ?? 0) / msToFinish });
    controller.close();
  }, "start") });
}
__name(workflowLoopStream, "workflowLoopStream");
function loop({ resumeContext, models, logger, runId, idGenerator, telemetry_settings, messageList, includeRawChunks, modelSettings, tools, _internal, mode = "stream", outputProcessors, returnScorerData, requireToolApproval, agentId, ...rest }) {
  let loggerToUse = logger || new ConsoleLogger({ level: "debug" });
  if (models.length === 0 || !models[0]) {
    const mastraError = new MastraError({
      id: "LOOP_MODELS_EMPTY",
      domain: "LLM",
      category: "USER"
      /* USER */
    });
    loggerToUse.trackException(mastraError);
    loggerToUse.error(mastraError.toString());
    throw mastraError;
  }
  const firstModel = models[0];
  let runIdToUse = runId;
  if (!runIdToUse) {
    runIdToUse = idGenerator?.() || crypto.randomUUID();
  }
  const internalToUse = { now: _internal?.now || (() => Date.now()), generateId: _internal?.generateId || (() => generateId()), currentDate: _internal?.currentDate || (() => /* @__PURE__ */ new Date()), saveQueueManager: _internal?.saveQueueManager, memoryConfig: _internal?.memoryConfig, threadId: _internal?.threadId, resourceId: _internal?.resourceId, memory: _internal?.memory, threadExists: _internal?.threadExists };
  let startTimestamp = internalToUse.now?.();
  const { rootSpan } = getRootSpan({ operationId: mode === "stream" ? `mastra.stream` : `mastra.generate`, model: { modelId: firstModel.model.modelId, provider: firstModel.model.provider }, modelSettings, headers: modelSettings?.headers ?? rest.headers, telemetry_settings });
  rootSpan.setAttributes({ ...telemetry_settings?.recordOutputs !== false ? { "stream.prompt.messages": JSON.stringify(messageList.get.input.aiV5.model()) } : {} });
  const { rootSpan: modelStreamSpan } = getRootSpan({ operationId: `mastra.${mode}.aisdk.doStream`, model: { modelId: firstModel.model.modelId, provider: firstModel.model.provider }, modelSettings, headers: modelSettings?.headers ?? rest.headers, telemetry_settings });
  const messageId = rest.experimental_generateMessageId?.() || internalToUse.generateId?.();
  let modelOutput;
  const serializeStreamState = /* @__PURE__ */ __name(() => {
    return modelOutput?.serializeState();
  }, "serializeStreamState");
  const deserializeStreamState = /* @__PURE__ */ __name((state) => {
    modelOutput?.deserializeState(state);
  }, "deserializeStreamState");
  const processorStates = outputProcessors && outputProcessors.length > 0 ? /* @__PURE__ */ new Map() : void 0;
  const workflowLoopProps = { resumeContext, models, runId: runIdToUse, logger: loggerToUse, startTimestamp, messageList, includeRawChunks: !!includeRawChunks, _internal: internalToUse, tools, modelStreamSpan, telemetry_settings, modelSettings, outputProcessors, messageId, agentId, requireToolApproval, streamState: { serialize: serializeStreamState, deserialize: deserializeStreamState }, processorStates, ...rest };
  const existingSnapshot = resumeContext?.snapshot;
  let initialStreamState;
  if (existingSnapshot) {
    for (const key in existingSnapshot?.context) {
      const step = existingSnapshot?.context[key];
      if (step && step.status === "suspended" && step.suspendPayload?.__streamState) {
        initialStreamState = step.suspendPayload?.__streamState;
        break;
      }
    }
  }
  const baseStream = workflowLoopStream(workflowLoopProps);
  const stream = rest.modelSpanTracker?.wrapStream(baseStream) ?? baseStream;
  modelOutput = new MastraModelOutput({ model: { modelId: firstModel.model.modelId, provider: firstModel.model.provider, version: firstModel.model.specificationVersion }, stream, messageList, messageId, options: { runId: runIdToUse, telemetry_settings, rootSpan, toolCallStreaming: rest.toolCallStreaming, onFinish: rest.options?.onFinish, onStepFinish: rest.options?.onStepFinish, includeRawChunks: !!includeRawChunks, structuredOutput: rest.structuredOutput, outputProcessors, returnScorerData, tracingContext: rest.modelSpanTracker?.getTracingContext() }, initialState: initialStreamState });
  return createDestructurableOutput(modelOutput);
}
__name(loop, "loop");
var MastraLLMVNext = class extends MastraBase {
  static {
    __name(this, "MastraLLMVNext");
  }
  #models;
  #mastra;
  #options;
  #firstModel;
  constructor({ mastra, models, options }) {
    super({ name: "aisdk" });
    this.#options = options;
    if (mastra) {
      this.#mastra = mastra;
      if (mastra.getLogger()) {
        this.__setLogger(this.#mastra.getLogger());
      }
    }
    if (models.length === 0 || !models[0]) {
      const mastraError = new MastraError({
        id: "LLM_LOOP_MODELS_EMPTY",
        domain: "LLM",
        category: "USER"
        /* USER */
      });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    } else {
      this.#models = models;
      this.#firstModel = models[0];
    }
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  __registerMastra(p) {
    this.#mastra = p;
  }
  getProvider() {
    return this.#firstModel.model.provider;
  }
  getModelId() {
    return this.#firstModel.model.modelId;
  }
  getModel() {
    return this.#firstModel.model;
  }
  _applySchemaCompat(schema) {
    const model = this.#firstModel.model;
    const schemaCompatLayers = [];
    if (model) {
      const modelInfo = { modelId: model.modelId, supportsStructuredOutputs: true, provider: model.provider };
      schemaCompatLayers.push(new OpenAIReasoningSchemaCompatLayer(modelInfo), new OpenAISchemaCompatLayer(modelInfo), new GoogleSchemaCompatLayer(modelInfo), new AnthropicSchemaCompatLayer(modelInfo), new DeepSeekSchemaCompatLayer(modelInfo), new MetaSchemaCompatLayer(modelInfo));
    }
    return applyCompatLayer({ schema, compatLayers: schemaCompatLayers, mode: "aiSdkSchema" });
  }
  convertToMessages(messages) {
    if (Array.isArray(messages)) {
      return messages.map((m) => {
        if (typeof m === "string") {
          return { role: "user", content: m };
        }
        return m;
      });
    }
    return [{ role: "user", content: messages }];
  }
  stream({ resumeContext, runId, stopWhen = stepCountIs(5), maxSteps, tools = {}, modelSettings, toolChoice = "auto", telemetry_settings, threadId, resourceId, structuredOutput, options, outputProcessors, returnScorerData, providerOptions, tracingContext, messageList, requireToolApproval, _internal, agentId, toolCallId, methodType, includeRawChunks }) {
    let stopWhenToUse;
    if (maxSteps && typeof maxSteps === "number") {
      stopWhenToUse = stepCountIs(maxSteps);
    } else {
      stopWhenToUse = stopWhen;
    }
    const messages = messageList.get.all.aiV5.model();
    const firstModel = this.#firstModel.model;
    this.logger.debug(`[LLM] - Streaming text`, { runId, threadId, resourceId, messages, tools: Object.keys(tools || {}) });
    const llmAISpan = tracingContext?.currentSpan?.createChildSpan({ name: `llm: '${firstModel.modelId}'`, type: "model_generation", input: { messages: [...messageList.getSystemMessages(), ...messages] }, attributes: { model: firstModel.modelId, provider: firstModel.provider, streaming: true, parameters: modelSettings }, metadata: { runId, threadId, resourceId }, tracingPolicy: this.#options?.tracingPolicy });
    const modelSpanTracker = new ModelSpanTracker(llmAISpan);
    try {
      const loopOptions = { mastra: this.#mastra, resumeContext, runId, toolCallId, messageList, models: this.#models, tools, stopWhen: stopWhenToUse, toolChoice, modelSettings, providerOptions, telemetry_settings: { ...this.experimental_telemetry, ...telemetry_settings }, _internal, structuredOutput, outputProcessors, returnScorerData, modelSpanTracker, requireToolApproval, agentId, methodType, includeRawChunks, options: { ...options, onStepFinish: /* @__PURE__ */ __name(async (props) => {
        try {
          await options?.onStepFinish?.({ ...props, runId });
        } catch (e) {
          const mastraError = new MastraError({ id: "LLM_STREAM_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED", domain: "LLM", category: "USER", details: { modelId: props.model?.modelId, modelProvider: props.model?.provider, runId: runId ?? "unknown", threadId: threadId ?? "unknown", resourceId: resourceId ?? "unknown", finishReason: props?.finishReason, toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "", toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "", usage: props?.usage ? JSON.stringify(props.usage) : "" } }, e);
          modelSpanTracker?.reportGenerationError({ error: mastraError });
          this.logger.trackException(mastraError);
          throw mastraError;
        }
        this.logger.debug("[LLM] - Stream Step Change:", { text: props?.text, toolCalls: props?.toolCalls, toolResults: props?.toolResults, finishReason: props?.finishReason, usage: props?.usage, runId });
        const remainingTokens = parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"] ?? "", 10);
        if (!isNaN(remainingTokens) && remainingTokens > 0 && remainingTokens < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay2(10 * 1e3);
        }
      }, "onStepFinish"), onFinish: /* @__PURE__ */ __name(async (props) => {
        modelSpanTracker?.endGeneration({ output: { files: props?.files, object: props?.object, reasoning: props?.reasoning, reasoningText: props?.reasoningText, sources: props?.sources, text: props?.text, warnings: props?.warnings }, attributes: { finishReason: props?.finishReason, usage: { inputTokens: props?.totalUsage?.inputTokens, outputTokens: props?.totalUsage?.outputTokens, totalTokens: props?.totalUsage?.totalTokens, reasoningTokens: props?.totalUsage?.reasoningTokens, cachedInputTokens: props?.totalUsage?.cachedInputTokens } } });
        try {
          await options?.onFinish?.({ ...props, runId });
        } catch (e) {
          const mastraError = new MastraError({ id: "LLM_STREAM_ON_FINISH_CALLBACK_EXECUTION_FAILED", domain: "LLM", category: "USER", details: { modelId: props.model?.modelId, modelProvider: props.model?.provider, runId: runId ?? "unknown", threadId: threadId ?? "unknown", resourceId: resourceId ?? "unknown", finishReason: props?.finishReason, toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "", toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "", usage: props?.usage ? JSON.stringify(props.usage) : "" } }, e);
          modelSpanTracker?.reportGenerationError({ error: mastraError });
          this.logger.trackException(mastraError);
          throw mastraError;
        }
        this.logger.debug("[LLM] - Stream Finished:", { text: props?.text, toolCalls: props?.toolCalls, toolResults: props?.toolResults, finishReason: props?.finishReason, usage: props?.usage, runId, threadId, resourceId });
      }, "onFinish") } };
      return loop(loopOptions);
    } catch (e) {
      const mastraError = new MastraError({ id: "LLM_STREAM_TEXT_AI_SDK_EXECUTION_FAILED", domain: "LLM", category: "THIRD_PARTY", details: { modelId: firstModel.modelId, modelProvider: firstModel.provider, runId: runId ?? "unknown", threadId: threadId ?? "unknown", resourceId: resourceId ?? "unknown" } }, e);
      modelSpanTracker?.reportGenerationError({ error: mastraError });
      throw mastraError;
    }
  }
};
var MastraAgentNetworkStream = class extends ReadableStream$1 {
  static {
    __name(this, "MastraAgentNetworkStream");
  }
  #usageCount = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };
  #streamPromise;
  #run;
  constructor({ createStream, run }) {
    const deferredPromise = { promise: null, resolve: null, reject: null };
    deferredPromise.promise = new Promise((resolve3, reject) => {
      deferredPromise.resolve = resolve3;
      deferredPromise.reject = reject;
    });
    const updateUsageCount = /* @__PURE__ */ __name((usage) => {
      this.#usageCount.inputTokens += parseInt(usage?.inputTokens?.toString() ?? "0", 10);
      this.#usageCount.outputTokens += parseInt(usage?.outputTokens?.toString() ?? "0", 10);
      this.#usageCount.totalTokens += parseInt(usage?.totalTokens?.toString() ?? "0", 10);
    }, "updateUsageCount");
    super({ start: /* @__PURE__ */ __name(async (controller) => {
      const writer = new WritableStream({ write: /* @__PURE__ */ __name((chunk) => {
        if (chunk.type === "step-output" && chunk.payload?.output?.from === "AGENT" && chunk.payload?.output?.type === "finish" || chunk.type === "step-output" && chunk.payload?.output?.from === "WORKFLOW" && chunk.payload?.output?.type === "finish") {
          const output = chunk.payload?.output;
          if (output && "payload" in output && output.payload) {
            const finishPayload = output.payload;
            if ("usage" in finishPayload && finishPayload.usage) {
              updateUsageCount(finishPayload.usage);
            }
          }
        }
        controller.enqueue(chunk);
      }, "write") });
      const stream = await createStream(writer);
      const getInnerChunk = /* @__PURE__ */ __name((chunk) => {
        if (chunk.type === "workflow-step-output") {
          return getInnerChunk(chunk.payload.output);
        }
        return chunk;
      }, "getInnerChunk");
      for await (const chunk of stream) {
        if (chunk.type === "workflow-step-output") {
          const innerChunk = getInnerChunk(chunk);
          if (innerChunk.type === "routing-agent-end" || innerChunk.type === "agent-execution-end" || innerChunk.type === "workflow-execution-end") {
            if (innerChunk.payload?.usage) {
              updateUsageCount(innerChunk.payload.usage);
            }
          }
          if (innerChunk.type === "network-execution-event-step-finish") {
            const finishPayload = { ...innerChunk.payload, usage: this.#usageCount };
            controller.enqueue({ ...innerChunk, payload: finishPayload });
          } else {
            controller.enqueue(innerChunk);
          }
        }
      }
      controller.close();
      deferredPromise.resolve();
    }, "start") });
    this.#run = run;
    this.#streamPromise = deferredPromise;
  }
  get status() {
    return this.#streamPromise.promise.then(() => this.#run._getExecutionResults()).then((res) => res.status);
  }
  get result() {
    return this.#streamPromise.promise.then(() => this.#run._getExecutionResults());
  }
  get usage() {
    return this.#streamPromise.promise.then(() => this.#usageCount);
  }
};
var PRIMITIVE_TYPES = zod_default.enum(["agent", "workflow", "none", "tool"]);
async function getRoutingAgent({ runtimeContext, agent }) {
  const instructionsToUse = await agent.getInstructions({ runtimeContext });
  const agentsToUse = await agent.listAgents({ runtimeContext });
  const workflowsToUse = await agent.getWorkflows({ runtimeContext });
  const toolsToUse = await agent.getTools({ runtimeContext });
  const model = await agent.getModel({ runtimeContext });
  const memoryToUse = await agent.getMemory({ runtimeContext });
  const agentList = Object.entries(agentsToUse).map(([name51, agent2]) => {
    return ` - **${name51}**: ${agent2.getDescription()}`;
  }).join("\n");
  const workflowList = Object.entries(workflowsToUse).map(([name51, workflow]) => {
    return ` - **${name51}**: ${workflow.description}, input schema: ${JSON.stringify(zodToJsonSchema3(workflow.inputSchema))}`;
  }).join("\n");
  const memoryTools = await memoryToUse?.getTools?.();
  const toolList = Object.entries({ ...toolsToUse, ...memoryTools }).map(([name51, tool5]) => {
    return ` - **${name51}**: ${tool5.description}, input schema: ${JSON.stringify(zodToJsonSchema3(tool5.inputSchema || zod_default.object({})))}`;
  }).join("\n");
  const instructions = `
          You are a router in a network of specialized AI agents. 
          Your job is to decide which agent should handle each step of a task.
          If asking for completion of a task, make sure to follow system instructions closely.

          Every step will result in a prompt message. It will be a JSON object with a "selectionReason" and "finalResult" property. Make your decision based on previous decision history, as well as the overall task criteria. If you already called a primitive, you shouldn't need to call it again, unless you strongly believe it adds something to the task completion criteria. Make sure to call enough primitives to complete the task. 
            
          ## System Instructions
          ${instructionsToUse}
          You can only pick agents and workflows that are available in the lists below. Never call any agents or workflows that are not available in the lists below.
          ## Available Agents in Network
          ${agentList}
          ## Available Workflows in Network (make sure to use inputs corresponding to the input schema when calling a workflow)
          ${workflowList}
          ## Available Tools in Network (make sure to use inputs corresponding to the input schema when calling a tool)
          ${toolList}
          If you have multiple entries that need to be called with a workflow or agent, call them separately with each input.
          When calling a workflow, the prompt should be a JSON value that corresponds to the input schema of the workflow. The JSON value is stringified.
          When calling a tool, the prompt should be a JSON value that corresponds to the input schema of the tool. The JSON value is stringified.
          When calling an agent, the prompt should be a text value, like you would call an LLM in a chat interface.
          Keep in mind that the user only sees the final result of the task. When reviewing completion, you should know that the user will not see the intermediate results.
        `;
  return new Agent({
    name: "routing-agent",
    instructions,
    model,
    memory: memoryToUse,
    // @ts-ignore
    _agentNetworkAppend: true
  });
}
__name(getRoutingAgent, "getRoutingAgent");
function getLastMessage(messages) {
  let message = "";
  if (typeof messages === "string") {
    message = messages;
  } else {
    const lastMessage = Array.isArray(messages) ? messages[messages.length - 1] : messages;
    if (typeof lastMessage === "string") {
      message = lastMessage;
    } else if (lastMessage && `content` in lastMessage && lastMessage?.content) {
      const lastMessageContent = lastMessage.content;
      if (typeof lastMessageContent === "string") {
        message = lastMessageContent;
      } else if (Array.isArray(lastMessageContent)) {
        const lastPart = lastMessageContent[lastMessageContent.length - 1];
        if (lastPart?.type === "text") {
          message = lastPart.text;
        }
      }
    }
  }
  return message;
}
__name(getLastMessage, "getLastMessage");
async function prepareMemoryStep({ threadId, resourceId, messages, routingAgent, runtimeContext, generateId: generateId32, tracingContext, memoryConfig }) {
  const memory = await routingAgent.getMemory({ runtimeContext });
  let thread = await memory?.getThreadById({ threadId });
  if (!thread) {
    thread = await memory?.createThread({ threadId, title: `New Thread ${(/* @__PURE__ */ new Date()).toISOString()}`, resourceId });
  }
  let userMessage;
  const promises = [];
  if (typeof messages === "string") {
    userMessage = messages;
    if (memory) {
      promises.push(memory.saveMessages({ messages: [{ id: generateId32(), type: "text", role: "user", content: { parts: [{ type: "text", text: messages }], format: 2 }, createdAt: /* @__PURE__ */ new Date(), threadId: thread?.id, resourceId: thread?.resourceId }], format: "v2" }));
    }
  } else {
    const messageList = new MessageList({ threadId: thread?.id, resourceId: thread?.resourceId });
    messageList.add(messages, "user");
    const messagesToSave = messageList.get.all.v2();
    if (memory) {
      promises.push(memory.saveMessages({ messages: messagesToSave, format: "v2" }));
    }
    const uiMessages = messageList.get.all.ui();
    const mostRecentUserMessage = routingAgent.getMostRecentUserMessage(uiMessages);
    userMessage = mostRecentUserMessage?.content;
  }
  if (thread?.title?.startsWith("New Thread") && memory) {
    const config4 = memory.getMergedThreadConfig(memoryConfig || {});
    const { shouldGenerate, model: titleModel, instructions: titleInstructions } = routingAgent.resolveTitleGenerationConfig(config4?.threads?.generateTitle);
    if (shouldGenerate && userMessage) {
      promises.push(routingAgent.genTitle(userMessage, runtimeContext, tracingContext || { currentSpan: void 0 }, titleModel, titleInstructions).then((title2) => {
        if (title2) {
          return memory.createThread({ threadId: thread.id, resourceId: thread.resourceId, memoryConfig, title: title2, metadata: thread.metadata });
        }
      }));
    }
  }
  await Promise.all(promises);
  return { thread };
}
__name(prepareMemoryStep, "prepareMemoryStep");
async function createNetworkLoop({ networkName, runtimeContext, runId, agent, generateId: generateId32, routingAgentOptions }) {
  const routingStep = createStep({ id: "routing-agent-step", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string().optional(), iteration: zod_default.number(), threadId: zod_default.string().optional(), threadResourceId: zod_default.string().optional(), isOneOff: zod_default.boolean(), verboseIntrospection: zod_default.boolean() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), selectionReason: zod_default.string(), iteration: zod_default.number() }), execute: /* @__PURE__ */ __name(async ({ inputData, getInitData, writer }) => {
    const initData = await getInitData();
    const completionSchema = zod_default.object({ isComplete: zod_default.boolean(), finalResult: zod_default.string(), completionReason: zod_default.string() });
    const routingAgent = await getRoutingAgent({ runtimeContext, agent });
    let completionResult;
    const iterationCount = (inputData.iteration ?? -1) + 1;
    const stepId = generateId32();
    await writer.write({
      type: "routing-agent-start",
      payload: { networkId: agent.id, agentId: routingAgent.id, runId: stepId, inputData: { ...inputData, iteration: iterationCount } },
      runId,
      from: "NETWORK"
      /* NETWORK */
    });
    if (inputData.primitiveType !== "none" && inputData?.result) {
      const completionPrompt = `
                          The ${inputData.primitiveType} ${inputData.primitiveId} has contributed to the task.
                          This is the result from the agent: ${typeof inputData.result === "object" ? JSON.stringify(inputData.result) : inputData.result}
  
                          You need to evaluate that our task is complete. Pay very close attention to the SYSTEM INSTRUCTIONS for when the task is considered complete. Only return true if the task is complete according to the system instructions. Pay close attention to the finalResult and completionReason.
                          Original task: ${inputData.task}.

                          When generating the final result, make sure to take into account previous decision making history and results of all the previous iterations from conversation history. These are messages whose text is a JSON structure with "isNetwork" true.

                          You must return this JSON shape.
  
                          {
                              "isComplete": boolean,
                              "completionReason": string,
                              "finalResult": string
                          }
                      `;
      const streamOptions = { structuredOutput: { schema: completionSchema }, runtimeContext, maxSteps: 1, memory: { thread: initData?.threadId ?? runId, resource: initData?.threadResourceId ?? networkName, readOnly: true }, ...routingAgentOptions };
      let completionStream = await routingAgent.stream(completionPrompt, streamOptions);
      let currentText = "";
      let currentTextIdx = 0;
      await writer.write({ type: "routing-agent-text-start", payload: { runId: stepId }, from: "NETWORK", runId });
      for await (const chunk of completionStream.objectStream) {
        if (chunk?.finalResult) {
          currentText = chunk.finalResult;
        }
        const currentSlice = currentText.slice(currentTextIdx);
        if (chunk?.isComplete && currentSlice.length) {
          await writer.write({ type: "routing-agent-text-delta", payload: { runId: stepId, text: currentSlice }, from: "NETWORK", runId });
          currentTextIdx = currentText.length;
        }
      }
      if (completionStream.error) {
        console.warn("Error detected in structured output stream. Attempting fallback with JSON prompt injection.");
        currentText = "";
        currentTextIdx = 0;
        completionStream = await routingAgent.stream(completionPrompt, { ...streamOptions, structuredOutput: { ...streamOptions.structuredOutput, jsonPromptInjection: true } });
        for await (const chunk of completionStream.objectStream) {
          if (chunk?.finalResult) {
            currentText = chunk.finalResult;
          }
          const currentSlice = currentText.slice(currentTextIdx);
          if (chunk?.isComplete && currentSlice.length) {
            await writer.write({ type: "routing-agent-text-delta", payload: { runId: stepId, text: currentSlice }, from: "NETWORK", runId });
            currentTextIdx = currentText.length;
          }
        }
      }
      completionResult = await completionStream.getFullOutput();
      if (completionResult?.object?.isComplete) {
        const endPayload2 = { task: inputData.task, primitiveId: "", primitiveType: "none", prompt: "", result: completionResult.object.finalResult, isComplete: true, selectionReason: completionResult.object.completionReason || "", iteration: iterationCount, runId: stepId };
        await writer.write({ type: "routing-agent-end", payload: { ...endPayload2, usage: await completionStream.usage }, from: "NETWORK", runId });
        const memory = await agent.getMemory({ runtimeContext });
        await memory?.saveMessages({ messages: [{ id: generateId32(), type: "text", role: "assistant", content: { parts: [{ type: "text", text: completionResult?.object?.finalResult || "" }], format: 2 }, createdAt: /* @__PURE__ */ new Date(), threadId: initData?.threadId || runId, resourceId: initData?.threadResourceId || networkName }], format: "v2" });
        return endPayload2;
      }
    }
    const prompt = [{ role: "assistant", content: `
                    ${inputData.isOneOff ? "You are executing just one primitive based on the user task. Make sure to pick the primitive that is the best suited to accomplish the whole task. Primitives that execute only part of the task should be avoided." : "You will be calling just *one* primitive at a time to accomplish the user task, every call to you is one decision in the process of accomplishing the user task. Make sure to pick primitives that are the best suited to accomplish the whole task. Completeness is the highest priority."}
  
                    The user has given you the following task: 
                    ${inputData.task}
                    ${completionResult ? `

${completionResult?.object?.finalResult}` : ""}

                    # Rules:

                    ## Agent:
                    - prompt should be a text value, like you would call an LLM in a chat interface.
                    - If you are calling the same agent again, make sure to adjust the prompt to be more specific.

                    ## Workflow/Tool:
                    - prompt should be a JSON value that corresponds to the input schema of the workflow or tool. The JSON value is stringified.
                    - Make sure to use inputs corresponding to the input schema when calling a workflow or tool.

                    DO NOT CALL THE PRIMITIVE YOURSELF. Make sure to not call the same primitive twice, unless you call it with different arguments and believe it adds something to the task completion criteria. Take into account previous decision making history and results in your decision making and final result. These are messages whose text is a JSON structure with "isNetwork" true.
  
                    Please select the most appropriate primitive to handle this task and the prompt to be sent to the primitive. If no primitive is appropriate, return "none" for the primitiveId and "none" for the primitiveType.
                    
                    {
                        "primitiveId": string,
                        "primitiveType": "agent" | "workflow" | "tool",
                        "prompt": string,
                        "selectionReason": string
                    }
  
                    The 'selectionReason' property should explain why you picked the primitive${inputData.verboseIntrospection ? ", as well as why the other primitives were not picked." : "."}
                    ` }];
    const options = { structuredOutput: { schema: zod_default.object({ primitiveId: zod_default.string().describe("The id of the primitive to be called"), primitiveType: PRIMITIVE_TYPES.describe("The type of the primitive to be called"), prompt: zod_default.string().describe("The json string or text value to be sent to the primitive"), selectionReason: zod_default.string().describe("The reason you picked the primitive") }) }, runtimeContext, maxSteps: 1, memory: { thread: initData?.threadId ?? runId, resource: initData?.threadResourceId ?? networkName, readOnly: true }, ...routingAgentOptions };
    const result = await tryGenerateWithJsonFallback(routingAgent, prompt, options);
    const object5 = result.object;
    const endPayload = { task: inputData.task, result: "", primitiveId: object5.primitiveId, primitiveType: object5.primitiveType, prompt: object5.prompt, isComplete: object5.primitiveId === "none" && object5.primitiveType === "none", selectionReason: object5.selectionReason, iteration: iterationCount, runId: stepId };
    await writer.write({ type: "routing-agent-end", payload: { ...endPayload, usage: result.usage }, from: "NETWORK", runId });
    return endPayload;
  }, "execute") });
  const agentStep = createStep({ id: "agent-execution-step", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), selectionReason: zod_default.string(), iteration: zod_default.number() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string(), isComplete: zod_default.boolean().optional(), iteration: zod_default.number() }), execute: /* @__PURE__ */ __name(async ({ inputData, writer, getInitData }) => {
    const agentsMap = await agent.listAgents({ runtimeContext });
    const agentForStep = agentsMap[inputData.primitiveId];
    if (!agentForStep) {
      const mastraError = new MastraError({ id: "AGENT_NETWORK_AGENT_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Agent ${inputData.primitiveId} not found` });
      throw mastraError;
    }
    const agentId = agentForStep.id;
    const stepId = generateId32();
    await writer.write({ type: "agent-execution-start", payload: { agentId, args: inputData, runId: stepId }, from: "NETWORK", runId });
    const result = await agentForStep.stream(inputData.prompt, {
      // resourceId: inputData.resourceId,
      // threadId: inputData.threadId,
      runtimeContext,
      runId
    });
    for await (const chunk of result.fullStream) {
      await writer.write({ type: `agent-execution-event-${chunk.type}`, payload: { ...chunk, runId: stepId }, from: "NETWORK", runId });
    }
    const memory = await agent.getMemory({ runtimeContext });
    const initData = await getInitData();
    const messages = result.messageList.get.all.v1();
    await memory?.saveMessages({ messages: [{ id: generateId32(), type: "text", role: "assistant", content: { parts: [{ type: "text", text: JSON.stringify({ isNetwork: true, selectionReason: inputData.selectionReason, primitiveType: inputData.primitiveType, primitiveId: inputData.primitiveId, input: inputData.prompt, finalResult: { text: await result.text, toolCalls: await result.toolCalls, messages } }) }], format: 2 }, createdAt: /* @__PURE__ */ new Date(), threadId: initData?.threadId || runId, resourceId: initData?.threadResourceId || networkName }], format: "v2" });
    const endPayload = { task: inputData.task, agentId, result: await result.text, isComplete: false, iteration: inputData.iteration, runId: stepId };
    await writer.write({ type: "agent-execution-end", payload: { ...endPayload, usage: await result.usage }, from: "NETWORK", runId });
    return { task: inputData.task, primitiveId: inputData.primitiveId, primitiveType: inputData.primitiveType, result: await result.text, isComplete: false, iteration: inputData.iteration };
  }, "execute") });
  const workflowStep = createStep({ id: "workflow-execution-step", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), selectionReason: zod_default.string(), iteration: zod_default.number() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string(), isComplete: zod_default.boolean().optional(), iteration: zod_default.number() }), execute: /* @__PURE__ */ __name(async ({ inputData, writer, getInitData }) => {
    const workflowsMap = await agent.getWorkflows({ runtimeContext });
    const workflowId = inputData.primitiveId;
    const wf = workflowsMap[workflowId];
    if (!wf) {
      const mastraError = new MastraError({ id: "AGENT_NETWORK_WORKFLOW_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Workflow ${workflowId} not found` });
      throw mastraError;
    }
    let input;
    try {
      input = JSON.parse(inputData.prompt);
    } catch (e) {
      const mastraError = new MastraError({ id: "WORKFLOW_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Invalid task input: ${inputData.task}` }, e);
      throw mastraError;
    }
    const stepId = generateId32();
    const run = await wf.createRunAsync({ runId });
    const toolData = { workflowId: wf.id, args: inputData, runId: stepId };
    await writer?.write({ type: "workflow-execution-start", payload: toolData, from: "NETWORK", runId });
    const stream = run.streamVNext({ inputData: input, runtimeContext });
    let chunks = [];
    for await (const chunk of stream.fullStream) {
      chunks.push(chunk);
      await writer?.write({ type: `workflow-execution-event-${chunk.type}`, payload: { ...chunk, runId: stepId }, from: "NETWORK", runId });
    }
    let runSuccess = true;
    const workflowState = await stream.result;
    if (!workflowState?.status || workflowState?.status === "failed") {
      runSuccess = false;
    }
    const finalResult = JSON.stringify({ isNetwork: true, primitiveType: inputData.primitiveType, primitiveId: inputData.primitiveId, selectionReason: inputData.selectionReason, input, finalResult: { runId: run.runId, runResult: workflowState, chunks, runSuccess } });
    const memory = await agent.getMemory({ runtimeContext });
    const initData = await getInitData();
    await memory?.saveMessages({ messages: [{ id: generateId32(), type: "text", role: "assistant", content: { parts: [{ type: "text", text: finalResult }], format: 2 }, createdAt: /* @__PURE__ */ new Date(), threadId: initData?.threadId || runId, resourceId: initData?.threadResourceId || networkName }], format: "v2" });
    const endPayload = { task: inputData.task, primitiveId: inputData.primitiveId, primitiveType: inputData.primitiveType, result: finalResult, isComplete: false, iteration: inputData.iteration };
    await writer?.write({ type: "workflow-execution-end", payload: { ...endPayload, result: workflowState, name: wf.name, runId: stepId, usage: await stream.usage }, from: "NETWORK", runId });
    return endPayload;
  }, "execute") });
  const toolStep = createStep({ id: "tool-execution-step", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), selectionReason: zod_default.string(), iteration: zod_default.number() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string(), isComplete: zod_default.boolean().optional(), iteration: zod_default.number() }), execute: /* @__PURE__ */ __name(async ({ inputData, getInitData, writer }) => {
    const initData = await getInitData();
    const agentTools = await agent.getTools({ runtimeContext });
    const memory = await agent.getMemory({ runtimeContext });
    const memoryTools = await memory?.getTools?.();
    const toolsMap = { ...agentTools, ...memoryTools };
    let tool5 = toolsMap[inputData.primitiveId];
    if (!tool5) {
      const mastraError = new MastraError({ id: "AGENT_NETWORK_TOOL_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Tool ${inputData.primitiveId} not found` });
      throw mastraError;
    }
    if (!tool5.execute) {
      const mastraError = new MastraError({ id: "AGENT_NETWORK_TOOL_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Tool ${inputData.primitiveId} does not have an execute function` });
      throw mastraError;
    }
    const toolId = tool5.id;
    let inputDataToUse;
    try {
      inputDataToUse = JSON.parse(inputData.prompt);
    } catch (e) {
      const mastraError = new MastraError({ id: "AGENT_NETWORK_TOOL_EXECUTION_STEP_INVALID_TASK_INPUT", domain: "AGENT_NETWORK", category: "USER", text: `Invalid task input: ${inputData.task}` }, e);
      throw mastraError;
    }
    const toolCallId = generateId32();
    await writer?.write({ type: "tool-execution-start", payload: { args: { ...inputData, args: inputDataToUse, toolName: toolId, toolCallId }, runId }, from: "NETWORK", runId });
    const finalResult = await tool5.execute({
      runtimeContext,
      mastra: agent.getMastraInstance(),
      resourceId: initData.threadResourceId || networkName,
      threadId: initData.threadId,
      runId,
      memory,
      context: inputDataToUse,
      // TODO: Pass proper tracing context when network supports tracing
      tracingContext: { currentSpan: void 0 },
      writer
    }, { toolCallId, messages: [] });
    await memory?.saveMessages({ messages: [{ id: generateId32(), type: "text", role: "assistant", content: { parts: [{ type: "text", text: JSON.stringify({ isNetwork: true, selectionReason: inputData.selectionReason, primitiveType: inputData.primitiveType, primitiveId: toolId, finalResult: { result: finalResult, toolCallId }, input: inputDataToUse }) }], format: 2 }, createdAt: /* @__PURE__ */ new Date(), threadId: initData.threadId || runId, resourceId: initData.threadResourceId || networkName }], format: "v2" });
    const endPayload = { task: inputData.task, primitiveId: toolId, primitiveType: inputData.primitiveType, result: finalResult, isComplete: false, iteration: inputData.iteration, toolCallId, toolName: toolId };
    await writer?.write({ type: "tool-execution-end", payload: endPayload, from: "NETWORK", runId });
    return endPayload;
  }, "execute") });
  const finishStep = createStep({ id: "finish-step", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), selectionReason: zod_default.string(), iteration: zod_default.number() }), outputSchema: zod_default.object({ task: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean(), iteration: zod_default.number() }), execute: /* @__PURE__ */ __name(async ({ inputData, writer }) => {
    let endResult = inputData.result;
    if (inputData.primitiveId === "none" && inputData.primitiveType === "none" && !inputData.result) {
      endResult = inputData.selectionReason;
    }
    const endPayload = { task: inputData.task, result: endResult, isComplete: !!inputData.isComplete, iteration: inputData.iteration, runId };
    await writer?.write({ type: "network-execution-event-step-finish", payload: endPayload, from: "NETWORK", runId });
    return endPayload;
  }, "execute") });
  const networkWorkflow = createWorkflow({ id: "Agent-Network-Outer-Workflow", inputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string().optional(), iteration: zod_default.number(), threadId: zod_default.string().optional(), threadResourceId: zod_default.string().optional(), isOneOff: zod_default.boolean(), verboseIntrospection: zod_default.boolean() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), completionReason: zod_default.string().optional(), iteration: zod_default.number(), threadId: zod_default.string().optional(), threadResourceId: zod_default.string().optional(), isOneOff: zod_default.boolean() }), options: { shouldPersistSnapshot: /* @__PURE__ */ __name(({ workflowStatus }) => workflowStatus === "suspended", "shouldPersistSnapshot") } });
  networkWorkflow.then(routingStep).branch([[async ({ inputData }) => !inputData.isComplete && inputData.primitiveType === "agent", agentStep], [async ({ inputData }) => !inputData.isComplete && inputData.primitiveType === "workflow", workflowStep], [async ({ inputData }) => !inputData.isComplete && inputData.primitiveType === "tool", toolStep], [async ({ inputData }) => !!inputData.isComplete, finishStep]]).map({ task: { step: [routingStep, agentStep, workflowStep, toolStep], path: "task" }, isComplete: { step: [agentStep, workflowStep, toolStep, finishStep], path: "isComplete" }, completionReason: { step: [routingStep, agentStep, workflowStep, toolStep, finishStep], path: "completionReason" }, result: { step: [agentStep, workflowStep, toolStep, finishStep], path: "result" }, primitiveId: { step: [routingStep, agentStep, workflowStep, toolStep], path: "primitiveId" }, primitiveType: { step: [routingStep, agentStep, workflowStep, toolStep], path: "primitiveType" }, iteration: { step: [routingStep, agentStep, workflowStep, toolStep], path: "iteration" }, isOneOff: { initData: networkWorkflow, path: "isOneOff" }, threadId: { initData: networkWorkflow, path: "threadId" }, threadResourceId: { initData: networkWorkflow, path: "threadResourceId" } }).commit();
  return { networkWorkflow };
}
__name(createNetworkLoop, "createNetworkLoop");
async function networkLoop({ networkName, runtimeContext, runId, routingAgent, routingAgentOptions, generateId: generateId32, maxIterations, threadId, resourceId, messages }) {
  const memoryToUse = await routingAgent.getMemory({ runtimeContext });
  if (!memoryToUse) {
    throw new MastraError({ id: "AGENT_NETWORK_MEMORY_REQUIRED", domain: "AGENT_NETWORK", category: "USER", text: "Memory is required for the agent network to function properly. Please configure memory for the agent.", details: { status: 400 } });
  }
  const { memory: routingAgentMemoryOptions, ...routingAgentOptionsWithoutMemory } = routingAgentOptions || {};
  const { networkWorkflow } = await createNetworkLoop({ networkName, runtimeContext, runId, agent: routingAgent, routingAgentOptions: routingAgentOptionsWithoutMemory, generateId: generateId32 });
  const finalStep = createStep({ id: "final-step", inputSchema: networkWorkflow.outputSchema, outputSchema: networkWorkflow.outputSchema, execute: /* @__PURE__ */ __name(async ({ inputData, writer }) => {
    if (inputData.iteration >= maxIterations) {
      await writer?.write({ type: "network-execution-event-finish", payload: { ...inputData, completionReason: `Max iterations reached: ${maxIterations}` }, from: "NETWORK", runId });
      return { ...inputData, completionReason: `Max iterations reached: ${maxIterations}` };
    }
    return inputData;
  }, "execute") });
  const mainWorkflow = createWorkflow({ id: "agent-loop-main-workflow", inputSchema: zod_default.object({ iteration: zod_default.number(), task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, result: zod_default.string().optional(), threadId: zod_default.string().optional(), threadResourceId: zod_default.string().optional(), isOneOff: zod_default.boolean(), verboseIntrospection: zod_default.boolean() }), outputSchema: zod_default.object({ task: zod_default.string(), primitiveId: zod_default.string(), primitiveType: PRIMITIVE_TYPES, prompt: zod_default.string(), result: zod_default.string(), isComplete: zod_default.boolean().optional(), completionReason: zod_default.string().optional(), iteration: zod_default.number() }), options: { shouldPersistSnapshot: /* @__PURE__ */ __name(({ workflowStatus }) => workflowStatus === "suspended", "shouldPersistSnapshot") } }).dountil(networkWorkflow, async ({ inputData }) => {
    return inputData.isComplete || inputData.iteration >= maxIterations;
  }).then(finalStep).commit();
  const run = await mainWorkflow.createRunAsync({ runId });
  const { thread } = await prepareMemoryStep({ runtimeContext, threadId: threadId || run.runId, resourceId: resourceId || networkName, messages, routingAgent, generateId: generateId32, tracingContext: routingAgentOptions?.tracingContext, memoryConfig: routingAgentMemoryOptions?.options });
  const task = getLastMessage(messages);
  return new MastraAgentNetworkStream({ run, createStream: /* @__PURE__ */ __name(() => {
    return run.streamVNext({ inputData: {
      task,
      primitiveId: "",
      primitiveType: "none",
      // Start at -1 so first iteration increments to 0 (not 1)
      iteration: -1,
      threadResourceId: thread?.resourceId,
      threadId: thread?.id,
      isOneOff: false,
      verboseIntrospection: true
    } }).fullStream;
  }, "createStream") });
}
__name(networkLoop, "networkLoop");
var ProcessorState = class {
  static {
    __name(this, "ProcessorState");
  }
  accumulatedText = "";
  customState = {};
  streamParts = [];
  span;
  constructor(options) {
    const { processorName, tracingContext, processorIndex } = options;
    const currentSpan = tracingContext?.currentSpan;
    const parentSpan = currentSpan?.findParent(
      "agent_run"
      /* AGENT_RUN */
    ) || currentSpan?.parent || currentSpan;
    this.span = parentSpan?.createChildSpan({ type: "processor_run", name: `output processor: ${processorName}`, attributes: { processorName, processorType: "output", processorIndex: processorIndex ?? 0 }, input: { streamParts: [], state: {}, totalChunks: 0 } });
  }
  // Internal methods for the runner
  addPart(part) {
    if (part.type === "text-delta") {
      this.accumulatedText += part.payload.text;
    }
    this.streamParts.push(part);
    if (this.span) {
      this.span.input = { streamParts: this.streamParts, state: this.customState, totalChunks: this.streamParts.length, accumulatedText: this.accumulatedText };
    }
  }
};
var ProcessorRunner = class {
  static {
    __name(this, "ProcessorRunner");
  }
  inputProcessors;
  outputProcessors;
  logger;
  agentName;
  constructor({ inputProcessors, outputProcessors, logger, agentName }) {
    this.inputProcessors = inputProcessors ?? [];
    this.outputProcessors = outputProcessors ?? [];
    this.logger = logger;
    this.agentName = agentName;
  }
  async runOutputProcessors(messageList, tracingContext, telemetry) {
    const responseMessages = messageList.clear.response.v2();
    let processableMessages = [...responseMessages];
    const ctx = { abort: /* @__PURE__ */ __name(() => {
      throw new TripWire("Tripwire triggered");
    }, "abort") };
    for (const [index, processor] of this.outputProcessors.entries()) {
      const abort2 = /* @__PURE__ */ __name((reason) => {
        throw new TripWire(reason || `Tripwire triggered by ${processor.name}`);
      }, "abort");
      ctx.abort = abort2;
      const processMethod = processor.processOutputResult?.bind(processor);
      if (!processMethod) {
        continue;
      }
      const currentSpan = tracingContext?.currentSpan;
      const parentSpan = currentSpan?.findParent(
        "agent_run"
        /* AGENT_RUN */
      ) || currentSpan?.parent || currentSpan;
      const processorSpan = parentSpan?.createChildSpan({ type: "processor_run", name: `output processor: ${processor.name}`, attributes: { processorName: processor.name, processorType: "output", processorIndex: index }, input: processableMessages });
      if (!telemetry) {
        processableMessages = await processMethod({ messages: processableMessages, abort: ctx.abort, tracingContext: { currentSpan: processorSpan } });
      } else {
        await telemetry.traceMethod(async () => {
          processableMessages = await processMethod({ messages: processableMessages, abort: ctx.abort, tracingContext: { currentSpan: processorSpan } });
          return processableMessages;
        }, { spanName: `agent.outputProcessor.${processor.name}`, attributes: { "processor.name": processor.name, "processor.index": index.toString(), "processor.total": this.outputProcessors.length.toString() } })();
      }
      processorSpan?.end({ output: processableMessages });
    }
    if (processableMessages.length > 0) {
      messageList.add(processableMessages, "response");
    }
    return messageList;
  }
  /**
  * Process a stream part through all output processors with state management
  */
  async processPart(part, processorStates, tracingContext) {
    if (!this.outputProcessors.length) {
      return { part, blocked: false };
    }
    try {
      let processedPart = part;
      const isFinishChunk = part.type === "finish";
      for (const [index, processor] of this.outputProcessors.entries()) {
        try {
          if (processor.processOutputStream && processedPart) {
            let state = processorStates.get(processor.name);
            if (!state) {
              state = new ProcessorState({ processorName: processor.name, tracingContext, processorIndex: index });
              processorStates.set(processor.name, state);
            }
            state.addPart(processedPart);
            const result = await processor.processOutputStream({ part: processedPart, streamParts: state.streamParts, state: state.customState, abort: /* @__PURE__ */ __name((reason) => {
              throw new TripWire(reason || `Stream part blocked by ${processor.name}`);
            }, "abort"), tracingContext: { currentSpan: state.span } });
            if (state.span && !state.span.isEvent) {
              state.span.output = result;
            }
            processedPart = result;
          }
        } catch (error87) {
          if (error87 instanceof TripWire) {
            const state2 = processorStates.get(processor.name);
            state2?.span?.end({ metadata: { blocked: true, reason: error87.message } });
            return { part: null, blocked: true, reason: error87.message };
          }
          const state = processorStates.get(processor.name);
          state?.span?.error({ error: error87, endSpan: true });
          this.logger.error(`[Agent:${this.agentName}] - Output processor ${processor.name} failed:`, error87);
        }
      }
      if (isFinishChunk) {
        for (const state of processorStates.values()) {
          if (state.span) {
            const finalOutput = { ...state.span.output, totalChunks: state.streamParts.length, finalState: state.customState };
            state.span.end({ output: finalOutput });
          }
        }
      }
      return { part: processedPart, blocked: false };
    } catch (error87) {
      this.logger.error(`[Agent:${this.agentName}] - Stream part processing failed:`, error87);
      for (const state of processorStates.values()) {
        state.span?.error({ error: error87, endSpan: true });
      }
      return { part, blocked: false };
    }
  }
  async runOutputProcessorsForStream(streamResult, tracingContext) {
    return new ReadableStream({ start: /* @__PURE__ */ __name(async (controller) => {
      const reader = streamResult.fullStream.getReader();
      const processorStates = /* @__PURE__ */ new Map();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            break;
          }
          const { part: processedPart, blocked, reason } = await this.processPart(value, processorStates, tracingContext);
          if (blocked) {
            void this.logger.debug(`[Agent:${this.agentName}] - Stream part blocked by output processor`, { reason, originalPart: value });
            controller.enqueue({ type: "tripwire", tripwireReason: reason || "Output processor blocked content" });
            controller.close();
            break;
          } else if (processedPart !== null) {
            controller.enqueue(processedPart);
          }
        }
      } catch (error87) {
        controller.error(error87);
      }
    }, "start") });
  }
  async runInputProcessors(messageList, tracingContext, telemetry) {
    const userMessages = messageList.clear.input.v2();
    let processableMessages = [...userMessages];
    const ctx = { abort: /* @__PURE__ */ __name(() => {
      throw new TripWire("Tripwire triggered");
    }, "abort") };
    for (const [index, processor] of this.inputProcessors.entries()) {
      const abort2 = /* @__PURE__ */ __name((reason) => {
        throw new TripWire(reason || `Tripwire triggered by ${processor.name}`);
      }, "abort");
      ctx.abort = abort2;
      const processMethod = processor.processInput?.bind(processor);
      if (!processMethod) {
        continue;
      }
      const currentSpan = tracingContext?.currentSpan;
      const parentSpan = currentSpan?.findParent(
        "agent_run"
        /* AGENT_RUN */
      ) || currentSpan?.parent || currentSpan;
      const processorSpan = parentSpan?.createChildSpan({ type: "processor_run", name: `input processor: ${processor.name}`, attributes: { processorName: processor.name, processorType: "input", processorIndex: index }, input: processableMessages });
      if (!telemetry) {
        processableMessages = await processMethod({ messages: processableMessages, abort: ctx.abort, tracingContext: { currentSpan: processorSpan } });
      } else {
        await telemetry.traceMethod(async () => {
          processableMessages = await processMethod({ messages: processableMessages, abort: ctx.abort, tracingContext: { currentSpan: processorSpan } });
          return processableMessages;
        }, { spanName: `agent.inputProcessor.${processor.name}`, attributes: { "processor.name": processor.name, "processor.index": index.toString(), "processor.total": this.inputProcessors.length.toString() } })();
      }
      processorSpan?.end({ output: processableMessages });
    }
    if (processableMessages.length > 0) {
      const systemMessages = processableMessages.filter((m) => m.role === "system");
      const nonSystemMessages = processableMessages.filter((m) => m.role !== "system");
      for (const sysMsg of systemMessages) {
        messageList.addSystem(sysMsg.content.content || sysMsg.content.parts.map((p) => p.type === "text" ? p.text : "").join("\n"));
      }
      if (nonSystemMessages.length > 0) {
        messageList.add(nonSystemMessages, "input");
      }
    }
    return messageList;
  }
};
var LegacyStep = class {
  static {
    __name(this, "LegacyStep");
  }
  id;
  description;
  inputSchema;
  outputSchema;
  payload;
  execute;
  retryConfig;
  mastra;
  constructor({ id, description, execute: execute2, payload, outputSchema: outputSchema2, inputSchema, retryConfig }) {
    this.id = id;
    this.description = description ?? "";
    this.inputSchema = inputSchema;
    this.payload = payload;
    this.outputSchema = outputSchema2;
    this.execute = execute2;
    this.retryConfig = retryConfig;
  }
};
function agentToStep(agent, { mastra } = {}) {
  return { id: agent.name, inputSchema: external_exports2.object({ prompt: external_exports2.string(), resourceId: external_exports2.string().optional(), threadId: external_exports2.string().optional() }), outputSchema: external_exports2.object({ text: external_exports2.string() }), execute: /* @__PURE__ */ __name(async ({ context: context3, runId, mastra: mastraFromExecute }) => {
    const realMastra = mastraFromExecute ?? mastra;
    if (!realMastra) {
      throw new Error("Mastra instance not found");
    }
    agent.__registerMastra(realMastra);
    agent.__registerPrimitives({ logger: realMastra.getLogger(), telemetry: realMastra.getTelemetry() });
    const result = await agent.generateLegacy(context3.inputData.prompt, { runId, resourceId: context3.inputData.resourceId, threadId: context3.inputData.threadId });
    return { text: result.text };
  }, "execute") };
}
__name(agentToStep, "agentToStep");
var SaveQueueManager = class _SaveQueueManager {
  static {
    __name(this, "_SaveQueueManager");
  }
  logger;
  debounceMs;
  memory;
  static MAX_STALENESS_MS = 1e3;
  constructor({ logger, debounceMs, memory }) {
    this.logger = logger;
    this.debounceMs = debounceMs || 100;
    this.memory = memory;
  }
  saveQueues = /* @__PURE__ */ new Map();
  saveDebounceTimers = /* @__PURE__ */ new Map();
  /**
  * Debounces save operations for a thread, ensuring that consecutive save requests
  * are batched and only the latest is executed after a short delay.
  * @param threadId - The ID of the thread to debounce saves for.
  * @param saveFn - The save function to debounce.
  */
  debounceSave(threadId, messageList, memoryConfig) {
    if (this.saveDebounceTimers.has(threadId)) {
      clearTimeout(this.saveDebounceTimers.get(threadId));
    }
    this.saveDebounceTimers.set(threadId, setTimeout(() => {
      this.enqueueSave(threadId, messageList, memoryConfig).catch((err) => {
        this.logger?.error?.("Error in debounceSave", { err, threadId });
      });
      this.saveDebounceTimers.delete(threadId);
    }, this.debounceMs));
  }
  /**
  * Enqueues a save operation for a thread, ensuring that saves are executed in order and
  * only one save runs at a time per thread. If a save is already in progress for the thread,
  * the new save is queued to run after the previous completes.
  *
  * @param threadId - The ID of the thread whose messages should be saved.
  * @param messageList - The MessageList instance containing unsaved messages.
  * @param memoryConfig - Optional memory configuration to use for saving.
  */
  enqueueSave(threadId, messageList, memoryConfig) {
    const prev = this.saveQueues.get(threadId) || Promise.resolve();
    const next = prev.then(() => this.persistUnsavedMessages(messageList, memoryConfig)).catch((err) => {
      this.logger?.error?.("Error in enqueueSave", { err, threadId });
    }).then(() => {
      if (this.saveQueues.get(threadId) === next) {
        this.saveQueues.delete(threadId);
      }
    });
    this.saveQueues.set(threadId, next);
    return next;
  }
  /**
  * Clears any pending debounced save for a thread, preventing the scheduled save
  * from executing if it hasn't already fired.
  *
  * @param threadId - The ID of the thread whose debounced save should be cleared.
  */
  clearDebounce(threadId) {
    if (this.saveDebounceTimers.has(threadId)) {
      clearTimeout(this.saveDebounceTimers.get(threadId));
      this.saveDebounceTimers.delete(threadId);
    }
  }
  /**
  * Persists any unsaved messages from the MessageList to memory storage.
  * Drains the list of unsaved messages and writes them using the memory backend.
  * @param messageList - The MessageList instance for the current thread.
  * @param memoryConfig - The memory configuration for saving.
  */
  async persistUnsavedMessages(messageList, memoryConfig) {
    const newMessages = messageList.drainUnsavedMessages();
    if (newMessages.length > 0 && this.memory) {
      await this.memory.saveMessages({ messages: newMessages, memoryConfig });
    }
  }
  /**
  * Batches a save of unsaved messages for a thread, using debouncing to batch rapid updates.
  * If the oldest unsaved message is stale (older than MAX_STALENESS_MS), the save is performed immediately.
  * Otherwise, the save is delayed to batch multiple updates and reduce redundant writes.
  *
  * @param messageList - The MessageList instance containing unsaved messages.
  * @param threadId - The ID of the thread whose messages are being saved.
  * @param memoryConfig - Optional memory configuration for saving.
  */
  async batchMessages(messageList, threadId, memoryConfig) {
    if (!threadId) return;
    const earliest = messageList.getEarliestUnsavedMessageTimestamp();
    const now2 = Date.now();
    if (earliest && now2 - earliest > _SaveQueueManager.MAX_STALENESS_MS) {
      return this.flushMessages(messageList, threadId, memoryConfig);
    } else {
      return this.debounceSave(threadId, messageList, memoryConfig);
    }
  }
  /**
  * Forces an immediate save of unsaved messages for a thread, bypassing any debounce delay.
  * This is used when a flush to persistent storage is required (e.g., on shutdown or critical transitions).
  *
  * @param messageList - The MessageList instance containing unsaved messages.
  * @param threadId - The ID of the thread whose messages are being saved.
  * @param memoryConfig - Optional memory configuration for saving.
  */
  async flushMessages(messageList, threadId, memoryConfig) {
    if (!threadId) return;
    this.clearDebounce(threadId);
    return this.enqueueSave(threadId, messageList, memoryConfig);
  }
};
function getModelMethodFromAgentMethod(methodType) {
  if (methodType === "generate" || methodType === "generateLegacy") {
    return "generate";
  } else if (methodType === "stream" || methodType === "streamLegacy") {
    return "stream";
  } else {
    throw new MastraError({
      id: "INVALID_METHOD_TYPE",
      domain: "AGENT",
      category: "USER"
      /* USER */
    });
  }
}
__name(getModelMethodFromAgentMethod, "getModelMethodFromAgentMethod");
var STRUCTURED_OUTPUT_PROCESSOR_NAME = "structured-output";
var StructuredOutputProcessor = class {
  static {
    __name(this, "StructuredOutputProcessor");
  }
  name = STRUCTURED_OUTPUT_PROCESSOR_NAME;
  schema;
  structuringAgent;
  errorStrategy;
  fallbackValue;
  isStructuringAgentStreamStarted = false;
  jsonPromptInjection;
  constructor(options) {
    if (!options.schema) {
      throw new MastraError({ id: "STRUCTURED_OUTPUT_PROCESSOR_SCHEMA_REQUIRED", domain: "AGENT", category: "USER", text: "StructuredOutputProcessor requires a schema to be provided" });
    }
    if (!options.model) {
      throw new MastraError({ id: "STRUCTURED_OUTPUT_PROCESSOR_MODEL_REQUIRED", domain: "AGENT", category: "USER", text: "StructuredOutputProcessor requires a model to be provided either in options or as fallback" });
    }
    this.schema = options.schema;
    this.errorStrategy = options.errorStrategy ?? "strict";
    this.fallbackValue = options.fallbackValue;
    this.jsonPromptInjection = options.jsonPromptInjection;
    this.structuringAgent = new Agent({ name: "structured-output-structurer", instructions: options.instructions || this.generateInstructions(), model: options.model });
  }
  async processOutputStream(args) {
    const { part, state, streamParts, abort: abort2, tracingContext } = args;
    const controller = state.controller;
    switch (part.type) {
      case "finish":
        await this.processAndEmitStructuredOutput(streamParts, controller, abort2, tracingContext);
        return part;
      default:
        return part;
    }
  }
  async processAndEmitStructuredOutput(streamParts, controller, abort2, tracingContext) {
    if (this.isStructuringAgentStreamStarted) return;
    this.isStructuringAgentStreamStarted = true;
    try {
      const structuringPrompt = this.buildStructuringPrompt(streamParts);
      const prompt = `Extract and structure the key information from the following text according to the specified schema. Keep the original meaning and details:

${structuringPrompt}`;
      const structuringAgentStream = await this.structuringAgent.stream(prompt, { structuredOutput: { schema: this.schema, jsonPromptInjection: this.jsonPromptInjection }, tracingContext });
      const excludedChunkTypes = ["start", "finish", "text-start", "text-delta", "text-end", "step-start", "step-finish"];
      for await (const chunk of structuringAgentStream.fullStream) {
        if (excludedChunkTypes.includes(chunk.type) || chunk.type.startsWith("data-")) {
          continue;
        }
        if (chunk.type === "error") {
          this.handleError("Structuring failed", "Internal agent did not generate structured output", abort2);
          if (this.errorStrategy === "warn") {
            break;
          }
          if (this.errorStrategy === "fallback" && this.fallbackValue !== void 0) {
            const fallbackChunk = { runId: chunk.runId, from: "AGENT", type: "object-result", object: this.fallbackValue, metadata: { from: "structured-output", fallback: true } };
            controller.enqueue(fallbackChunk);
            break;
          }
        }
        const newChunk = { ...chunk, metadata: { from: "structured-output" } };
        controller.enqueue(newChunk);
      }
    } catch (error87) {
      this.handleError("Structured output processing failed", error87 instanceof Error ? error87.message : "Unknown error", abort2);
    }
  }
  /**
  * Build a structured markdown prompt from stream parts
  * Collects chunks by type and formats them in a consistent structure
  */
  buildStructuringPrompt(streamParts) {
    const textChunks = [];
    const reasoningChunks = [];
    const toolCalls = [];
    const toolResults = [];
    for (const part of streamParts) {
      switch (part.type) {
        case "text-delta":
          textChunks.push(part.payload.text);
          break;
        case "reasoning-delta":
          reasoningChunks.push(part.payload.text);
          break;
        case "tool-call":
          toolCalls.push(part);
          break;
        case "tool-result":
          toolResults.push(part);
          break;
      }
    }
    const sections = [];
    if (reasoningChunks.length > 0) {
      sections.push(`# Assistant Reasoning
${reasoningChunks.join("")}`);
    }
    if (toolCalls.length > 0) {
      const toolCallsText = toolCalls.map((tc) => {
        const args = typeof tc.payload.args === "object" ? JSON.stringify(tc.payload.args, null) : tc.payload.args;
        const output = tc.payload.output !== void 0 ? `${typeof tc.payload.output === "object" ? JSON.stringify(tc.payload.output, null) : tc.payload.output}` : "";
        return `## ${tc.payload.toolName}
### Input: ${args}
### Output: ${output}`;
      }).join("\n");
      sections.push(`# Tool Calls
${toolCallsText}`);
    }
    if (toolResults.length > 0) {
      const resultsText = toolResults.map((tr) => {
        const result = tr.payload.result;
        if (result === void 0 || result === null) {
          return `${tr.payload.toolName}: null`;
        }
        return `${tr.payload.toolName}: ${typeof result === "object" ? JSON.stringify(result, null, 2) : result}`;
      }).join("\n");
      sections.push(`# Tool Results
${resultsText}`);
    }
    if (textChunks.length > 0) {
      sections.push(`# Assistant Response
${textChunks.join("")}`);
    }
    return sections.join("\n\n");
  }
  /**
  * Generate instructions for the structuring agent based on the schema
  */
  generateInstructions() {
    return `You are a data structuring specialist. Your job is to convert unstructured text into a specific JSON format.

TASK: Convert the provided unstructured text into valid JSON that matches the following schema:

REQUIREMENTS:
- Return ONLY valid JSON, no additional text or explanation
- Extract relevant information from the input text
- If information is missing, use reasonable defaults or null values
- Maintain data types as specified in the schema
- Be consistent and accurate in your conversions

The input text may be in any format (sentences, bullet points, paragraphs, etc.). Extract the relevant data and structure it according to the schema.`;
  }
  /**
  * Handle errors based on the configured strategy
  */
  handleError(context3, error87, abort2) {
    const message = `[StructuredOutputProcessor] ${context3}: ${error87}`;
    switch (this.errorStrategy) {
      case "strict":
        console.error(message);
        abort2(message);
        break;
      case "warn":
        console.warn(message);
        break;
      case "fallback":
        console.info(`${message} (using fallback)`);
        break;
    }
  }
};
function createMapResultsStep({ capabilities, options, resourceId, runId, runtimeContext, memory, memoryConfig, saveQueueManager, agentAISpan, instructions, agentId, methodType }) {
  return async ({ inputData, bail, tracingContext }) => {
    const toolsData = inputData["prepare-tools-step"];
    const memoryData = inputData["prepare-memory-step"];
    const result = { ...options, tools: toolsData.convertedTools, toolChoice: options.toolChoice, thread: memoryData.thread, threadId: memoryData.thread?.id, resourceId, runtimeContext, onStepFinish: /* @__PURE__ */ __name(async (props) => {
      if (options.savePerStep) {
        if (!memoryData.threadExists && memory && memoryData.thread) {
          await memory.createThread({ threadId: memoryData.thread?.id, title: memoryData.thread?.title, metadata: memoryData.thread?.metadata, resourceId: memoryData.thread?.resourceId, memoryConfig });
          memoryData.threadExists = true;
        }
        await capabilities.saveStepMessages({ saveQueueManager, result: props, messageList: memoryData.messageList, threadId: memoryData.thread?.id, memoryConfig, runId });
      }
      return options.onStepFinish?.({ ...props, runId });
    }, "onStepFinish"), ...memoryData.tripwire && { tripwire: memoryData.tripwire, tripwireReason: memoryData.tripwireReason } };
    if (result.tripwire) {
      const agentModel = await capabilities.getModel({ runtimeContext: result.runtimeContext });
      const modelOutput = await getModelOutputForTripwire({ tripwireReason: result.tripwireReason, runId, tracingContext, options, model: agentModel, messageList: memoryData.messageList });
      return bail(modelOutput);
    }
    let effectiveOutputProcessors = options.outputProcessors || (capabilities.outputProcessors ? typeof capabilities.outputProcessors === "function" ? await capabilities.outputProcessors({ runtimeContext: result.runtimeContext }) : capabilities.outputProcessors : []);
    if (options.structuredOutput?.model) {
      const structuredProcessor = new StructuredOutputProcessor(options.structuredOutput);
      effectiveOutputProcessors = effectiveOutputProcessors ? [...effectiveOutputProcessors, structuredProcessor] : [structuredProcessor];
    }
    const messageList = memoryData.messageList;
    const modelMethodType = getModelMethodFromAgentMethod(methodType);
    const loopOptions = { methodType: modelMethodType, agentId, runtimeContext: result.runtimeContext, tracingContext: { currentSpan: agentAISpan }, runId, toolChoice: result.toolChoice, tools: result.tools, resourceId: result.resourceId, threadId: result.threadId, stopWhen: result.stopWhen, maxSteps: result.maxSteps, providerOptions: result.providerOptions, includeRawChunks: options.includeRawChunks, options: { ...options.prepareStep && { prepareStep: options.prepareStep }, onFinish: /* @__PURE__ */ __name(async (payload) => {
      if (payload.finishReason === "error") {
        capabilities.logger.error("Error in agent stream", { error: payload.error, runId });
        return;
      }
      try {
        const outputText = messageList.get.all.core().map((m) => m.content).join("\n");
        await capabilities.executeOnFinish({ result: payload, outputText, instructions, thread: result.thread, threadId: result.threadId, readOnlyMemory: options.memory?.readOnly, resourceId, memoryConfig, runtimeContext, agentAISpan, runId, messageList, threadExists: memoryData.threadExists, structuredOutput: !!options.structuredOutput?.schema, saveQueueManager, overrideScorers: options.scorers });
      } catch (e) {
        capabilities.logger.error("Error saving memory on finish", { error: e, runId });
      }
      await options?.onFinish?.({ ...payload, runId, messages: messageList.get.response.aiV5.model(), usage: payload.usage, totalUsage: payload.totalUsage });
    }, "onFinish"), onStepFinish: result.onStepFinish, onChunk: options.onChunk, onError: options.onError, onAbort: options.onAbort, activeTools: options.activeTools, abortSignal: options.abortSignal }, structuredOutput: options.structuredOutput, outputProcessors: effectiveOutputProcessors, modelSettings: { temperature: 0, ...options.modelSettings || {} }, messageList: memoryData.messageList };
    return loopOptions;
  };
}
__name(createMapResultsStep, "createMapResultsStep");
var import_fast_deep_equal = __toESM2(require_fast_deep_equal(), 1);
var coreToolSchema = external_exports2.object({ id: external_exports2.string().optional(), description: external_exports2.string().optional(), parameters: external_exports2.union([
  external_exports2.record(external_exports2.string(), external_exports2.any()),
  // JSON Schema as object
  external_exports2.any()
  // Zod schema or other schema types - validated at tool execution
]), outputSchema: external_exports2.union([external_exports2.record(external_exports2.string(), external_exports2.any()), external_exports2.any()]).optional(), execute: external_exports2.function(external_exports2.tuple([external_exports2.any(), external_exports2.any()]), external_exports2.promise(external_exports2.any())).optional(), type: external_exports2.union([external_exports2.literal("function"), external_exports2.literal("provider-defined"), external_exports2.undefined()]).optional(), args: external_exports2.record(external_exports2.string(), external_exports2.any()).optional() });
var storageThreadSchema = external_exports2.object({ id: external_exports2.string(), title: external_exports2.string().optional(), resourceId: external_exports2.string(), createdAt: external_exports2.date(), updatedAt: external_exports2.date(), metadata: external_exports2.record(external_exports2.string(), external_exports2.any()).optional() });
var prepareToolsStepOutputSchema = external_exports2.object({ convertedTools: external_exports2.record(external_exports2.string(), coreToolSchema) });
var prepareMemoryStepOutputSchema = external_exports2.object({ threadExists: external_exports2.boolean(), thread: storageThreadSchema.optional(), messageList: external_exports2.instanceof(MessageList), tripwire: external_exports2.boolean().optional(), tripwireReason: external_exports2.string().optional() });
function addSystemMessage(messageList, content, tag) {
  if (!content) return;
  if (Array.isArray(content)) {
    for (const msg of content) {
      messageList.addSystem(msg, tag);
    }
  } else {
    messageList.addSystem(content, tag);
  }
}
__name(addSystemMessage, "addSystemMessage");
function createPrepareMemoryStep({ capabilities, options, threadFromArgs, resourceId, runId, runtimeContext, instructions, memoryConfig, memory }) {
  return createStep({ id: "prepare-memory-step", inputSchema: external_exports2.object({}), outputSchema: prepareMemoryStepOutputSchema, execute: /* @__PURE__ */ __name(async ({ tracingContext }) => {
    const thread = threadFromArgs;
    const messageList = new MessageList({
      threadId: thread?.id,
      resourceId,
      generateMessageId: capabilities.generateMessageId,
      // @ts-ignore Flag for agent network messages
      _agentNetworkAppend: capabilities._agentNetworkAppend
    });
    addSystemMessage(messageList, instructions);
    messageList.add(options.context || [], "context");
    addSystemMessage(messageList, options.system, "user-provided");
    if (!memory || !thread?.id && !resourceId) {
      messageList.add(options.messages, "user");
      const { tripwireTriggered: tripwireTriggered2, tripwireReason: tripwireReason2 } = await capabilities.runInputProcessors({ runtimeContext, tracingContext, messageList, inputProcessorOverrides: options.inputProcessors });
      return { threadExists: false, thread: void 0, messageList, ...tripwireTriggered2 && { tripwire: true, tripwireReason: tripwireReason2 } };
    }
    if (!thread?.id || !resourceId) {
      const mastraError = new MastraError({ id: "AGENT_MEMORY_MISSING_RESOURCE_ID", domain: "AGENT", category: "USER", details: { agentName: capabilities.agentName, threadId: thread?.id || "", resourceId: resourceId || "" }, text: `A resourceId and a threadId must be provided when using Memory. Saw threadId "${thread?.id}" and resourceId "${resourceId}"` });
      capabilities.logger.error(mastraError.toString());
      capabilities.logger.trackException(mastraError);
      throw mastraError;
    }
    const store = memory.constructor.name;
    capabilities.logger.debug(`[Agent:${capabilities.agentName}] - Memory persistence enabled: store=${store}, resourceId=${resourceId}`, { runId, resourceId, threadId: thread?.id, memoryStore: store });
    let threadObject = void 0;
    const existingThread = await memory.getThreadById({ threadId: thread?.id });
    if (existingThread) {
      if (!existingThread.metadata && thread.metadata || thread.metadata && !(0, import_fast_deep_equal.default)(existingThread.metadata, thread.metadata)) {
        threadObject = await memory.saveThread({ thread: { ...existingThread, metadata: thread.metadata }, memoryConfig });
      } else {
        threadObject = existingThread;
      }
    } else {
      threadObject = await memory.createThread({ threadId: thread?.id, metadata: thread.metadata, title: thread.title, memoryConfig, resourceId, saveThread: false });
    }
    const config4 = memory.getMergedThreadConfig(memoryConfig || {});
    const hasResourceScopeSemanticRecall = typeof config4?.semanticRecall === "object" && config4?.semanticRecall?.scope === "resource";
    let [memoryMessages, memorySystemMessage] = await Promise.all([existingThread || hasResourceScopeSemanticRecall ? capabilities.getMemoryMessages({ resourceId, threadId: threadObject.id, vectorMessageSearch: new MessageList().add(options.messages, `user`).getLatestUserContent() || "", memoryConfig, runtimeContext }) : [], memory.getSystemMessage({ threadId: threadObject.id, resourceId, memoryConfig: capabilities._agentNetworkAppend ? { ...memoryConfig, workingMemory: { enabled: false } } : memoryConfig })]);
    capabilities.logger.debug("Fetched messages from memory", { threadId: threadObject.id, runId, fetchedCount: memoryMessages.length });
    const resultsFromOtherThreads = memoryMessages.filter((m) => m.threadId !== threadObject.id);
    if (resultsFromOtherThreads.length && !memorySystemMessage) {
      memorySystemMessage = ``;
    }
    if (resultsFromOtherThreads.length) {
      memorySystemMessage += `
The following messages were remembered from a different conversation:
<remembered_from_other_conversation>
${(() => {
        let result = ``;
        const messages = new MessageList().add(resultsFromOtherThreads, "memory").get.all.v1();
        let lastYmd = null;
        for (const msg of messages) {
          const date9 = msg.createdAt;
          const year = date9.getUTCFullYear();
          const month = date9.toLocaleString("default", { month: "short" });
          const day = date9.getUTCDate();
          const ymd = `${year}, ${month}, ${day}`;
          const utcHour = date9.getUTCHours();
          const utcMinute = date9.getUTCMinutes();
          const hour12 = utcHour % 12 || 12;
          const ampm = utcHour < 12 ? "AM" : "PM";
          const timeofday = `${hour12}:${utcMinute < 10 ? "0" : ""}${utcMinute} ${ampm}`;
          if (!lastYmd || lastYmd !== ymd) {
            result += `
the following messages are from ${ymd}
`;
          }
          result += `Message ${msg.threadId && msg.threadId !== threadObject.id ? "from previous conversation" : ""} at ${timeofday}: ${JSON.stringify(msg)}`;
          lastYmd = ymd;
        }
        return result;
      })()}
<end_remembered_from_other_conversation>`;
    }
    if (memorySystemMessage) {
      messageList.addSystem(memorySystemMessage, "memory");
    }
    messageList.add(memoryMessages.filter((m) => m.threadId === threadObject.id), "memory").add(options.messages, "user");
    const { tripwireTriggered, tripwireReason } = await capabilities.runInputProcessors({ runtimeContext, tracingContext, messageList, inputProcessorOverrides: options.inputProcessors });
    const systemMessages = messageList.getSystemMessages();
    const systemMessage = [...systemMessages, ...messageList.getSystemMessages("memory")]?.map((m) => m.content)?.join(`
`) ?? void 0;
    const processedMemoryMessages = await memory.processMessages({ messages: messageList.get.remembered.v1(), newMessages: messageList.get.input.v1(), systemMessage, memorySystemMessage: memorySystemMessage || void 0 });
    const processedList = new MessageList({
      threadId: threadObject.id,
      resourceId,
      generateMessageId: capabilities.generateMessageId,
      // @ts-ignore Flag for agent network messages
      _agentNetworkAppend: capabilities._agentNetworkAppend
    });
    addSystemMessage(processedList, instructions);
    processedList.addSystem(memorySystemMessage).addSystem(systemMessages).add(options.context || [], "context");
    addSystemMessage(processedList, options.system, "user-provided");
    processedList.add(processedMemoryMessages, "memory").add(messageList.get.input.v2(), "user");
    return { thread: threadObject, messageList: processedList, ...tripwireTriggered && { tripwire: true, tripwireReason }, threadExists: !!existingThread };
  }, "execute") });
}
__name(createPrepareMemoryStep, "createPrepareMemoryStep");
function createPrepareToolsStep({ capabilities, options, threadFromArgs, resourceId, runId, runtimeContext, agentAISpan, methodType, memory }) {
  return createStep({ id: "prepare-tools-step", inputSchema: external_exports2.object({}), outputSchema: prepareToolsStepOutputSchema, execute: /* @__PURE__ */ __name(async () => {
    const toolEnhancements = [options?.toolsets && Object.keys(options?.toolsets || {}).length > 0 ? `toolsets present (${Object.keys(options?.toolsets || {}).length} tools)` : void 0, memory && resourceId ? "memory and resourceId available" : void 0].filter(Boolean).join(", ");
    capabilities.logger.debug(`[Agent:${capabilities.agentName}] - Enhancing tools: ${toolEnhancements}`, { runId, toolsets: options?.toolsets ? Object.keys(options?.toolsets) : void 0, clientTools: options?.clientTools ? Object.keys(options?.clientTools) : void 0, hasMemory: !!memory, hasResourceId: !!resourceId });
    const threadId = threadFromArgs?.id;
    const convertedTools = await capabilities.convertTools({ toolsets: options?.toolsets, clientTools: options?.clientTools, threadId, resourceId, runId, runtimeContext, tracingContext: { currentSpan: agentAISpan }, writableStream: options.writableStream, methodType });
    return { convertedTools };
  }, "execute") });
}
__name(createPrepareToolsStep, "createPrepareToolsStep");
function createStreamStep({ capabilities, runId, returnScorerData, format = "mastra", requireToolApproval, resumeContext, agentId, toolCallId, methodType, saveQueueManager, memoryConfig, memory, resourceId }) {
  return createStep({
    id: "stream-text-step",
    inputSchema: external_exports2.any(),
    // tried to type this in various ways but it's too complex
    outputSchema: external_exports2.union([external_exports2.instanceof(MastraModelOutput), external_exports2.instanceof(AISDKV5OutputStream)]),
    execute: /* @__PURE__ */ __name(async ({ inputData, tracingContext }) => {
      const validatedInputData = inputData;
      capabilities.logger.debug(`Starting agent ${capabilities.agentName} llm stream call`, { runId });
      const processors = validatedInputData.outputProcessors || (capabilities.outputProcessors ? typeof capabilities.outputProcessors === "function" ? await capabilities.outputProcessors({ runtimeContext: validatedInputData.runtimeContext || new RuntimeContext() }) : capabilities.outputProcessors : []);
      const modelMethodType = getModelMethodFromAgentMethod(methodType);
      const streamResult = capabilities.llm.stream({ ...validatedInputData, outputProcessors: processors, returnScorerData, tracingContext, requireToolApproval, resumeContext, _internal: { generateId: capabilities.generateMessageId, saveQueueManager, memoryConfig, threadId: validatedInputData.threadId, resourceId, memory }, agentId, toolCallId, methodType: modelMethodType });
      if (format === "aisdk") {
        return streamResult.aisdk.v5;
      }
      return streamResult;
    }, "execute")
  });
}
__name(createStreamStep, "createStreamStep");
function createPrepareStreamWorkflow({ capabilities, options, threadFromArgs, resourceId, runId, runtimeContext, agentAISpan, methodType, format, instructions, memoryConfig, memory, saveQueueManager, returnScorerData, requireToolApproval, resumeContext, agentId, toolCallId }) {
  const prepareToolsStep = createPrepareToolsStep({ capabilities, options, threadFromArgs, resourceId, runId, runtimeContext, agentAISpan, methodType, memory });
  const prepareMemoryStep2 = createPrepareMemoryStep({ capabilities, options, threadFromArgs, resourceId, runId, runtimeContext, instructions, memoryConfig, memory });
  const streamStep = createStreamStep({ capabilities, runId, returnScorerData, format, requireToolApproval, resumeContext, agentId, toolCallId, methodType, saveQueueManager, memoryConfig, memory, resourceId });
  const mapResultsStep = createMapResultsStep({ capabilities, options, resourceId, runId, runtimeContext, memory, memoryConfig, saveQueueManager, agentAISpan, instructions, agentId, methodType });
  return createWorkflow({ id: "execution-workflow", inputSchema: external_exports2.object({}), outputSchema: external_exports2.union([external_exports2.instanceof(MastraModelOutput), external_exports2.instanceof(AISDKV5OutputStream)]), steps: [prepareToolsStep, prepareMemoryStep2, streamStep], options: { tracingPolicy: {
    internal: 1
    /* WORKFLOW */
  } } }).parallel([prepareToolsStep, prepareMemoryStep2]).map(mapResultsStep).then(streamStep).commit();
}
__name(createPrepareStreamWorkflow, "createPrepareStreamWorkflow");
function resolveMaybePromise(value, cb) {
  if (value instanceof Promise || value != null && typeof value.then === "function") {
    return Promise.resolve(value).then(cb);
  }
  return cb(value);
}
__name(resolveMaybePromise, "resolveMaybePromise");
function resolveThreadIdFromArgs(args) {
  if (args?.memory?.thread) {
    if (typeof args.memory.thread === "string") return { id: args.memory.thread };
    if (typeof args.memory.thread === "object" && args.memory.thread.id) return args.memory.thread;
  }
  if (args?.threadId) return { id: args.threadId };
  return void 0;
}
__name(resolveThreadIdFromArgs, "resolveThreadIdFromArgs");
var _Agent_decorators;
var _init2;
var _a60;
_Agent_decorators = [InstrumentClass({ prefix: "agent", excludeMethods: ["hasOwnMemory", "getMemory", "__primitive", "__registerMastra", "__registerPrimitives", "__runInputProcessors", "__runOutputProcessors", "_wrapToolsWithAITracing", "getProcessorRunner", "__setTools", "__setLogger", "__setTelemetry", "log", "listAgents", "getModel", "getInstructions", "getTools", "getLLM", "getWorkflows", "getDefaultGenerateOptions", "getDefaultStreamOptions", "getDescription", "getScorers", "getVoice"] })];
var Agent = class extends (_a60 = MastraBase) {
  static {
    __name(this, "Agent");
  }
  id;
  name;
  #instructions;
  #description;
  model;
  #originalModel;
  maxRetries;
  #mastra;
  #memory;
  #workflows;
  #defaultGenerateOptions;
  #defaultStreamOptions;
  #defaultVNextStreamOptions;
  #tools;
  evals;
  #scorers;
  #agents;
  #voice;
  #inputProcessors;
  #outputProcessors;
  #options;
  // This flag is for agent network messages. We should change the agent network formatting and remove this flag after.
  _agentNetworkAppend = false;
  /**
  * Creates a new Agent instance with the specified configuration.
  *
  * @example
  * ```typescript
  * import { Agent } from '@mastra/core/agent';
  * import { Memory } from '@mastra/memory';
  *
  * const agent = new Agent({
  *   name: 'weatherAgent',
  *   instructions: 'You help users with weather information',
  *   model: 'openai/gpt-5',
  *   tools: { getWeather },
  *   memory: new Memory(),
  *   maxRetries: 2,
  * });
  * ```
  */
  constructor(config4) {
    super({ component: RegisteredLogger.AGENT });
    this.name = config4.name;
    this.id = config4.id ?? config4.name;
    this.#instructions = config4.instructions;
    this.#description = config4.description;
    this.#options = config4.options;
    if (!config4.model) {
      const mastraError = new MastraError({ id: "AGENT_CONSTRUCTOR_MODEL_REQUIRED", domain: "AGENT", category: "USER", details: { agentName: config4.name }, text: `LanguageModel is required to create an Agent. Please provide the 'model'.` });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    if (Array.isArray(config4.model)) {
      if (config4.model.length === 0) {
        const mastraError = new MastraError({ id: "AGENT_CONSTRUCTOR_MODEL_ARRAY_EMPTY", domain: "AGENT", category: "USER", details: { agentName: config4.name }, text: `Model array is empty. Please provide at least one model.` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      this.model = config4.model.map((mdl) => ({ id: randomUUID3(), model: mdl.model, maxRetries: mdl.maxRetries ?? config4?.maxRetries ?? 0, enabled: mdl.enabled ?? true }));
      this.#originalModel = [...this.model];
    } else {
      this.model = config4.model;
      this.#originalModel = config4.model;
    }
    this.maxRetries = config4.maxRetries ?? 0;
    if (config4.workflows) {
      this.#workflows = config4.workflows;
    }
    this.#defaultGenerateOptions = config4.defaultGenerateOptions || {};
    this.#defaultStreamOptions = config4.defaultStreamOptions || {};
    this.#defaultVNextStreamOptions = config4.defaultVNextStreamOptions || {};
    this.#tools = config4.tools || {};
    this.evals = {};
    if (config4.mastra) {
      this.__registerMastra(config4.mastra);
      this.__registerPrimitives({ telemetry: config4.mastra.getTelemetry(), logger: config4.mastra.getLogger() });
    }
    this.#scorers = config4.scorers || {};
    this.#agents = config4.agents || {};
    if (config4.evals) {
      this.evals = config4.evals;
    }
    if (config4.memory) {
      this.#memory = config4.memory;
    }
    if (config4.voice) {
      this.#voice = config4.voice;
      if (typeof config4.tools !== "function") {
        this.#voice?.addTools(this.tools);
      }
      if (typeof config4.instructions === "string") {
        this.#voice?.addInstructions(config4.instructions);
      }
    } else {
      this.#voice = new DefaultVoice();
    }
    if (config4.inputProcessors) {
      this.#inputProcessors = config4.inputProcessors;
    }
    if (config4.outputProcessors) {
      this.#outputProcessors = config4.outputProcessors;
    }
    this._agentNetworkAppend = config4._agentNetworkAppend || false;
  }
  getMastraInstance() {
    return this.#mastra;
  }
  /**
  * Returns the agents configured for this agent, resolving function-based agents if necessary.
  * Used in multi-agent collaboration scenarios where this agent can delegate to other agents.
  *
  * @example
  * ```typescript
  * const agents = await agent.listAgents();
  * console.log(Object.keys(agents)); // ['agent1', 'agent2']
  * ```
  */
  listAgents({ runtimeContext = new RuntimeContext() } = {}) {
    const agentsToUse = this.#agents ? typeof this.#agents === "function" ? this.#agents({ runtimeContext }) : this.#agents : {};
    return resolveMaybePromise(agentsToUse, (agents) => {
      if (!agents) {
        const mastraError = new MastraError({ id: "AGENT_GET_AGENTS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based agents returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return agents;
    });
  }
  /**
  * Creates and returns a ProcessorRunner with resolved input/output processors.
  * @internal
  */
  async getProcessorRunner({ runtimeContext, inputProcessorOverrides, outputProcessorOverrides }) {
    const inputProcessors = inputProcessorOverrides ?? (this.#inputProcessors ? typeof this.#inputProcessors === "function" ? await this.#inputProcessors({ runtimeContext }) : this.#inputProcessors : []);
    const outputProcessors = outputProcessorOverrides ?? (this.#outputProcessors ? typeof this.#outputProcessors === "function" ? await this.#outputProcessors({ runtimeContext }) : this.#outputProcessors : []);
    this.logger.debug("outputProcessors", outputProcessors);
    return new ProcessorRunner({ inputProcessors, outputProcessors, logger: this.logger, agentName: this.name });
  }
  /**
  * Resolves and returns output processors from agent configuration.
  * @internal
  */
  async getResolvedOutputProcessors(runtimeContext) {
    if (!this.#outputProcessors) {
      return [];
    }
    if (typeof this.#outputProcessors === "function") {
      return await this.#outputProcessors({ runtimeContext: runtimeContext || new RuntimeContext() });
    }
    return this.#outputProcessors;
  }
  /**
  * Resolves and returns input processors from agent configuration.
  * @internal
  */
  async getResolvedInputProcessors(runtimeContext) {
    if (!this.#inputProcessors) {
      return [];
    }
    if (typeof this.#inputProcessors === "function") {
      return await this.#inputProcessors({ runtimeContext: runtimeContext || new RuntimeContext() });
    }
    return this.#inputProcessors;
  }
  /**
  * Returns the input processors for this agent, resolving function-based processors if necessary.
  */
  async getInputProcessors(runtimeContext) {
    return this.getResolvedInputProcessors(runtimeContext);
  }
  /**
  * Returns the output processors for this agent, resolving function-based processors if necessary.
  */
  async getOutputProcessors(runtimeContext) {
    return this.getResolvedOutputProcessors(runtimeContext);
  }
  /**
  * Returns whether this agent has its own memory configured.
  *
  * @example
  * ```typescript
  * if (agent.hasOwnMemory()) {
  *   const memory = await agent.getMemory();
  * }
  * ```
  */
  hasOwnMemory() {
    return Boolean(this.#memory);
  }
  /**
  * Gets the memory instance for this agent, resolving function-based memory if necessary.
  * The memory system enables conversation persistence, semantic recall, and working memory.
  *
  * @example
  * ```typescript
  * const memory = await agent.getMemory();
  * if (memory) {
  *   // Memory is configured
  * }
  * ```
  */
  async getMemory({ runtimeContext = new RuntimeContext() } = {}) {
    if (!this.#memory) {
      return void 0;
    }
    let resolvedMemory;
    if (typeof this.#memory !== "function") {
      resolvedMemory = this.#memory;
    } else {
      const result = this.#memory({ runtimeContext, mastra: this.#mastra });
      resolvedMemory = await Promise.resolve(result);
      if (!resolvedMemory) {
        const mastraError = new MastraError({ id: "AGENT_GET_MEMORY_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based memory returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
    }
    if (this.#mastra && resolvedMemory) {
      resolvedMemory.__registerMastra(this.#mastra);
      if (!resolvedMemory.hasOwnStorage) {
        const storage = this.#mastra.getStorage();
        if (storage) {
          resolvedMemory.setStorage(storage);
        }
      }
    }
    return resolvedMemory;
  }
  get voice() {
    if (typeof this.#instructions === "function") {
      const mastraError = new MastraError({ id: "AGENT_VOICE_INCOMPATIBLE_WITH_FUNCTION_INSTRUCTIONS", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "Voice is not compatible when instructions are a function. Please use getVoice() instead." });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    return this.#voice;
  }
  /**
  * Gets the workflows configured for this agent, resolving function-based workflows if necessary.
  * Workflows are step-based execution flows that can be triggered by the agent.
  *
  * @example
  * ```typescript
  * const workflows = await agent.getWorkflows();
  * const workflow = workflows['myWorkflow'];
  * ```
  */
  async getWorkflows({ runtimeContext = new RuntimeContext() } = {}) {
    let workflowRecord;
    if (typeof this.#workflows === "function") {
      workflowRecord = await Promise.resolve(this.#workflows({ runtimeContext, mastra: this.#mastra }));
    } else {
      workflowRecord = this.#workflows ?? {};
    }
    Object.entries(workflowRecord || {}).forEach(([_workflowName, workflow]) => {
      if (this.#mastra) {
        workflow.__registerMastra(this.#mastra);
      }
    });
    return workflowRecord;
  }
  async getScorers({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#scorers !== "function") {
      return this.#scorers;
    }
    const result = this.#scorers({ runtimeContext, mastra: this.#mastra });
    return resolveMaybePromise(result, (scorers) => {
      if (!scorers) {
        const mastraError = new MastraError({ id: "AGENT_GET_SCORERS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based scorers returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return scorers;
    });
  }
  /**
  * Gets the voice instance for this agent with tools and instructions configured.
  * The voice instance enables text-to-speech and speech-to-text capabilities.
  *
  * @example
  * ```typescript
  * const voice = await agent.getVoice();
  * const audioStream = await voice.speak('Hello world');
  * ```
  */
  async getVoice({ runtimeContext } = {}) {
    if (this.#voice) {
      const voice = this.#voice;
      voice?.addTools(await this.getTools({ runtimeContext }));
      const instructions = await this.getInstructions({ runtimeContext });
      voice?.addInstructions(this.#convertInstructionsToString(instructions));
      return voice;
    } else {
      return new DefaultVoice();
    }
  }
  get instructions() {
    this.logger.warn("The instructions property is deprecated. Please use getInstructions() instead.");
    if (typeof this.#instructions === "function") {
      const mastraError = new MastraError({ id: "AGENT_INSTRUCTIONS_INCOMPATIBLE_WITH_FUNCTION_INSTRUCTIONS", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "Instructions are not compatible when instructions are a function. Please use getInstructions() instead." });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    if (typeof this.#instructions !== "string") {
      const mastraError = new MastraError({ id: "AGENT_INSTRUCTIONS_MUST_BE_STRING_FOR_DEPRECATED_GETTER", domain: "AGENT", category: "USER", details: { agentName: this.name, instructionsType: Array.isArray(this.#instructions) ? "array" : "object" }, text: "The instructions getter is deprecated and only supports string instructions. For non-string instructions, please use getInstructions() instead." });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    return this.#instructions;
  }
  /**
  * Gets the instructions for this agent, resolving function-based instructions if necessary.
  * Instructions define the agent's behavior and capabilities.
  *
  * @example
  * ```typescript
  * const instructions = await agent.getInstructions();
  * console.log(instructions); // 'You are a helpful assistant'
  * ```
  */
  getInstructions({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#instructions === "function") {
      const result = this.#instructions({ runtimeContext, mastra: this.#mastra });
      return resolveMaybePromise(result, (instructions) => {
        if (!instructions) {
          const mastraError = new MastraError({ id: "AGENT_GET_INSTRUCTIONS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "Instructions are required to use an Agent. The function-based instructions returned an empty value." });
          this.logger.trackException(mastraError);
          this.logger.error(mastraError.toString());
          throw mastraError;
        }
        return instructions;
      });
    }
    return this.#instructions;
  }
  /**
  * Helper function to convert agent instructions to string for backward compatibility
  * Used for legacy methods that expect string instructions (e.g., voice, telemetry)
  * @internal
  */
  #convertInstructionsToString(instructions) {
    if (typeof instructions === "string") {
      return instructions;
    }
    if (Array.isArray(instructions)) {
      return instructions.map((msg) => {
        if (typeof msg === "string") {
          return msg;
        }
        return typeof msg.content === "string" ? msg.content : "";
      }).filter((content) => content).join("\n\n");
    }
    return typeof instructions.content === "string" ? instructions.content : "";
  }
  /**
  * Returns the description of the agent.
  *
  * @example
  * ```typescript
  * const description = agent.getDescription();
  * console.log(description); // 'A helpful weather assistant'
  * ```
  */
  getDescription() {
    return this.#description ?? "";
  }
  /**
  * Gets the default generate options for this agent, resolving function-based options if necessary.
  * These options are used as defaults when calling `generate()` without explicit options.
  *
  * @example
  * ```typescript
  * const options = await agent.getDefaultGenerateOptions();
  * console.log(options.maxSteps); // 5
  * ```
  */
  getDefaultGenerateOptions({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#defaultGenerateOptions !== "function") {
      return this.#defaultGenerateOptions;
    }
    const result = this.#defaultGenerateOptions({ runtimeContext, mastra: this.#mastra });
    return resolveMaybePromise(result, (options) => {
      if (!options) {
        const mastraError = new MastraError({ id: "AGENT_GET_DEFAULT_GENERATE_OPTIONS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based default generate options returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return options;
    });
  }
  /**
  * Gets the default stream options for this agent, resolving function-based options if necessary.
  * These options are used as defaults when calling `stream()` without explicit options.
  *
  * @example
  * ```typescript
  * const options = await agent.getDefaultStreamOptions();
  * console.log(options.temperature); // 0.7
  * ```
  */
  getDefaultStreamOptions({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#defaultStreamOptions !== "function") {
      return this.#defaultStreamOptions;
    }
    const result = this.#defaultStreamOptions({ runtimeContext, mastra: this.#mastra });
    return resolveMaybePromise(result, (options) => {
      if (!options) {
        const mastraError = new MastraError({ id: "AGENT_GET_DEFAULT_STREAM_OPTIONS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based default stream options returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return options;
    });
  }
  /**
  * Gets the default VNext stream options for this agent, resolving function-based options if necessary.
  * These options are used as defaults when calling `streamVNext()` or `generateVNext()` without explicit options.
  *
  * @example
  * ```typescript
  * const options = await agent.getDefaultVNextStreamOptions();
  * console.log(options.maxSteps); // 5
  * ```
  */
  getDefaultVNextStreamOptions({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#defaultVNextStreamOptions !== "function") {
      if (this.#defaultVNextStreamOptions.output && this.#defaultVNextStreamOptions.structuredOutput) {
        throw new MastraError({ id: "AGENT_GET_DEFAULT_VNEXT_STREAM_OPTIONS_OUTPUT_AND_STRUCTURED_OUTPUT_PROVIDED", domain: "AGENT", category: "USER", text: "output and structuredOutput cannot be provided at the same time" });
      }
      const { output, ...defaultVNextStreamOptions } = this.#defaultVNextStreamOptions;
      return { ...output ? { structuredOutput: { schema: output } } : {}, ...defaultVNextStreamOptions };
    }
    const result = this.#defaultVNextStreamOptions({ runtimeContext, mastra: this.#mastra });
    return resolveMaybePromise(result, (options) => {
      if (!options) {
        const mastraError = new MastraError({ id: "AGENT_GET_DEFAULT_VNEXT_STREAM_OPTIONS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based default vnext stream options returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      if (options.output && options.structuredOutput) {
        throw new MastraError({ id: "AGENT_GET_DEFAULT_VNEXT_STREAM_OPTIONS_OUTPUT_AND_STRUCTURED_OUTPUT_PROVIDED", domain: "AGENT", category: "USER", text: "output and structuredOutput cannot be provided at the same time" });
      }
      const { output, ...restOptions } = options;
      return { ...output ? { structuredOutput: { schema: output } } : {}, ...restOptions };
    });
  }
  get tools() {
    this.logger.warn("The tools property is deprecated. Please use getTools() instead.");
    if (typeof this.#tools === "function") {
      const mastraError = new MastraError({ id: "AGENT_GET_TOOLS_FUNCTION_INCOMPATIBLE_WITH_TOOL_FUNCTION_TYPE", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "Tools are not compatible when tools are a function. Please use getTools() instead." });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    return ensureToolProperties(this.#tools);
  }
  /**
  * Gets the tools configured for this agent, resolving function-based tools if necessary.
  * Tools extend the agent's capabilities, allowing it to perform specific actions or access external systems.
  *
  * @example
  * ```typescript
  * const tools = await agent.getTools();
  * console.log(Object.keys(tools)); // ['calculator', 'weather']
  * ```
  */
  getTools({ runtimeContext = new RuntimeContext() } = {}) {
    if (typeof this.#tools !== "function") {
      return ensureToolProperties(this.#tools);
    }
    const result = this.#tools({ runtimeContext, mastra: this.#mastra });
    return resolveMaybePromise(result, (tools) => {
      if (!tools) {
        const mastraError = new MastraError({ id: "AGENT_GET_TOOLS_FUNCTION_EMPTY_RETURN", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Function-based tools returned empty value` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return ensureToolProperties(tools);
    });
  }
  get llm() {
    this.logger.warn("The llm property is deprecated. Please use getLLM() instead.");
    if (typeof this.model === "function") {
      const mastraError = new MastraError({ id: "AGENT_LLM_GETTER_INCOMPATIBLE_WITH_FUNCTION_MODEL", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "LLM is not compatible when model is a function. Please use getLLM() instead." });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    return this.getLLM();
  }
  /**
  * Gets or creates an LLM instance based on the provided or configured model.
  * The LLM wraps the language model with additional capabilities like telemetry and error handling.
  *
  * @example
  * ```typescript
  * const llm = await agent.getLLM();
  * // Use with custom model
  * const customLlm = await agent.getLLM({ model: 'openai/gpt-5' });
  * ```
  */
  getLLM({ runtimeContext = new RuntimeContext(), model } = {}) {
    const modelToUse = this.getModel({ modelConfig: model, runtimeContext });
    return resolveMaybePromise(modelToUse, (resolvedModel) => {
      let llm;
      if (resolvedModel.specificationVersion === "v2") {
        const modelsPromise = Array.isArray(this.model) && !model ? this.prepareModels(runtimeContext) : this.prepareModels(runtimeContext, resolvedModel);
        llm = modelsPromise.then((models) => {
          const enabledModels = models.filter((model2) => model2.enabled);
          return new MastraLLMVNext({ models: enabledModels, mastra: this.#mastra, options: { tracingPolicy: this.#options?.tracingPolicy } });
        });
      } else {
        llm = new MastraLLMV1({ model: resolvedModel, mastra: this.#mastra, options: { tracingPolicy: this.#options?.tracingPolicy } });
      }
      return resolveMaybePromise(llm, (resolvedLLM) => {
        if (this.#primitives) {
          resolvedLLM.__registerPrimitives(this.#primitives);
        }
        if (this.#mastra) {
          resolvedLLM.__registerMastra(this.#mastra);
        }
        return resolvedLLM;
      });
    });
  }
  /**
  * Resolves a model configuration to a LanguageModel instance
  * @param modelConfig The model configuration (magic string, config object, or LanguageModel)
  * @returns A LanguageModel instance
  * @internal
  */
  async resolveModelConfig(modelConfig, runtimeContext) {
    try {
      return await resolveModelConfig(modelConfig, runtimeContext, this.#mastra);
    } catch (error87) {
      const mastraError = new MastraError({ id: "AGENT_GET_MODEL_MISSING_MODEL_INSTANCE", domain: "AGENT", category: "USER", details: { agentName: this.name, originalError: error87 instanceof Error ? error87.message : String(error87) }, text: `[Agent:${this.name}] - Failed to resolve model configuration` });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
  }
  /**
  * Gets the model instance, resolving it if it's a function or model configuration.
  * When the agent has multiple models configured, returns the first enabled model.
  *
  * @example
  * ```typescript
  * const model = await agent.getModel();
  * // Get with custom model config
  * const customModel = await agent.getModel({
  *   modelConfig: 'openai/gpt-5'
  * });
  * ```
  */
  getModel({ runtimeContext = new RuntimeContext(), modelConfig = this.model } = {}) {
    if (!Array.isArray(modelConfig)) return this.resolveModelConfig(modelConfig, runtimeContext);
    if (modelConfig.length === 0 || !modelConfig[0]) {
      const mastraError = new MastraError({ id: "AGENT_GET_MODEL_MISSING_MODEL_INSTANCE", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Empty model list provided` });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    return this.resolveModelConfig(modelConfig[0].model, runtimeContext);
  }
  /**
  * Gets the list of configured models if the agent has multiple models, otherwise returns null.
  * Used for model fallback and load balancing scenarios.
  *
  * @example
  * ```typescript
  * const models = await agent.getModelList();
  * if (models) {
  *   console.log(models.map(m => m.id));
  * }
  * ```
  */
  async getModelList(runtimeContext = new RuntimeContext()) {
    if (!Array.isArray(this.model)) {
      return null;
    }
    return this.prepareModels(runtimeContext);
  }
  /**
  * Updates the agent's instructions.
  * @internal
  */
  __updateInstructions(newInstructions) {
    this.#instructions = newInstructions;
    this.logger.debug(`[Agents:${this.name}] Instructions updated.`, { model: this.model, name: this.name });
  }
  /**
  * Updates the agent's model configuration.
  * @internal
  */
  __updateModel({ model }) {
    this.model = model;
    this.logger.debug(`[Agents:${this.name}] Model updated.`, { model: this.model, name: this.name });
  }
  /**
  * Resets the agent's model to the original model set during construction.
  * Clones arrays to prevent reordering mutations from affecting the original snapshot.
  * @internal
  */
  __resetToOriginalModel() {
    this.model = Array.isArray(this.#originalModel) ? [...this.#originalModel] : this.#originalModel;
    this.logger.debug(`[Agents:${this.name}] Model reset to original.`, { model: this.model, name: this.name });
  }
  reorderModels(modelIds) {
    if (!Array.isArray(this.model)) {
      this.logger.warn(`[Agents:${this.name}] model is not an array`);
      return;
    }
    this.model = this.model.sort((a, b) => {
      const aIndex = modelIds.indexOf(a.id);
      const bIndex = modelIds.indexOf(b.id);
      return aIndex - bIndex;
    });
    this.logger.debug(`[Agents:${this.name}] Models reordered`);
  }
  updateModelInModelList({ id, model, enabled, maxRetries }) {
    if (!Array.isArray(this.model)) {
      this.logger.warn(`[Agents:${this.name}] model is not an array`);
      return;
    }
    const modelToUpdate = this.model.find((m) => m.id === id);
    if (!modelToUpdate) {
      this.logger.warn(`[Agents:${this.name}] model ${id} not found`);
      return;
    }
    this.model = this.model.map((mdl) => {
      if (mdl.id === id) {
        return { ...mdl, model: model ?? mdl.model, enabled: enabled ?? mdl.enabled, maxRetries: maxRetries ?? mdl.maxRetries };
      }
      return mdl;
    });
    this.logger.debug(`[Agents:${this.name}] model ${id} updated`);
  }
  #primitives;
  /**
  * Registers telemetry and logger primitives with the agent.
  * @internal
  */
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
    this.#primitives = p;
    this.logger.debug(`[Agents:${this.name}] initialized.`, { model: this.model, name: this.name });
  }
  /**
  * Registers the Mastra instance with the agent.
  * @internal
  */
  __registerMastra(mastra) {
    this.#mastra = mastra;
  }
  /**
  * Set the concrete tools for the agent
  * @param tools
  * @internal
  */
  __setTools(tools) {
    this.#tools = tools;
    this.logger.debug(`[Agents:${this.name}] Tools set for agent ${this.name}`, { model: this.model, name: this.name });
  }
  async generateTitleFromUserMessage({ message, runtimeContext = new RuntimeContext(), tracingContext, model, instructions }) {
    const llm = await this.getLLM({ runtimeContext, model });
    const normMessage = new MessageList().add(message, "user").get.all.ui().at(-1);
    if (!normMessage) {
      throw new Error(`Could not generate title from input ${JSON.stringify(message)}`);
    }
    const partsToGen = [];
    for (const part of normMessage.parts) {
      if (part.type === `text`) {
        partsToGen.push(part);
      } else if (part.type === `source`) {
        partsToGen.push({ type: "text", text: `User added URL: ${part.source.url.substring(0, 100)}` });
      } else if (part.type === `file`) {
        partsToGen.push({ type: "text", text: `User added ${part.mimeType} file: ${part.data.substring(0, 100)}` });
      }
    }
    const systemInstructions = await this.resolveTitleInstructions(runtimeContext, instructions);
    let text3 = "";
    if (llm.getModel().specificationVersion === "v2") {
      const messageList = new MessageList().add([{ role: "system", content: systemInstructions }], "system").add([{ role: "user", content: JSON.stringify(partsToGen) }], "input");
      const result = llm.stream({ methodType: "generate", runtimeContext, tracingContext, messageList, agentId: this.id });
      text3 = await result.text;
    } else {
      const result = await llm.__text({ runtimeContext, tracingContext, messages: [{ role: "system", content: systemInstructions }, { role: "user", content: JSON.stringify(partsToGen) }] });
      text3 = result.text;
    }
    const cleanedText = text3.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    return cleanedText;
  }
  getMostRecentUserMessage(messages) {
    const userMessages = messages.filter((message) => message.role === "user");
    return userMessages.at(-1);
  }
  async genTitle(userMessage, runtimeContext, tracingContext, model, instructions) {
    try {
      if (userMessage) {
        const normMessage = new MessageList().add(userMessage, "user").get.all.ui().at(-1);
        if (normMessage) {
          return await this.generateTitleFromUserMessage({ message: normMessage, runtimeContext, tracingContext, model, instructions });
        }
      }
      return `New Thread ${(/* @__PURE__ */ new Date()).toISOString()}`;
    } catch (e) {
      this.logger.error("Error generating title:", e);
      return void 0;
    }
  }
  __setMemory(memory) {
    this.#memory = memory;
  }
  /* @deprecated use agent.getMemory() and query memory directly */
  async fetchMemory({ threadId, thread: passedThread, memoryConfig, resourceId, runId, userMessages, systemMessage, messageList = new MessageList({ threadId, resourceId }), runtimeContext = new RuntimeContext() }) {
    const memory = await this.getMemory({ runtimeContext });
    if (memory) {
      const thread = passedThread ?? await memory.getThreadById({ threadId });
      if (!thread) {
        return { threadId: threadId || "", messages: userMessages || [] };
      }
      if (userMessages && userMessages.length > 0) {
        messageList.add(userMessages, "memory");
      }
      if (systemMessage?.role === "system") {
        messageList.addSystem(systemMessage, "memory");
      }
      const [memoryMessages, memorySystemMessage] = threadId && memory ? await Promise.all([memory.rememberMessages({ threadId, resourceId, config: memoryConfig, vectorMessageSearch: messageList.getLatestUserContent() || "" }).then((r) => r.messagesV2), memory.getSystemMessage({ threadId, memoryConfig })]) : [[], null];
      this.logger.debug("Fetched messages from memory", { threadId, runId, fetchedCount: memoryMessages.length });
      if (memorySystemMessage) {
        messageList.addSystem(memorySystemMessage, "memory");
      }
      messageList.add(memoryMessages, "memory");
      const systemMessages = messageList.getSystemMessages()?.map((m) => m.content)?.join(`
`) ?? void 0;
      const newMessages = messageList.get.input.v1();
      const processedMemoryMessages = await memory.processMessages({
        // these will be processed
        messages: messageList.get.remembered.v1(),
        // these are here for inspecting but shouldn't be returned by the processor
        // - ex TokenLimiter needs to measure all tokens even though it's only processing remembered messages
        newMessages,
        systemMessage: systemMessages,
        memorySystemMessage: memorySystemMessage || void 0
      });
      const returnList = new MessageList().addSystem(systemMessages).add(processedMemoryMessages, "memory").add(newMessages, "user");
      return { threadId: thread.id, messages: returnList.get.all.prompt() };
    }
    return { threadId: threadId || "", messages: userMessages || [] };
  }
  /**
  * Retrieves and converts memory tools to CoreTool format.
  * @internal
  */
  async getMemoryTools({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy }) {
    let convertedMemoryTools = {};
    if (this._agentNetworkAppend) {
      this.logger.debug(`[Agent:${this.name}] - Skipping memory tools (agent network context)`, { runId });
      return convertedMemoryTools;
    }
    const memory = await this.getMemory({ runtimeContext });
    const memoryTools = memory?.getTools?.();
    if (memoryTools) {
      this.logger.debug(`[Agent:${this.name}] - Adding tools from memory ${Object.keys(memoryTools || {}).join(", ")}`, { runId });
      for (const [toolName, tool5] of Object.entries(memoryTools)) {
        const toolObj = tool5;
        const options = { name: toolName, runId, threadId, resourceId, logger: this.logger, mastra: mastraProxy, memory, agentName: this.name, runtimeContext, tracingContext, model: await this.getModel({ runtimeContext }), tracingPolicy: this.#options?.tracingPolicy, requireApproval: toolObj.requireApproval };
        const convertedToCoreTool = makeCoreTool(toolObj, options);
        convertedMemoryTools[toolName] = convertedToCoreTool;
      }
    }
    return convertedMemoryTools;
  }
  /**
  * Executes input processors on the message list before LLM processing.
  * @internal
  */
  async __runInputProcessors({ runtimeContext, tracingContext, messageList, inputProcessorOverrides }) {
    let tripwireTriggered = false;
    let tripwireReason = "";
    if (inputProcessorOverrides?.length || this.#inputProcessors) {
      const runner = await this.getProcessorRunner({ runtimeContext, inputProcessorOverrides });
      const tracedRunInputProcessors = /* @__PURE__ */ __name((messageList2, tracingContext2) => {
        const telemetry = this.#mastra?.getTelemetry();
        if (!telemetry) {
          return runner.runInputProcessors(messageList2, tracingContext2, void 0);
        }
        return telemetry.traceMethod(async (data) => {
          return runner.runInputProcessors(data.messageList, tracingContext2, telemetry);
        }, { spanName: `agent.${this.name}.inputProcessors`, attributes: { "agent.name": this.name, "inputProcessors.count": runner.inputProcessors.length.toString(), "inputProcessors.names": runner.inputProcessors.map((p) => p.name).join(",") } })({ messageList: messageList2 });
      }, "tracedRunInputProcessors");
      try {
        messageList = await tracedRunInputProcessors(messageList, tracingContext);
      } catch (error87) {
        if (error87 instanceof TripWire) {
          tripwireTriggered = true;
          tripwireReason = error87.message;
        } else {
          throw new MastraError({ id: "AGENT_INPUT_PROCESSOR_ERROR", domain: "AGENT", category: "USER", text: `[Agent:${this.name}] - Input processor error` }, error87);
        }
      }
    }
    return { messageList, tripwireTriggered, tripwireReason };
  }
  /**
  * Executes output processors on the message list after LLM processing.
  * @internal
  */
  async __runOutputProcessors({ runtimeContext, tracingContext, messageList, outputProcessorOverrides }) {
    let tripwireTriggered = false;
    let tripwireReason = "";
    if (outputProcessorOverrides?.length || this.#outputProcessors) {
      const runner = await this.getProcessorRunner({ runtimeContext, outputProcessorOverrides });
      const tracedRunOutputProcessors = /* @__PURE__ */ __name((messageList2, tracingContext2) => {
        const telemetry = this.#mastra?.getTelemetry();
        if (!telemetry) {
          return runner.runOutputProcessors(messageList2, tracingContext2, void 0);
        }
        return telemetry.traceMethod(async (data) => {
          return runner.runOutputProcessors(data.messageList, tracingContext2, telemetry);
        }, { spanName: `agent.${this.name}.outputProcessors`, attributes: { "agent.name": this.name, "outputProcessors.count": runner.outputProcessors.length.toString(), "outputProcessors.names": runner.outputProcessors.map((p) => p.name).join(",") } })({ messageList: messageList2 });
      }, "tracedRunOutputProcessors");
      try {
        messageList = await tracedRunOutputProcessors(messageList, tracingContext);
      } catch (e) {
        if (e instanceof TripWire) {
          tripwireTriggered = true;
          tripwireReason = e.message;
          this.logger.debug(`[Agent:${this.name}] - Output processor tripwire triggered: ${e.message}`);
        } else {
          throw e;
        }
      }
    }
    return { messageList, tripwireTriggered, tripwireReason };
  }
  /**
  * Fetches remembered messages from memory for the current thread.
  * @internal
  */
  async getMemoryMessages({ resourceId, threadId, vectorMessageSearch, memoryConfig, runtimeContext }) {
    const memory = await this.getMemory({ runtimeContext });
    if (!memory) {
      return [];
    }
    return memory.rememberMessages({
      threadId,
      resourceId,
      config: memoryConfig,
      // The new user messages aren't in the list yet cause we add memory messages first to try to make sure ordering is correct (memory comes before new user messages)
      vectorMessageSearch
    }).then((r) => r.messagesV2);
  }
  /**
  * Retrieves and converts assigned tools to CoreTool format.
  * @internal
  */
  async getAssignedTools({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy, writableStream }) {
    let toolsForRequest = {};
    this.logger.debug(`[Agents:${this.name}] - Assembling assigned tools`, { runId, threadId, resourceId });
    const memory = await this.getMemory({ runtimeContext });
    const assignedTools = await this.getTools({ runtimeContext });
    const assignedToolEntries = Object.entries(assignedTools || {});
    const assignedCoreToolEntries = await Promise.all(assignedToolEntries.map(async ([k, tool5]) => {
      if (!tool5) {
        return;
      }
      const options = { name: k, runId, threadId, resourceId, logger: this.logger, mastra: mastraProxy, memory, agentName: this.name, runtimeContext, tracingContext, model: await this.getModel({ runtimeContext }), writableStream, tracingPolicy: this.#options?.tracingPolicy, requireApproval: tool5.requireApproval };
      return [k, makeCoreTool(tool5, options)];
    }));
    const assignedToolEntriesConverted = Object.fromEntries(assignedCoreToolEntries.filter((entry) => Boolean(entry)));
    toolsForRequest = { ...assignedToolEntriesConverted };
    return toolsForRequest;
  }
  /**
  * Retrieves and converts toolset tools to CoreTool format.
  * @internal
  */
  async getToolsets({ runId, threadId, resourceId, toolsets, runtimeContext, tracingContext, mastraProxy }) {
    let toolsForRequest = {};
    const memory = await this.getMemory({ runtimeContext });
    const toolsFromToolsets = Object.values(toolsets || {});
    if (toolsFromToolsets.length > 0) {
      this.logger.debug(`[Agent:${this.name}] - Adding tools from toolsets ${Object.keys(toolsets || {}).join(", ")}`, { runId });
      for (const toolset of toolsFromToolsets) {
        for (const [toolName, tool5] of Object.entries(toolset)) {
          const toolObj = tool5;
          const options = { name: toolName, runId, threadId, resourceId, logger: this.logger, mastra: mastraProxy, memory, agentName: this.name, runtimeContext, tracingContext, model: await this.getModel({ runtimeContext }), tracingPolicy: this.#options?.tracingPolicy, requireApproval: toolObj.requireApproval };
          const convertedToCoreTool = makeCoreTool(toolObj, options, "toolset");
          toolsForRequest[toolName] = convertedToCoreTool;
        }
      }
    }
    return toolsForRequest;
  }
  /**
  * Retrieves and converts client-side tools to CoreTool format.
  * @internal
  */
  async getClientTools({ runId, threadId, resourceId, runtimeContext, tracingContext, mastraProxy, clientTools }) {
    let toolsForRequest = {};
    const memory = await this.getMemory({ runtimeContext });
    const clientToolsForInput = Object.entries(clientTools || {});
    if (clientToolsForInput.length > 0) {
      this.logger.debug(`[Agent:${this.name}] - Adding client tools ${Object.keys(clientTools || {}).join(", ")}`, { runId });
      for (const [toolName, tool5] of clientToolsForInput) {
        const { execute: execute2, ...rest } = tool5;
        const options = { name: toolName, runId, threadId, resourceId, logger: this.logger, mastra: mastraProxy, memory, agentName: this.name, runtimeContext, tracingContext, model: await this.getModel({ runtimeContext }), tracingPolicy: this.#options?.tracingPolicy, requireApproval: tool5.requireApproval };
        const convertedToCoreTool = makeCoreTool(rest, options, "client-tool");
        toolsForRequest[toolName] = convertedToCoreTool;
      }
    }
    return toolsForRequest;
  }
  /**
  * Retrieves and converts agent tools to CoreTool format.
  * @internal
  */
  async getAgentTools({ runId, threadId, resourceId, runtimeContext, tracingContext, methodType }) {
    const convertedAgentTools = {};
    const agents = await this.listAgents({ runtimeContext });
    if (Object.keys(agents).length > 0) {
      for (const [agentName, agent] of Object.entries(agents)) {
        const agentInputSchema = external_exports2.object({ prompt: external_exports2.string().describe("The prompt to send to the agent") });
        const agentOutputSchema = external_exports2.object({ text: external_exports2.string().describe("The response from the agent"), subAgentThreadId: external_exports2.string().describe("The thread ID of the agent").optional(), subAgentResourceId: external_exports2.string().describe("The resource ID of the agent").optional() });
        const modelVersion = (await agent.getModel()).specificationVersion;
        const toolObj = createTool({
          id: `agent-${agentName}`,
          description: `Agent: ${agentName}`,
          inputSchema: agentInputSchema,
          outputSchema: agentOutputSchema,
          mastra: this.#mastra,
          // manually wrap agent tools with ai tracing, so that we can pass the
          // current tool span onto the agent to maintain continuity of the trace
          execute: /* @__PURE__ */ __name(async ({ context: context3, writer, tracingContext: innerTracingContext }) => {
            try {
              this.logger.debug(`[Agent:${this.name}] - Executing agent as tool ${agentName}`, { name: agentName, args: context3, runId, threadId, resourceId });
              let result;
              if ((methodType === "generate" || methodType === "generateLegacy") && modelVersion === "v2") {
                if (!agent.hasOwnMemory() && this.#memory) {
                  agent.__setMemory(this.#memory);
                }
                const subAgentThreadId = randomUUID3();
                const subAgentResourceId = `${slugify2(this.id)}-${agentName}`;
                const generateResult = await agent.generate(context3.prompt, { runtimeContext, tracingContext: innerTracingContext, ...resourceId && threadId ? { memory: { resource: subAgentResourceId, thread: subAgentThreadId } } : {} });
                result = { text: generateResult.text, subAgentThreadId, subAgentResourceId };
              } else if ((methodType === "generate" || methodType === "generateLegacy") && modelVersion === "v1") {
                const generateResult = await agent.generateLegacy(context3.prompt, { runtimeContext, tracingContext: innerTracingContext });
                result = { text: generateResult.text };
              } else if ((methodType === "stream" || methodType === "streamLegacy") && modelVersion === "v2") {
                if (!agent.hasOwnMemory() && this.#memory) {
                  agent.__setMemory(this.#memory);
                }
                const subAgentThreadId = randomUUID3();
                const subAgentResourceId = `${slugify2(this.id)}-${agentName}`;
                const streamResult = await agent.stream(context3.prompt, { runtimeContext, tracingContext: innerTracingContext, ...resourceId && threadId ? { memory: { resource: subAgentResourceId, thread: subAgentThreadId } } : {} });
                let fullText = "";
                for await (const chunk of streamResult.fullStream) {
                  if (writer) {
                    if (chunk.type.startsWith("data-")) {
                      await writer.custom(chunk);
                    } else {
                      await writer.write(chunk);
                    }
                  }
                  if (chunk.type === "text-delta") {
                    fullText += chunk.payload.text;
                  }
                }
                result = { text: fullText, subAgentThreadId, subAgentResourceId };
              } else {
                const streamResult = await agent.streamLegacy(context3.prompt, { runtimeContext, tracingContext: innerTracingContext });
                let fullText = "";
                for await (const chunk of streamResult.fullStream) {
                  if (writer) {
                    if (chunk.type.startsWith("data-")) {
                      await writer.custom(chunk);
                    } else {
                      await writer.write(chunk);
                    }
                  }
                  if (chunk.type === "text-delta") {
                    fullText += chunk.textDelta;
                  }
                }
                result = { text: fullText };
              }
              return result;
            } catch (err) {
              const mastraError = new MastraError({ id: "AGENT_AGENT_TOOL_EXECUTION_FAILED", domain: "AGENT", category: "USER", details: { agentName: this.name, subAgentName: agentName, runId: runId || "", threadId: threadId || "", resourceId: resourceId || "" }, text: `[Agent:${this.name}] - Failed agent tool execution for ${agentName}` }, err);
              this.logger.trackException(mastraError);
              this.logger.error(mastraError.toString());
              throw mastraError;
            }
          }, "execute")
        });
        const options = { name: `agent-${agentName}`, runId, threadId, resourceId, logger: this.logger, mastra: this.#mastra, memory: await this.getMemory({ runtimeContext }), agentName: this.name, runtimeContext, model: await this.getModel({ runtimeContext }), tracingContext, tracingPolicy: this.#options?.tracingPolicy };
        convertedAgentTools[`agent-${agentName}`] = makeCoreTool(toolObj, options);
      }
    }
    return convertedAgentTools;
  }
  /**
  * Retrieves and converts workflow tools to CoreTool format.
  * @internal
  */
  async getWorkflowTools({ runId, threadId, resourceId, runtimeContext, tracingContext, methodType }) {
    const convertedWorkflowTools = {};
    const workflows = await this.getWorkflows({ runtimeContext });
    if (Object.keys(workflows).length > 0) {
      for (const [workflowName, workflow] of Object.entries(workflows)) {
        const toolObj = createTool({
          id: `workflow-${workflowName}`,
          description: workflow.description || `Workflow: ${workflowName}`,
          inputSchema: workflow.inputSchema,
          outputSchema: workflow.outputSchema,
          mastra: this.#mastra,
          // manually wrap workflow tools with ai tracing, so that we can pass the
          // current tool span onto the workflow to maintain continuity of the trace
          execute: /* @__PURE__ */ __name(async ({ context: context3, writer, tracingContext: innerTracingContext }) => {
            try {
              this.logger.debug(`[Agent:${this.name}] - Executing workflow as tool ${workflowName}`, { name: workflowName, description: workflow.description, args: context3, runId, threadId, resourceId });
              const run = await workflow.createRunAsync();
              let result;
              if (methodType === "generate" || methodType === "generateLegacy") {
                result = await run.start({ inputData: context3, runtimeContext, tracingContext: innerTracingContext });
              } else if (methodType === "streamLegacy") {
                const streamResult = run.streamLegacy({ inputData: context3, runtimeContext, tracingContext: innerTracingContext });
                if (writer) {
                  await streamResult.stream.pipeTo(writer);
                } else {
                  for await (const _chunk of streamResult.stream) {
                  }
                }
                result = await streamResult.getWorkflowState();
              } else if (methodType === "stream") {
                const streamResult = run.stream({ inputData: context3, runtimeContext, tracingContext: innerTracingContext });
                if (writer) {
                  await streamResult.fullStream.pipeTo(writer);
                }
                result = await streamResult.result;
              }
              return { result, runId: run.runId };
            } catch (err) {
              const mastraError = new MastraError({ id: "AGENT_WORKFLOW_TOOL_EXECUTION_FAILED", domain: "AGENT", category: "USER", details: { agentName: this.name, runId: runId || "", threadId: threadId || "", resourceId: resourceId || "" }, text: `[Agent:${this.name}] - Failed workflow tool execution` }, err);
              this.logger.trackException(mastraError);
              this.logger.error(mastraError.toString());
              throw mastraError;
            }
          }, "execute")
        });
        const options = { name: `workflow-${workflowName}`, runId, threadId, resourceId, logger: this.logger, mastra: this.#mastra, memory: await this.getMemory({ runtimeContext }), agentName: this.name, runtimeContext, model: await this.getModel({ runtimeContext }), tracingContext, tracingPolicy: this.#options?.tracingPolicy };
        convertedWorkflowTools[`workflow-${workflowName}`] = makeCoreTool(toolObj, options);
      }
    }
    return convertedWorkflowTools;
  }
  /**
  * Assembles all tools from various sources into a unified CoreTool dictionary.
  * @internal
  */
  async convertTools({ toolsets, clientTools, threadId, resourceId, runId, runtimeContext, tracingContext, writableStream, methodType }) {
    let mastraProxy = void 0;
    const logger = this.logger;
    if (this.#mastra) {
      mastraProxy = createMastraProxy({ mastra: this.#mastra, logger });
    }
    const assignedTools = await this.getAssignedTools({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy, writableStream });
    const memoryTools = await this.getMemoryTools({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy });
    const toolsetTools = await this.getToolsets({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy, toolsets });
    const clientSideTools = await this.getClientTools({ runId, resourceId, threadId, runtimeContext, tracingContext, mastraProxy, clientTools });
    const agentTools = await this.getAgentTools({ runId, resourceId, threadId, runtimeContext, methodType, tracingContext });
    const workflowTools = await this.getWorkflowTools({ runId, resourceId, threadId, runtimeContext, methodType, tracingContext });
    return this.formatTools({ ...assignedTools, ...memoryTools, ...toolsetTools, ...clientSideTools, ...agentTools, ...workflowTools });
  }
  /**
  * Formats and validates tool names to comply with naming restrictions.
  * @internal
  */
  formatTools(tools) {
    const INVALID_CHAR_REGEX = /[^a-zA-Z0-9_\-]/g;
    const STARTING_CHAR_REGEX = /[a-zA-Z_]/;
    for (const key of Object.keys(tools)) {
      if (tools[key] && (key.length > 63 || key.match(INVALID_CHAR_REGEX) || !key[0].match(STARTING_CHAR_REGEX))) {
        let newKey = key.replace(INVALID_CHAR_REGEX, "_");
        if (!newKey[0].match(STARTING_CHAR_REGEX)) {
          newKey = "_" + newKey;
        }
        newKey = newKey.slice(0, 63);
        if (tools[newKey]) {
          const mastraError = new MastraError({ id: "AGENT_TOOL_NAME_COLLISION", domain: "AGENT", category: "USER", details: { agentName: this.name, toolName: newKey }, text: `Two or more tools resolve to the same name "${newKey}". Please rename one of the tools to avoid this collision.` });
          this.logger.trackException(mastraError);
          this.logger.error(mastraError.toString());
          throw mastraError;
        }
        tools[newKey] = tools[key];
        delete tools[key];
      }
    }
    return tools;
  }
  /**
  * Adds response messages from a step to the MessageList and schedules persistence.
  * This is used for incremental saving: after each agent step, messages are added to a save queue
  * and a debounced save operation is triggered to avoid redundant writes.
  *
  * @param result - The step result containing response messages.
  * @param messageList - The MessageList instance for the current thread.
  * @param threadId - The thread ID.
  * @param memoryConfig - The memory configuration for saving.
  * @param runId - (Optional) The run ID for logging.
  * @internal
  */
  async saveStepMessages({ saveQueueManager, result, messageList, threadId, memoryConfig, runId }) {
    try {
      messageList.add(result.response.messages, "response");
      await saveQueueManager.batchMessages(messageList, threadId, memoryConfig);
    } catch (e) {
      await saveQueueManager.flushMessages(messageList, threadId, memoryConfig);
      this.logger.error("Error saving memory on step finish", { error: e, runId });
      throw e;
    }
  }
  /**
  * Prepares message list and tools before LLM execution and handles memory persistence after.
  * @internal
  */
  __primitive({ instructions, messages, context: context3, thread, memoryConfig, resourceId, runId, toolsets, clientTools, runtimeContext, saveQueueManager, writableStream, methodType, tracingContext, tracingOptions }) {
    return { before: /* @__PURE__ */ __name(async () => {
      if (true) {
        this.logger.debug(`[Agents:${this.name}] - Starting generation`, { runId });
      }
      const agentAISpan = getOrCreateSpan({ type: "agent_run", name: `agent run: '${this.id}'`, input: { messages }, attributes: { agentId: this.id, instructions: this.#convertInstructionsToString(instructions), availableTools: [...toolsets ? Object.keys(toolsets) : [], ...clientTools ? Object.keys(clientTools) : []] }, metadata: { runId, resourceId, threadId: thread ? thread.id : void 0 }, tracingPolicy: this.#options?.tracingPolicy, tracingOptions, tracingContext, runtimeContext });
      const innerTracingContext = { currentSpan: agentAISpan };
      const memory = await this.getMemory({ runtimeContext });
      const toolEnhancements = [
        // toolsets
        toolsets && Object.keys(toolsets || {}).length > 0 ? `toolsets present (${Object.keys(toolsets || {}).length} tools)` : void 0,
        // memory tools
        memory && resourceId ? "memory and resourceId available" : void 0
      ].filter(Boolean).join(", ");
      this.logger.debug(`[Agent:${this.name}] - Enhancing tools: ${toolEnhancements}`, { runId, toolsets: toolsets ? Object.keys(toolsets) : void 0, clientTools: clientTools ? Object.keys(clientTools) : void 0, hasMemory: !!memory, hasResourceId: !!resourceId });
      const threadId = thread?.id;
      const convertedTools = await this.convertTools({ toolsets, clientTools, threadId, resourceId, runId, runtimeContext, tracingContext: innerTracingContext, writableStream, methodType });
      const messageList = new MessageList({
        threadId,
        resourceId,
        generateMessageId: this.#mastra?.generateId?.bind(this.#mastra),
        // @ts-ignore Flag for agent network messages
        _agentNetworkAppend: this._agentNetworkAppend
      }).addSystem(instructions || await this.getInstructions({ runtimeContext })).add(context3 || [], "context");
      if (!memory || !threadId && !resourceId) {
        messageList.add(messages, "user");
        const { tripwireTriggered: tripwireTriggered2, tripwireReason: tripwireReason2 } = await this.__runInputProcessors({ runtimeContext, tracingContext: innerTracingContext, messageList });
        return { messageObjects: tripwireTriggered2 ? [] : messageList.get.all.prompt(), convertedTools, threadExists: false, thread: void 0, messageList, agentAISpan, ...tripwireTriggered2 && { tripwire: true, tripwireReason: tripwireReason2 } };
      }
      if (!threadId || !resourceId) {
        const mastraError = new MastraError({ id: "AGENT_MEMORY_MISSING_RESOURCE_ID", domain: "AGENT", category: "USER", details: { agentName: this.name, threadId: threadId || "", resourceId: resourceId || "" }, text: `A resourceId and a threadId must be provided when using Memory. Saw threadId "${threadId}" and resourceId "${resourceId}"` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        agentAISpan?.error({ error: mastraError });
        throw mastraError;
      }
      const store = memory.constructor.name;
      this.logger.debug(`[Agent:${this.name}] - Memory persistence enabled: store=${store}, resourceId=${resourceId}`, { runId, resourceId, threadId, memoryStore: store });
      let threadObject = void 0;
      const existingThread = await memory.getThreadById({ threadId });
      if (existingThread) {
        if (!existingThread.metadata && thread.metadata || thread.metadata && !(0, import_fast_deep_equal2.default)(existingThread.metadata, thread.metadata)) {
          threadObject = await memory.saveThread({ thread: { ...existingThread, metadata: thread.metadata }, memoryConfig });
        } else {
          threadObject = existingThread;
        }
      } else {
        threadObject = await memory.createThread({ threadId, metadata: thread.metadata, title: thread.title, memoryConfig, resourceId, saveThread: false });
      }
      const config4 = memory.getMergedThreadConfig(memoryConfig || {});
      const hasResourceScopeSemanticRecall = typeof config4?.semanticRecall === "object" && config4?.semanticRecall?.scope === "resource";
      let [memoryMessages, memorySystemMessage] = await Promise.all([existingThread || hasResourceScopeSemanticRecall ? this.getMemoryMessages({ resourceId, threadId: threadObject.id, vectorMessageSearch: new MessageList().add(messages, `user`).getLatestUserContent() || "", memoryConfig, runtimeContext }) : [], memory.getSystemMessage({ threadId: threadObject.id, resourceId, memoryConfig })]);
      this.logger.debug("Fetched messages from memory", { threadId: threadObject.id, runId, fetchedCount: memoryMessages.length });
      const resultsFromOtherThreads = memoryMessages.filter((m) => m.threadId !== threadObject.id);
      if (resultsFromOtherThreads.length && !memorySystemMessage) {
        memorySystemMessage = ``;
      }
      if (resultsFromOtherThreads.length) {
        memorySystemMessage += `
The following messages were remembered from a different conversation:
<remembered_from_other_conversation>
${(() => {
          let result = ``;
          const messages2 = new MessageList().add(resultsFromOtherThreads, "memory").get.all.v1();
          let lastYmd = null;
          for (const msg of messages2) {
            const date9 = msg.createdAt;
            const year = date9.getUTCFullYear();
            const month = date9.toLocaleString("default", { month: "short" });
            const day = date9.getUTCDate();
            const ymd = `${year}, ${month}, ${day}`;
            const utcHour = date9.getUTCHours();
            const utcMinute = date9.getUTCMinutes();
            const hour12 = utcHour % 12 || 12;
            const ampm = utcHour < 12 ? "AM" : "PM";
            const timeofday = `${hour12}:${utcMinute < 10 ? "0" : ""}${utcMinute} ${ampm}`;
            if (!lastYmd || lastYmd !== ymd) {
              result += `
the following messages are from ${ymd}
`;
            }
            result += `
  Message ${msg.threadId && msg.threadId !== threadObject.id ? "from previous conversation" : ""} at ${timeofday}: ${JSON.stringify(msg)}`;
            lastYmd = ymd;
          }
          return result;
        })()}
<end_remembered_from_other_conversation>`;
      }
      if (memorySystemMessage) {
        messageList.addSystem(memorySystemMessage, "memory");
      }
      messageList.add(
        memoryMessages.filter((m) => m.threadId === threadObject.id),
        // filter out messages from other threads. those are added to system message above
        "memory"
      ).add(messages, "user");
      const { tripwireTriggered, tripwireReason } = await this.__runInputProcessors({ runtimeContext, tracingContext: innerTracingContext, messageList });
      const systemMessages = messageList.getSystemMessages();
      const systemMessage = [...systemMessages, ...messageList.getSystemMessages("memory")]?.map((m) => m.content)?.join(`
`) ?? void 0;
      const processedMemoryMessages = await memory.processMessages({
        // these will be processed
        messages: messageList.get.remembered.v1(),
        // these are here for inspecting but shouldn't be returned by the processor
        // - ex TokenLimiter needs to measure all tokens even though it's only processing remembered messages
        newMessages: messageList.get.input.v1(),
        systemMessage,
        memorySystemMessage: memorySystemMessage || void 0
      });
      const processedList = new MessageList({
        threadId: threadObject.id,
        resourceId,
        generateMessageId: this.#mastra?.generateId?.bind(this.#mastra),
        // @ts-ignore Flag for agent network messages
        _agentNetworkAppend: this._agentNetworkAppend
      }).addSystem(instructions || await this.getInstructions({ runtimeContext })).addSystem(memorySystemMessage).addSystem(systemMessages).add(context3 || [], "context").add(processedMemoryMessages, "memory").add(messageList.get.input.v2(), "user").get.all.prompt();
      return {
        convertedTools,
        thread: threadObject,
        messageList,
        // add old processed messages + new input messages
        messageObjects: processedList,
        agentAISpan,
        ...tripwireTriggered && { tripwire: true, tripwireReason },
        threadExists: !!existingThread
      };
    }, "before"), after: /* @__PURE__ */ __name(async ({ result, thread: threadAfter, threadId, memoryConfig: memoryConfig2, outputText, runId: runId2, messageList, threadExists, structuredOutput = false, overrideScorers, agentAISpan }) => {
      const resToLog = { text: result?.text, object: result?.object, toolResults: result?.toolResults, toolCalls: result?.toolCalls, usage: result?.usage, steps: result?.steps?.map((s) => {
        return { stepType: s?.stepType, text: result?.text, object: result?.object, toolResults: result?.toolResults, toolCalls: result?.toolCalls, usage: result?.usage };
      }) };
      this.logger.debug(`[Agent:${this.name}] - Post processing LLM response`, { runId: runId2, result: resToLog, threadId });
      const messageListResponses = new MessageList({
        threadId,
        resourceId,
        generateMessageId: this.#mastra?.generateId?.bind(this.#mastra),
        // @ts-ignore Flag for agent network messages
        _agentNetworkAppend: this._agentNetworkAppend
      }).add(result.response.messages, "response").get.all.core();
      const usedWorkingMemory = messageListResponses?.some((m) => m.role === "tool" && m?.content?.some((c) => c?.toolName === "updateWorkingMemory"));
      const memory = await this.getMemory({ runtimeContext });
      const thread2 = usedWorkingMemory ? threadId ? await memory?.getThreadById({ threadId }) : void 0 : threadAfter;
      if (memory && resourceId && thread2) {
        try {
          let responseMessages = result.response.messages;
          if (!responseMessages && result.object) {
            responseMessages = [{ role: "assistant", content: [{
              type: "text",
              text: outputText
              // outputText contains the stringified object
            }] }];
          }
          if (responseMessages) {
            messageList.add(responseMessages, "response");
          }
          if (!threadExists) {
            await memory.createThread({ threadId: thread2.id, metadata: thread2.metadata, title: thread2.title, memoryConfig: memoryConfig2, resourceId: thread2.resourceId });
          }
          const promises = [saveQueueManager.flushMessages(messageList, threadId, memoryConfig2)];
          if (thread2.title?.startsWith("New Thread")) {
            const config4 = memory.getMergedThreadConfig(memoryConfig2);
            const userMessage = this.getMostRecentUserMessage(messageList.get.all.ui());
            const { shouldGenerate, model: titleModel, instructions: titleInstructions } = this.resolveTitleGenerationConfig(config4?.threads?.generateTitle);
            if (shouldGenerate && userMessage) {
              promises.push(this.genTitle(userMessage, runtimeContext, { currentSpan: agentAISpan }, titleModel, titleInstructions).then((title2) => {
                if (title2) {
                  return memory.createThread({ threadId: thread2.id, resourceId, memoryConfig: memoryConfig2, title: title2, metadata: thread2.metadata });
                }
              }));
            }
          }
          await Promise.all(promises);
        } catch (e) {
          await saveQueueManager.flushMessages(messageList, threadId, memoryConfig2);
          if (e instanceof MastraError) {
            agentAISpan?.error({ error: e });
            throw e;
          }
          const mastraError = new MastraError({ id: "AGENT_MEMORY_PERSIST_RESPONSE_MESSAGES_FAILED", domain: "AGENT", category: "SYSTEM", details: { agentName: this.name, runId: runId2 || "", threadId: threadId || "", result: JSON.stringify(resToLog) } }, e);
          this.logger.trackException(mastraError);
          this.logger.error(mastraError.toString());
          agentAISpan?.error({ error: mastraError });
          throw mastraError;
        }
      } else {
        let responseMessages = result.response.messages;
        if (!responseMessages && result.object) {
          responseMessages = [{ role: "assistant", content: [{
            type: "text",
            text: outputText
            // outputText contains the stringified object
          }] }];
        }
        if (responseMessages) {
          messageList.add(responseMessages, "response");
        }
      }
      await this.#runScorers({ messageList, runId: runId2, outputText, instructions, runtimeContext, structuredOutput, overrideScorers, threadId, resourceId, tracingContext: { currentSpan: agentAISpan } });
      const scoringData = { input: { inputMessages: messageList.getPersisted.input.ui(), rememberedMessages: messageList.getPersisted.remembered.ui(), systemMessages: messageList.getSystemMessages(), taggedSystemMessages: messageList.getPersisted.taggedSystemMessages }, output: messageList.getPersisted.response.ui() };
      agentAISpan?.end({ output: { text: result?.text, object: result?.object, files: result?.files } });
      return { scoringData };
    }, "after") };
  }
  async #runScorers({ messageList, runId, outputText, instructions, runtimeContext, structuredOutput, overrideScorers, threadId, resourceId, tracingContext }) {
    const agentName = this.name;
    const userInputMessages = messageList.get.all.ui().filter((m) => m.role === "user");
    const input = userInputMessages.map((message) => typeof message.content === "string" ? message.content : "").join("\n");
    const runIdToUse = runId || this.#mastra?.generateId() || randomUUID3();
    if (Object.keys(this.evals || {}).length > 0) {
      for (const metric of Object.values(this.evals || {})) {
        executeHook("onGeneration", { input, output: outputText, runId: runIdToUse, metric, agentName, instructions: this.#convertInstructionsToString(instructions) });
      }
    }
    let scorers = {};
    try {
      scorers = overrideScorers ? this.resolveOverrideScorerReferences(overrideScorers) : await this.getScorers({ runtimeContext });
    } catch (e) {
      this.logger.warn(`[Agent:${this.name}] - Failed to get scorers: ${e}`);
      return;
    }
    const scorerInput = { inputMessages: messageList.getPersisted.input.ui(), rememberedMessages: messageList.getPersisted.remembered.ui(), systemMessages: messageList.getSystemMessages(), taggedSystemMessages: messageList.getPersisted.taggedSystemMessages };
    const scorerOutput = messageList.getPersisted.response.ui();
    if (Object.keys(scorers || {}).length > 0) {
      for (const [_id, scorerObject] of Object.entries(scorers)) {
        runScorer({ scorerId: overrideScorers ? scorerObject.scorer.name : scorerObject.scorer.name, scorerObject, runId, input: scorerInput, output: scorerOutput, runtimeContext, entity: { id: this.id, name: this.name }, source: "LIVE", entityType: "AGENT", structuredOutput: !!structuredOutput, threadId, resourceId, tracingContext });
      }
    }
  }
  /**
  * Resolves scorer name references to actual scorer instances from Mastra.
  * @internal
  */
  resolveOverrideScorerReferences(overrideScorers) {
    const result = {};
    for (const [id, scorerObject] of Object.entries(overrideScorers)) {
      if (typeof scorerObject.scorer === "string") {
        try {
          if (!this.#mastra) {
            throw new MastraError({ id: "AGENT_GENEREATE_SCORER_NOT_FOUND", domain: "AGENT", category: "USER", text: `Mastra not found when fetching scorer. Make sure to fetch agent from mastra.getAgent()` });
          }
          const scorer = this.#mastra.getScorerByName(scorerObject.scorer);
          result[id] = { scorer, sampling: scorerObject.sampling };
        } catch (error87) {
          this.logger.warn(`[Agent:${this.name}] - Failed to get scorer ${scorerObject.scorer}: ${error87}`);
        }
      } else {
        result[id] = scorerObject;
      }
    }
    if (Object.keys(result).length === 0) {
      throw new MastraError({ id: "AGENT_GENEREATE_SCORER_NOT_FOUND", domain: "AGENT", category: "USER", text: `No scorers found in overrideScorers` });
    }
    return result;
  }
  /**
  * @internal
  */
  async prepareLLMOptions(messages, options, methodType) {
    const { context: context3, memoryOptions: memoryConfigFromArgs, resourceId: resourceIdFromArgs, maxSteps, onStepFinish, toolsets, clientTools, temperature, toolChoice = "auto", runtimeContext = new RuntimeContext(), tracingContext, tracingOptions, savePerStep, writableStream, ...args } = options;
    const threadFromArgs = resolveThreadIdFromArgs({ threadId: args.threadId, memory: args.memory });
    const resourceId = args.memory?.resource || resourceIdFromArgs;
    const memoryConfig = args.memory?.options || memoryConfigFromArgs;
    if (resourceId && threadFromArgs && !this.hasOwnMemory()) {
      this.logger.warn(`[Agent:${this.name}] - No memory is configured but resourceId and threadId were passed in args. This will not work.`);
    }
    const runId = args.runId || this.#mastra?.generateId() || randomUUID3();
    const instructions = args.instructions || await this.getInstructions({ runtimeContext });
    const llm = await this.getLLM({ runtimeContext });
    const activeSpan = Telemetry.getActiveSpan();
    const baggageEntries = {};
    if (threadFromArgs?.id) {
      if (activeSpan) {
        activeSpan.setAttribute("threadId", threadFromArgs.id);
      }
      baggageEntries.threadId = { value: threadFromArgs.id };
    }
    if (resourceId) {
      if (activeSpan) {
        activeSpan.setAttribute("resourceId", resourceId);
      }
      baggageEntries.resourceId = { value: resourceId };
    }
    if (Object.keys(baggageEntries).length > 0) {
      Telemetry.setBaggage(baggageEntries);
    }
    const memory = await this.getMemory({ runtimeContext });
    const saveQueueManager = new SaveQueueManager({ logger: this.logger, memory });
    const { before, after } = this.__primitive({ messages, instructions, context: context3, thread: threadFromArgs, memoryConfig, resourceId, runId, toolsets, clientTools, runtimeContext, saveQueueManager, writableStream, methodType, tracingContext, tracingOptions });
    let messageList;
    let thread;
    let threadExists;
    return { llm, before: /* @__PURE__ */ __name(async () => {
      const beforeResult = await before();
      const { messageObjects, convertedTools, agentAISpan } = beforeResult;
      threadExists = beforeResult.threadExists || false;
      messageList = beforeResult.messageList;
      thread = beforeResult.thread;
      const threadId = thread?.id;
      const result = { ...options, messages: messageObjects, tools: convertedTools, runId, temperature, toolChoice, threadId, resourceId, runtimeContext, onStepFinish: /* @__PURE__ */ __name(async (props) => {
        if (savePerStep) {
          if (!threadExists && memory && thread) {
            await memory.createThread({ threadId, title: thread.title, metadata: thread.metadata, resourceId: thread.resourceId, memoryConfig });
            threadExists = true;
          }
          await this.saveStepMessages({ saveQueueManager, result: props, messageList, threadId, memoryConfig, runId });
        }
        return onStepFinish?.({ ...props, runId });
      }, "onStepFinish"), ...beforeResult.tripwire && { tripwire: beforeResult.tripwire, tripwireReason: beforeResult.tripwireReason }, ...args, agentAISpan };
      return result;
    }, "before"), after: /* @__PURE__ */ __name(async ({ result, outputText, structuredOutput = false, agentAISpan, overrideScorers }) => {
      const afterResult = await after({ result, outputText, threadId: thread?.id, thread, memoryConfig, runId, messageList, structuredOutput, threadExists, agentAISpan, overrideScorers });
      return afterResult;
    }, "after") };
  }
  /**
  * Resolves and prepares model configurations for the LLM.
  * @internal
  */
  async prepareModels(runtimeContext, model) {
    if (model || !Array.isArray(this.model)) {
      const modelToUse = model ?? this.model;
      const resolvedModel = typeof modelToUse === "function" ? await modelToUse({ runtimeContext, mastra: this.#mastra }) : modelToUse;
      if (resolvedModel?.specificationVersion !== "v2") {
        const mastraError = new MastraError({ id: "AGENT_PREPARE_MODELS_INCOMPATIBLE_WITH_MODEL_ARRAY_V1", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Only v2 models are allowed when an array of models is provided` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return [{
        id: "main",
        // TODO fix type check
        model: resolvedModel,
        maxRetries: this.maxRetries ?? 0,
        enabled: true
      }];
    }
    const models = await Promise.all(this.model.map(async (modelConfig) => {
      const model2 = await this.resolveModelConfig(modelConfig.model, runtimeContext);
      if (!isV2Model(model2)) {
        const mastraError = new MastraError({ id: "AGENT_PREPARE_MODELS_INCOMPATIBLE_WITH_MODEL_ARRAY_V1", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Only v2 models are allowed when an array of models is provided` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      const modelId = modelConfig.id || model2.modelId;
      if (!modelId) {
        const mastraError = new MastraError({ id: "AGENT_PREPARE_MODELS_MISSING_MODEL_ID", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: `[Agent:${this.name}] - Unable to determine model ID. Please provide an explicit ID in the model configuration.` });
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
      return { id: modelId, model: model2, maxRetries: modelConfig.maxRetries ?? 0, enabled: modelConfig.enabled ?? true };
    }));
    return models;
  }
  /**
  * Merges telemetry wrapper with default onFinish callback when needed
  * @internal
  */
  #mergeOnFinishWithTelemetry(streamOptions, defaultStreamOptions) {
    let finalOnFinish = streamOptions?.onFinish || defaultStreamOptions.onFinish;
    if (streamOptions?.onFinish && streamOptions.onFinish.__hasOriginalOnFinish === false && defaultStreamOptions.onFinish) {
      const telemetryWrapper = streamOptions.onFinish;
      const defaultCallback = defaultStreamOptions.onFinish;
      finalOnFinish = /* @__PURE__ */ __name(async (data) => {
        await telemetryWrapper(data);
        await defaultCallback(data);
      }, "finalOnFinish");
    }
    return finalOnFinish;
  }
  /**
  * Executes the agent with VNext execution model, handling tools, memory, and streaming.
  * @internal
  */
  async #execute({ methodType, format = "mastra", resumeContext, ...options }) {
    const existingSnapshot = resumeContext?.snapshot;
    let snapshotMemoryInfo;
    if (existingSnapshot) {
      for (const key in existingSnapshot?.context) {
        const step = existingSnapshot?.context[key];
        if (step && step.status === "suspended" && step.suspendPayload?.__streamState) {
          snapshotMemoryInfo = step.suspendPayload?.__streamState?.messageList?.memoryInfo;
          break;
        }
      }
    }
    const runtimeContext = options.runtimeContext || new RuntimeContext();
    const threadFromArgs = resolveThreadIdFromArgs({ threadId: options.threadId || snapshotMemoryInfo?.threadId, memory: options.memory });
    const resourceId = options.memory?.resource || options.resourceId || snapshotMemoryInfo?.resourceId;
    const memoryConfig = options.memory?.options;
    if (resourceId && threadFromArgs && !this.hasOwnMemory()) {
      this.logger.warn(`[Agent:${this.name}] - No memory is configured but resourceId and threadId were passed in args. This will not work.`);
    }
    const llm = await this.getLLM({ runtimeContext, model: options.model });
    const runId = options.runId || this.#mastra?.generateId() || randomUUID3();
    const instructions = options.instructions || await this.getInstructions({ runtimeContext });
    const agentAISpan = getOrCreateSpan({ type: "agent_run", name: `agent run: '${this.id}'`, input: options.messages, attributes: { agentId: this.id, instructions: this.#convertInstructionsToString(instructions) }, metadata: { runId, resourceId, threadId: threadFromArgs?.id }, tracingPolicy: this.#options?.tracingPolicy, tracingOptions: options.tracingOptions, tracingContext: options.tracingContext, runtimeContext });
    const activeSpan = Telemetry.getActiveSpan();
    const baggageEntries = {};
    if (threadFromArgs?.id) {
      if (activeSpan) {
        activeSpan.setAttribute("threadId", threadFromArgs.id);
      }
      baggageEntries.threadId = { value: threadFromArgs.id };
    }
    if (resourceId) {
      if (activeSpan) {
        activeSpan.setAttribute("resourceId", resourceId);
      }
      baggageEntries.resourceId = { value: resourceId };
    }
    if (Object.keys(baggageEntries).length > 0) {
      Telemetry.setBaggage(baggageEntries);
    }
    const memory = await this.getMemory({ runtimeContext });
    const saveQueueManager = new SaveQueueManager({ logger: this.logger, memory });
    if (true) {
      this.logger.debug(`[Agents:${this.name}] - Starting generation`, { runId });
    }
    const capabilities = { agentName: this.name, logger: this.logger, getMemory: this.getMemory.bind(this), getModel: this.getModel.bind(this), generateMessageId: this.#mastra?.generateId?.bind(this.#mastra) || (() => randomUUID3()), _agentNetworkAppend: "_agentNetworkAppend" in this ? Boolean(this._agentNetworkAppend) : void 0, saveStepMessages: this.saveStepMessages.bind(this), convertTools: this.convertTools.bind(this), getMemoryMessages: this.getMemoryMessages.bind(this), runInputProcessors: this.__runInputProcessors.bind(this), executeOnFinish: this.#executeOnFinish.bind(this), outputProcessors: this.#outputProcessors, llm, getTelemetry: this.#mastra?.getTelemetry?.bind(this.#mastra) };
    const executionWorkflow = createPrepareStreamWorkflow({ capabilities, options: { ...options, methodType }, threadFromArgs, resourceId, runId, runtimeContext, agentAISpan, methodType, format, instructions, memoryConfig, memory, saveQueueManager, returnScorerData: options.returnScorerData, requireToolApproval: options.requireToolApproval, resumeContext, agentId: this.id, toolCallId: options.toolCallId });
    const run = await executionWorkflow.createRunAsync();
    const result = await run.start({ tracingContext: { currentSpan: agentAISpan } });
    return result;
  }
  /**
  * Handles post-execution tasks including memory persistence and title generation.
  * @internal
  */
  async #executeOnFinish({ result, instructions, readOnlyMemory, thread: threadAfter, threadId, resourceId, memoryConfig, outputText, runtimeContext, agentAISpan, runId, messageList, threadExists, structuredOutput = false, saveQueueManager, overrideScorers }) {
    const resToLog = { text: result.text, object: result.object, toolResults: result.toolResults, toolCalls: result.toolCalls, usage: result.usage, steps: result.steps.map((s) => {
      return { stepType: s.stepType, text: s.text, toolResults: s.toolResults, toolCalls: s.toolCalls, usage: s.usage };
    }) };
    this.logger.debug(`[Agent:${this.name}] - Post processing LLM response`, { runId, result: resToLog, threadId, resourceId });
    const messageListResponses = messageList.get.response.aiV4.core();
    const usedWorkingMemory = messageListResponses.some((m) => m.role === "tool" && m.content.some((c) => c.toolName === "updateWorkingMemory"));
    const memory = await this.getMemory({ runtimeContext });
    const thread = usedWorkingMemory ? threadId ? await memory?.getThreadById({ threadId }) : void 0 : threadAfter;
    if (memory && resourceId && thread && !readOnlyMemory) {
      try {
        let responseMessages = result.response.messages;
        if (!responseMessages && result.object) {
          responseMessages = [{ id: result.response.id, role: "assistant", content: [{
            type: "text",
            text: outputText
            // outputText contains the stringified object
          }] }];
        }
        if (responseMessages) {
          messageList.add(responseMessages, "response");
        }
        if (!threadExists) {
          await memory.createThread({ threadId: thread.id, metadata: thread.metadata, title: thread.title, memoryConfig, resourceId: thread.resourceId });
        }
        const promises = [saveQueueManager.flushMessages(messageList, threadId, memoryConfig)];
        if (thread.title?.startsWith("New Thread")) {
          const config4 = memory.getMergedThreadConfig(memoryConfig);
          const userMessage = this.getMostRecentUserMessage(messageList.get.all.ui());
          const { shouldGenerate, model: titleModel, instructions: titleInstructions } = this.resolveTitleGenerationConfig(config4.threads?.generateTitle);
          if (shouldGenerate && userMessage) {
            promises.push(this.genTitle(userMessage, runtimeContext, { currentSpan: agentAISpan }, titleModel, titleInstructions).then((title2) => {
              if (title2) {
                return memory.createThread({ threadId: thread.id, resourceId, memoryConfig, title: title2, metadata: thread.metadata });
              }
            }));
          }
        }
        await Promise.all(promises);
      } catch (e) {
        await saveQueueManager.flushMessages(messageList, threadId, memoryConfig);
        if (e instanceof MastraError) {
          throw e;
        }
        const mastraError = new MastraError({ id: "AGENT_MEMORY_PERSIST_RESPONSE_MESSAGES_FAILED", domain: "AGENT", category: "SYSTEM", details: { agentName: this.name, runId: runId || "", threadId: threadId || "", result: JSON.stringify(resToLog) } }, e);
        this.logger.trackException(mastraError);
        this.logger.error(mastraError.toString());
        throw mastraError;
      }
    } else {
      let responseMessages = result.response.messages;
      if (!responseMessages && result.object) {
        responseMessages = [{ id: result.response.id, role: "assistant", content: [{
          type: "text",
          text: outputText
          // outputText contains the stringified object
        }] }];
      }
      if (responseMessages) {
        messageList.add(responseMessages, "response");
      }
    }
    await this.#runScorers({ messageList, runId, outputText, instructions, runtimeContext, structuredOutput, overrideScorers, tracingContext: { currentSpan: agentAISpan } });
    agentAISpan?.end({ output: { text: result.text, object: result.object, files: result.files } });
  }
  /**
  * Executes a network loop where multiple agents can collaborate to handle messages.
  * The routing agent delegates tasks to appropriate sub-agents based on the conversation.
  *
  * @experimental
  *
  * @example
  * ```typescript
  * const result = await agent.network('Find the weather in Tokyo and plan an activity', {
  *   memory: {
  *     thread: 'user-123',
  *     resource: 'my-app'
  *   },
  *   maxSteps: 10
  * });
  *
  * for await (const chunk of result.stream) {
  *   console.log(chunk);
  * }
  * ```
  */
  async network(messages, options) {
    const runId = options?.runId || this.#mastra?.generateId() || randomUUID3();
    const runtimeContextToUse = options?.runtimeContext || new RuntimeContext();
    return await networkLoop({ networkName: this.name, runtimeContext: runtimeContextToUse, runId, routingAgent: this, routingAgentOptions: { telemetry: options?.telemetry, modelSettings: options?.modelSettings, memory: options?.memory }, generateId: /* @__PURE__ */ __name(() => this.#mastra?.generateId() || randomUUID3(), "generateId"), maxIterations: options?.maxSteps || 1, messages, threadId: typeof options?.memory?.thread === "string" ? options?.memory?.thread : options?.memory?.thread?.id, resourceId: options?.memory?.resource });
  }
  /**
  * @deprecated `generateVNext()` has been renamed to `generate()`. Please use `generate()` instead.
  */
  async generateVNext(_messages, _options) {
    throw new MastraError({ id: "AGENT_GENERATE_VNEXT_DEPRECATED", domain: "AGENT", category: "USER", text: "generateVNext has been renamed to generate. Please use generate instead." });
  }
  async generate(messages, options) {
    if (options?.structuredOutput?.schema && options?.output) {
      throw new MastraError({ id: "AGENT_GENERATE_STRUCTURED_OUTPUT_AND_OUTPUT_PROVIDED", domain: "AGENT", category: "USER", text: "structuredOutput and output cannot be provided at the same time to agent.generate" });
    }
    const normalizedOptions = options?.output ? { structuredOutput: { schema: options.output, ...options.structuredOutput }, ...options, output: void 0 } : options;
    const result = await this.stream(messages, { ...normalizedOptions, methodType: "generate" });
    const fullOutput = await result.getFullOutput();
    const error87 = fullOutput.error;
    if (fullOutput.finishReason === "error" && error87) {
      throw error87;
    }
    return fullOutput;
  }
  /**
  * @deprecated `streamVNext()` has been renamed to `stream()`. Please use `stream()` instead.
  */
  async streamVNext(_messages, _streamOptions) {
    throw new MastraError({ id: "AGENT_STREAM_VNEXT_DEPRECATED", domain: "AGENT", category: "USER", text: "streamVNext has been renamed to stream. Please use stream instead." });
  }
  async stream(messages, streamOptions) {
    const defaultStreamOptions = await this.getDefaultVNextStreamOptions({ runtimeContext: streamOptions?.runtimeContext });
    if (streamOptions?.structuredOutput?.schema && streamOptions?.output) {
      throw new MastraError({ id: "AGENT_STREAM_STRUCTURED_OUTPUT_AND_OUTPUT_PROVIDED", domain: "AGENT", category: "USER", text: "structuredOutput and output cannot be provided at the same time to agent.stream" });
    }
    const baseStreamOptions = { ...defaultStreamOptions, ...streamOptions ?? {}, onFinish: this.#mergeOnFinishWithTelemetry(streamOptions, defaultStreamOptions) };
    const mergedStreamOptions = baseStreamOptions.output ? { structuredOutput: { schema: baseStreamOptions.output, ...baseStreamOptions.structuredOutput }, ...baseStreamOptions, output: void 0 } : baseStreamOptions;
    const llm = await this.getLLM({ runtimeContext: mergedStreamOptions.runtimeContext });
    const modelInfo = llm.getModel();
    if ("structuredOutput" in mergedStreamOptions && mergedStreamOptions.structuredOutput && mergedStreamOptions.structuredOutput.schema) {
      let structuredOutputModel = llm.getModel();
      if (mergedStreamOptions.structuredOutput?.model) {
        structuredOutputModel = await this.resolveModelConfig(mergedStreamOptions.structuredOutput?.model, mergedStreamOptions.runtimeContext || new RuntimeContext());
      }
      const targetProvider = structuredOutputModel.provider;
      const targetModelId = structuredOutputModel.modelId;
      if (targetProvider.includes("openai") || targetModelId.includes("openai")) {
        if (isZodType2(mergedStreamOptions.structuredOutput.schema) && targetModelId) {
          const modelInfo2 = {
            provider: targetProvider,
            modelId: targetModelId,
            supportsStructuredOutputs: false
            // Set to false to enable transform
          };
          const isReasoningModel2 = /^o[1-5]/.test(targetModelId);
          const compatLayer = isReasoningModel2 ? new OpenAIReasoningSchemaCompatLayer(modelInfo2) : new OpenAISchemaCompatLayer(modelInfo2);
          if (compatLayer.shouldApply() && mergedStreamOptions.structuredOutput.schema) {
            mergedStreamOptions.structuredOutput.schema = compatLayer.processZodType(mergedStreamOptions.structuredOutput.schema);
          }
        }
      }
    }
    if (modelInfo.specificationVersion !== "v2") {
      const modelId = modelInfo.modelId || "unknown";
      const provider = modelInfo.provider || "unknown";
      throw new MastraError({ id: "AGENT_STREAM_V1_MODEL_NOT_SUPPORTED", domain: "AGENT", category: "USER", text: `Agent "${this.name}" is using AI SDK v4 model (${provider}:${modelId}) which is not compatible with stream(). Please use AI SDK v5 models or call the streamLegacy() method instead. See https://mastra.ai/en/docs/streaming/overview for more information.`, details: { agentName: this.name, modelId, provider, specificationVersion: modelInfo.specificationVersion } });
    }
    const executeOptions = { ...mergedStreamOptions, messages, methodType: baseStreamOptions.methodType || "stream" };
    const result = await this.#execute(executeOptions);
    if (result.status !== "success") {
      if (result.status === "failed") {
        throw new MastraError(
          {
            id: "AGENT_STREAM_FAILED",
            domain: "AGENT",
            category: "USER"
            /* USER */
          },
          // pass original error to preserve stack trace
          result.error
        );
      }
      throw new MastraError({ id: "AGENT_STREAM_UNKNOWN_ERROR", domain: "AGENT", category: "USER", text: "An unknown error occurred while streaming" });
    }
    if (streamOptions?.format === "aisdk") {
      this.logger.warn('The `format: "aisdk"` is deprecated in stream/generate options. Use the @mastra/ai-sdk package instead. See https://mastra.ai/en/docs/frameworks/agentic-uis/ai-sdk#streaming');
    }
    return result.result;
  }
  /**
  * Resumes a previously suspended VNext stream execution.
  * Used to continue execution after a suspension point (e.g., tool approval, workflow suspend).
  *
  * @example
  * ```typescript
  * // Resume after suspension
  * const stream = await agent.resumeStreamVNext(
  *   { approved: true },
  *   { runId: 'previous-run-id' }
  * );
  * ```
  */
  async resumeStream(resumeData, streamOptions) {
    const defaultStreamOptions = await this.getDefaultVNextStreamOptions({ runtimeContext: streamOptions?.runtimeContext });
    let mergedStreamOptions = { ...defaultStreamOptions, ...streamOptions, onFinish: this.#mergeOnFinishWithTelemetry(streamOptions, defaultStreamOptions) };
    const llm = await this.getLLM({ runtimeContext: mergedStreamOptions.runtimeContext });
    if (llm.getModel().specificationVersion !== "v2") {
      throw new MastraError({ id: "AGENT_STREAM_VNEXT_V1_MODEL_NOT_SUPPORTED", domain: "AGENT", category: "USER", text: "V1 models are not supported for stream. Please use streamLegacy instead." });
    }
    const existingSnapshot = await this.#mastra?.getStorage()?.loadWorkflowSnapshot({ workflowName: "agentic-loop", runId: streamOptions?.runId ?? "" });
    const result = await this.#execute({ ...mergedStreamOptions, messages: [], resumeContext: { resumeData, snapshot: existingSnapshot }, methodType: "stream" });
    if (result.status !== "success") {
      if (result.status === "failed") {
        throw new MastraError(
          {
            id: "AGENT_STREAM_VNEXT_FAILED",
            domain: "AGENT",
            category: "USER"
            /* USER */
          },
          // pass original error to preserve stack trace
          result.error
        );
      }
      throw new MastraError({ id: "AGENT_STREAM_VNEXT_UNKNOWN_ERROR", domain: "AGENT", category: "USER", text: "An unknown error occurred while streaming" });
    }
    return result.result;
  }
  /**
  * Approves a pending tool call and resumes execution.
  * Used when `requireToolApproval` is enabled to allow the agent to proceed with a tool call.
  *
  * @example
  * ```typescript
  * const stream = await agent.approveToolCall({
  *   runId: 'pending-run-id'
  * });
  *
  * for await (const chunk of stream) {
  *   console.log(chunk);
  * }
  * ```
  */
  async approveToolCall(options) {
    return this.resumeStream({ approved: true }, options);
  }
  /**
  * Declines a pending tool call and resumes execution.
  * Used when `requireToolApproval` is enabled to prevent the agent from executing a tool call.
  *
  * @example
  * ```typescript
  * const stream = await agent.declineToolCall({
  *   runId: 'pending-run-id'
  * });
  *
  * for await (const chunk of stream) {
  *   console.log(chunk);
  * }
  * ```
  */
  async declineToolCall(options) {
    return this.resumeStream({ approved: false }, options);
  }
  async generateLegacy(messages, generateOptions = {}) {
    if ("structuredOutput" in generateOptions && generateOptions.structuredOutput) {
      throw new MastraError({ id: "AGENT_GENERATE_LEGACY_STRUCTURED_OUTPUT_NOT_SUPPORTED", domain: "AGENT", category: "USER", text: "This method does not support structured output. Please use generateVNext instead." });
    }
    const defaultGenerateOptions = await this.getDefaultGenerateOptions({ runtimeContext: generateOptions.runtimeContext });
    const mergedGenerateOptions = { ...defaultGenerateOptions, ...generateOptions, experimental_generateMessageId: defaultGenerateOptions.experimental_generateMessageId || this.#mastra?.generateId?.bind(this.#mastra) };
    const { llm, before, after } = await this.prepareLLMOptions(messages, mergedGenerateOptions, "generate");
    if (llm.getModel().specificationVersion !== "v1") {
      this.logger.error("V2 models are not supported for generateLegacy. Please use generate instead.", { modelId: llm.getModel().modelId });
      throw new MastraError({ id: "AGENT_GENERATE_V2_MODEL_NOT_SUPPORTED", domain: "AGENT", category: "USER", details: { modelId: llm.getModel().modelId }, text: "V2 models are not supported for generateLegacy. Please use generate instead." });
    }
    let llmToUse = llm;
    const beforeResult = await before();
    const traceId = getValidTraceId(beforeResult.agentAISpan);
    if (beforeResult.tripwire) {
      const tripwireResult = { text: "", object: void 0, usage: { totalTokens: 0, promptTokens: 0, completionTokens: 0 }, finishReason: "other", response: { id: randomUUID3(), timestamp: /* @__PURE__ */ new Date(), modelId: "tripwire", messages: [] }, responseMessages: [], toolCalls: [], toolResults: [], warnings: void 0, request: { body: JSON.stringify({ messages: [] }) }, experimental_output: void 0, steps: void 0, experimental_providerMetadata: void 0, tripwire: true, tripwireReason: beforeResult.tripwireReason, traceId };
      return tripwireResult;
    }
    const { experimental_output, output, agentAISpan, ...llmOptions } = beforeResult;
    const tracingContext = { currentSpan: agentAISpan };
    let finalOutputProcessors = mergedGenerateOptions.outputProcessors;
    if (!output || experimental_output) {
      const result2 = await llmToUse.__text({ ...llmOptions, tracingContext, experimental_output });
      const outputProcessorResult2 = await this.__runOutputProcessors({ runtimeContext: mergedGenerateOptions.runtimeContext || new RuntimeContext(), tracingContext, outputProcessorOverrides: finalOutputProcessors, messageList: new MessageList({ threadId: llmOptions.threadId || "", resourceId: llmOptions.resourceId || "" }).add({ role: "assistant", content: [{ type: "text", text: result2.text }] }, "response") });
      if (outputProcessorResult2.tripwireTriggered) {
        const tripwireResult = { text: "", object: void 0, usage: { totalTokens: 0, promptTokens: 0, completionTokens: 0 }, finishReason: "other", response: { id: randomUUID3(), timestamp: /* @__PURE__ */ new Date(), modelId: "tripwire", messages: [] }, responseMessages: [], toolCalls: [], toolResults: [], warnings: void 0, request: { body: JSON.stringify({ messages: [] }) }, experimental_output: void 0, steps: void 0, experimental_providerMetadata: void 0, tripwire: true, tripwireReason: outputProcessorResult2.tripwireReason, traceId };
        return tripwireResult;
      }
      const newText2 = outputProcessorResult2.messageList.get.response.v2().map((msg) => msg.content.parts.map((part) => part.type === "text" ? part.text : "").join("")).join("");
      result2.text = newText2;
      if (finalOutputProcessors && finalOutputProcessors.length > 0) {
        const messages2 = outputProcessorResult2.messageList.get.response.v2();
        this.logger.debug("Checking messages for experimentalOutput metadata:", messages2.map((m) => ({ role: m.role, hasContentMetadata: !!m.content.metadata, contentMetadata: m.content.metadata })));
        const messagesWithStructuredData = messages2.filter((msg) => msg.content.metadata && msg.content.metadata.structuredOutput);
        this.logger.debug("Messages with structured data:", messagesWithStructuredData.length);
        if (messagesWithStructuredData[0] && messagesWithStructuredData[0].content.metadata?.structuredOutput) {
          result2.object = messagesWithStructuredData[0].content.metadata.structuredOutput;
          this.logger.debug("Using structured data from processor metadata for result.object");
        } else {
          try {
            const processedOutput = JSON.parse(newText2);
            result2.object = processedOutput;
            this.logger.debug("Using fallback JSON parsing for result.object");
          } catch (error87) {
            this.logger.warn("Failed to parse processed output as JSON, updating text only", { error: error87 });
          }
        }
      }
      const overrideScorers = mergedGenerateOptions.scorers;
      const afterResult2 = await after({ result: result2, outputText: newText2, agentAISpan, ...overrideScorers ? { overrideScorers } : {} });
      if (generateOptions.returnScorerData) {
        result2.scoringData = afterResult2.scoringData;
      }
      result2.traceId = traceId;
      return result2;
    }
    const result = await llmToUse.__textObject({ ...llmOptions, tracingContext, structuredOutput: output });
    const outputText = JSON.stringify(result.object);
    const outputProcessorResult = await this.__runOutputProcessors({ runtimeContext: mergedGenerateOptions.runtimeContext || new RuntimeContext(), tracingContext, messageList: new MessageList({ threadId: llmOptions.threadId || "", resourceId: llmOptions.resourceId || "" }).add({ role: "assistant", content: [{ type: "text", text: outputText }] }, "response") });
    if (outputProcessorResult.tripwireTriggered) {
      const tripwireResult = { text: "", object: void 0, usage: { totalTokens: 0, promptTokens: 0, completionTokens: 0 }, finishReason: "other", response: { id: randomUUID3(), timestamp: /* @__PURE__ */ new Date(), modelId: "tripwire", messages: [] }, responseMessages: [], toolCalls: [], toolResults: [], warnings: void 0, request: { body: JSON.stringify({ messages: [] }) }, experimental_output: void 0, steps: void 0, experimental_providerMetadata: void 0, tripwire: true, tripwireReason: outputProcessorResult.tripwireReason, traceId };
      return tripwireResult;
    }
    const newText = outputProcessorResult.messageList.get.response.v2().map((msg) => msg.content.parts.map((part) => part.type === "text" ? part.text : "").join("")).join("");
    try {
      const processedObject = JSON.parse(newText);
      result.object = processedObject;
    } catch (error87) {
      this.logger.warn("Failed to parse processed output as JSON, keeping original result", { error: error87 });
    }
    const afterResult = await after({ result, outputText: newText, ...generateOptions.scorers ? { overrideScorers: generateOptions.scorers } : {}, structuredOutput: true, agentAISpan });
    if (generateOptions.returnScorerData) {
      result.scoringData = afterResult.scoringData;
    }
    result.traceId = traceId;
    return result;
  }
  async streamLegacy(messages, streamOptions = {}) {
    const defaultStreamOptions = await this.getDefaultStreamOptions({ runtimeContext: streamOptions.runtimeContext });
    const mergedStreamOptions = { ...defaultStreamOptions, ...streamOptions, onFinish: this.#mergeOnFinishWithTelemetry(streamOptions, defaultStreamOptions), experimental_generateMessageId: defaultStreamOptions.experimental_generateMessageId || this.#mastra?.generateId?.bind(this.#mastra) };
    const { llm, before, after } = await this.prepareLLMOptions(messages, mergedStreamOptions, "stream");
    if (llm.getModel().specificationVersion !== "v1") {
      this.logger.error("V2 models are not supported for streamLegacy. Please use stream instead.", { modelId: llm.getModel().modelId });
      throw new MastraError({ id: "AGENT_STREAM_V2_MODEL_NOT_SUPPORTED", domain: "AGENT", category: "USER", details: { modelId: llm.getModel().modelId }, text: "V2 models are not supported for streamLegacy. Please use stream instead." });
    }
    const beforeResult = await before();
    const traceId = getValidTraceId(beforeResult.agentAISpan);
    if (beforeResult.tripwire) {
      const emptyResult = { textStream: (async function* () {
      })(), fullStream: Promise.resolve("").then(() => {
        const emptyStream = new globalThis.ReadableStream({ start(controller) {
          controller.close();
        } });
        return emptyStream;
      }), text: Promise.resolve(""), usage: Promise.resolve({ totalTokens: 0, promptTokens: 0, completionTokens: 0 }), finishReason: Promise.resolve("other"), tripwire: true, tripwireReason: beforeResult.tripwireReason, response: { id: randomUUID3(), timestamp: /* @__PURE__ */ new Date(), modelId: "tripwire", messages: [] }, toolCalls: Promise.resolve([]), toolResults: Promise.resolve([]), warnings: Promise.resolve(void 0), request: { body: JSON.stringify({ messages: [] }) }, experimental_output: void 0, steps: void 0, experimental_providerMetadata: void 0, traceId, toAIStream: /* @__PURE__ */ __name(() => Promise.resolve("").then(() => {
        const emptyStream = new globalThis.ReadableStream({ start(controller) {
          controller.close();
        } });
        return emptyStream;
      }), "toAIStream"), get experimental_partialOutputStream() {
        return (async function* () {
        })();
      }, pipeDataStreamToResponse: /* @__PURE__ */ __name(() => Promise.resolve(), "pipeDataStreamToResponse"), pipeTextStreamToResponse: /* @__PURE__ */ __name(() => Promise.resolve(), "pipeTextStreamToResponse"), toDataStreamResponse: /* @__PURE__ */ __name(() => new Response("", { status: 200, headers: { "Content-Type": "text/plain" } }), "toDataStreamResponse"), toTextStreamResponse: /* @__PURE__ */ __name(() => new Response("", { status: 200, headers: { "Content-Type": "text/plain" } }), "toTextStreamResponse") };
      return emptyResult;
    }
    const { onFinish, runId, output, experimental_output, agentAISpan, ...llmOptions } = beforeResult;
    const overrideScorers = mergedStreamOptions.scorers;
    const tracingContext = { currentSpan: agentAISpan };
    if (!output || experimental_output) {
      this.logger.debug(`Starting agent ${this.name} llm stream call`, { runId });
      const streamResult = llm.__stream({ ...llmOptions, experimental_output, tracingContext, outputProcessors: await this.getResolvedOutputProcessors(mergedStreamOptions.runtimeContext), onFinish: /* @__PURE__ */ __name(async (result) => {
        try {
          const outputText = result.text;
          await after({ result, outputText, agentAISpan, ...overrideScorers ? { overrideScorers } : {} });
        } catch (e) {
          this.logger.error("Error saving memory on finish", { error: e, runId });
        }
        await onFinish?.({ ...result, runId });
      }, "onFinish"), runId });
      streamResult.traceId = traceId;
      return streamResult;
    }
    this.logger.debug(`Starting agent ${this.name} llm streamObject call`, { runId });
    const streamObjectResult = llm.__streamObject({ ...llmOptions, tracingContext, onFinish: /* @__PURE__ */ __name(async (result) => {
      try {
        const outputText = JSON.stringify(result.object);
        await after({ result, outputText, structuredOutput: true, agentAISpan, ...overrideScorers ? { overrideScorers } : {} });
      } catch (e) {
        this.logger.error("Error saving memory on finish", { error: e, runId });
      }
      await onFinish?.({ ...result, runId });
    }, "onFinish"), runId, structuredOutput: output });
    streamObjectResult.traceId = traceId;
    return streamObjectResult;
  }
  /**
  * Convert text to speech using the configured voice provider
  * @param input Text or text stream to convert to speech
  * @param options Speech options including speaker and provider-specific options
  * @returns Audio stream
  * @deprecated Use agent.voice.speak() instead
  */
  async speak(input, options) {
    if (!this.voice) {
      const mastraError = new MastraError({ id: "AGENT_SPEAK_METHOD_VOICE_NOT_CONFIGURED", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "No voice provider configured" });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    this.logger.warn("Warning: agent.speak() is deprecated. Please use agent.voice.speak() instead.");
    try {
      return this.voice.speak(input, options);
    } catch (e) {
      let err;
      if (e instanceof MastraError) {
        err = e;
      } else {
        err = new MastraError({ id: "AGENT_SPEAK_METHOD_ERROR", domain: "AGENT", category: "UNKNOWN", details: { agentName: this.name }, text: "Error during agent speak" }, e);
      }
      this.logger.trackException(err);
      this.logger.error(err.toString());
      throw err;
    }
  }
  /**
  * Convert speech to text using the configured voice provider
  * @param audioStream Audio stream to transcribe
  * @param options Provider-specific transcription options
  * @returns Text or text stream
  * @deprecated Use agent.voice.listen() instead
  */
  async listen(audioStream, options) {
    if (!this.voice) {
      const mastraError = new MastraError({ id: "AGENT_LISTEN_METHOD_VOICE_NOT_CONFIGURED", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "No voice provider configured" });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    this.logger.warn("Warning: agent.listen() is deprecated. Please use agent.voice.listen() instead");
    try {
      return this.voice.listen(audioStream, options);
    } catch (e) {
      let err;
      if (e instanceof MastraError) {
        err = e;
      } else {
        err = new MastraError({ id: "AGENT_LISTEN_METHOD_ERROR", domain: "AGENT", category: "UNKNOWN", details: { agentName: this.name }, text: "Error during agent listen" }, e);
      }
      this.logger.trackException(err);
      this.logger.error(err.toString());
      throw err;
    }
  }
  /**
  * Get a list of available speakers from the configured voice provider
  * @throws {Error} If no voice provider is configured
  * @returns {Promise<Array<{voiceId: string}>>} List of available speakers
  * @deprecated Use agent.voice.getSpeakers() instead
  */
  async getSpeakers() {
    if (!this.voice) {
      const mastraError = new MastraError({ id: "AGENT_SPEAKERS_METHOD_VOICE_NOT_CONFIGURED", domain: "AGENT", category: "USER", details: { agentName: this.name }, text: "No voice provider configured" });
      this.logger.trackException(mastraError);
      this.logger.error(mastraError.toString());
      throw mastraError;
    }
    this.logger.warn("Warning: agent.getSpeakers() is deprecated. Please use agent.voice.getSpeakers() instead.");
    try {
      return await this.voice.getSpeakers();
    } catch (e) {
      let err;
      if (e instanceof MastraError) {
        err = e;
      } else {
        err = new MastraError({ id: "AGENT_GET_SPEAKERS_METHOD_ERROR", domain: "AGENT", category: "UNKNOWN", details: { agentName: this.name }, text: "Error during agent getSpeakers" }, e);
      }
      this.logger.trackException(err);
      this.logger.error(err.toString());
      throw err;
    }
  }
  /**
  * Converts the agent to a workflow step for use in legacy workflows.
  * The step accepts a prompt and returns text output.
  *
  * @deprecated Use agent directly in workflows instead
  *
  * @example
  * ```typescript
  * const agentStep = agent.toStep();
  * const workflow = new Workflow({
  *   steps: {
  *     analyze: agentStep
  *   }
  * });
  * ```
  */
  toStep() {
    const x = agentToStep(this);
    return new LegacyStep(x);
  }
  /**
  * Resolves the configuration for title generation.
  * @internal
  */
  resolveTitleGenerationConfig(generateTitleConfig) {
    if (typeof generateTitleConfig === "boolean") {
      return { shouldGenerate: generateTitleConfig };
    }
    if (typeof generateTitleConfig === "object" && generateTitleConfig !== null) {
      return { shouldGenerate: true, model: generateTitleConfig.model, instructions: generateTitleConfig.instructions };
    }
    return { shouldGenerate: false };
  }
  /**
  * Resolves title generation instructions, handling both static strings and dynamic functions
  * @internal
  */
  async resolveTitleInstructions(runtimeContext, instructions) {
    const DEFAULT_TITLE_INSTRUCTIONS = `
      - you will generate a short title based on the first message a user begins a conversation with
      - ensure it is not more than 80 characters long
      - the title should be a summary of the user's message
      - do not use quotes or colons
      - the entire text you return will be used as the title`;
    if (!instructions) {
      return DEFAULT_TITLE_INSTRUCTIONS;
    }
    if (typeof instructions === "string") {
      return instructions;
    } else {
      const result = instructions({ runtimeContext, mastra: this.#mastra });
      return resolveMaybePromise(result, (resolvedInstructions) => {
        return resolvedInstructions || DEFAULT_TITLE_INSTRUCTIONS;
      });
    }
  }
};
Agent = /* @__PURE__ */ ((_) => {
  _init2 = __decoratorStart(_a60);
  Agent = __decorateElement(_init2, 0, "Agent", _Agent_decorators, Agent);
  __runInitializers(_init2, 1, Agent);
  return Agent;
})();
async function tryGenerateWithJsonFallback(agent, prompt, options) {
  if (!options.structuredOutput?.schema) {
    throw new MastraError({ id: "STRUCTURED_OUTPUT_OPTIONS_REQUIRED", domain: "AGENT", category: "USER", text: "structuredOutput is required to use tryGenerateWithJsonFallback" });
  }
  try {
    return await agent.generate(prompt, options);
  } catch (error87) {
    console.warn("Error in tryGenerateWithJsonFallback. Attempting fallback.", error87);
    return await agent.generate(prompt, { ...options, structuredOutput: { ...options.structuredOutput, jsonPromptInjection: true } });
  }
}
__name(tryGenerateWithJsonFallback, "tryGenerateWithJsonFallback");
var AISDKV5OutputStream = class {
  static {
    __name(this, "AISDKV5OutputStream");
  }
  #modelOutput;
  #options;
  #messageList;
  /**
  * Trace ID used on the execution (if the execution was traced).
  */
  traceId;
  constructor({ modelOutput, options, messageList }) {
    this.#modelOutput = modelOutput;
    this.#options = options;
    this.#messageList = messageList;
    this.traceId = getValidTraceId(options.tracingContext?.currentSpan);
  }
  toTextStreamResponse(init) {
    return createTextStreamResponse({
      // Type assertion needed due to ReadableStream type mismatch between Node.js (stream/web) and DOM types
      // Both have the same interface but TypeScript treats them as incompatible
      textStream: this.#modelOutput.textStream,
      ...init
    });
  }
  toUIMessageStreamResponse({ generateMessageId, originalMessages, sendFinish, sendReasoning, sendSources, onError, sendStart, messageMetadata, onFinish, ...init } = {}) {
    return createUIMessageStreamResponse({ stream: this.toUIMessageStream({ generateMessageId, originalMessages, sendFinish, sendReasoning, sendSources, onError, sendStart, messageMetadata, onFinish }), ...init });
  }
  toUIMessageStream({ generateMessageId, originalMessages, sendFinish = true, sendReasoning = true, sendSources = false, onError = getErrorMessage13, sendStart = true, messageMetadata, onFinish } = {}) {
    let responseMessageId = generateMessageId != null ? getResponseUIMessageId({ originalMessages, responseMessageId: generateMessageId }) : void 0;
    return createUIMessageStream({ onError, onFinish, generateId: /* @__PURE__ */ __name(() => responseMessageId ?? generateMessageId?.() ?? generateId(), "generateId"), execute: /* @__PURE__ */ __name(async ({ writer }) => {
      for await (const part of this.fullStream) {
        const messageMetadataValue = messageMetadata?.({ part });
        const partType = part.type;
        responseMessageId = this.#modelOutput.messageId;
        const transformedChunk = convertFullStreamChunkToUIMessageStream({ part, sendReasoning, messageMetadataValue, sendSources, sendStart, sendFinish, responseMessageId, onError });
        if (transformedChunk) {
          writer.write(transformedChunk);
        }
        if (messageMetadataValue != null && partType !== "start" && partType !== "finish") {
          writer.write({ type: "message-metadata", messageMetadata: messageMetadataValue });
        }
      }
    }, "execute") });
  }
  async consumeStream(options) {
    await this.#modelOutput.consumeStream(options);
  }
  get sources() {
    return this.#modelOutput.sources.then((sources) => sources.map((source) => {
      return convertMastraChunkToAISDKv5({ chunk: source });
    }));
  }
  get files() {
    return this.#modelOutput.files.then((files) => files.map((file3) => {
      if (file3.type === "file") {
        const result = convertMastraChunkToAISDKv5({ chunk: file3 });
        return result && "file" in result ? result.file : void 0;
      }
      return;
    }).filter(Boolean));
  }
  get text() {
    return this.#modelOutput.text;
  }
  /**
  * Stream of valid JSON chunks. The final JSON result is validated against the output schema when the stream ends.
  */
  get objectStream() {
    return this.#modelOutput.objectStream;
  }
  get toolCalls() {
    return this.#modelOutput.toolCalls.then((toolCalls) => toolCalls.map((toolCall) => {
      return convertMastraChunkToAISDKv5({ chunk: toolCall });
    }));
  }
  get toolResults() {
    return this.#modelOutput.toolResults.then((toolResults) => toolResults.map((toolResult) => {
      return convertMastraChunkToAISDKv5({ chunk: toolResult });
    }));
  }
  get reasoningText() {
    return this.#modelOutput.reasoningText;
  }
  get reasoning() {
    return this.#modelOutput.reasoning.then((reasoningChunk) => {
      return reasoningChunk.map((reasoningPart) => {
        return { providerMetadata: reasoningPart.payload.providerMetadata, text: reasoningPart.payload.text, type: "reasoning" };
      });
    });
  }
  get warnings() {
    return this.#modelOutput.warnings;
  }
  get usage() {
    return this.#modelOutput.usage;
  }
  get finishReason() {
    return this.#modelOutput.finishReason;
  }
  get providerMetadata() {
    return this.#modelOutput.providerMetadata;
  }
  get request() {
    return this.#modelOutput.request;
  }
  get totalUsage() {
    return this.#modelOutput.totalUsage;
  }
  get response() {
    return this.#modelOutput.response.then((response) => ({ ...response }));
  }
  get steps() {
    return this.#modelOutput.steps.then((steps) => steps);
  }
  get content() {
    return this.#messageList.get.response.aiV5.modelContent();
  }
  /**
  * Stream of only text content, compatible with streaming text responses.
  */
  get textStream() {
    return this.#modelOutput.textStream;
  }
  /**
  * Stream of individual array elements when output schema is an array type.
  */
  get elementStream() {
    return this.#modelOutput.elementStream;
  }
  /**
  * Stream of all chunks in AI SDK v5 format.
  */
  get fullStream() {
    let startEvent;
    let hasStarted = false;
    return this.#modelOutput.fullStream.pipeThrough(new TransformStream3({ transform(chunk, controller) {
      if (chunk.type === "object") {
        controller.enqueue(chunk);
        return;
      }
      if (chunk.type === "step-start" && !startEvent) {
        startEvent = convertMastraChunkToAISDKv5({ chunk });
        return;
      } else if (chunk.type !== "error") {
        hasStarted = true;
      }
      if (startEvent && hasStarted) {
        controller.enqueue(startEvent);
        startEvent = void 0;
      }
      if ("payload" in chunk) {
        const transformedChunk = convertMastraChunkToAISDKv5({ chunk });
        if (transformedChunk) {
          controller.enqueue(transformedChunk);
        }
      }
    } }));
  }
  async getFullOutput() {
    await this.consumeStream({ onError: /* @__PURE__ */ __name((error87) => {
      console.error(error87);
      throw error87;
    }, "onError") });
    const object5 = await this.object;
    const fullOutput = { text: await this.#modelOutput.text, usage: await this.#modelOutput.usage, steps: await this.steps, finishReason: await this.#modelOutput.finishReason, warnings: await this.#modelOutput.warnings, providerMetadata: await this.#modelOutput.providerMetadata, request: await this.#modelOutput.request, reasoning: await this.reasoning, reasoningText: await this.reasoningText, toolCalls: await this.toolCalls, toolResults: await this.toolResults, sources: await this.sources, files: await this.files, response: await this.response, content: this.content, totalUsage: await this.#modelOutput.totalUsage, error: this.error, tripwire: this.#modelOutput.tripwire, tripwireReason: this.#modelOutput.tripwireReason, traceId: this.traceId, ...object5 ? { object: object5 } : {} };
    fullOutput.response.messages = this.#modelOutput.messageList.get.response.aiV5.model();
    return fullOutput;
  }
  get tripwire() {
    return this.#modelOutput.tripwire;
  }
  get tripwireReason() {
    return this.#modelOutput.tripwireReason;
  }
  get error() {
    return this.#modelOutput.error;
  }
  get object() {
    return this.#modelOutput.object;
  }
};
var BaseFormatHandler = class {
  static {
    __name(this, "BaseFormatHandler");
  }
  /**
  * The original user-provided schema (Zod, JSON Schema, or AI SDK Schema).
  */
  schema;
  /**
  * Validate partial chunks as they are streamed. @planned
  */
  validatePartialChunks = false;
  partialSchema;
  constructor(schema, options = {}) {
    this.schema = schema;
    if (options.validatePartialChunks && this.isZodSchema(schema) && "partial" in schema && typeof schema.partial === "function") {
      this.partialSchema = schema.partial();
      this.validatePartialChunks = true;
    }
  }
  /**
  * Checks if the original schema is a Zod schema with safeParse method.
  */
  isZodSchema(schema) {
    return schema !== void 0 && schema !== null && typeof schema === "object" && "safeParse" in schema && typeof schema.safeParse === "function";
  }
  /**
  * Validates a value against the schema, preferring Zod's safeParse.
  */
  async validateValue(value) {
    if (!this.schema) {
      return { success: true, value };
    }
    if (this.isZodSchema(this.schema)) {
      try {
        const result = this.schema.safeParse(value);
        if (result.success) {
          return { success: true, value: result.data };
        } else {
          return { success: false, error: new MastraError({ domain: "AGENT", category: "SYSTEM", id: "STRUCTURED_OUTPUT_SCHEMA_VALIDATION_FAILED", text: `Structured output validation failed
${v4_default.prettifyError(result.error)}
`, details: { value: typeof value === "object" ? JSON.stringify(value) : String(value) } }, result.error) };
        }
      } catch (error87) {
        return { success: false, error: error87 instanceof Error ? error87 : new Error("Zod validation failed", { cause: error87 }) };
      }
    }
    try {
      if (typeof this.schema === "object" && !this.schema.jsonSchema) {
        const result = await safeValidateTypes11({ value, schema: jsonSchema(this.schema) });
        return result;
      } else if (this.schema.jsonSchema) {
        const result = await safeValidateTypes11({ value, schema: this.schema });
        return result;
      } else {
        return { success: true, value };
      }
    } catch (error87) {
      return { success: false, error: error87 instanceof Error ? error87 : new Error("Validation failed", { cause: error87 }) };
    }
  }
  /**
  * Preprocesses accumulated text to handle LLMs that wrap JSON in code blocks.
  * Extracts content from the first complete valid ```json...``` code block or removes opening ```json prefix if no complete code block is found (streaming chunks).
  * @param accumulatedText - Raw accumulated text from streaming
  * @returns Processed text ready for JSON parsing
  */
  preprocessText(accumulatedText) {
    let processedText = accumulatedText;
    if (processedText.includes("<|message|>")) {
      const match2 = processedText.match(/<\|message\|>([\s\S]+)$/);
      if (match2 && match2[1]) {
        processedText = match2[1];
      }
    }
    if (processedText.includes("```json")) {
      const match2 = processedText.match(/```json\s*\n?([\s\S]*?)\n?\s*```/);
      if (match2 && match2[1]) {
        processedText = match2[1].trim();
      } else {
        processedText = processedText.replace(/^```json\s*\n?/, "");
      }
    }
    return processedText;
  }
};
var ObjectFormatHandler = class extends BaseFormatHandler {
  static {
    __name(this, "ObjectFormatHandler");
  }
  type = "object";
  async processPartialChunk({ accumulatedText, previousObject }) {
    const processedAccumulatedText = this.preprocessText(accumulatedText);
    const { value: currentObjectJson, state } = await parsePartialJson(processedAccumulatedText);
    if (this.validatePartialChunks && this.partialSchema) {
      const result = this.partialSchema?.safeParse(currentObjectJson);
      if (result.success && result.data && result.data !== void 0 && !isDeepEqualData(previousObject, result.data)) {
        return { shouldEmit: true, emitValue: result.data, newPreviousResult: result.data };
      }
      return { shouldEmit: false };
    }
    if (currentObjectJson !== void 0 && currentObjectJson !== null && typeof currentObjectJson === "object" && !isDeepEqualData(previousObject, currentObjectJson)) {
      return { shouldEmit: ["successful-parse", "repaired-parse"].includes(state), emitValue: currentObjectJson, newPreviousResult: currentObjectJson };
    }
    return { shouldEmit: false };
  }
  async validateAndTransformFinal(finalRawValue) {
    if (!finalRawValue) {
      return { success: false, error: new Error("No object generated: could not parse the response.") };
    }
    const rawValue = this.preprocessText(finalRawValue);
    const { value } = await parsePartialJson(rawValue);
    return this.validateValue(value);
  }
};
var ArrayFormatHandler = class extends BaseFormatHandler {
  static {
    __name(this, "ArrayFormatHandler");
  }
  type = "array";
  /** Previously filtered array to track changes */
  textPreviousFilteredArray = [];
  /** Whether we've emitted the initial empty array */
  hasEmittedInitialArray = false;
  async processPartialChunk({ accumulatedText, previousObject }) {
    const processedAccumulatedText = this.preprocessText(accumulatedText);
    const { value: currentObjectJson, state: parseState } = await parsePartialJson(processedAccumulatedText);
    if (currentObjectJson !== void 0 && !isDeepEqualData(previousObject, currentObjectJson)) {
      const rawElements = currentObjectJson?.elements || [];
      const filteredElements = [];
      for (let i = 0; i < rawElements.length; i++) {
        const element = rawElements[i];
        if (i === rawElements.length - 1 && parseState !== "successful-parse") {
          if (element && typeof element === "object" && Object.keys(element).length > 0) {
            filteredElements.push(element);
          }
        } else {
          if (element && typeof element === "object" && Object.keys(element).length > 0) {
            filteredElements.push(element);
          }
        }
      }
      if (!this.hasEmittedInitialArray) {
        this.hasEmittedInitialArray = true;
        if (filteredElements.length === 0) {
          this.textPreviousFilteredArray = [];
          return { shouldEmit: true, emitValue: [], newPreviousResult: currentObjectJson };
        }
      }
      if (!isDeepEqualData(this.textPreviousFilteredArray, filteredElements)) {
        this.textPreviousFilteredArray = [...filteredElements];
        return { shouldEmit: true, emitValue: filteredElements, newPreviousResult: currentObjectJson };
      }
    }
    return { shouldEmit: false };
  }
  async validateAndTransformFinal(_finalValue) {
    const resultValue = this.textPreviousFilteredArray;
    if (!resultValue) {
      return { success: false, error: new Error("No object generated: could not parse the response.") };
    }
    return this.validateValue(resultValue);
  }
};
var EnumFormatHandler = class extends BaseFormatHandler {
  static {
    __name(this, "EnumFormatHandler");
  }
  type = "enum";
  /** Previously emitted enum result to avoid duplicate emissions */
  textPreviousEnumResult;
  /**
  * Finds the best matching enum value for a partial result string.
  * If multiple values match, returns the partial string. If only one matches, returns that value.
  * @param partialResult - Partial enum string from streaming
  * @returns Best matching enum value or undefined if no matches
  */
  findBestEnumMatch(partialResult) {
    if (!this.schema) {
      return void 0;
    }
    let enumValues;
    if (this.isZodSchema(this.schema)) {
      const wrappedSchema = asSchema(this.schema);
      enumValues = wrappedSchema.jsonSchema?.enum;
    } else if (typeof this.schema === "object" && !this.schema.jsonSchema) {
      const wrappedSchema = jsonSchema(this.schema);
      enumValues = wrappedSchema.jsonSchema?.enum;
    } else {
      enumValues = this.schema.jsonSchema?.enum;
    }
    if (!enumValues) {
      return void 0;
    }
    const possibleEnumValues = enumValues.filter((value) => typeof value === "string").filter((enumValue) => enumValue.startsWith(partialResult));
    if (possibleEnumValues.length === 0) {
      return void 0;
    }
    const firstMatch = possibleEnumValues[0];
    return possibleEnumValues.length === 1 && firstMatch !== void 0 ? firstMatch : partialResult;
  }
  async processPartialChunk({ accumulatedText, previousObject }) {
    const processedAccumulatedText = this.preprocessText(accumulatedText);
    const { value: currentObjectJson } = await parsePartialJson(processedAccumulatedText);
    if (currentObjectJson !== void 0 && currentObjectJson !== null && typeof currentObjectJson === "object" && !Array.isArray(currentObjectJson) && "result" in currentObjectJson && typeof currentObjectJson.result === "string" && !isDeepEqualData(previousObject, currentObjectJson)) {
      const partialResult = currentObjectJson.result;
      const bestMatch = this.findBestEnumMatch(partialResult);
      if (partialResult.length > 0 && bestMatch && bestMatch !== this.textPreviousEnumResult) {
        this.textPreviousEnumResult = bestMatch;
        return { shouldEmit: true, emitValue: bestMatch, newPreviousResult: currentObjectJson };
      }
    }
    return { shouldEmit: false };
  }
  async validateAndTransformFinal(rawFinalValue) {
    const processedValue = this.preprocessText(rawFinalValue);
    const { value } = await parsePartialJson(processedValue);
    if (!(typeof value === "object" && value !== null && "result" in value)) {
      return { success: false, error: new Error("Invalid enum format: expected object with result property") };
    }
    const finalValue = value;
    if (!finalValue || typeof finalValue !== "object" || typeof finalValue.result !== "string") {
      return { success: false, error: new Error("Invalid enum format: expected object with result property") };
    }
    return this.validateValue(finalValue.result);
  }
};
function createOutputHandler({ schema }) {
  const transformedSchema = getTransformedSchema(schema);
  switch (transformedSchema?.outputFormat) {
    case "array":
      return new ArrayFormatHandler(schema);
    case "enum":
      return new EnumFormatHandler(schema);
    case "object":
    default:
      return new ObjectFormatHandler(schema);
  }
}
__name(createOutputHandler, "createOutputHandler");
function createObjectStreamTransformer({ structuredOutput, logger }) {
  const handler = createOutputHandler({ schema: structuredOutput?.schema });
  let accumulatedText = "";
  let previousObject = void 0;
  let currentRunId;
  let finalResult;
  return new TransformStream3({ async transform(chunk, controller) {
    if (chunk.runId) {
      currentRunId = chunk.runId;
    }
    if (chunk.type === "text-delta" && typeof chunk.payload?.text === "string") {
      accumulatedText += chunk.payload.text;
      const result = await handler.processPartialChunk({ accumulatedText, previousObject });
      if (result.shouldEmit) {
        previousObject = result.newPreviousResult ?? previousObject;
        const chunkData = {
          from: chunk.from,
          runId: chunk.runId,
          type: "object",
          object: result.emitValue
          // TODO: handle partial runtime type validation of json chunks
        };
        controller.enqueue(chunkData);
      }
    }
    if (chunk.type === "text-end") {
      controller.enqueue(chunk);
      if (accumulatedText?.trim() && !finalResult) {
        finalResult = await handler.validateAndTransformFinal(accumulatedText);
        if (finalResult.success) {
          controller.enqueue({ from: "AGENT", runId: currentRunId ?? "", type: "object-result", object: finalResult.value });
        }
      }
      return;
    }
    controller.enqueue(chunk);
  }, async flush(controller) {
    if (finalResult && !finalResult.success) {
      handleValidationError(finalResult.error, controller);
    }
    if (accumulatedText?.trim() && !finalResult) {
      finalResult = await handler.validateAndTransformFinal(accumulatedText);
      if (finalResult.success) {
        controller.enqueue({ from: "AGENT", runId: currentRunId ?? "", type: "object-result", object: finalResult.value });
      } else {
        handleValidationError(finalResult.error, controller);
      }
    }
  } });
  function handleValidationError(error87, controller) {
    if (structuredOutput?.errorStrategy === "warn") {
      logger?.warn(error87.message);
    } else if (structuredOutput?.errorStrategy === "fallback") {
      controller.enqueue({ from: "AGENT", runId: currentRunId ?? "", type: "object-result", object: structuredOutput?.fallbackValue });
    } else {
      controller.enqueue({ from: "AGENT", runId: currentRunId ?? "", type: "error", payload: { error: error87 } });
    }
  }
  __name(handleValidationError, "handleValidationError");
}
__name(createObjectStreamTransformer, "createObjectStreamTransformer");
function createJsonTextStreamTransformer(schema) {
  let previousArrayLength = 0;
  let hasStartedArray = false;
  let chunkCount = 0;
  const outputSchema2 = getTransformedSchema(schema);
  return new TransformStream3({ transform(chunk, controller) {
    if (chunk.type !== "object" || !chunk.object) {
      return;
    }
    if (outputSchema2?.outputFormat === "array") {
      chunkCount++;
      if (chunkCount === 1) {
        if (chunk.object.length > 0) {
          controller.enqueue(JSON.stringify(chunk.object));
          previousArrayLength = chunk.object.length;
          hasStartedArray = true;
          return;
        }
      }
      if (!hasStartedArray) {
        controller.enqueue("[");
        hasStartedArray = true;
      }
      for (let i = previousArrayLength; i < chunk.object.length; i++) {
        const elementJson = JSON.stringify(chunk.object[i]);
        if (i > 0) {
          controller.enqueue("," + elementJson);
        } else {
          controller.enqueue(elementJson);
        }
      }
      previousArrayLength = chunk.object.length;
    } else {
      controller.enqueue(JSON.stringify(chunk.object));
    }
  }, flush(controller) {
    if (hasStartedArray && outputSchema2?.outputFormat === "array" && chunkCount > 1) {
      controller.enqueue("]");
    }
  } });
}
__name(createJsonTextStreamTransformer, "createJsonTextStreamTransformer");
function createDestructurableOutput(output) {
  return new Proxy(output, { get(target, prop, _receiver) {
    const originalValue = Reflect.get(target, prop, target);
    if (typeof originalValue === "function") {
      return originalValue.bind(target);
    }
    return originalValue;
  } });
}
__name(createDestructurableOutput, "createDestructurableOutput");
var MastraModelOutput = class extends MastraBase {
  static {
    __name(this, "MastraModelOutput");
  }
  #status = "running";
  #aisdkv5;
  #error;
  #baseStream;
  #bufferedChunks = [];
  #streamFinished = false;
  #emitter = new EventEmitter$1();
  #bufferedSteps = [];
  #bufferedReasoningDetails = {};
  #bufferedByStep = { text: "", reasoning: [], sources: [], files: [], toolCalls: [], toolResults: [], dynamicToolCalls: [], dynamicToolResults: [], staticToolCalls: [], staticToolResults: [], content: [], usage: { inputTokens: void 0, outputTokens: void 0, totalTokens: void 0 }, warnings: [], request: {}, response: { id: "", timestamp: /* @__PURE__ */ new Date(), modelId: "", messages: [], uiMessages: [] }, reasoningText: "", providerMetadata: void 0, finishReason: void 0 };
  #bufferedText = [];
  #bufferedObject;
  #bufferedTextChunks = {};
  #bufferedSources = [];
  #bufferedReasoning = [];
  #bufferedFiles = [];
  #toolCallArgsDeltas = {};
  #toolCallDeltaIdNameMap = {};
  #toolCalls = [];
  #toolResults = [];
  #warnings = [];
  #finishReason = void 0;
  #request = {};
  #usageCount = { inputTokens: void 0, outputTokens: void 0, totalTokens: void 0 };
  #tripwire = false;
  #tripwireReason = "";
  #delayedPromises = { suspendPayload: new DelayedPromise2(), object: new DelayedPromise2(), finishReason: new DelayedPromise2(), usage: new DelayedPromise2(), warnings: new DelayedPromise2(), providerMetadata: new DelayedPromise2(), response: new DelayedPromise2(), request: new DelayedPromise2(), text: new DelayedPromise2(), reasoning: new DelayedPromise2(), reasoningText: new DelayedPromise2(), sources: new DelayedPromise2(), files: new DelayedPromise2(), toolCalls: new DelayedPromise2(), toolResults: new DelayedPromise2(), steps: new DelayedPromise2(), totalUsage: new DelayedPromise2(), content: new DelayedPromise2() };
  #consumptionStarted = false;
  #returnScorerData = false;
  #structuredOutputMode = void 0;
  #model;
  /**
  * Unique identifier for this execution run.
  */
  runId;
  #options;
  /**
  * The processor runner for this stream.
  */
  processorRunner;
  /**
  * The message list for this stream.
  */
  messageList;
  /**
  * Trace ID used on the execution (if the execution was traced).
  */
  traceId;
  messageId;
  constructor({ model: _model, stream, messageList, options, messageId, initialState }) {
    super({ component: "LLM", name: "MastraModelOutput" });
    this.#options = options;
    this.#returnScorerData = !!options.returnScorerData;
    this.runId = options.runId;
    this.traceId = getValidTraceId(options.tracingContext?.currentSpan);
    this.#model = _model;
    this.messageId = messageId;
    if (options.structuredOutput?.schema) {
      this.#structuredOutputMode = options.structuredOutput.model ? "processor" : "direct";
    }
    if (options.outputProcessors?.length) {
      this.processorRunner = new ProcessorRunner({ inputProcessors: [], outputProcessors: options.outputProcessors, logger: this.logger, agentName: "MastraModelOutput" });
    }
    this.messageList = messageList;
    const self2 = this;
    let processedStream = stream;
    const processorRunner = this.processorRunner;
    if (processorRunner && options.isLLMExecutionStep) {
      const processorStates = options.processorStates || /* @__PURE__ */ new Map();
      processedStream = stream.pipeThrough(new TransformStream3({ async transform(chunk, controller) {
        if (chunk.type === "finish" && chunk.payload?.stepResult?.reason === "tool-calls") {
          controller.enqueue(chunk);
          return;
        } else {
          if (!processorStates.has(STRUCTURED_OUTPUT_PROCESSOR_NAME)) {
            const processorIndex = processorRunner.outputProcessors.findIndex((p) => p.name === STRUCTURED_OUTPUT_PROCESSOR_NAME);
            if (processorIndex !== -1) {
              const structuredOutputProcessorState = new ProcessorState({ processorName: STRUCTURED_OUTPUT_PROCESSOR_NAME, tracingContext: options.tracingContext, processorIndex });
              structuredOutputProcessorState.customState = { controller };
              processorStates.set(STRUCTURED_OUTPUT_PROCESSOR_NAME, structuredOutputProcessorState);
            }
          } else {
            const structuredOutputProcessorState = processorStates.get(STRUCTURED_OUTPUT_PROCESSOR_NAME);
            if (structuredOutputProcessorState) {
              structuredOutputProcessorState.customState.controller = controller;
            }
          }
          const { part: processed, blocked, reason } = await processorRunner.processPart(chunk, processorStates, options.tracingContext);
          if (blocked) {
            controller.enqueue({ type: "tripwire", payload: { tripwireReason: reason || "Output processor blocked content" } });
            return;
          }
          if (processed) {
            controller.enqueue(processed);
          }
        }
      } }));
    }
    if (self2.#structuredOutputMode === "direct" && self2.#options.isLLMExecutionStep) {
      processedStream = processedStream.pipeThrough(createObjectStreamTransformer({ structuredOutput: self2.#options.structuredOutput, logger: self2.logger }));
    }
    this.#baseStream = processedStream.pipeThrough(new TransformStream3({ transform: /* @__PURE__ */ __name(async (chunk, controller) => {
      switch (chunk.type) {
        case "tool-call-suspended":
        case "tool-call-approval":
          self2.#status = "suspended";
          self2.#delayedPromises.suspendPayload.resolve(chunk.payload);
          break;
        case "raw":
          if (!self2.#options.includeRawChunks) {
            return;
          }
          break;
        case "object-result":
          self2.#bufferedObject = chunk.object;
          if (self2.#delayedPromises.object.status.type === "pending") {
            self2.#delayedPromises.object.resolve(chunk.object);
          }
          break;
        case "source":
          self2.#bufferedSources.push(chunk);
          self2.#bufferedByStep.sources.push(chunk);
          break;
        case "text-delta":
          self2.#bufferedText.push(chunk.payload.text);
          self2.#bufferedByStep.text += chunk.payload.text;
          if (chunk.payload.id) {
            const ary = self2.#bufferedTextChunks[chunk.payload.id] ?? [];
            ary.push(chunk.payload.text);
            self2.#bufferedTextChunks[chunk.payload.id] = ary;
          }
          break;
        case "tool-call-input-streaming-start":
          self2.#toolCallDeltaIdNameMap[chunk.payload.toolCallId] = chunk.payload.toolName;
          break;
        case "tool-call-delta":
          if (!self2.#toolCallArgsDeltas[chunk.payload.toolCallId]) {
            self2.#toolCallArgsDeltas[chunk.payload.toolCallId] = [];
          }
          self2.#toolCallArgsDeltas?.[chunk.payload.toolCallId]?.push(chunk.payload.argsTextDelta);
          chunk.payload.toolName ||= self2.#toolCallDeltaIdNameMap[chunk.payload.toolCallId];
          break;
        case "file":
          self2.#bufferedFiles.push(chunk);
          self2.#bufferedByStep.files.push(chunk);
          break;
        case "reasoning-start":
          self2.#bufferedReasoningDetails[chunk.payload.id] = { type: "reasoning", runId: chunk.runId, from: chunk.from, payload: { id: chunk.payload.id, providerMetadata: chunk.payload.providerMetadata, text: "" } };
          break;
        case "reasoning-delta": {
          self2.#bufferedReasoning.push({ type: "reasoning", runId: chunk.runId, from: chunk.from, payload: chunk.payload });
          self2.#bufferedByStep.reasoning.push({ type: "reasoning", runId: chunk.runId, from: chunk.from, payload: chunk.payload });
          const bufferedReasoning = self2.#bufferedReasoningDetails[chunk.payload.id];
          if (bufferedReasoning) {
            bufferedReasoning.payload.text += chunk.payload.text;
            if (chunk.payload.providerMetadata) {
              bufferedReasoning.payload.providerMetadata = chunk.payload.providerMetadata;
            }
          }
          break;
        }
        case "reasoning-end": {
          const bufferedReasoning = self2.#bufferedReasoningDetails[chunk.payload.id];
          if (chunk.payload.providerMetadata && bufferedReasoning) {
            bufferedReasoning.payload.providerMetadata = chunk.payload.providerMetadata;
          }
          break;
        }
        case "tool-call":
          self2.#toolCalls.push(chunk);
          self2.#bufferedByStep.toolCalls.push(chunk);
          const toolCallPayload = chunk.payload;
          if (toolCallPayload?.output?.from === "AGENT" && toolCallPayload?.output?.type === "finish") {
            const finishPayload = toolCallPayload.output.payload;
            if (finishPayload?.usage) {
              self2.updateUsageCount(finishPayload.usage);
            }
          }
          break;
        case "tool-result":
          self2.#toolResults.push(chunk);
          self2.#bufferedByStep.toolResults.push(chunk);
          break;
        case "step-finish": {
          self2.updateUsageCount(chunk.payload.output.usage);
          self2.#warnings = chunk.payload.stepResult.warnings || [];
          if (chunk.payload.metadata.request) {
            self2.#request = chunk.payload.metadata.request;
          }
          const { providerMetadata, request, ...otherMetadata } = chunk.payload.metadata;
          const stepResult = { stepType: self2.#bufferedSteps.length === 0 ? "initial" : "tool-result", sources: self2.#bufferedByStep.sources, files: self2.#bufferedByStep.files, toolCalls: self2.#bufferedByStep.toolCalls, toolResults: self2.#bufferedByStep.toolResults, content: messageList.get.response.aiV5.modelContent(-1), text: self2.#bufferedByStep.text, reasoningText: self2.#bufferedReasoning.map((reasoningPart) => reasoningPart.payload.text).join(""), reasoning: Object.values(self2.#bufferedReasoningDetails), get staticToolCalls() {
            return self2.#bufferedByStep.toolCalls.filter((part) => part.type === "tool-call" && part.payload?.dynamic === false);
          }, get dynamicToolCalls() {
            return self2.#bufferedByStep.toolCalls.filter((part) => part.type === "tool-call" && part.payload?.dynamic === true);
          }, get staticToolResults() {
            return self2.#bufferedByStep.toolResults.filter((part) => part.type === "tool-result" && part.payload?.dynamic === false);
          }, get dynamicToolResults() {
            return self2.#bufferedByStep.toolResults.filter((part) => part.type === "tool-result" && part.payload?.dynamic === true);
          }, finishReason: chunk.payload.stepResult.reason, usage: chunk.payload.output.usage, warnings: self2.#warnings, request: request || {}, response: {
            id: chunk.payload.id || "",
            timestamp: chunk.payload.metadata?.timestamp || /* @__PURE__ */ new Date(),
            modelId: chunk.payload.metadata?.modelId || chunk.payload.metadata?.model || "",
            ...otherMetadata,
            messages: chunk.payload.messages?.nonUser || [],
            // We have to cast this until messageList can take generics also and type metadata, it was too
            // complicated to do this in this PR, it will require a much bigger change.
            uiMessages: messageList.get.response.aiV5.ui()
          }, providerMetadata };
          await options?.onStepFinish?.({ ...self2.#model.modelId && self2.#model.provider && self2.#model.version ? { model: self2.#model } : {}, ...stepResult });
          self2.#bufferedSteps.push(stepResult);
          self2.#bufferedByStep = { text: "", reasoning: [], sources: [], files: [], toolCalls: [], toolResults: [], dynamicToolCalls: [], dynamicToolResults: [], staticToolCalls: [], staticToolResults: [], content: [], usage: { inputTokens: void 0, outputTokens: void 0, totalTokens: void 0 }, warnings: [], request: {}, response: { id: "", timestamp: /* @__PURE__ */ new Date(), modelId: "", messages: [], uiMessages: [] }, reasoningText: "", providerMetadata: void 0, finishReason: void 0 };
          break;
        }
        case "tripwire":
          self2.#tripwire = true;
          self2.#tripwireReason = chunk.payload?.tripwireReason || "Content blocked";
          self2.#finishReason = "other";
          self2.#streamFinished = true;
          self2.#delayedPromises.text.resolve(self2.#bufferedText.join(""));
          self2.#delayedPromises.finishReason.resolve("other");
          self2.#delayedPromises.object.resolve(void 0);
          self2.#delayedPromises.usage.resolve(self2.#usageCount);
          self2.#delayedPromises.warnings.resolve(self2.#warnings);
          self2.#delayedPromises.providerMetadata.resolve(void 0);
          self2.#delayedPromises.response.resolve({});
          self2.#delayedPromises.request.resolve({});
          self2.#delayedPromises.reasoning.resolve([]);
          self2.#delayedPromises.reasoningText.resolve(void 0);
          self2.#delayedPromises.sources.resolve([]);
          self2.#delayedPromises.files.resolve([]);
          self2.#delayedPromises.toolCalls.resolve([]);
          self2.#delayedPromises.toolResults.resolve([]);
          self2.#delayedPromises.steps.resolve(self2.#bufferedSteps);
          self2.#delayedPromises.totalUsage.resolve(self2.#usageCount);
          self2.#delayedPromises.content.resolve([]);
          self2.#emitChunk(chunk);
          controller.enqueue(chunk);
          self2.#emitter.emit("finish");
          controller.terminate();
          return;
        case "finish":
          self2.#status = "success";
          if (chunk.payload.stepResult.reason) {
            self2.#finishReason = chunk.payload.stepResult.reason;
          }
          if (self2.#bufferedObject !== void 0) {
            const responseMessages = messageList.get.response.v2();
            const lastAssistantMessage = [...responseMessages].reverse().find((m) => m.role === "assistant");
            if (lastAssistantMessage) {
              if (!lastAssistantMessage.content.metadata) {
                lastAssistantMessage.content.metadata = {};
              }
              lastAssistantMessage.content.metadata.structuredOutput = self2.#bufferedObject;
            }
          }
          let response = {};
          if (chunk.payload.metadata) {
            const { providerMetadata, request, ...otherMetadata } = chunk.payload.metadata;
            response = { ...otherMetadata, messages: messageList.get.response.aiV5.model(), uiMessages: messageList.get.response.aiV5.ui() };
          }
          this.populateUsageCount(chunk.payload.output.usage);
          chunk.payload.output.usage = { inputTokens: self2.#usageCount.inputTokens ?? 0, outputTokens: self2.#usageCount.outputTokens ?? 0, totalTokens: self2.#usageCount.totalTokens ?? 0, ...self2.#usageCount.reasoningTokens !== void 0 && { reasoningTokens: self2.#usageCount.reasoningTokens }, ...self2.#usageCount.cachedInputTokens !== void 0 && { cachedInputTokens: self2.#usageCount.cachedInputTokens } };
          try {
            if (self2.processorRunner && !self2.#options.isLLMExecutionStep) {
              self2.messageList = await self2.processorRunner.runOutputProcessors(self2.messageList, options.tracingContext);
              const outputText = self2.messageList.get.response.aiV4.core().map((m) => MessageList.coreContentToString(m.content)).join("\n");
              self2.#delayedPromises.text.resolve(outputText);
              self2.#delayedPromises.finishReason.resolve(self2.#finishReason);
              if (chunk.payload.metadata) {
                const { providerMetadata, request, ...otherMetadata } = chunk.payload.metadata;
                response = { ...otherMetadata, messages: messageList.get.response.aiV5.model(), uiMessages: messageList.get.response.aiV5.ui() };
              }
            } else {
              const textContent = self2.#bufferedText.join("");
              self2.#delayedPromises.text.resolve(textContent);
              self2.#delayedPromises.finishReason.resolve(self2.#finishReason);
            }
          } catch (error210) {
            if (error210 instanceof TripWire) {
              self2.#tripwire = true;
              self2.#tripwireReason = error210.message;
              self2.#delayedPromises.finishReason.resolve("other");
              self2.#delayedPromises.text.resolve("");
            } else {
              self2.#error = getErrorFromUnknown(error210, { fallbackMessage: "Unknown error in stream" });
              self2.#delayedPromises.finishReason.resolve("error");
              self2.#delayedPromises.text.resolve("");
            }
            if (self2.#delayedPromises.object.status.type !== "resolved") {
              self2.#delayedPromises.object.resolve(void 0);
            }
          }
          self2.#delayedPromises.usage.resolve(self2.#usageCount);
          self2.#delayedPromises.warnings.resolve(self2.#warnings);
          self2.#delayedPromises.providerMetadata.resolve(chunk.payload.metadata?.providerMetadata);
          self2.#delayedPromises.response.resolve(response);
          self2.#delayedPromises.request.resolve(self2.#request || {});
          self2.#delayedPromises.text.resolve(self2.#bufferedText.join(""));
          const reasoningText = self2.#bufferedReasoning.length > 0 ? self2.#bufferedReasoning.map((reasoningPart) => reasoningPart.payload.text).join("") : void 0;
          self2.#delayedPromises.reasoningText.resolve(reasoningText);
          self2.#delayedPromises.reasoning.resolve(Object.values(self2.#bufferedReasoningDetails || {}));
          self2.#delayedPromises.sources.resolve(self2.#bufferedSources);
          self2.#delayedPromises.files.resolve(self2.#bufferedFiles);
          self2.#delayedPromises.toolCalls.resolve(self2.#toolCalls);
          self2.#delayedPromises.toolResults.resolve(self2.#toolResults);
          self2.#delayedPromises.steps.resolve(self2.#bufferedSteps);
          self2.#delayedPromises.totalUsage.resolve(self2.#getTotalUsage());
          self2.#delayedPromises.content.resolve(messageList.get.response.aiV5.stepContent());
          self2.#delayedPromises.suspendPayload.resolve(void 0);
          const baseFinishStep = self2.#bufferedSteps[self2.#bufferedSteps.length - 1];
          if (baseFinishStep) {
            const onFinishPayload = {
              // StepResult properties from baseFinishStep
              providerMetadata: baseFinishStep.providerMetadata,
              text: baseFinishStep.text,
              warnings: baseFinishStep.warnings ?? [],
              finishReason: chunk.payload.stepResult.reason,
              content: messageList.get.response.aiV5.stepContent(),
              request: await self2.request,
              error: self2.error,
              reasoning: await self2.reasoning,
              reasoningText: await self2.reasoningText,
              sources: await self2.sources,
              files: await self2.files,
              steps: self2.#bufferedSteps,
              response: { ...await self2.response, ...baseFinishStep.response, messages: messageList.get.response.aiV5.model() },
              usage: chunk.payload.output.usage,
              totalUsage: self2.#getTotalUsage(),
              toolCalls: await self2.toolCalls,
              toolResults: await self2.toolResults,
              staticToolCalls: (await self2.toolCalls).filter((toolCall) => toolCall?.payload?.dynamic === false),
              staticToolResults: (await self2.toolResults).filter((toolResult) => toolResult?.payload?.dynamic === false),
              dynamicToolCalls: (await self2.toolCalls).filter((toolCall) => toolCall?.payload?.dynamic === true),
              dynamicToolResults: (await self2.toolResults).filter((toolResult) => toolResult?.payload?.dynamic === true),
              // Custom properties (not part of standard callback)
              ...self2.#model.modelId && self2.#model.provider && self2.#model.version ? { model: self2.#model } : {},
              object: self2.#delayedPromises.object.status.type === "rejected" ? void 0 : self2.#delayedPromises.object.status.type === "resolved" ? self2.#delayedPromises.object.status.value : self2.#structuredOutputMode === "direct" && baseFinishStep.text ? (() => {
                try {
                  return JSON.parse(baseFinishStep.text);
                } catch {
                  return void 0;
                }
              })() : void 0
            };
            await options?.onFinish?.(onFinishPayload);
          }
          if (options?.rootSpan) {
            options.rootSpan.setAttributes({ ...self2.#model.modelId ? { "aisdk.model.id": self2.#model.modelId } : {}, ...self2.#model.provider ? { "aisdk.model.provider": self2.#model.provider } : {}, ...baseFinishStep?.usage?.reasoningTokens ? { "stream.usage.reasoningTokens": baseFinishStep.usage.reasoningTokens } : {}, ...baseFinishStep?.usage?.totalTokens ? { "stream.usage.totalTokens": baseFinishStep.usage.totalTokens } : {}, ...baseFinishStep?.usage?.inputTokens ? { "stream.usage.inputTokens": baseFinishStep.usage.inputTokens } : {}, ...baseFinishStep?.usage?.outputTokens ? { "stream.usage.outputTokens": baseFinishStep.usage.outputTokens } : {}, ...baseFinishStep?.usage?.cachedInputTokens ? { "stream.usage.cachedInputTokens": baseFinishStep.usage.cachedInputTokens } : {}, ...baseFinishStep?.providerMetadata ? { "stream.response.providerMetadata": JSON.stringify(baseFinishStep?.providerMetadata) } : {}, ...baseFinishStep?.finishReason ? { "stream.response.finishReason": baseFinishStep?.finishReason } : {}, ...options?.telemetry_settings?.recordOutputs !== false ? { "stream.response.text": baseFinishStep?.text } : {}, ...baseFinishStep?.toolCalls && options?.telemetry_settings?.recordOutputs !== false ? { "stream.response.toolCalls": JSON.stringify(baseFinishStep?.toolCalls?.map((toolCall) => {
              return { type: "tool-call", toolCallId: toolCall.payload?.toolCallId, args: toolCall.payload?.args, toolName: toolCall.payload?.toolName };
            }).filter(Boolean)) } : {} });
            options.rootSpan.end();
          }
          break;
        case "error":
          const error87 = getErrorFromUnknown(chunk.payload.error, { fallbackMessage: "Unknown error chunk in stream" });
          self2.#error = error87;
          self2.#status = "failed";
          self2.#streamFinished = true;
          Object.values(self2.#delayedPromises).forEach((promise3) => {
            if (promise3.status.type === "pending") {
              promise3.reject(self2.#error);
            }
          });
          break;
      }
      self2.#emitChunk(chunk);
      controller.enqueue(chunk);
    }, "transform"), flush: /* @__PURE__ */ __name(() => {
      if (self2.#delayedPromises.object.status.type === "pending") {
        self2.#delayedPromises.object.resolve(void 0);
      }
      Object.entries(self2.#delayedPromises).forEach(([key, promise3]) => {
        if (promise3.status.type === "pending") {
          promise3.reject(new Error(`promise '${key}' was not resolved or rejected when stream finished`));
        }
      });
      self2.#streamFinished = true;
      self2.#emitter.emit("finish");
    }, "flush") }));
    this.#aisdkv5 = new AISDKV5OutputStream({ modelOutput: this, messageList, options: { toolCallStreaming: options?.toolCallStreaming, structuredOutput: options?.structuredOutput, tracingContext: options?.tracingContext } });
    if (initialState) {
      this.deserializeState(initialState);
    }
  }
  #getDelayedPromise(promise3) {
    if (!this.#consumptionStarted) {
      void this.consumeStream();
    }
    return promise3.promise;
  }
  /**
  * Resolves to the complete text response after streaming completes.
  */
  get text() {
    return this.#getDelayedPromise(this.#delayedPromises.text);
  }
  /**
  * Resolves to reasoning parts array for models that support reasoning.
  */
  get reasoning() {
    return this.#getDelayedPromise(this.#delayedPromises.reasoning);
  }
  /**
  * Resolves to complete reasoning text for models that support reasoning.
  */
  get reasoningText() {
    return this.#getDelayedPromise(this.#delayedPromises.reasoningText);
  }
  get sources() {
    return this.#getDelayedPromise(this.#delayedPromises.sources);
  }
  get files() {
    return this.#getDelayedPromise(this.#delayedPromises.files);
  }
  get steps() {
    return this.#getDelayedPromise(this.#delayedPromises.steps);
  }
  get suspendPayload() {
    return this.#getDelayedPromise(this.#delayedPromises.suspendPayload);
  }
  /**
  * Stream of all chunks. Provides complete control over stream processing.
  */
  get fullStream() {
    return this.#createEventedStream();
  }
  /**
  * Resolves to the reason generation finished.
  */
  get finishReason() {
    return this.#getDelayedPromise(this.#delayedPromises.finishReason);
  }
  /**
  * Resolves to array of all tool calls made during execution.
  */
  get toolCalls() {
    return this.#getDelayedPromise(this.#delayedPromises.toolCalls);
  }
  /**
  * Resolves to array of all tool execution results.
  */
  get toolResults() {
    return this.#getDelayedPromise(this.#delayedPromises.toolResults);
  }
  /**
  * Resolves to token usage statistics including inputTokens, outputTokens, and totalTokens.
  */
  get usage() {
    return this.#getDelayedPromise(this.#delayedPromises.usage);
  }
  /**
  * Resolves to array of all warnings generated during execution.
  */
  get warnings() {
    return this.#getDelayedPromise(this.#delayedPromises.warnings);
  }
  /**
  * Resolves to provider metadata generated during execution.
  */
  get providerMetadata() {
    return this.#getDelayedPromise(this.#delayedPromises.providerMetadata);
  }
  /**
  * Resolves to the complete response from the model.
  */
  get response() {
    return this.#getDelayedPromise(this.#delayedPromises.response);
  }
  /**
  * Resolves to the complete request sent to the model.
  */
  get request() {
    return this.#getDelayedPromise(this.#delayedPromises.request);
  }
  /**
  * Resolves to an error if an error occurred during streaming.
  */
  get error() {
    return this.#error;
  }
  updateUsageCount(usage) {
    if (!usage) {
      return;
    }
    if (usage.inputTokens !== void 0) {
      this.#usageCount.inputTokens = (this.#usageCount.inputTokens ?? 0) + usage.inputTokens;
    }
    if (usage.outputTokens !== void 0) {
      this.#usageCount.outputTokens = (this.#usageCount.outputTokens ?? 0) + usage.outputTokens;
    }
    if (usage.totalTokens !== void 0) {
      this.#usageCount.totalTokens = (this.#usageCount.totalTokens ?? 0) + usage.totalTokens;
    }
    if (usage.reasoningTokens !== void 0) {
      this.#usageCount.reasoningTokens = (this.#usageCount.reasoningTokens ?? 0) + usage.reasoningTokens;
    }
    if (usage.cachedInputTokens !== void 0) {
      this.#usageCount.cachedInputTokens = (this.#usageCount.cachedInputTokens ?? 0) + usage.cachedInputTokens;
    }
  }
  populateUsageCount(usage) {
    if (!usage) {
      return;
    }
    if (usage.inputTokens !== void 0 && this.#usageCount.inputTokens === void 0) {
      this.#usageCount.inputTokens = usage.inputTokens;
    }
    if (usage.outputTokens !== void 0 && this.#usageCount.outputTokens === void 0) {
      this.#usageCount.outputTokens = usage.outputTokens;
    }
    if (usage.totalTokens !== void 0 && this.#usageCount.totalTokens === void 0) {
      this.#usageCount.totalTokens = usage.totalTokens;
    }
    if (usage.reasoningTokens !== void 0 && this.#usageCount.reasoningTokens === void 0) {
      this.#usageCount.reasoningTokens = usage.reasoningTokens;
    }
    if (usage.cachedInputTokens !== void 0 && this.#usageCount.cachedInputTokens === void 0) {
      this.#usageCount.cachedInputTokens = usage.cachedInputTokens;
    }
  }
  async consumeStream(options) {
    if (this.#consumptionStarted) {
      return;
    }
    this.#consumptionStarted = true;
    try {
      await consumeStream2({ stream: this.#baseStream, onError: options?.onError });
    } catch (error87) {
      options?.onError?.(error87);
    }
  }
  /**
  * Returns complete output including text, usage, tool calls, and all metadata.
  */
  async getFullOutput() {
    await this.consumeStream({ onError: /* @__PURE__ */ __name((error87) => {
      console.error(error87);
      throw error87;
    }, "onError") });
    let scoringData;
    if (this.#returnScorerData) {
      scoringData = { input: { inputMessages: this.messageList.getPersisted.input.ui(), rememberedMessages: this.messageList.getPersisted.remembered.ui(), systemMessages: this.messageList.getSystemMessages(), taggedSystemMessages: this.messageList.getPersisted.taggedSystemMessages }, output: this.messageList.getPersisted.response.ui() };
    }
    const fullOutput = { text: await this.text, usage: await this.usage, steps: await this.steps, finishReason: await this.finishReason, warnings: await this.warnings, providerMetadata: await this.providerMetadata, request: await this.request, reasoning: await this.reasoning, reasoningText: await this.reasoningText, toolCalls: await this.toolCalls, toolResults: await this.toolResults, sources: await this.sources, files: await this.files, response: await this.response, totalUsage: await this.totalUsage, object: await this.object, error: this.error, tripwire: this.#tripwire, tripwireReason: this.#tripwireReason, ...scoringData ? { scoringData } : {}, traceId: this.traceId };
    return fullOutput;
  }
  /**
  * The tripwire flag is set when the stream is aborted due to an output processor blocking the content.
  */
  get tripwire() {
    return this.#tripwire;
  }
  /**
  * The reason for the tripwire.
  */
  get tripwireReason() {
    return this.#tripwireReason;
  }
  /**
  * The total usage of the stream.
  */
  get totalUsage() {
    return this.#getDelayedPromise(this.#delayedPromises.totalUsage);
  }
  get content() {
    return this.#getDelayedPromise(this.#delayedPromises.content);
  }
  /**
  * Other output stream formats.
  */
  get aisdk() {
    return {
      /**
      * The AI SDK v5 output stream format.
      */
      v5: this.#aisdkv5
    };
  }
  /**
  * Stream of valid JSON chunks. The final JSON result is validated against the output schema when the stream ends.
  *
  * @example
  * ```typescript
  * const stream = await agent.stream("Extract data", {
  *   structuredOutput: {
  *     schema: z.object({ name: z.string(), age: z.number() }),
  *     model: 'gpt-4o-mini' // optional to use a model for structuring json output
  *   }
  * });
  * // partial json chunks
  * for await (const data of stream.objectStream) {
  *   console.log(data); // { name: 'John' }, { name: 'John', age: 30 }
  * }
  * ```
  */
  get objectStream() {
    return this.#createEventedStream().pipeThrough(new TransformStream3({ transform(chunk, controller) {
      if (chunk.type === "object") {
        controller.enqueue(chunk.object);
      }
    } }));
  }
  /**
  * Stream of individual array elements when output schema is an array type.
  */
  get elementStream() {
    let publishedElements = 0;
    return this.#createEventedStream().pipeThrough(new TransformStream3({ transform(chunk, controller) {
      if (chunk.type === "object") {
        if (Array.isArray(chunk.object)) {
          for (; publishedElements < chunk.object.length; publishedElements++) {
            controller.enqueue(chunk.object[publishedElements]);
          }
        }
      }
    } }));
  }
  /**
  * Stream of only text content, filtering out metadata and other chunk types.
  */
  get textStream() {
    if (this.#structuredOutputMode === "direct") {
      const outputSchema2 = getTransformedSchema(this.#options.structuredOutput?.schema);
      if (outputSchema2?.outputFormat === "array") {
        return this.#createEventedStream().pipeThrough(createJsonTextStreamTransformer(this.#options.structuredOutput?.schema));
      }
    }
    return this.#createEventedStream().pipeThrough(new TransformStream3({ transform(chunk, controller) {
      if (chunk.type === "text-delta") {
        controller.enqueue(chunk.payload.text);
      }
    } }));
  }
  /**
  * Resolves to the complete object response from the model. Validated against the 'output' schema when the stream ends.
  *
  * @example
  * ```typescript
  * const stream = await agent.stream("Extract data", {
  *   structuredOutput: {
  *     schema: z.object({ name: z.string(), age: z.number() }),
  *     model: 'gpt-4o-mini' // optionally use a model for structuring json output
  *   }
  * });
  * // final validated json
  * const data = await stream.object // { name: 'John', age: 30 }
  * ```
  */
  get object() {
    if (!this.processorRunner && !this.#options.structuredOutput?.schema && this.#delayedPromises.object.status.type === "pending") {
      this.#delayedPromises.object.resolve(void 0);
    }
    return this.#getDelayedPromise(this.#delayedPromises.object);
  }
  // Internal methods for immediate values - used internally by Mastra (llm-execution.ts bailing on errors/abort signals with current state)
  // These are not part of the public API
  /** @internal */
  _getImmediateToolCalls() {
    return this.#toolCalls;
  }
  /** @internal */
  _getImmediateToolResults() {
    return this.#toolResults;
  }
  /** @internal */
  _getImmediateText() {
    return this.#bufferedText.join("");
  }
  /** @internal */
  _getImmediateObject() {
    return this.#bufferedObject;
  }
  /** @internal */
  _getImmediateUsage() {
    return this.#usageCount;
  }
  /** @internal */
  _getImmediateWarnings() {
    return this.#warnings;
  }
  /** @internal */
  _getImmediateFinishReason() {
    return this.#finishReason;
  }
  /** @internal  */
  _getBaseStream() {
    return this.#baseStream;
  }
  #getTotalUsage() {
    let total = this.#usageCount.totalTokens;
    if (total === void 0) {
      const input = this.#usageCount.inputTokens ?? 0;
      const output = this.#usageCount.outputTokens ?? 0;
      const reasoning = this.#usageCount.reasoningTokens ?? 0;
      total = input + output + reasoning;
    }
    return { inputTokens: this.#usageCount.inputTokens, outputTokens: this.#usageCount.outputTokens, totalTokens: total, reasoningTokens: this.#usageCount.reasoningTokens, cachedInputTokens: this.#usageCount.cachedInputTokens };
  }
  #emitChunk(chunk) {
    this.#bufferedChunks.push(chunk);
    this.#emitter.emit("chunk", chunk);
  }
  #createEventedStream() {
    const self2 = this;
    return new ReadableStream$1({ start(controller) {
      self2.#bufferedChunks.forEach((chunk) => {
        controller.enqueue(chunk);
      });
      if (self2.#streamFinished) {
        controller.close();
        return;
      }
      const chunkHandler = /* @__PURE__ */ __name((chunk) => {
        controller.enqueue(chunk);
      }, "chunkHandler");
      const finishHandler = /* @__PURE__ */ __name(() => {
        self2.#emitter.off("chunk", chunkHandler);
        self2.#emitter.off("finish", finishHandler);
        controller.close();
      }, "finishHandler");
      self2.#emitter.on("chunk", chunkHandler);
      self2.#emitter.on("finish", finishHandler);
    }, pull(_controller) {
      if (!self2.#consumptionStarted) {
        void self2.consumeStream();
      }
    }, cancel() {
      self2.#emitter.removeAllListeners();
    } });
  }
  get status() {
    return this.#status;
  }
  serializeState() {
    return { status: this.#status, bufferedSteps: this.#bufferedSteps, bufferedReasoningDetails: this.#bufferedReasoningDetails, bufferedByStep: this.#bufferedByStep, bufferedText: this.#bufferedText, bufferedTextChunks: this.#bufferedTextChunks, bufferedSources: this.#bufferedSources, bufferedReasoning: this.#bufferedReasoning, bufferedFiles: this.#bufferedFiles, toolCallArgsDeltas: this.#toolCallArgsDeltas, toolCallDeltaIdNameMap: this.#toolCallDeltaIdNameMap, toolCalls: this.#toolCalls, toolResults: this.#toolResults, warnings: this.#warnings, finishReason: this.#finishReason, request: this.#request, usageCount: this.#usageCount, tripwire: this.#tripwire, tripwireReason: this.#tripwireReason, messageList: this.messageList.serialize() };
  }
  deserializeState(state) {
    this.#status = state.status;
    this.#bufferedSteps = state.bufferedSteps;
    this.#bufferedReasoningDetails = state.bufferedReasoningDetails;
    this.#bufferedByStep = state.bufferedByStep;
    this.#bufferedText = state.bufferedText;
    this.#bufferedTextChunks = state.bufferedTextChunks;
    this.#bufferedSources = state.bufferedSources;
    this.#bufferedReasoning = state.bufferedReasoning;
    this.#bufferedFiles = state.bufferedFiles;
    this.#toolCallArgsDeltas = state.toolCallArgsDeltas;
    this.#toolCallDeltaIdNameMap = state.toolCallDeltaIdNameMap;
    this.#toolCalls = state.toolCalls;
    this.#toolResults = state.toolResults;
    this.#warnings = state.warnings;
    this.#finishReason = state.finishReason;
    this.#request = state.request;
    this.#usageCount = state.usageCount;
    this.#tripwire = state.tripwire;
    this.#tripwireReason = state.tripwireReason;
    this.messageList = this.messageList.deserialize(state.messageList);
  }
};

// src/agents/agent-config.ts
import tutorFAQ from "./6aa7d996db7528074f73dbc38ed80db8a7a0974b-Tutor-FAQs-Connect-Me.md";
import handbookS6 from "./8c228e3e4a72a544b3454dc9b25356db86060e04-Connect-Me-Handbook.md";
import tutorPortalManual from "./8a39c20e9cb4935240ab81fd9aeb2195a3873842-Connect-Me-Tutor-Portal-Manual.md";
var generalAgent = new Agent({
  name: "general-agent",
  instructions: [
    {
      role: "system",
      content: `### RESTRICTION:
- You are strictly prohibited from using outside knowledge.
- You must ONLY answer using the provided 'Connect Me Resources'.
- If the answer is not explicitly contained within the provided text, or if the user is asking for general information, your response MUST be exactly one word: 'EMPTY'.
`
    },
    {
      role: "system",
      content: `Your are a helpful assistant answering questions based off the data given!`
    },
    {
      role: "system",
      content: "Provide any relevant links"
    },
    { role: "system", content: `Keep the response under 2000 characters` },
    { role: "system", content: handbookS6 },
    { role: "system", content: tutorPortalManual },
    { role: "system", content: tutorFAQ }
  ],
  model: "mistral/ministral-8b-latest"
});
var dmAgent = new Agent({
  name: "dm-agent",
  instructions: [
    { role: "system", content: `Keep the response under 2000 characters` },
    {
      role: "system",
      content: `Your are a helpful assistant answering questions based off the context given`
    },
    { role: "system", content: handbookS6 },
    { role: "system", content: tutorPortalManual },
    { role: "system", content: tutorFAQ }
  ],
  model: "mistral/mistral-small-latest"
});

// src/main.ts
var app = new Hono2();
app.get("/", async (c) => {
  return c.text("Hono App Is Working");
});
app.post("/process-dm", async (c) => {
  const body = await c.req.json();
  try {
    const response = await callDmAgent(body.message);
    return response ? c.text(response) : c.text("No response");
  } catch (error87) {
    console.error("Read Item Exception", error87);
  }
});
app.post("/process-general", async (c) => {
  const body = await c.req.json();
  try {
    const response = await callGeneralAgent(body.message);
    return response ? c.text(response) : c.text("No response");
  } catch (error87) {
    console.error("Read Item Exception", error87);
    throw error87;
  }
});
var callGeneralAgent = /* @__PURE__ */ __name(async (query) => {
  const response = await generalAgent.generate(query);
  return response.text;
}, "callGeneralAgent");
var callDmAgent = /* @__PURE__ */ __name(async (query) => {
  const response = await dmAgent.generate(query);
  return response.text;
}, "callDmAgent");
var main_default = app;
export {
  main_default as default
};
//# sourceMappingURL=main.js.map
